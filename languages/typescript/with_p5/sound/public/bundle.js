var __create = Object.create;
var __getProtoOf = Object.getPrototypeOf;
var __defProp = Object.defineProperty;
var __getOwnPropNames = Object.getOwnPropertyNames;
var __getOwnPropDesc = Object.getOwnPropertyDescriptor;
var __hasOwnProp = Object.prototype.hasOwnProperty;
var __toESM = (mod, isNodeMode, target) => {
  target = mod != null ? __create(__getProtoOf(mod)) : {};
  const to = isNodeMode || !mod || !mod.__esModule ? __defProp(target, "default", { value: mod, enumerable: true }) : target;
  for (let key of __getOwnPropNames(mod))
    if (!__hasOwnProp.call(to, key))
      __defProp(to, key, {
        get: () => mod[key],
        enumerable: true
      });
  return to;
};
var __moduleCache = /* @__PURE__ */ new WeakMap;
var __toCommonJS = (from) => {
  var entry = __moduleCache.get(from), desc;
  if (entry)
    return entry;
  entry = __defProp({}, "__esModule", { value: true });
  if (from && typeof from === "object" || typeof from === "function")
    __getOwnPropNames(from).map((key) => !__hasOwnProp.call(entry, key) && __defProp(entry, key, {
      get: () => from[key],
      enumerable: !(desc = __getOwnPropDesc(from, key)) || desc.enumerable
    }));
  __moduleCache.set(from, entry);
  return entry;
};
var __commonJS = (cb, mod) => () => (mod || cb((mod = { exports: {} }).exports, mod), mod.exports);
var __export = (target, all) => {
  for (var name in all)
    __defProp(target, name, {
      get: all[name],
      enumerable: true,
      configurable: true,
      set: (newValue) => all[name] = () => newValue
    });
};
var __esm = (fn2, res) => () => (fn2 && (res = fn2(fn2 = 0)), res);

// node_modules/file-saver/FileSaver.js
var require_FileSaver = __commonJS((exports, module) => {
  /*! @source http://purl.eligrey.com/github/FileSaver.js/blob/master/FileSaver.js */
  var saveAs = saveAs || function(view) {
    if (typeof view === "undefined" || typeof navigator !== "undefined" && /MSIE [1-9]\./.test(navigator.userAgent)) {
      return;
    }
    var doc = view.document, get_URL = function() {
      return view.URL || view.webkitURL || view;
    }, save_link = doc.createElementNS("http://www.w3.org/1999/xhtml", "a"), can_use_save_link = "download" in save_link, click = function(node) {
      var event = new MouseEvent("click");
      node.dispatchEvent(event);
    }, is_safari = /constructor/i.test(view.HTMLElement) || view.safari, is_chrome_ios = /CriOS\/[\d]+/.test(navigator.userAgent), throw_outside = function(ex) {
      (view.setImmediate || view.setTimeout)(function() {
        throw ex;
      }, 0);
    }, force_saveable_type = "application/octet-stream", arbitrary_revoke_timeout = 1000 * 40, revoke = function(file2) {
      var revoker = function() {
        if (typeof file2 === "string") {
          get_URL().revokeObjectURL(file2);
        } else {
          file2.remove();
        }
      };
      setTimeout(revoker, arbitrary_revoke_timeout);
    }, dispatch = function(filesaver, event_types, event) {
      event_types = [].concat(event_types);
      var i = event_types.length;
      while (i--) {
        var listener = filesaver["on" + event_types[i]];
        if (typeof listener === "function") {
          try {
            listener.call(filesaver, event || filesaver);
          } catch (ex) {
            throw_outside(ex);
          }
        }
      }
    }, auto_bom = function(blob) {
      if (/^\s*(?:text\/\S*|application\/xml|\S*\/\S*\+xml)\s*;.*charset\s*=\s*utf-8/i.test(blob.type)) {
        return new Blob([String.fromCharCode(65279), blob], { type: blob.type });
      }
      return blob;
    }, FileSaver = function(blob, name, no_auto_bom) {
      if (!no_auto_bom) {
        blob = auto_bom(blob);
      }
      var filesaver = this, type2 = blob.type, force = type2 === force_saveable_type, object_url, dispatch_all = function() {
        dispatch(filesaver, "writestart progress write writeend".split(" "));
      }, fs_error = function() {
        if ((is_chrome_ios || force && is_safari) && view.FileReader) {
          var reader = new FileReader;
          reader.onloadend = function() {
            var url = is_chrome_ios ? reader.result : reader.result.replace(/^data:[^;]*;/, "data:attachment/file;");
            var popup = view.open(url, "_blank");
            if (!popup)
              view.location.href = url;
            url = undefined;
            filesaver.readyState = filesaver.DONE;
            dispatch_all();
          };
          reader.readAsDataURL(blob);
          filesaver.readyState = filesaver.INIT;
          return;
        }
        if (!object_url) {
          object_url = get_URL().createObjectURL(blob);
        }
        if (force) {
          view.location.href = object_url;
        } else {
          var opened = view.open(object_url, "_blank");
          if (!opened) {
            view.location.href = object_url;
          }
        }
        filesaver.readyState = filesaver.DONE;
        dispatch_all();
        revoke(object_url);
      };
      filesaver.readyState = filesaver.INIT;
      if (can_use_save_link) {
        object_url = get_URL().createObjectURL(blob);
        setTimeout(function() {
          save_link.href = object_url;
          save_link.download = name;
          click(save_link);
          dispatch_all();
          revoke(object_url);
          filesaver.readyState = filesaver.DONE;
        });
        return;
      }
      fs_error();
    }, FS_proto = FileSaver.prototype, saveAs2 = function(blob, name, no_auto_bom) {
      return new FileSaver(blob, name || blob.name || "download", no_auto_bom);
    };
    if (typeof navigator !== "undefined" && navigator.msSaveOrOpenBlob) {
      return function(blob, name, no_auto_bom) {
        name = name || blob.name || "download";
        if (!no_auto_bom) {
          blob = auto_bom(blob);
        }
        return navigator.msSaveOrOpenBlob(blob, name);
      };
    }
    FS_proto.abort = function() {};
    FS_proto.readyState = FS_proto.INIT = 0;
    FS_proto.WRITING = 1;
    FS_proto.DONE = 2;
    FS_proto.error = FS_proto.onwritestart = FS_proto.onprogress = FS_proto.onwrite = FS_proto.onabort = FS_proto.onerror = FS_proto.onwriteend = null;
    return saveAs2;
  }(typeof self !== "undefined" && self || typeof window !== "undefined" && window || exports.content);
  if (typeof module !== "undefined" && module.exports) {
    module.exports.saveAs = saveAs;
  } else if (typeof define !== "undefined" && define !== null && define.amd !== null) {
    define("FileSaver.js", function() {
      return saveAs;
    });
  }
});

// node_modules/omggif/omggif.js
var require_omggif = __commonJS((exports) => {
  function GifWriter(buf, width, height, gopts) {
    var p2 = 0;
    var gopts = gopts === undefined ? {} : gopts;
    var loop_count = gopts.loop === undefined ? null : gopts.loop;
    var global_palette = gopts.palette === undefined ? null : gopts.palette;
    if (width <= 0 || height <= 0 || width > 65535 || height > 65535)
      throw new Error("Width/Height invalid.");
    function check_palette_and_num_colors(palette) {
      var num_colors = palette.length;
      if (num_colors < 2 || num_colors > 256 || num_colors & num_colors - 1) {
        throw new Error("Invalid code/color length, must be power of 2 and 2 .. 256.");
      }
      return num_colors;
    }
    buf[p2++] = 71;
    buf[p2++] = 73;
    buf[p2++] = 70;
    buf[p2++] = 56;
    buf[p2++] = 57;
    buf[p2++] = 97;
    var gp_num_colors_pow2 = 0;
    var background = 0;
    if (global_palette !== null) {
      var gp_num_colors = check_palette_and_num_colors(global_palette);
      while (gp_num_colors >>= 1)
        ++gp_num_colors_pow2;
      gp_num_colors = 1 << gp_num_colors_pow2;
      --gp_num_colors_pow2;
      if (gopts.background !== undefined) {
        background = gopts.background;
        if (background >= gp_num_colors)
          throw new Error("Background index out of range.");
        if (background === 0)
          throw new Error("Background index explicitly passed as 0.");
      }
    }
    buf[p2++] = width & 255;
    buf[p2++] = width >> 8 & 255;
    buf[p2++] = height & 255;
    buf[p2++] = height >> 8 & 255;
    buf[p2++] = (global_palette !== null ? 128 : 0) | gp_num_colors_pow2;
    buf[p2++] = background;
    buf[p2++] = 0;
    if (global_palette !== null) {
      for (var i = 0, il = global_palette.length;i < il; ++i) {
        var rgb = global_palette[i];
        buf[p2++] = rgb >> 16 & 255;
        buf[p2++] = rgb >> 8 & 255;
        buf[p2++] = rgb & 255;
      }
    }
    if (loop_count !== null) {
      if (loop_count < 0 || loop_count > 65535)
        throw new Error("Loop count invalid.");
      buf[p2++] = 33;
      buf[p2++] = 255;
      buf[p2++] = 11;
      buf[p2++] = 78;
      buf[p2++] = 69;
      buf[p2++] = 84;
      buf[p2++] = 83;
      buf[p2++] = 67;
      buf[p2++] = 65;
      buf[p2++] = 80;
      buf[p2++] = 69;
      buf[p2++] = 50;
      buf[p2++] = 46;
      buf[p2++] = 48;
      buf[p2++] = 3;
      buf[p2++] = 1;
      buf[p2++] = loop_count & 255;
      buf[p2++] = loop_count >> 8 & 255;
      buf[p2++] = 0;
    }
    var ended = false;
    this.addFrame = function(x, y, w, h, indexed_pixels, opts) {
      if (ended === true) {
        --p2;
        ended = false;
      }
      opts = opts === undefined ? {} : opts;
      if (x < 0 || y < 0 || x > 65535 || y > 65535)
        throw new Error("x/y invalid.");
      if (w <= 0 || h <= 0 || w > 65535 || h > 65535)
        throw new Error("Width/Height invalid.");
      if (indexed_pixels.length < w * h)
        throw new Error("Not enough pixels for the frame size.");
      var using_local_palette = true;
      var palette = opts.palette;
      if (palette === undefined || palette === null) {
        using_local_palette = false;
        palette = global_palette;
      }
      if (palette === undefined || palette === null)
        throw new Error("Must supply either a local or global palette.");
      var num_colors = check_palette_and_num_colors(palette);
      var min_code_size = 0;
      while (num_colors >>= 1)
        ++min_code_size;
      num_colors = 1 << min_code_size;
      var delay = opts.delay === undefined ? 0 : opts.delay;
      var disposal = opts.disposal === undefined ? 0 : opts.disposal;
      if (disposal < 0 || disposal > 3)
        throw new Error("Disposal out of range.");
      var use_transparency = false;
      var transparent_index = 0;
      if (opts.transparent !== undefined && opts.transparent !== null) {
        use_transparency = true;
        transparent_index = opts.transparent;
        if (transparent_index < 0 || transparent_index >= num_colors)
          throw new Error("Transparent color index.");
      }
      if (disposal !== 0 || use_transparency || delay !== 0) {
        buf[p2++] = 33;
        buf[p2++] = 249;
        buf[p2++] = 4;
        buf[p2++] = disposal << 2 | (use_transparency === true ? 1 : 0);
        buf[p2++] = delay & 255;
        buf[p2++] = delay >> 8 & 255;
        buf[p2++] = transparent_index;
        buf[p2++] = 0;
      }
      buf[p2++] = 44;
      buf[p2++] = x & 255;
      buf[p2++] = x >> 8 & 255;
      buf[p2++] = y & 255;
      buf[p2++] = y >> 8 & 255;
      buf[p2++] = w & 255;
      buf[p2++] = w >> 8 & 255;
      buf[p2++] = h & 255;
      buf[p2++] = h >> 8 & 255;
      buf[p2++] = using_local_palette === true ? 128 | min_code_size - 1 : 0;
      if (using_local_palette === true) {
        for (var i2 = 0, il2 = palette.length;i2 < il2; ++i2) {
          var rgb2 = palette[i2];
          buf[p2++] = rgb2 >> 16 & 255;
          buf[p2++] = rgb2 >> 8 & 255;
          buf[p2++] = rgb2 & 255;
        }
      }
      p2 = GifWriterOutputLZWCodeStream(buf, p2, min_code_size < 2 ? 2 : min_code_size, indexed_pixels);
      return p2;
    };
    this.end = function() {
      if (ended === false) {
        buf[p2++] = 59;
        ended = true;
      }
      return p2;
    };
    this.getOutputBuffer = function() {
      return buf;
    };
    this.setOutputBuffer = function(v) {
      buf = v;
    };
    this.getOutputBufferPosition = function() {
      return p2;
    };
    this.setOutputBufferPosition = function(v) {
      p2 = v;
    };
  }
  function GifWriterOutputLZWCodeStream(buf, p2, min_code_size, index_stream) {
    buf[p2++] = min_code_size;
    var cur_subblock = p2++;
    var clear_code = 1 << min_code_size;
    var code_mask = clear_code - 1;
    var eoi_code = clear_code + 1;
    var next_code = eoi_code + 1;
    var cur_code_size = min_code_size + 1;
    var cur_shift = 0;
    var cur = 0;
    function emit_bytes_to_buffer(bit_block_size) {
      while (cur_shift >= bit_block_size) {
        buf[p2++] = cur & 255;
        cur >>= 8;
        cur_shift -= 8;
        if (p2 === cur_subblock + 256) {
          buf[cur_subblock] = 255;
          cur_subblock = p2++;
        }
      }
    }
    function emit_code(c) {
      cur |= c << cur_shift;
      cur_shift += cur_code_size;
      emit_bytes_to_buffer(8);
    }
    var ib_code = index_stream[0] & code_mask;
    var code_table = {};
    emit_code(clear_code);
    for (var i = 1, il = index_stream.length;i < il; ++i) {
      var k = index_stream[i] & code_mask;
      var cur_key = ib_code << 8 | k;
      var cur_code = code_table[cur_key];
      if (cur_code === undefined) {
        cur |= ib_code << cur_shift;
        cur_shift += cur_code_size;
        while (cur_shift >= 8) {
          buf[p2++] = cur & 255;
          cur >>= 8;
          cur_shift -= 8;
          if (p2 === cur_subblock + 256) {
            buf[cur_subblock] = 255;
            cur_subblock = p2++;
          }
        }
        if (next_code === 4096) {
          emit_code(clear_code);
          next_code = eoi_code + 1;
          cur_code_size = min_code_size + 1;
          code_table = {};
        } else {
          if (next_code >= 1 << cur_code_size)
            ++cur_code_size;
          code_table[cur_key] = next_code++;
        }
        ib_code = k;
      } else {
        ib_code = cur_code;
      }
    }
    emit_code(ib_code);
    emit_code(eoi_code);
    emit_bytes_to_buffer(1);
    if (cur_subblock + 1 === p2) {
      buf[cur_subblock] = 0;
    } else {
      buf[cur_subblock] = p2 - cur_subblock - 1;
      buf[p2++] = 0;
    }
    return p2;
  }
  function GifReader(buf) {
    var p2 = 0;
    if (buf[p2++] !== 71 || buf[p2++] !== 73 || buf[p2++] !== 70 || buf[p2++] !== 56 || (buf[p2++] + 1 & 253) !== 56 || buf[p2++] !== 97) {
      throw new Error("Invalid GIF 87a/89a header.");
    }
    var width = buf[p2++] | buf[p2++] << 8;
    var height = buf[p2++] | buf[p2++] << 8;
    var pf0 = buf[p2++];
    var global_palette_flag = pf0 >> 7;
    var num_global_colors_pow2 = pf0 & 7;
    var num_global_colors = 1 << num_global_colors_pow2 + 1;
    var background = buf[p2++];
    buf[p2++];
    var global_palette_offset = null;
    var global_palette_size = null;
    if (global_palette_flag) {
      global_palette_offset = p2;
      global_palette_size = num_global_colors;
      p2 += num_global_colors * 3;
    }
    var no_eof = true;
    var frames = [];
    var delay = 0;
    var transparent_index = null;
    var disposal = 0;
    var loop_count = null;
    this.width = width;
    this.height = height;
    while (no_eof && p2 < buf.length) {
      switch (buf[p2++]) {
        case 33:
          switch (buf[p2++]) {
            case 255:
              if (buf[p2] !== 11 || buf[p2 + 1] == 78 && buf[p2 + 2] == 69 && buf[p2 + 3] == 84 && buf[p2 + 4] == 83 && buf[p2 + 5] == 67 && buf[p2 + 6] == 65 && buf[p2 + 7] == 80 && buf[p2 + 8] == 69 && buf[p2 + 9] == 50 && buf[p2 + 10] == 46 && buf[p2 + 11] == 48 && buf[p2 + 12] == 3 && buf[p2 + 13] == 1 && buf[p2 + 16] == 0) {
                p2 += 14;
                loop_count = buf[p2++] | buf[p2++] << 8;
                p2++;
              } else {
                p2 += 12;
                while (true) {
                  var block_size = buf[p2++];
                  if (!(block_size >= 0))
                    throw Error("Invalid block size");
                  if (block_size === 0)
                    break;
                  p2 += block_size;
                }
              }
              break;
            case 249:
              if (buf[p2++] !== 4 || buf[p2 + 4] !== 0)
                throw new Error("Invalid graphics extension block.");
              var pf1 = buf[p2++];
              delay = buf[p2++] | buf[p2++] << 8;
              transparent_index = buf[p2++];
              if ((pf1 & 1) === 0)
                transparent_index = null;
              disposal = pf1 >> 2 & 7;
              p2++;
              break;
            case 254:
              while (true) {
                var block_size = buf[p2++];
                if (!(block_size >= 0))
                  throw Error("Invalid block size");
                if (block_size === 0)
                  break;
                p2 += block_size;
              }
              break;
            default:
              throw new Error("Unknown graphic control label: 0x" + buf[p2 - 1].toString(16));
          }
          break;
        case 44:
          var x = buf[p2++] | buf[p2++] << 8;
          var y = buf[p2++] | buf[p2++] << 8;
          var w = buf[p2++] | buf[p2++] << 8;
          var h = buf[p2++] | buf[p2++] << 8;
          var pf2 = buf[p2++];
          var local_palette_flag = pf2 >> 7;
          var interlace_flag = pf2 >> 6 & 1;
          var num_local_colors_pow2 = pf2 & 7;
          var num_local_colors = 1 << num_local_colors_pow2 + 1;
          var palette_offset = global_palette_offset;
          var palette_size = global_palette_size;
          var has_local_palette = false;
          if (local_palette_flag) {
            var has_local_palette = true;
            palette_offset = p2;
            palette_size = num_local_colors;
            p2 += num_local_colors * 3;
          }
          var data_offset = p2;
          p2++;
          while (true) {
            var block_size = buf[p2++];
            if (!(block_size >= 0))
              throw Error("Invalid block size");
            if (block_size === 0)
              break;
            p2 += block_size;
          }
          frames.push({
            x,
            y,
            width: w,
            height: h,
            has_local_palette,
            palette_offset,
            palette_size,
            data_offset,
            data_length: p2 - data_offset,
            transparent_index,
            interlaced: !!interlace_flag,
            delay,
            disposal
          });
          break;
        case 59:
          no_eof = false;
          break;
        default:
          throw new Error("Unknown gif block: 0x" + buf[p2 - 1].toString(16));
          break;
      }
    }
    this.numFrames = function() {
      return frames.length;
    };
    this.loopCount = function() {
      return loop_count;
    };
    this.frameInfo = function(frame_num) {
      if (frame_num < 0 || frame_num >= frames.length)
        throw new Error("Frame index out of range.");
      return frames[frame_num];
    };
    this.decodeAndBlitFrameBGRA = function(frame_num, pixels) {
      var frame = this.frameInfo(frame_num);
      var num_pixels = frame.width * frame.height;
      var index_stream = new Uint8Array(num_pixels);
      GifReaderLZWOutputIndexStream(buf, frame.data_offset, index_stream, num_pixels);
      var palette_offset2 = frame.palette_offset;
      var trans = frame.transparent_index;
      if (trans === null)
        trans = 256;
      var framewidth = frame.width;
      var framestride = width - framewidth;
      var xleft = framewidth;
      var opbeg = (frame.y * width + frame.x) * 4;
      var opend = ((frame.y + frame.height) * width + frame.x) * 4;
      var op = opbeg;
      var scanstride = framestride * 4;
      if (frame.interlaced === true) {
        scanstride += width * 4 * 7;
      }
      var interlaceskip = 8;
      for (var i = 0, il = index_stream.length;i < il; ++i) {
        var index = index_stream[i];
        if (xleft === 0) {
          op += scanstride;
          xleft = framewidth;
          if (op >= opend) {
            scanstride = framestride * 4 + width * 4 * (interlaceskip - 1);
            op = opbeg + (framewidth + framestride) * (interlaceskip << 1);
            interlaceskip >>= 1;
          }
        }
        if (index === trans) {
          op += 4;
        } else {
          var r = buf[palette_offset2 + index * 3];
          var g2 = buf[palette_offset2 + index * 3 + 1];
          var b2 = buf[palette_offset2 + index * 3 + 2];
          pixels[op++] = b2;
          pixels[op++] = g2;
          pixels[op++] = r;
          pixels[op++] = 255;
        }
        --xleft;
      }
    };
    this.decodeAndBlitFrameRGBA = function(frame_num, pixels) {
      var frame = this.frameInfo(frame_num);
      var num_pixels = frame.width * frame.height;
      var index_stream = new Uint8Array(num_pixels);
      GifReaderLZWOutputIndexStream(buf, frame.data_offset, index_stream, num_pixels);
      var palette_offset2 = frame.palette_offset;
      var trans = frame.transparent_index;
      if (trans === null)
        trans = 256;
      var framewidth = frame.width;
      var framestride = width - framewidth;
      var xleft = framewidth;
      var opbeg = (frame.y * width + frame.x) * 4;
      var opend = ((frame.y + frame.height) * width + frame.x) * 4;
      var op = opbeg;
      var scanstride = framestride * 4;
      if (frame.interlaced === true) {
        scanstride += width * 4 * 7;
      }
      var interlaceskip = 8;
      for (var i = 0, il = index_stream.length;i < il; ++i) {
        var index = index_stream[i];
        if (xleft === 0) {
          op += scanstride;
          xleft = framewidth;
          if (op >= opend) {
            scanstride = framestride * 4 + width * 4 * (interlaceskip - 1);
            op = opbeg + (framewidth + framestride) * (interlaceskip << 1);
            interlaceskip >>= 1;
          }
        }
        if (index === trans) {
          op += 4;
        } else {
          var r = buf[palette_offset2 + index * 3];
          var g2 = buf[palette_offset2 + index * 3 + 1];
          var b2 = buf[palette_offset2 + index * 3 + 2];
          pixels[op++] = r;
          pixels[op++] = g2;
          pixels[op++] = b2;
          pixels[op++] = 255;
        }
        --xleft;
      }
    };
  }
  function GifReaderLZWOutputIndexStream(code_stream, p2, output, output_length) {
    var min_code_size = code_stream[p2++];
    var clear_code = 1 << min_code_size;
    var eoi_code = clear_code + 1;
    var next_code = eoi_code + 1;
    var cur_code_size = min_code_size + 1;
    var code_mask = (1 << cur_code_size) - 1;
    var cur_shift = 0;
    var cur = 0;
    var op = 0;
    var subblock_size = code_stream[p2++];
    var code_table = new Int32Array(4096);
    var prev_code = null;
    while (true) {
      while (cur_shift < 16) {
        if (subblock_size === 0)
          break;
        cur |= code_stream[p2++] << cur_shift;
        cur_shift += 8;
        if (subblock_size === 1) {
          subblock_size = code_stream[p2++];
        } else {
          --subblock_size;
        }
      }
      if (cur_shift < cur_code_size)
        break;
      var code = cur & code_mask;
      cur >>= cur_code_size;
      cur_shift -= cur_code_size;
      if (code === clear_code) {
        next_code = eoi_code + 1;
        cur_code_size = min_code_size + 1;
        code_mask = (1 << cur_code_size) - 1;
        prev_code = null;
        continue;
      } else if (code === eoi_code) {
        break;
      }
      var chase_code = code < next_code ? code : prev_code;
      var chase_length = 0;
      var chase = chase_code;
      while (chase > clear_code) {
        chase = code_table[chase] >> 8;
        ++chase_length;
      }
      var k = chase;
      var op_end = op + chase_length + (chase_code !== code ? 1 : 0);
      if (op_end > output_length) {
        console.log("Warning, gif stream longer than expected.");
        return;
      }
      output[op++] = k;
      op += chase_length;
      var b2 = op;
      if (chase_code !== code)
        output[op++] = k;
      chase = chase_code;
      while (chase_length--) {
        chase = code_table[chase];
        output[--b2] = chase & 255;
        chase >>= 8;
      }
      if (prev_code !== null && next_code < 4096) {
        code_table[next_code++] = prev_code << 8 | k;
        if (next_code >= code_mask + 1 && cur_code_size < 12) {
          ++cur_code_size;
          code_mask = code_mask << 1 | 1;
        }
      }
      prev_code = code;
    }
    if (op !== output_length) {
      console.log("Warning, gif stream shorter than expected.");
    }
    return output;
  }
  try {
    exports.GifWriter = GifWriter;
    exports.GifReader = GifReader;
  } catch (e2) {}
});

// node_modules/gifenc/dist/gifenc.js
var require_gifenc = __commonJS((exports) => {
  var __defProp2 = Object.defineProperty;
  var __markAsModule = (target) => __defProp2(target, "__esModule", { value: true });
  var __export2 = (target, all) => {
    for (var name in all)
      __defProp2(target, name, { get: all[name], enumerable: true });
  };
  __markAsModule(exports);
  __export2(exports, {
    GIFEncoder: () => GIFEncoder,
    applyPalette: () => applyPalette,
    default: () => src_default,
    nearestColor: () => nearestColor,
    nearestColorIndex: () => nearestColorIndex,
    nearestColorIndexWithDistance: () => nearestColorIndexWithDistance,
    prequantize: () => prequantize,
    quantize: () => quantize,
    snapColorsToPalette: () => snapColorsToPalette
  });
  var constants_default = {
    signature: "GIF",
    version: "89a",
    trailer: 59,
    extensionIntroducer: 33,
    applicationExtensionLabel: 255,
    graphicControlExtensionLabel: 249,
    imageSeparator: 44,
    signatureSize: 3,
    versionSize: 3,
    globalColorTableFlagMask: 128,
    colorResolutionMask: 112,
    sortFlagMask: 8,
    globalColorTableSizeMask: 7,
    applicationIdentifierSize: 8,
    applicationAuthCodeSize: 3,
    disposalMethodMask: 28,
    userInputFlagMask: 2,
    transparentColorFlagMask: 1,
    localColorTableFlagMask: 128,
    interlaceFlagMask: 64,
    idSortFlagMask: 32,
    localColorTableSizeMask: 7
  };
  function createStream(initialCapacity = 256) {
    let cursor = 0;
    let contents = new Uint8Array(initialCapacity);
    return {
      get buffer() {
        return contents.buffer;
      },
      reset() {
        cursor = 0;
      },
      bytesView() {
        return contents.subarray(0, cursor);
      },
      bytes() {
        return contents.slice(0, cursor);
      },
      writeByte(byte) {
        expand(cursor + 1);
        contents[cursor] = byte;
        cursor++;
      },
      writeBytes(data, offset = 0, byteLength = data.length) {
        expand(cursor + byteLength);
        for (let i = 0;i < byteLength; i++) {
          contents[cursor++] = data[i + offset];
        }
      },
      writeBytesView(data, offset = 0, byteLength = data.byteLength) {
        expand(cursor + byteLength);
        contents.set(data.subarray(offset, offset + byteLength), cursor);
        cursor += byteLength;
      }
    };
    function expand(newCapacity) {
      var prevCapacity = contents.length;
      if (prevCapacity >= newCapacity)
        return;
      var CAPACITY_DOUBLING_MAX = 1024 * 1024;
      newCapacity = Math.max(newCapacity, prevCapacity * (prevCapacity < CAPACITY_DOUBLING_MAX ? 2 : 1.125) >>> 0);
      if (prevCapacity != 0)
        newCapacity = Math.max(newCapacity, 256);
      const oldContents = contents;
      contents = new Uint8Array(newCapacity);
      if (cursor > 0)
        contents.set(oldContents.subarray(0, cursor), 0);
    }
  }
  var BITS = 12;
  var DEFAULT_HSIZE = 5003;
  var MASKS = [
    0,
    1,
    3,
    7,
    15,
    31,
    63,
    127,
    255,
    511,
    1023,
    2047,
    4095,
    8191,
    16383,
    32767,
    65535
  ];
  function lzwEncode(width, height, pixels, colorDepth, outStream = createStream(512), accum = new Uint8Array(256), htab = new Int32Array(DEFAULT_HSIZE), codetab = new Int32Array(DEFAULT_HSIZE)) {
    const hsize = htab.length;
    const initCodeSize = Math.max(2, colorDepth);
    accum.fill(0);
    codetab.fill(0);
    htab.fill(-1);
    let cur_accum = 0;
    let cur_bits = 0;
    const init_bits = initCodeSize + 1;
    const g_init_bits = init_bits;
    let clear_flg = false;
    let n_bits = g_init_bits;
    let maxcode = (1 << n_bits) - 1;
    const ClearCode = 1 << init_bits - 1;
    const EOFCode = ClearCode + 1;
    let free_ent = ClearCode + 2;
    let a_count = 0;
    let ent = pixels[0];
    let hshift = 0;
    for (let fcode = hsize;fcode < 65536; fcode *= 2) {
      ++hshift;
    }
    hshift = 8 - hshift;
    outStream.writeByte(initCodeSize);
    output(ClearCode);
    const length = pixels.length;
    for (let idx = 1;idx < length; idx++) {
      next_block: {
        const c = pixels[idx];
        const fcode = (c << BITS) + ent;
        let i = c << hshift ^ ent;
        if (htab[i] === fcode) {
          ent = codetab[i];
          break next_block;
        }
        const disp = i === 0 ? 1 : hsize - i;
        while (htab[i] >= 0) {
          i -= disp;
          if (i < 0)
            i += hsize;
          if (htab[i] === fcode) {
            ent = codetab[i];
            break next_block;
          }
        }
        output(ent);
        ent = c;
        if (free_ent < 1 << BITS) {
          codetab[i] = free_ent++;
          htab[i] = fcode;
        } else {
          htab.fill(-1);
          free_ent = ClearCode + 2;
          clear_flg = true;
          output(ClearCode);
        }
      }
    }
    output(ent);
    output(EOFCode);
    outStream.writeByte(0);
    return outStream.bytesView();
    function output(code) {
      cur_accum &= MASKS[cur_bits];
      if (cur_bits > 0)
        cur_accum |= code << cur_bits;
      else
        cur_accum = code;
      cur_bits += n_bits;
      while (cur_bits >= 8) {
        accum[a_count++] = cur_accum & 255;
        if (a_count >= 254) {
          outStream.writeByte(a_count);
          outStream.writeBytesView(accum, 0, a_count);
          a_count = 0;
        }
        cur_accum >>= 8;
        cur_bits -= 8;
      }
      if (free_ent > maxcode || clear_flg) {
        if (clear_flg) {
          n_bits = g_init_bits;
          maxcode = (1 << n_bits) - 1;
          clear_flg = false;
        } else {
          ++n_bits;
          maxcode = n_bits === BITS ? 1 << n_bits : (1 << n_bits) - 1;
        }
      }
      if (code == EOFCode) {
        while (cur_bits > 0) {
          accum[a_count++] = cur_accum & 255;
          if (a_count >= 254) {
            outStream.writeByte(a_count);
            outStream.writeBytesView(accum, 0, a_count);
            a_count = 0;
          }
          cur_accum >>= 8;
          cur_bits -= 8;
        }
        if (a_count > 0) {
          outStream.writeByte(a_count);
          outStream.writeBytesView(accum, 0, a_count);
          a_count = 0;
        }
      }
    }
  }
  var lzwEncode_default = lzwEncode;
  function rgb888_to_rgb565(r, g2, b2) {
    return r << 8 & 63488 | g2 << 2 & 992 | b2 >> 3;
  }
  function rgba8888_to_rgba4444(r, g2, b2, a) {
    return r >> 4 | g2 & 240 | (b2 & 240) << 4 | (a & 240) << 8;
  }
  function rgb888_to_rgb444(r, g2, b2) {
    return r >> 4 << 8 | g2 & 240 | b2 >> 4;
  }
  function clamp2(value, min, max) {
    return value < min ? min : value > max ? max : value;
  }
  function sqr(value) {
    return value * value;
  }
  function find_nn(bins, idx, hasAlpha) {
    var nn = 0;
    var err = 10000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000;
    const bin1 = bins[idx];
    const n1 = bin1.cnt;
    const wa = bin1.ac;
    const wr = bin1.rc;
    const wg = bin1.gc;
    const wb = bin1.bc;
    for (var i = bin1.fw;i != 0; i = bins[i].fw) {
      const bin = bins[i];
      const n2 = bin.cnt;
      const nerr2 = n1 * n2 / (n1 + n2);
      if (nerr2 >= err)
        continue;
      var nerr = 0;
      if (hasAlpha) {
        nerr += nerr2 * sqr(bin.ac - wa);
        if (nerr >= err)
          continue;
      }
      nerr += nerr2 * sqr(bin.rc - wr);
      if (nerr >= err)
        continue;
      nerr += nerr2 * sqr(bin.gc - wg);
      if (nerr >= err)
        continue;
      nerr += nerr2 * sqr(bin.bc - wb);
      if (nerr >= err)
        continue;
      err = nerr;
      nn = i;
    }
    bin1.err = err;
    bin1.nn = nn;
  }
  function create_bin() {
    return {
      ac: 0,
      rc: 0,
      gc: 0,
      bc: 0,
      cnt: 0,
      nn: 0,
      fw: 0,
      bk: 0,
      tm: 0,
      mtm: 0,
      err: 0
    };
  }
  function create_bin_list(data, format) {
    const bincount = format === "rgb444" ? 4096 : 65536;
    const bins = new Array(bincount);
    const size = data.length;
    if (format === "rgba4444") {
      for (let i = 0;i < size; ++i) {
        const color2 = data[i];
        const a = color2 >> 24 & 255;
        const b2 = color2 >> 16 & 255;
        const g2 = color2 >> 8 & 255;
        const r = color2 & 255;
        const index = rgba8888_to_rgba4444(r, g2, b2, a);
        let bin = index in bins ? bins[index] : bins[index] = create_bin();
        bin.rc += r;
        bin.gc += g2;
        bin.bc += b2;
        bin.ac += a;
        bin.cnt++;
      }
    } else if (format === "rgb444") {
      for (let i = 0;i < size; ++i) {
        const color2 = data[i];
        const b2 = color2 >> 16 & 255;
        const g2 = color2 >> 8 & 255;
        const r = color2 & 255;
        const index = rgb888_to_rgb444(r, g2, b2);
        let bin = index in bins ? bins[index] : bins[index] = create_bin();
        bin.rc += r;
        bin.gc += g2;
        bin.bc += b2;
        bin.cnt++;
      }
    } else {
      for (let i = 0;i < size; ++i) {
        const color2 = data[i];
        const b2 = color2 >> 16 & 255;
        const g2 = color2 >> 8 & 255;
        const r = color2 & 255;
        const index = rgb888_to_rgb565(r, g2, b2);
        let bin = index in bins ? bins[index] : bins[index] = create_bin();
        bin.rc += r;
        bin.gc += g2;
        bin.bc += b2;
        bin.cnt++;
      }
    }
    return bins;
  }
  function quantize(rgba, maxColors, opts = {}) {
    const {
      format = "rgb565",
      clearAlpha = true,
      clearAlphaColor = 0,
      clearAlphaThreshold = 0,
      oneBitAlpha = false
    } = opts;
    if (!rgba || !rgba.buffer) {
      throw new Error("quantize() expected RGBA Uint8Array data");
    }
    if (!(rgba instanceof Uint8Array) && !(rgba instanceof Uint8ClampedArray)) {
      throw new Error("quantize() expected RGBA Uint8Array data");
    }
    const data = new Uint32Array(rgba.buffer);
    let useSqrt = opts.useSqrt !== false;
    const hasAlpha = format === "rgba4444";
    const bins = create_bin_list(data, format);
    const bincount = bins.length;
    const bincountMinusOne = bincount - 1;
    const heap = new Uint32Array(bincount + 1);
    var maxbins = 0;
    for (var i = 0;i < bincount; ++i) {
      const bin = bins[i];
      if (bin != null) {
        var d2 = 1 / bin.cnt;
        if (hasAlpha)
          bin.ac *= d2;
        bin.rc *= d2;
        bin.gc *= d2;
        bin.bc *= d2;
        bins[maxbins++] = bin;
      }
    }
    if (sqr(maxColors) / maxbins < 0.022) {
      useSqrt = false;
    }
    var i = 0;
    for (;i < maxbins - 1; ++i) {
      bins[i].fw = i + 1;
      bins[i + 1].bk = i;
      if (useSqrt)
        bins[i].cnt = Math.sqrt(bins[i].cnt);
    }
    if (useSqrt)
      bins[i].cnt = Math.sqrt(bins[i].cnt);
    var h, l, l2;
    for (i = 0;i < maxbins; ++i) {
      find_nn(bins, i, false);
      var err = bins[i].err;
      for (l = ++heap[0];l > 1; l = l2) {
        l2 = l >> 1;
        if (bins[h = heap[l2]].err <= err)
          break;
        heap[l] = h;
      }
      heap[l] = i;
    }
    var extbins = maxbins - maxColors;
    for (i = 0;i < extbins; ) {
      var tb;
      for (;; ) {
        var b1 = heap[1];
        tb = bins[b1];
        if (tb.tm >= tb.mtm && bins[tb.nn].mtm <= tb.tm)
          break;
        if (tb.mtm == bincountMinusOne)
          b1 = heap[1] = heap[heap[0]--];
        else {
          find_nn(bins, b1, false);
          tb.tm = i;
        }
        var err = bins[b1].err;
        for (l = 1;(l2 = l + l) <= heap[0]; l = l2) {
          if (l2 < heap[0] && bins[heap[l2]].err > bins[heap[l2 + 1]].err)
            l2++;
          if (err <= bins[h = heap[l2]].err)
            break;
          heap[l] = h;
        }
        heap[l] = b1;
      }
      var nb = bins[tb.nn];
      var n1 = tb.cnt;
      var n2 = nb.cnt;
      var d2 = 1 / (n1 + n2);
      if (hasAlpha)
        tb.ac = d2 * (n1 * tb.ac + n2 * nb.ac);
      tb.rc = d2 * (n1 * tb.rc + n2 * nb.rc);
      tb.gc = d2 * (n1 * tb.gc + n2 * nb.gc);
      tb.bc = d2 * (n1 * tb.bc + n2 * nb.bc);
      tb.cnt += nb.cnt;
      tb.mtm = ++i;
      bins[nb.bk].fw = nb.fw;
      bins[nb.fw].bk = nb.bk;
      nb.mtm = bincountMinusOne;
    }
    let palette = [];
    var k = 0;
    for (i = 0;; ++k) {
      let r = clamp2(Math.round(bins[i].rc), 0, 255);
      let g2 = clamp2(Math.round(bins[i].gc), 0, 255);
      let b2 = clamp2(Math.round(bins[i].bc), 0, 255);
      let a = 255;
      if (hasAlpha) {
        a = clamp2(Math.round(bins[i].ac), 0, 255);
        if (oneBitAlpha) {
          const threshold = typeof oneBitAlpha === "number" ? oneBitAlpha : 127;
          a = a <= threshold ? 0 : 255;
        }
        if (clearAlpha && a <= clearAlphaThreshold) {
          r = g2 = b2 = clearAlphaColor;
          a = 0;
        }
      }
      const color2 = hasAlpha ? [r, g2, b2, a] : [r, g2, b2];
      const exists = existsInPalette(palette, color2);
      if (!exists)
        palette.push(color2);
      if ((i = bins[i].fw) == 0)
        break;
    }
    return palette;
  }
  function existsInPalette(palette, color2) {
    for (let i = 0;i < palette.length; i++) {
      const p2 = palette[i];
      let matchesRGB = p2[0] === color2[0] && p2[1] === color2[1] && p2[2] === color2[2];
      let matchesAlpha = p2.length >= 4 && color2.length >= 4 ? p2[3] === color2[3] : true;
      if (matchesRGB && matchesAlpha)
        return true;
    }
    return false;
  }
  function euclideanDistanceSquared(a, b2) {
    var sum = 0;
    var n2;
    for (n2 = 0;n2 < a.length; n2++) {
      const dx = a[n2] - b2[n2];
      sum += dx * dx;
    }
    return sum;
  }
  function roundStep(byte, step) {
    return step > 1 ? Math.round(byte / step) * step : byte;
  }
  function prequantize(rgba, { roundRGB = 5, roundAlpha = 10, oneBitAlpha = null } = {}) {
    const data = new Uint32Array(rgba.buffer);
    for (let i = 0;i < data.length; i++) {
      const color2 = data[i];
      let a = color2 >> 24 & 255;
      let b2 = color2 >> 16 & 255;
      let g2 = color2 >> 8 & 255;
      let r = color2 & 255;
      a = roundStep(a, roundAlpha);
      if (oneBitAlpha) {
        const threshold = typeof oneBitAlpha === "number" ? oneBitAlpha : 127;
        a = a <= threshold ? 0 : 255;
      }
      r = roundStep(r, roundRGB);
      g2 = roundStep(g2, roundRGB);
      b2 = roundStep(b2, roundRGB);
      data[i] = a << 24 | b2 << 16 | g2 << 8 | r << 0;
    }
  }
  function applyPalette(rgba, palette, format = "rgb565") {
    if (!rgba || !rgba.buffer) {
      throw new Error("quantize() expected RGBA Uint8Array data");
    }
    if (!(rgba instanceof Uint8Array) && !(rgba instanceof Uint8ClampedArray)) {
      throw new Error("quantize() expected RGBA Uint8Array data");
    }
    if (palette.length > 256) {
      throw new Error("applyPalette() only works with 256 colors or less");
    }
    const data = new Uint32Array(rgba.buffer);
    const length = data.length;
    const bincount = format === "rgb444" ? 4096 : 65536;
    const index = new Uint8Array(length);
    const cache = new Array(bincount);
    const hasAlpha = format === "rgba4444";
    if (format === "rgba4444") {
      for (let i = 0;i < length; i++) {
        const color2 = data[i];
        const a = color2 >> 24 & 255;
        const b2 = color2 >> 16 & 255;
        const g2 = color2 >> 8 & 255;
        const r = color2 & 255;
        const key = rgba8888_to_rgba4444(r, g2, b2, a);
        const idx = key in cache ? cache[key] : cache[key] = nearestColorIndexRGBA(r, g2, b2, a, palette);
        index[i] = idx;
      }
    } else {
      const rgb888_to_key = format === "rgb444" ? rgb888_to_rgb444 : rgb888_to_rgb565;
      for (let i = 0;i < length; i++) {
        const color2 = data[i];
        const b2 = color2 >> 16 & 255;
        const g2 = color2 >> 8 & 255;
        const r = color2 & 255;
        const key = rgb888_to_key(r, g2, b2);
        const idx = key in cache ? cache[key] : cache[key] = nearestColorIndexRGB(r, g2, b2, palette);
        index[i] = idx;
      }
    }
    return index;
  }
  function nearestColorIndexRGBA(r, g2, b2, a, palette) {
    let k = 0;
    let mindist = 10000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000;
    for (let i = 0;i < palette.length; i++) {
      const px2 = palette[i];
      const a2 = px2[3];
      let curdist = sqr2(a2 - a);
      if (curdist > mindist)
        continue;
      const r2 = px2[0];
      curdist += sqr2(r2 - r);
      if (curdist > mindist)
        continue;
      const g22 = px2[1];
      curdist += sqr2(g22 - g2);
      if (curdist > mindist)
        continue;
      const b22 = px2[2];
      curdist += sqr2(b22 - b2);
      if (curdist > mindist)
        continue;
      mindist = curdist;
      k = i;
    }
    return k;
  }
  function nearestColorIndexRGB(r, g2, b2, palette) {
    let k = 0;
    let mindist = 10000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000;
    for (let i = 0;i < palette.length; i++) {
      const px2 = palette[i];
      const r2 = px2[0];
      let curdist = sqr2(r2 - r);
      if (curdist > mindist)
        continue;
      const g22 = px2[1];
      curdist += sqr2(g22 - g2);
      if (curdist > mindist)
        continue;
      const b22 = px2[2];
      curdist += sqr2(b22 - b2);
      if (curdist > mindist)
        continue;
      mindist = curdist;
      k = i;
    }
    return k;
  }
  function snapColorsToPalette(palette, knownColors, threshold = 5) {
    if (!palette.length || !knownColors.length)
      return;
    const paletteRGB = palette.map((p2) => p2.slice(0, 3));
    const thresholdSq = threshold * threshold;
    const dim = palette[0].length;
    for (let i = 0;i < knownColors.length; i++) {
      let color2 = knownColors[i];
      if (color2.length < dim) {
        color2 = [color2[0], color2[1], color2[2], 255];
      } else if (color2.length > dim) {
        color2 = color2.slice(0, 3);
      } else {
        color2 = color2.slice();
      }
      const r = nearestColorIndexWithDistance(paletteRGB, color2.slice(0, 3), euclideanDistanceSquared);
      const idx = r[0];
      const distanceSq = r[1];
      if (distanceSq > 0 && distanceSq <= thresholdSq) {
        palette[idx] = color2;
      }
    }
  }
  function sqr2(a) {
    return a * a;
  }
  function nearestColorIndex(colors, pixel, distanceFn = euclideanDistanceSquared) {
    let minDist = Infinity;
    let minDistIndex = -1;
    for (let j = 0;j < colors.length; j++) {
      const paletteColor = colors[j];
      const dist = distanceFn(pixel, paletteColor);
      if (dist < minDist) {
        minDist = dist;
        minDistIndex = j;
      }
    }
    return minDistIndex;
  }
  function nearestColorIndexWithDistance(colors, pixel, distanceFn = euclideanDistanceSquared) {
    let minDist = Infinity;
    let minDistIndex = -1;
    for (let j = 0;j < colors.length; j++) {
      const paletteColor = colors[j];
      const dist = distanceFn(pixel, paletteColor);
      if (dist < minDist) {
        minDist = dist;
        minDistIndex = j;
      }
    }
    return [minDistIndex, minDist];
  }
  function nearestColor(colors, pixel, distanceFn = euclideanDistanceSquared) {
    return colors[nearestColorIndex(colors, pixel, distanceFn)];
  }
  function GIFEncoder(opt = {}) {
    const { initialCapacity = 4096, auto = true } = opt;
    const stream = createStream(initialCapacity);
    const HSIZE = 5003;
    const accum = new Uint8Array(256);
    const htab = new Int32Array(HSIZE);
    const codetab = new Int32Array(HSIZE);
    let hasInit = false;
    return {
      reset() {
        stream.reset();
        hasInit = false;
      },
      finish() {
        stream.writeByte(constants_default.trailer);
      },
      bytes() {
        return stream.bytes();
      },
      bytesView() {
        return stream.bytesView();
      },
      get buffer() {
        return stream.buffer;
      },
      get stream() {
        return stream;
      },
      writeHeader,
      writeFrame(index, width, height, opts = {}) {
        const {
          transparent = false,
          transparentIndex = 0,
          delay = 0,
          palette = null,
          repeat = 0,
          colorDepth = 8,
          dispose = -1
        } = opts;
        let first = false;
        if (auto) {
          if (!hasInit) {
            first = true;
            writeHeader();
            hasInit = true;
          }
        } else {
          first = Boolean(opts.first);
        }
        width = Math.max(0, Math.floor(width));
        height = Math.max(0, Math.floor(height));
        if (first) {
          if (!palette) {
            throw new Error("First frame must include a { palette } option");
          }
          encodeLogicalScreenDescriptor(stream, width, height, palette, colorDepth);
          encodeColorTable(stream, palette);
          if (repeat >= 0) {
            encodeNetscapeExt(stream, repeat);
          }
        }
        const delayTime = Math.round(delay / 10);
        encodeGraphicControlExt(stream, dispose, delayTime, transparent, transparentIndex);
        const useLocalColorTable = Boolean(palette) && !first;
        encodeImageDescriptor(stream, width, height, useLocalColorTable ? palette : null);
        if (useLocalColorTable)
          encodeColorTable(stream, palette);
        encodePixels(stream, index, width, height, colorDepth, accum, htab, codetab);
      }
    };
    function writeHeader() {
      writeUTFBytes(stream, "GIF89a");
    }
  }
  function encodeGraphicControlExt(stream, dispose, delay, transparent, transparentIndex) {
    stream.writeByte(33);
    stream.writeByte(249);
    stream.writeByte(4);
    if (transparentIndex < 0) {
      transparentIndex = 0;
      transparent = false;
    }
    var transp, disp;
    if (!transparent) {
      transp = 0;
      disp = 0;
    } else {
      transp = 1;
      disp = 2;
    }
    if (dispose >= 0) {
      disp = dispose & 7;
    }
    disp <<= 2;
    const userInput = 0;
    stream.writeByte(0 | disp | userInput | transp);
    writeUInt16(stream, delay);
    stream.writeByte(transparentIndex || 0);
    stream.writeByte(0);
  }
  function encodeLogicalScreenDescriptor(stream, width, height, palette, colorDepth = 8) {
    const globalColorTableFlag = 1;
    const sortFlag = 0;
    const globalColorTableSize = colorTableSize(palette.length) - 1;
    const fields = globalColorTableFlag << 7 | colorDepth - 1 << 4 | sortFlag << 3 | globalColorTableSize;
    const backgroundColorIndex = 0;
    const pixelAspectRatio = 0;
    writeUInt16(stream, width);
    writeUInt16(stream, height);
    stream.writeBytes([fields, backgroundColorIndex, pixelAspectRatio]);
  }
  function encodeNetscapeExt(stream, repeat) {
    stream.writeByte(33);
    stream.writeByte(255);
    stream.writeByte(11);
    writeUTFBytes(stream, "NETSCAPE2.0");
    stream.writeByte(3);
    stream.writeByte(1);
    writeUInt16(stream, repeat);
    stream.writeByte(0);
  }
  function encodeColorTable(stream, palette) {
    const colorTableLength = 1 << colorTableSize(palette.length);
    for (let i = 0;i < colorTableLength; i++) {
      let color2 = [0, 0, 0];
      if (i < palette.length) {
        color2 = palette[i];
      }
      stream.writeByte(color2[0]);
      stream.writeByte(color2[1]);
      stream.writeByte(color2[2]);
    }
  }
  function encodeImageDescriptor(stream, width, height, localPalette) {
    stream.writeByte(44);
    writeUInt16(stream, 0);
    writeUInt16(stream, 0);
    writeUInt16(stream, width);
    writeUInt16(stream, height);
    if (localPalette) {
      const interlace = 0;
      const sorted = 0;
      const palSize = colorTableSize(localPalette.length) - 1;
      stream.writeByte(128 | interlace | sorted | 0 | palSize);
    } else {
      stream.writeByte(0);
    }
  }
  function encodePixels(stream, index, width, height, colorDepth = 8, accum, htab, codetab) {
    lzwEncode_default(width, height, index, colorDepth, stream, accum, htab, codetab);
  }
  function writeUInt16(stream, short) {
    stream.writeByte(short & 255);
    stream.writeByte(short >> 8 & 255);
  }
  function writeUTFBytes(stream, text) {
    for (var i = 0;i < text.length; i++) {
      stream.writeByte(text.charCodeAt(i));
    }
  }
  function colorTableSize(length) {
    return Math.max(Math.ceil(Math.log2(length)), 1);
  }
  var src_default = GIFEncoder;
});

// node_modules/libtess/libtess.min.js
var require_libtess_min = __commonJS((exports, module) => {
  var n2;
  function t(a, b2) {
    return a.b === b2.b && a.a === b2.a;
  }
  function u(a, b2) {
    return a.b < b2.b || a.b === b2.b && a.a <= b2.a;
  }
  function v(a, b2, c) {
    var d2 = b2.b - a.b, e2 = c.b - b2.b;
    return 0 < d2 + e2 ? d2 < e2 ? b2.a - a.a + d2 / (d2 + e2) * (a.a - c.a) : b2.a - c.a + e2 / (d2 + e2) * (c.a - a.a) : 0;
  }
  function x(a, b2, c) {
    var d2 = b2.b - a.b, e2 = c.b - b2.b;
    return 0 < d2 + e2 ? (b2.a - c.a) * d2 + (b2.a - a.a) * e2 : 0;
  }
  function z(a, b2) {
    return a.a < b2.a || a.a === b2.a && a.b <= b2.b;
  }
  function aa(a, b2, c) {
    var d2 = b2.a - a.a, e2 = c.a - b2.a;
    return 0 < d2 + e2 ? d2 < e2 ? b2.b - a.b + d2 / (d2 + e2) * (a.b - c.b) : b2.b - c.b + e2 / (d2 + e2) * (c.b - a.b) : 0;
  }
  function ba(a, b2, c) {
    var d2 = b2.a - a.a, e2 = c.a - b2.a;
    return 0 < d2 + e2 ? (b2.b - c.b) * d2 + (b2.b - a.b) * e2 : 0;
  }
  function ca(a) {
    return u(a.b.a, a.a);
  }
  function da(a) {
    return u(a.a, a.b.a);
  }
  function A(a, b2, c, d2) {
    a = 0 > a ? 0 : a;
    c = 0 > c ? 0 : c;
    return a <= c ? c === 0 ? (b2 + d2) / 2 : b2 + a / (a + c) * (d2 - b2) : d2 + c / (a + c) * (b2 - d2);
  }
  function ea(a) {
    var b2 = B(a.b);
    C(b2, a.c);
    C(b2.b, a.c);
    D(b2, a.a);
    return b2;
  }
  function E(a, b2) {
    var c = false, d2 = false;
    a !== b2 && (b2.a !== a.a && (d2 = true, F(b2.a, a.a)), b2.d !== a.d && (c = true, G(b2.d, a.d)), H(b2, a), d2 || (C(b2, a.a), a.a.c = a), c || (D(b2, a.d), a.d.a = a));
  }
  function I(a) {
    var b2 = a.b, c = false;
    a.d !== a.b.d && (c = true, G(a.d, a.b.d));
    a.c === a ? F(a.a, null) : (a.b.d.a = J(a), a.a.c = a.c, H(a, J(a)), c || D(a, a.d));
    b2.c === b2 ? (F(b2.a, null), G(b2.d, null)) : (a.d.a = J(b2), b2.a.c = b2.c, H(b2, J(b2)));
    fa(a);
  }
  function K(a) {
    var b2 = B(a), c = b2.b;
    H(b2, a.e);
    b2.a = a.b.a;
    C(c, b2.a);
    b2.d = c.d = a.d;
    b2 = b2.b;
    H(a.b, J(a.b));
    H(a.b, b2);
    a.b.a = b2.a;
    b2.b.a.c = b2.b;
    b2.b.d = a.b.d;
    b2.f = a.f;
    b2.b.f = a.b.f;
    return b2;
  }
  function L(a, b2) {
    var c = false, d2 = B(a), e2 = d2.b;
    b2.d !== a.d && (c = true, G(b2.d, a.d));
    H(d2, a.e);
    H(e2, b2);
    d2.a = a.b.a;
    e2.a = b2.a;
    d2.d = e2.d = a.d;
    a.d.a = e2;
    c || D(d2, a.d);
    return d2;
  }
  function B(a) {
    var b2 = new M, c = new M, d2 = a.b.h;
    c.h = d2;
    d2.b.h = b2;
    b2.h = a;
    a.b.h = c;
    b2.b = c;
    b2.c = b2;
    b2.e = c;
    c.b = b2;
    c.c = c;
    return c.e = b2;
  }
  function H(a, b2) {
    var c = a.c, d2 = b2.c;
    c.b.e = b2;
    d2.b.e = a;
    a.c = d2;
    b2.c = c;
  }
  function C(a, b2) {
    var c = b2.f, d2 = new N(b2, c);
    c.e = d2;
    b2.f = d2;
    c = d2.c = a;
    do
      c.a = d2, c = c.c;
    while (c !== a);
  }
  function D(a, b2) {
    var c = b2.d, d2 = new ga(b2, c);
    c.b = d2;
    b2.d = d2;
    d2.a = a;
    d2.c = b2.c;
    c = a;
    do
      c.d = d2, c = c.e;
    while (c !== a);
  }
  function fa(a) {
    var b2 = a.h;
    a = a.b.h;
    b2.b.h = a;
    a.b.h = b2;
  }
  function F(a, b2) {
    var c = a.c, d2 = c;
    do
      d2.a = b2, d2 = d2.c;
    while (d2 !== c);
    c = a.f;
    d2 = a.e;
    d2.f = c;
    c.e = d2;
  }
  function G(a, b2) {
    var c = a.a, d2 = c;
    do
      d2.d = b2, d2 = d2.e;
    while (d2 !== c);
    c = a.d;
    d2 = a.b;
    d2.d = c;
    c.b = d2;
  }
  function ha(a) {
    var b2 = 0;
    Math.abs(a[1]) > Math.abs(a[0]) && (b2 = 1);
    Math.abs(a[2]) > Math.abs(a[b2]) && (b2 = 2);
    return b2;
  }
  var O = 4 * 1000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000;
  function P(a, b2) {
    a.f += b2.f;
    a.b.f += b2.b.f;
  }
  function ia(a, b2, c) {
    a = a.a;
    b2 = b2.a;
    c = c.a;
    if (b2.b.a === a)
      return c.b.a === a ? u(b2.a, c.a) ? 0 >= x(c.b.a, b2.a, c.a) : 0 <= x(b2.b.a, c.a, b2.a) : 0 >= x(c.b.a, a, c.a);
    if (c.b.a === a)
      return 0 <= x(b2.b.a, a, b2.a);
    b2 = v(b2.b.a, a, b2.a);
    a = v(c.b.a, a, c.a);
    return b2 >= a;
  }
  function Q(a) {
    a.a.i = null;
    var b2 = a.e;
    b2.a.c = b2.c;
    b2.c.a = b2.a;
    a.e = null;
  }
  function ja(a, b2) {
    I(a.a);
    a.c = false;
    a.a = b2;
    b2.i = a;
  }
  function ka(a) {
    var b2 = a.a.a;
    do
      a = R(a);
    while (a.a.a === b2);
    a.c && (b2 = L(S(a).a.b, a.a.e), ja(a, b2), a = R(a));
    return a;
  }
  function la(a, b2, c) {
    var d2 = new ma;
    d2.a = c;
    d2.e = na(a.f, b2.e, d2);
    return c.i = d2;
  }
  function oa(a, b2) {
    switch (a.s) {
      case 100130:
        return (b2 & 1) !== 0;
      case 100131:
        return b2 !== 0;
      case 100132:
        return 0 < b2;
      case 100133:
        return 0 > b2;
      case 100134:
        return 2 <= b2 || -2 >= b2;
    }
    return false;
  }
  function pa(a) {
    var b2 = a.a, c = b2.d;
    c.c = a.d;
    c.a = b2;
    Q(a);
  }
  function T(a, b2, c) {
    a = b2;
    for (b2 = b2.a;a !== c; ) {
      a.c = false;
      var d2 = S(a), e2 = d2.a;
      if (e2.a !== b2.a) {
        if (!d2.c) {
          pa(a);
          break;
        }
        e2 = L(b2.c.b, e2.b);
        ja(d2, e2);
      }
      b2.c !== e2 && (E(J(e2), e2), E(b2, e2));
      pa(a);
      b2 = d2.a;
      a = d2;
    }
    return b2;
  }
  function U(a, b2, c, d2, e2, f) {
    var g2 = true;
    do
      la(a, b2, c.b), c = c.c;
    while (c !== d2);
    for (e2 === null && (e2 = S(b2).a.b.c);; ) {
      d2 = S(b2);
      c = d2.a.b;
      if (c.a !== e2.a)
        break;
      c.c !== e2 && (E(J(c), c), E(J(e2), c));
      d2.f = b2.f - c.f;
      d2.d = oa(a, d2.f);
      b2.b = true;
      !g2 && qa(a, b2) && (P(c, e2), Q(b2), I(e2));
      g2 = false;
      b2 = d2;
      e2 = c;
    }
    b2.b = true;
    f && ra(a, b2);
  }
  function sa(a, b2, c, d2, e2) {
    var f = [b2.g[0], b2.g[1], b2.g[2]];
    b2.d = null;
    b2.d = a.o ? a.o(f, c, d2, a.c) || null : null;
    b2.d === null && (e2 ? a.n || (V(a, 100156), a.n = true) : b2.d = c[0]);
  }
  function ta(a, b2, c) {
    var d2 = [null, null, null, null];
    d2[0] = b2.a.d;
    d2[1] = c.a.d;
    sa(a, b2.a, d2, [0.5, 0.5, 0, 0], false);
    E(b2, c);
  }
  function ua(a, b2, c, d2, e2) {
    var f = Math.abs(b2.b - a.b) + Math.abs(b2.a - a.a), g2 = Math.abs(c.b - a.b) + Math.abs(c.a - a.a), h = e2 + 1;
    d2[e2] = 0.5 * g2 / (f + g2);
    d2[h] = 0.5 * f / (f + g2);
    a.g[0] += d2[e2] * b2.g[0] + d2[h] * c.g[0];
    a.g[1] += d2[e2] * b2.g[1] + d2[h] * c.g[1];
    a.g[2] += d2[e2] * b2.g[2] + d2[h] * c.g[2];
  }
  function qa(a, b2) {
    var c = S(b2), d2 = b2.a, e2 = c.a;
    if (u(d2.a, e2.a)) {
      if (0 < x(e2.b.a, d2.a, e2.a))
        return false;
      if (!t(d2.a, e2.a))
        K(e2.b), E(d2, J(e2)), b2.b = c.b = true;
      else if (d2.a !== e2.a) {
        var c = a.e, f = d2.a.h;
        if (0 <= f) {
          var { b: c, d: g2, e: h, c: k } = c, l = k[f];
          g2[l] = g2[c.a];
          k[g2[l]] = l;
          l <= --c.a && (1 >= l ? W(c, l) : u(h[g2[l >> 1]], h[g2[l]]) ? W(c, l) : va(c, l));
          h[f] = null;
          k[f] = c.b;
          c.b = f;
        } else
          for (c.c[-(f + 1)] = null;0 < c.a && c.c[c.d[c.a - 1]] === null; )
            --c.a;
        ta(a, J(e2), d2);
      }
    } else {
      if (0 > x(d2.b.a, e2.a, d2.a))
        return false;
      R(b2).b = b2.b = true;
      K(d2.b);
      E(J(e2), d2);
    }
    return true;
  }
  function wa(a, b2) {
    var c = S(b2), d2 = b2.a, e2 = c.a, f = d2.a, g2 = e2.a, h = d2.b.a, k = e2.b.a, l = new N;
    x(h, a.a, f);
    x(k, a.a, g2);
    if (f === g2 || Math.min(f.a, h.a) > Math.max(g2.a, k.a))
      return false;
    if (u(f, g2)) {
      if (0 < x(k, f, g2))
        return false;
    } else if (0 > x(h, g2, f))
      return false;
    var r = h, p2 = f, q = k, y = g2, m, w;
    u(r, p2) || (m = r, r = p2, p2 = m);
    u(q, y) || (m = q, q = y, y = m);
    u(r, q) || (m = r, r = q, q = m, m = p2, p2 = y, y = m);
    u(q, p2) ? u(p2, y) ? (m = v(r, q, p2), w = v(q, p2, y), 0 > m + w && (m = -m, w = -w), l.b = A(m, q.b, w, p2.b)) : (m = x(r, q, p2), w = -x(r, y, p2), 0 > m + w && (m = -m, w = -w), l.b = A(m, q.b, w, y.b)) : l.b = (q.b + p2.b) / 2;
    z(r, p2) || (m = r, r = p2, p2 = m);
    z(q, y) || (m = q, q = y, y = m);
    z(r, q) || (m = r, r = q, q = m, m = p2, p2 = y, y = m);
    z(q, p2) ? z(p2, y) ? (m = aa(r, q, p2), w = aa(q, p2, y), 0 > m + w && (m = -m, w = -w), l.a = A(m, q.a, w, p2.a)) : (m = ba(r, q, p2), w = -ba(r, y, p2), 0 > m + w && (m = -m, w = -w), l.a = A(m, q.a, w, y.a)) : l.a = (q.a + p2.a) / 2;
    u(l, a.a) && (l.b = a.a.b, l.a = a.a.a);
    r = u(f, g2) ? f : g2;
    u(r, l) && (l.b = r.b, l.a = r.a);
    if (t(l, f) || t(l, g2))
      return qa(a, b2), false;
    if (!t(h, a.a) && 0 <= x(h, a.a, l) || !t(k, a.a) && 0 >= x(k, a.a, l)) {
      if (k === a.a)
        return K(d2.b), E(e2.b, d2), b2 = ka(b2), d2 = S(b2).a, T(a, S(b2), c), U(a, b2, J(d2), d2, d2, true), true;
      if (h === a.a) {
        K(e2.b);
        E(d2.e, J(e2));
        f = c = b2;
        g2 = f.a.b.a;
        do
          f = R(f);
        while (f.a.b.a === g2);
        b2 = f;
        f = S(b2).a.b.c;
        c.a = J(e2);
        e2 = T(a, c, null);
        U(a, b2, e2.c, d2.b.c, f, true);
        return true;
      }
      0 <= x(h, a.a, l) && (R(b2).b = b2.b = true, K(d2.b), d2.a.b = a.a.b, d2.a.a = a.a.a);
      0 >= x(k, a.a, l) && (b2.b = c.b = true, K(e2.b), e2.a.b = a.a.b, e2.a.a = a.a.a);
      return false;
    }
    K(d2.b);
    K(e2.b);
    E(J(e2), d2);
    d2.a.b = l.b;
    d2.a.a = l.a;
    d2.a.h = xa(a.e, d2.a);
    d2 = d2.a;
    e2 = [0, 0, 0, 0];
    l = [f.d, h.d, g2.d, k.d];
    d2.g[0] = d2.g[1] = d2.g[2] = 0;
    ua(d2, f, h, e2, 0);
    ua(d2, g2, k, e2, 2);
    sa(a, d2, l, e2, true);
    R(b2).b = b2.b = c.b = true;
    return false;
  }
  function ra(a, b2) {
    for (var c = S(b2);; ) {
      for (;c.b; )
        b2 = c, c = S(c);
      if (!b2.b && (c = b2, b2 = R(b2), b2 === null || !b2.b))
        break;
      b2.b = false;
      var d2 = b2.a, e2 = c.a, f;
      if (f = d2.b.a !== e2.b.a)
        a: {
          f = b2;
          var g2 = S(f), h = f.a, k = g2.a, l = undefined;
          if (u(h.b.a, k.b.a)) {
            if (0 > x(h.b.a, k.b.a, h.a)) {
              f = false;
              break a;
            }
            R(f).b = f.b = true;
            l = K(h);
            E(k.b, l);
            l.d.c = f.d;
          } else {
            if (0 < x(k.b.a, h.b.a, k.a)) {
              f = false;
              break a;
            }
            f.b = g2.b = true;
            l = K(k);
            E(h.e, k.b);
            l.b.d.c = f.d;
          }
          f = true;
        }
      f && (c.c ? (Q(c), I(e2), c = S(b2), e2 = c.a) : b2.c && (Q(b2), I(d2), b2 = R(c), d2 = b2.a));
      if (d2.a !== e2.a) {
        if (d2.b.a === e2.b.a || b2.c || c.c || d2.b.a !== a.a && e2.b.a !== a.a)
          qa(a, b2);
        else if (wa(a, b2))
          break;
      }
      d2.a === e2.a && d2.b.a === e2.b.a && (P(e2, d2), Q(b2), I(d2), b2 = R(c));
    }
  }
  function ya(a, b2) {
    a.a = b2;
    for (var c = b2.c;c.i === null; )
      if (c = c.c, c === b2.c) {
        var c = a, d2 = b2, e2 = new ma;
        e2.a = d2.c.b;
        var f = c.f, g2 = f.a;
        do
          g2 = g2.a;
        while (g2.b !== null && !f.c(f.b, e2, g2.b));
        var f = g2.b, h = S(f), e2 = f.a, g2 = h.a;
        if (x(e2.b.a, d2, e2.a) === 0)
          e2 = f.a, t(e2.a, d2) || t(e2.b.a, d2) || (K(e2.b), f.c && (I(e2.c), f.c = false), E(d2.c, e2), ya(c, d2));
        else {
          var k = u(g2.b.a, e2.b.a) ? f : h, h = undefined;
          f.d || k.c ? (k === f ? h = L(d2.c.b, e2.e) : h = L(g2.b.c.b, d2.c).b, k.c ? ja(k, h) : (e2 = c, f = la(c, f, h), f.f = R(f).f + f.a.f, f.d = oa(e2, f.f)), ya(c, d2)) : U(c, f, d2.c, d2.c, null, true);
        }
        return;
      }
    c = ka(c.i);
    e2 = S(c);
    f = e2.a;
    e2 = T(a, e2, null);
    if (e2.c === f) {
      var f = e2, e2 = f.c, g2 = S(c), h = c.a, k = g2.a, l = false;
      h.b.a !== k.b.a && wa(a, c);
      t(h.a, a.a) && (E(J(e2), h), c = ka(c), e2 = S(c).a, T(a, S(c), g2), l = true);
      t(k.a, a.a) && (E(f, J(k)), f = T(a, g2, null), l = true);
      l ? U(a, c, f.c, e2, e2, true) : (u(k.a, h.a) ? d2 = J(k) : d2 = h, d2 = L(f.c.b, d2), U(a, c, d2, d2.c, d2.c, false), d2.b.i.c = true, ra(a, c));
    } else
      U(a, c, e2.c, f, f, true);
  }
  function za(a, b2) {
    var c = new ma, d2 = ea(a.b);
    d2.a.b = O;
    d2.a.a = b2;
    d2.b.a.b = -O;
    d2.b.a.a = b2;
    a.a = d2.b.a;
    c.a = d2;
    c.f = 0;
    c.d = false;
    c.c = false;
    c.h = true;
    c.b = false;
    d2 = a.f;
    d2 = na(d2, d2.a, c);
    c.e = d2;
  }
  function Aa(a) {
    this.a = new Ba;
    this.b = a;
    this.c = ia;
  }
  function na(a, b2, c) {
    do
      b2 = b2.c;
    while (b2.b !== null && !a.c(a.b, b2.b, c));
    a = new Ba(c, b2.a, b2);
    b2.a.c = a;
    return b2.a = a;
  }
  function Ba(a, b2, c) {
    this.b = a || null;
    this.a = b2 || this;
    this.c = c || this;
  }
  function X() {
    this.d = Y;
    this.p = this.b = this.q = null;
    this.j = [0, 0, 0];
    this.s = 100130;
    this.n = false;
    this.o = this.a = this.e = this.f = null;
    this.m = false;
    this.c = this.r = this.i = this.k = this.l = this.h = null;
  }
  var Y = 0;
  n2 = X.prototype;
  n2.x = function() {
    Z(this, Y);
  };
  n2.B = function(a, b2) {
    switch (a) {
      case 100142:
        return;
      case 100140:
        switch (b2) {
          case 100130:
          case 100131:
          case 100132:
          case 100133:
          case 100134:
            this.s = b2;
            return;
        }
        break;
      case 100141:
        this.m = !!b2;
        return;
      default:
        V(this, 100900);
        return;
    }
    V(this, 100901);
  };
  n2.y = function(a) {
    switch (a) {
      case 100142:
        return 0;
      case 100140:
        return this.s;
      case 100141:
        return this.m;
      default:
        V(this, 100900);
    }
    return false;
  };
  n2.A = function(a, b2, c) {
    this.j[0] = a;
    this.j[1] = b2;
    this.j[2] = c;
  };
  n2.z = function(a, b2) {
    var c = b2 ? b2 : null;
    switch (a) {
      case 100100:
      case 100106:
        this.h = c;
        break;
      case 100104:
      case 100110:
        this.l = c;
        break;
      case 100101:
      case 100107:
        this.k = c;
        break;
      case 100102:
      case 100108:
        this.i = c;
        break;
      case 100103:
      case 100109:
        this.p = c;
        break;
      case 100105:
      case 100111:
        this.o = c;
        break;
      case 100112:
        this.r = c;
        break;
      default:
        V(this, 100900);
    }
  };
  n2.C = function(a, b2) {
    var c = false, d2 = [0, 0, 0];
    Z(this, 2);
    for (var e2 = 0;3 > e2; ++e2) {
      var f = a[e2];
      -1000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000 > f && (f = -1000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000, c = true);
      1000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000 < f && (f = 1000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000, c = true);
      d2[e2] = f;
    }
    c && V(this, 100155);
    c = this.q;
    c === null ? (c = ea(this.b), E(c, c.b)) : (K(c), c = c.e);
    c.a.d = b2;
    c.a.g[0] = d2[0];
    c.a.g[1] = d2[1];
    c.a.g[2] = d2[2];
    c.f = 1;
    c.b.f = -1;
    this.q = c;
  };
  n2.u = function(a) {
    Z(this, Y);
    this.d = 1;
    this.b = new Ca;
    this.c = a;
  };
  n2.t = function() {
    Z(this, 1);
    this.d = 2;
    this.q = null;
  };
  n2.v = function() {
    Z(this, 2);
    this.d = 1;
  };
  n2.w = function() {
    Z(this, 1);
    this.d = Y;
    var a = this.j[0], b2 = this.j[1], c = this.j[2], d2 = false, e2 = [a, b2, c];
    if (a === 0 && b2 === 0 && c === 0) {
      for (var b2 = [-2 * 1000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000, -2 * 1000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000, -2 * 1000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000], f = [2 * 1000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000, 2 * 1000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000, 2 * 1000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000], c = [], g2 = [], d2 = this.b.c, a = d2.e;a !== d2; a = a.e)
        for (var h = 0;3 > h; ++h) {
          var k = a.g[h];
          k < f[h] && (f[h] = k, g2[h] = a);
          k > b2[h] && (b2[h] = k, c[h] = a);
        }
      a = 0;
      b2[1] - f[1] > b2[0] - f[0] && (a = 1);
      b2[2] - f[2] > b2[a] - f[a] && (a = 2);
      if (f[a] >= b2[a])
        e2[0] = 0, e2[1] = 0, e2[2] = 1;
      else {
        b2 = 0;
        f = g2[a];
        c = c[a];
        g2 = [0, 0, 0];
        f = [f.g[0] - c.g[0], f.g[1] - c.g[1], f.g[2] - c.g[2]];
        h = [0, 0, 0];
        for (a = d2.e;a !== d2; a = a.e)
          h[0] = a.g[0] - c.g[0], h[1] = a.g[1] - c.g[1], h[2] = a.g[2] - c.g[2], g2[0] = f[1] * h[2] - f[2] * h[1], g2[1] = f[2] * h[0] - f[0] * h[2], g2[2] = f[0] * h[1] - f[1] * h[0], k = g2[0] * g2[0] + g2[1] * g2[1] + g2[2] * g2[2], k > b2 && (b2 = k, e2[0] = g2[0], e2[1] = g2[1], e2[2] = g2[2]);
        0 >= b2 && (e2[0] = e2[1] = e2[2] = 0, e2[ha(f)] = 1);
      }
      d2 = true;
    }
    g2 = ha(e2);
    a = this.b.c;
    b2 = (g2 + 1) % 3;
    c = (g2 + 2) % 3;
    g2 = 0 < e2[g2] ? 1 : -1;
    for (e2 = a.e;e2 !== a; e2 = e2.e)
      e2.b = e2.g[b2], e2.a = g2 * e2.g[c];
    if (d2) {
      e2 = 0;
      d2 = this.b.a;
      for (a = d2.b;a !== d2; a = a.b)
        if (b2 = a.a, !(0 >= b2.f)) {
          do
            e2 += (b2.a.b - b2.b.a.b) * (b2.a.a + b2.b.a.a), b2 = b2.e;
          while (b2 !== a.a);
        }
      if (0 > e2)
        for (e2 = this.b.c, d2 = e2.e;d2 !== e2; d2 = d2.e)
          d2.a = -d2.a;
    }
    this.n = false;
    e2 = this.b.b;
    for (a = e2.h;a !== e2; a = d2)
      if (d2 = a.h, b2 = a.e, t(a.a, a.b.a) && a.e.e !== a && (ta(this, b2, a), I(a), a = b2, b2 = a.e), b2.e === a) {
        if (b2 !== a) {
          if (b2 === d2 || b2 === d2.b)
            d2 = d2.h;
          I(b2);
        }
        if (a === d2 || a === d2.b)
          d2 = d2.h;
        I(a);
      }
    this.e = e2 = new Da;
    d2 = this.b.c;
    for (a = d2.e;a !== d2; a = a.e)
      a.h = xa(e2, a);
    Ea(e2);
    this.f = new Aa(this);
    za(this, -O);
    for (za(this, O);(e2 = Fa(this.e)) !== null; ) {
      for (;; ) {
        a:
          if (a = this.e, a.a === 0)
            d2 = Ga(a.b);
          else if (d2 = a.c[a.d[a.a - 1]], a.b.a !== 0 && (a = Ga(a.b), u(a, d2))) {
            d2 = a;
            break a;
          }
        if (d2 === null || !t(d2, e2))
          break;
        d2 = Fa(this.e);
        ta(this, e2.c, d2.c);
      }
      ya(this, e2);
    }
    this.a = this.f.a.a.b.a.a;
    for (e2 = 0;(d2 = this.f.a.a.b) !== null; )
      d2.h || ++e2, Q(d2);
    this.f = null;
    e2 = this.e;
    e2.b = null;
    e2.d = null;
    this.e = e2.c = null;
    e2 = this.b;
    for (a = e2.a.b;a !== e2.a; a = d2)
      d2 = a.b, a = a.a, a.e.e === a && (P(a.c, a), I(a));
    if (!this.n) {
      e2 = this.b;
      if (this.m)
        for (a = e2.b.h;a !== e2.b; a = d2)
          d2 = a.h, a.b.d.c !== a.d.c ? a.f = a.d.c ? 1 : -1 : I(a);
      else
        for (a = e2.a.b;a !== e2.a; a = d2)
          if (d2 = a.b, a.c) {
            for (a = a.a;u(a.b.a, a.a); a = a.c.b)
              ;
            for (;u(a.a, a.b.a); a = a.e)
              ;
            b2 = a.c.b;
            for (c = undefined;a.e !== b2; )
              if (u(a.b.a, b2.a)) {
                for (;b2.e !== a && (ca(b2.e) || 0 >= x(b2.a, b2.b.a, b2.e.b.a)); )
                  c = L(b2.e, b2), b2 = c.b;
                b2 = b2.c.b;
              } else {
                for (;b2.e !== a && (da(a.c.b) || 0 <= x(a.b.a, a.a, a.c.b.a)); )
                  c = L(a, a.c.b), a = c.b;
                a = a.e;
              }
            for (;b2.e.e !== a; )
              c = L(b2.e, b2), b2 = c.b;
          }
      if (this.h || this.i || this.k || this.l)
        if (this.m)
          for (e2 = this.b, d2 = e2.a.b;d2 !== e2.a; d2 = d2.b) {
            if (d2.c) {
              this.h && this.h(2, this.c);
              a = d2.a;
              do
                this.k && this.k(a.a.d, this.c), a = a.e;
              while (a !== d2.a);
              this.i && this.i(this.c);
            }
          }
        else {
          e2 = this.b;
          d2 = !!this.l;
          a = false;
          b2 = -1;
          for (c = e2.a.d;c !== e2.a; c = c.d)
            if (c.c) {
              a || (this.h && this.h(4, this.c), a = true);
              g2 = c.a;
              do
                d2 && (f = g2.b.d.c ? 0 : 1, b2 !== f && (b2 = f, this.l && this.l(!!b2, this.c))), this.k && this.k(g2.a.d, this.c), g2 = g2.e;
              while (g2 !== c.a);
            }
          a && this.i && this.i(this.c);
        }
      if (this.r) {
        e2 = this.b;
        for (a = e2.a.b;a !== e2.a; a = d2)
          if (d2 = a.b, !a.c) {
            b2 = a.a;
            c = b2.e;
            g2 = undefined;
            do
              g2 = c, c = g2.e, g2.d = null, g2.b.d === null && (g2.c === g2 ? F(g2.a, null) : (g2.a.c = g2.c, H(g2, J(g2))), f = g2.b, f.c === f ? F(f.a, null) : (f.a.c = f.c, H(f, J(f))), fa(g2));
            while (g2 !== b2);
            b2 = a.d;
            a = a.b;
            a.d = b2;
            b2.b = a;
          }
        this.r(this.b);
        this.c = this.b = null;
        return;
      }
    }
    this.b = this.c = null;
  };
  function Z(a, b2) {
    if (a.d !== b2)
      for (;a.d !== b2; )
        if (a.d < b2)
          switch (a.d) {
            case Y:
              V(a, 100151);
              a.u(null);
              break;
            case 1:
              V(a, 100152), a.t();
          }
        else
          switch (a.d) {
            case 2:
              V(a, 100154);
              a.v();
              break;
            case 1:
              V(a, 100153), a.w();
          }
  }
  function V(a, b2) {
    a.p && a.p(b2, a.c);
  }
  function ga(a, b2) {
    this.b = a || this;
    this.d = b2 || this;
    this.a = null;
    this.c = false;
  }
  function M() {
    this.h = this;
    this.i = this.d = this.a = this.e = this.c = this.b = null;
    this.f = 0;
  }
  function J(a) {
    return a.b.e;
  }
  function Ca() {
    this.c = new N;
    this.a = new ga;
    this.b = new M;
    this.d = new M;
    this.b.b = this.d;
    this.d.b = this.b;
  }
  function N(a, b2) {
    this.e = a || this;
    this.f = b2 || this;
    this.d = this.c = null;
    this.g = [0, 0, 0];
    this.h = this.a = this.b = 0;
  }
  function Da() {
    this.c = [];
    this.d = null;
    this.a = 0;
    this.e = false;
    this.b = new Ha;
  }
  function Ea(a) {
    a.d = [];
    for (var b2 = 0;b2 < a.a; b2++)
      a.d[b2] = b2;
    a.d.sort(function(a2) {
      return function(b3, e2) {
        return u(a2[b3], a2[e2]) ? 1 : -1;
      };
    }(a.c));
    a.e = true;
    Ia(a.b);
  }
  function xa(a, b2) {
    if (a.e) {
      var c = a.b, d2 = ++c.a;
      2 * d2 > c.f && (c.f *= 2, c.c = Ja(c.c, c.f + 1));
      var e2;
      c.b === 0 ? e2 = d2 : (e2 = c.b, c.b = c.c[c.b]);
      c.e[e2] = b2;
      c.c[e2] = d2;
      c.d[d2] = e2;
      c.h && va(c, d2);
      return e2;
    }
    c = a.a++;
    a.c[c] = b2;
    return -(c + 1);
  }
  function Fa(a) {
    if (a.a === 0)
      return Ka(a.b);
    var b2 = a.c[a.d[a.a - 1]];
    if (a.b.a !== 0 && u(Ga(a.b), b2))
      return Ka(a.b);
    do
      --a.a;
    while (0 < a.a && a.c[a.d[a.a - 1]] === null);
    return b2;
  }
  function Ha() {
    this.d = Ja([0], 33);
    this.e = [null, null];
    this.c = [0, 0];
    this.a = 0;
    this.f = 32;
    this.b = 0;
    this.h = false;
    this.d[1] = 1;
  }
  function Ja(a, b2) {
    for (var c = Array(b2), d2 = 0;d2 < a.length; d2++)
      c[d2] = a[d2];
    for (;d2 < b2; d2++)
      c[d2] = 0;
    return c;
  }
  function Ia(a) {
    for (var b2 = a.a;1 <= b2; --b2)
      W(a, b2);
    a.h = true;
  }
  function Ga(a) {
    return a.e[a.d[1]];
  }
  function Ka(a) {
    var { d: b2, e: c, c: d2 } = a, e2 = b2[1], f = c[e2];
    0 < a.a && (b2[1] = b2[a.a], d2[b2[1]] = 1, c[e2] = null, d2[e2] = a.b, a.b = e2, 0 < --a.a && W(a, 1));
    return f;
  }
  function W(a, b2) {
    for (var { d: c, e: d2, c: e2 } = a, f = b2, g2 = c[f];; ) {
      var h = f << 1;
      h < a.a && u(d2[c[h + 1]], d2[c[h]]) && (h += 1);
      var k = c[h];
      if (h > a.a || u(d2[g2], d2[k])) {
        c[f] = g2;
        e2[g2] = f;
        break;
      }
      c[f] = k;
      e2[k] = f;
      f = h;
    }
  }
  function va(a, b2) {
    for (var { d: c, e: d2, c: e2 } = a, f = b2, g2 = c[f];; ) {
      var h = f >> 1, k = c[h];
      if (h === 0 || u(d2[k], d2[g2])) {
        c[f] = g2;
        e2[g2] = f;
        break;
      }
      c[f] = k;
      e2[k] = f;
      f = h;
    }
  }
  function ma() {
    this.e = this.a = null;
    this.f = 0;
    this.c = this.b = this.h = this.d = false;
  }
  function S(a) {
    return a.e.c.b;
  }
  function R(a) {
    return a.e.a.b;
  }
  exports.libtess = {
    GluTesselator: X,
    windingRule: { GLU_TESS_WINDING_ODD: 100130, GLU_TESS_WINDING_NONZERO: 100131, GLU_TESS_WINDING_POSITIVE: 100132, GLU_TESS_WINDING_NEGATIVE: 100133, GLU_TESS_WINDING_ABS_GEQ_TWO: 100134 },
    primitiveType: { GL_LINE_LOOP: 2, GL_TRIANGLES: 4, GL_TRIANGLE_STRIP: 5, GL_TRIANGLE_FAN: 6 },
    errorType: { GLU_TESS_MISSING_BEGIN_POLYGON: 100151, GLU_TESS_MISSING_END_POLYGON: 100153, GLU_TESS_MISSING_BEGIN_CONTOUR: 100152, GLU_TESS_MISSING_END_CONTOUR: 100154, GLU_TESS_COORD_TOO_LARGE: 100155, GLU_TESS_NEED_COMBINE_CALLBACK: 100156 },
    gluEnum: { GLU_TESS_MESH: 100112, GLU_TESS_TOLERANCE: 100142, GLU_TESS_WINDING_RULE: 100140, GLU_TESS_BOUNDARY_ONLY: 100141, GLU_INVALID_ENUM: 100900, GLU_INVALID_VALUE: 100901, GLU_TESS_BEGIN: 100100, GLU_TESS_VERTEX: 100101, GLU_TESS_END: 100102, GLU_TESS_ERROR: 100103, GLU_TESS_EDGE_FLAG: 100104, GLU_TESS_COMBINE: 100105, GLU_TESS_BEGIN_DATA: 100106, GLU_TESS_VERTEX_DATA: 100107, GLU_TESS_END_DATA: 100108, GLU_TESS_ERROR_DATA: 100109, GLU_TESS_EDGE_FLAG_DATA: 100110, GLU_TESS_COMBINE_DATA: 100111 }
  };
  X.prototype.gluDeleteTess = X.prototype.x;
  X.prototype.gluTessProperty = X.prototype.B;
  X.prototype.gluGetTessProperty = X.prototype.y;
  X.prototype.gluTessNormal = X.prototype.A;
  X.prototype.gluTessCallback = X.prototype.z;
  X.prototype.gluTessVertex = X.prototype.C;
  X.prototype.gluTessBeginPolygon = X.prototype.u;
  X.prototype.gluTessBeginContour = X.prototype.t;
  X.prototype.gluTessEndContour = X.prototype.v;
  X.prototype.gluTessEndPolygon = X.prototype.w;
  if (typeof module !== "undefined") {
    module.exports = exports.libtess;
  }
});

// node_modules/p5/translations/en/translation.json
var translation_default;
var init_translation = __esm(() => {
  translation_default = {
    fes: {
      autoplay: `The media that tried to play (with '{{src}}') wasn't allowed to by this browser, most likely due to the browser's autoplay policy.

+ More info: {{url}}`,
      checkUserDefinedFns: "It seems that you may have accidentally written {{name}} instead of {{actualName}}. Please correct it if it's not intentional.",
      fileLoadError: {
        bytes: "It looks like there was a problem loading your file. {{suggestion}}",
        font: "It looks like there was a problem loading your font. {{suggestion}}",
        gif: "There was some trouble loading your GIF. Make sure that your GIF is using 87a or 89a encoding.",
        image: "It looks like there was a problem loading your image. {{suggestion}}",
        json: "It looks like there was a problem loading your JSON file. {{suggestion}}",
        large: "If your large file isn't fetched successfully, we recommend splitting the file into smaller segments and fetching those.",
        strings: "It looks like there was a problem loading your text file. {{suggestion}}",
        suggestion: `Try checking if the file path ({{filePath}}) is correct, hosting the file online, or running a local server.

+ More info: {{url}}`,
        table: "It looks like there was a problem loading your table file. {{suggestion}}",
        xml: "It looks like there was a problem loading your XML file. {{suggestion}}"
      },
      friendlyParamError: {
        type_EMPTY_VAR: `{{location}} {{func}}() was expecting {{formatType}} for the {{position}} parameter, received an empty variable instead. If not intentional, this is often a problem with scope.

+ More info: {{url}}`,
        type_TOO_FEW_ARGUMENTS: "{{location}} {{func}}() was expecting at least {{minParams}} arguments, but received only {{argCount}}.",
        type_TOO_MANY_ARGUMENTS: "{{location}} {{func}}() was expecting no more than {{maxParams}} arguments, but received {{argCount}}.",
        type_WRONG_TYPE: "{{location}} {{func}}() was expecting {{formatType}} for the {{position}} parameter, received {{argType}} instead."
      },
      globalErrors: {
        reference: {
          cannotAccess: `
{{location}} "{{symbol}}" is used before declaration. Make sure you have declared the variable before using it.

+ More info: {{url}}`,
          notDefined: `
{{location}} "{{symbol}}" is not defined in the current scope. If you have defined it in your code, you should check its scope, spelling, and letter-casing (JavaScript is case-sensitive).

+ More info: {{url}}`
        },
        stackSubseq: `[{{location}}] 
	 Called from line {{line}} in {{func}}()
`,
        stackTop: `[{{location}}] 
	 Error at line {{line}} in {{func}}()
`,
        syntax: {
          badReturnOrYield: `
Syntax Error - return lies outside of a function. Make sure youre not missing any brackets, so that return lies inside a function.

+ More info: {{url}}`,
          invalidToken: `
Syntax Error - Found a symbol that JavaScript doesn't recognize or didn't expect at it's place.

+ More info: {{url}}`,
          missingInitializer: `
Syntax Error - A const variable is declared but not initialized. In JavaScript, an initializer for a const is required. A value must be specified in the same statement in which the variable is declared. Check the line number in the error and assign the const variable a value.

+ More info: {{url}}`,
          redeclaredVariable: `
Syntax Error - "{{symbol}}" is being redeclared. JavaScript doesn't allow declaring a variable more than once. Check the line number in error for redeclaration of the variable.

+ More info: {{url}}`,
          unexpectedToken: `
Syntax Error - Symbol present at a place that wasn't expected.
Usually this is due to a typo. Check the line number in the error for anything missing/extra.

+ More info: {{url}}`
        },
        type: {
          constAssign: `
{{location}} A const variable is being re-assigned. In javascript, re-assigning a value to a constant is not allowed. If you want to re-assign new values to a variable, make sure it is declared as var or let.

+ More info: {{url}}`,
          notfunc: `
{{location}} "{{symbol}}" could not be called as a function.
Check the spelling, letter-casing (JavaScript is case-sensitive) and its type.

+ More info: {{url}}`,
          notfuncObj: `
{{location}} "{{symbol}}" could not be called as a function.
Verify whether "{{obj}}" has "{{symbol}}" in it and check the spelling, letter-casing (JavaScript is case-sensitive) and its type.

+ More info: {{url}}`,
          readFromNull: `
{{location}} The property of null can't be read. In javascript the value null indicates that an object has no value.

+ More info: {{url}}`,
          readFromUndefined: `
{{location}} Cannot read property of undefined. Check the line number in error and make sure the variable which is being operated is not undefined.

 + More info: {{url}}`
        }
      },
      libraryError: '{{location}} An error with message "{{error}}" occurred inside the p5js library when {{func}} was called. If not stated otherwise, it might be an issue with the arguments passed to {{func}}.',
      location: "[{{file}}, line {{line}}]",
      misspelling: '{{location}} It seems that you may have accidentally written "{{name}}" instead of "{{actualName}}". Please correct it to {{actualName}} if you wish to use the {{type}} from p5.js.',
      misspelling_plural: `{{location}} It seems that you may have accidentally written "{{name}}".
You may have meant one of the following: 
{{suggestions}}`,
      misusedTopLevel: `Did you just try to use p5.js's {{symbolName}} {{symbolType}}? If so, you may want to move it into your sketch's setup() function.

+ More info: {{url}}`,
      preloadDisabled: "The preload() function has been removed in p5.js 2.0. Please load assets in setup() using async / await keywords or callbacks instead. See https://github.com/processing/p5.js-compatibility for more information about 2.0 and compatibility, or https://dev.to/limzykenneth/asynchronous-p5js-20-458f for more information about promises and async/await.",
      positions: {
        p_1: "first",
        p_10: "tenth",
        p_11: "eleventh",
        p_12: "twelfth",
        p_2: "second",
        p_3: "third",
        p_4: "fourth",
        p_5: "fifth",
        p_6: "sixth",
        p_7: "seventh",
        p_8: "eighth",
        p_9: "ninth"
      },
      pre: `
 p5.js says: {{message}}`,
      sketchReaderErrors: {
        reservedConst: `you have used a p5.js reserved variable "{{symbol}}" make sure you change the variable name to something else.

+ More info: {{url}}`,
        reservedFunc: `you have used a p5.js reserved function "{{symbol}}" make sure you change the function name to something else.

+ More info: {{url}}`
      },
      welcome: "Welcome! This is your friendly debugger. To turn me off, switch to using p5.min.js.",
      wrongPreload: '{{location}} An error with message "{{error}}" occurred inside the p5js library when "{{func}}" was called. If not stated otherwise, it might be due to "{{func}}" being called from preload. Nothing besides load calls (loadImage, loadJSON, loadFont, loadStrings, etc.) should be inside the preload function.'
    }
  };
});

// node_modules/p5/translations/es/translation.json
var translation_default2;
var init_translation2 = __esm(() => {
  translation_default2 = {
    fes: {
      autoplay: "Su browser impido un medio tocar (de '{{src}}'), posiblemente porque las reglas de autoplay. Para aprender ms, visite {{link}}.",
      checkUserDefinedFns: "",
      fileLoadError: {
        bytes: "",
        font: "",
        gif: "",
        image: "",
        json: "",
        large: "",
        strings: "",
        suggestion: "",
        table: "",
        xml: ""
      },
      friendlyParamError: {
        type_EMPTY_VAR: "",
        type_TOO_FEW_ARGUMENTS: "",
        type_TOO_MANY_ARGUMENTS: "",
        type_WRONG_TYPE: ""
      },
      globalErrors: {
        reference: {
          cannotAccess: "",
          notDefined: ""
        },
        stackSubseq: "",
        stackTop: "",
        syntax: {
          badReturnOrYield: "",
          invalidToken: "",
          missingInitializer: "",
          redeclaredVariable: "",
          unexpectedToken: ""
        },
        type: {
          constAssign: "",
          notfunc: "",
          notfuncObj: "",
          readFromNull: "",
          readFromUndefined: ""
        }
      },
      libraryError: "",
      location: "",
      misspelling: "",
      misspelling_plural: "",
      misusedTopLevel: "",
      positions: {
        p_1: "",
        p_10: "",
        p_11: "",
        p_12: "",
        p_2: "",
        p_3: "",
        p_4: "",
        p_5: "",
        p_6: "",
        p_7: "",
        p_8: "",
        p_9: ""
      },
      pre: " p5.js dice: {{message}}",
      sketchReaderErrors: {
        reservedConst: "",
        reservedFunc: ""
      },
      welcome: "",
      wrongPreload: ""
    }
  };
});

// node_modules/p5/translations/ko/translation.json
var translation_default3;
var init_translation3 = __esm(() => {
  translation_default3 = {
    fes: {
      autoplay: `('{{src}}')    .         .

+  : {{url}}`,
      checkUserDefinedFns: " {{actualName}}  {{name}}    .",
      fileLoadError: {
        bytes: "    . {{suggestion}}",
        font: "    . {{suggestion}}",
        gif: "GIF     . GIF    87a 89a .",
        image: "    . {{suggestion}}",
        json: "JSON     . {{suggestion}}",
        large: "       .    .",
        strings: "     . {{suggestion}}",
        suggestion: ` ({{filePath}})  .              .

+  : {{url}}`,
        table: "     . {{suggestion}}",
        xml: "XML     . {{suggestion}}"
      },
      friendlyParamError: {
        type_EMPTY_VAR: `{{location}} {{formatType}}    {{func}}() {{position}} (parameter)    . (scope)    .

+  : {{url}}`,
        type_TOO_FEW_ARGUMENTS: "{{location}}  {{minParams}} (argument)   {{func}}()  {{argCount}} .",
        type_TOO_MANY_ARGUMENTS: "{{location}}  {{maxParams}} (argument)   {{func}}()  {{argCount}} .",
        type_WRONG_TYPE: "{{location}} {{formatType}}    {{func}}() {{position}} (parameter) {{argType}}   ."
      },
      globalErrors: {
        reference: {
          cannotAccess: `
{{location}} "{{symbol}}"    .   ,   .

+  : {{url}}`,
          notDefined: `
{{location}} "{{symbol}}"  (scope)   .   ,   ,    (  ).

+  : {{url}}`
        },
        stackSubseq: `[{{location}}] 
	 {{func}}()  {{line}} 
`,
        stackTop: `[{{location}}] 
	 {{func}}()  {{line}}  
`,
        syntax: {
          badReturnOrYield: `
  -      , return   .

+  : {{url}}`,
          invalidToken: `
  -    ,     .

+  : {{url}}`,
          missingInitializer: `
  - const    .      .

+  : {{url}}`,
          redeclaredVariable: `
  -   "{{symbol}}" .         .

+  : {{url}}`,
          unexpectedToken: `
  -      .       .     .

+  : {{url}}`
        },
        type: {
          constAssign: `
{{location}} const  .  const             , const  var let    .

+  : {{url}}`,
          notfunc: `
{{location}} "{{symbol}}"    .  ,   .

+  : {{url}}`,
          notfuncObj: `
{{location}} "{{symbol}}"    . "{{obj}}" "{{symbol}}"   ,  ,   .

+  : {{url}}`,
          readFromNull: `
{{location}} null (property)   .  null, (object)    .

+  : {{url}}`,
          readFromUndefined: `
{{location}} undefined (property)   .       .

+  : {{url}}`
        }
      },
      libraryError: '{{location}}  {{func}}  ,  "{{error}}"  p5js   .  {{func}}  (argument)   .',
      location: "[{{file}}, {{line}}]",
      misspelling: '{{location}}  p5.js {{type}}  "{{name}}" {{actualName}}  .',
      misspelling_plural: `{{location}}  p5.js {{type}}  "{{name}}"    : 
{{suggestions}}`,
      misusedTopLevel: `{{location}}  p5.js {{symbolType}}  {{symbolName}} ?  {{symbolName}}   setup()    .

+  : {{url}}`,
      positions: {
        p_1: "1",
        p_10: "10",
        p_11: "11",
        p_12: "12",
        p_2: "2",
        p_3: "3",
        p_4: "4",
        p_5: "5",
        p_6: "6",
        p_7: "7",
        p_8: "8",
        p_9: "9"
      },
      pre: `
 p5.js says: {{message}}`,
      sketchReaderErrors: {
        reservedConst: `p5.js     "{{symbol}}" .      .

+  : {{url}}`,
        reservedFunc: `p5.js     "{{symbol}}" .      .

+  : {{url}}`
      },
      welcome: "{{logo}} ,      .    p5.js p5.min.js .",
      wrongPreload: `{{location}} "{{func}}"  p5js     : "{{error}}".

  "{{func}}" preload()    . preload()    (: loadImage, loadJSON, loadFont, loadStrings )   .`
    }
  };
});

// node_modules/p5/translations/zh/translation.json
var translation_default4;
var init_translation4 = __esm(() => {
  translation_default4 = {
    fes: {
      autoplay: `'{{src}}'

+ {{url}}`,
      checkUserDefinedFns: "{{name}}{{actualName}}",
      fileLoadError: {
        bytes: "{{suggestion}}",
        font: "{{suggestion}}",
        gif: "GIFGIF87a89a",
        image: "{{suggestion}}",
        json: "JSON{{suggestion}}",
        large: "",
        strings: "{{suggestion}}",
        suggestion: `{{filePath}}

+ {{url}}`,
        table: "{{suggestion}}",
        xml: "XML{{suggestion}}"
      },
      friendlyParamError: {
        type_EMPTY_VAR: `{{location}} {{func}}() {{formatType}}{{position}}

+ {{url}}`,
        type_TOO_FEW_ARGUMENTS: "{{location}} {{func}}() {{minParams}}{{argCount}}",
        type_TOO_MANY_ARGUMENTS: "{{location}} {{func}}() {{maxParams}}{{argCount}}",
        type_WRONG_TYPE: "{{location}} {{func}}() {{formatType}}{{position}}{{argType}}"
      },
      globalErrors: {
        reference: {
          cannotAccess: `
{{location}} "{{symbol}}"

+ {{url}}`,
          notDefined: `
{{location}} "{{symbol}}"JavaScript

+ {{url}}`
        },
        stackSubseq: `[{{location}}] 
	 {{func}}(){{line}}
`,
        stackTop: `[{{location}}] 
	 {{func}}(){{line}}
`,
        syntax: {
          badReturnOrYield: `
 - returnreturn

+ {{url}}`,
          invalidToken: `
 - JavaScript

+ {{url}}`,
          missingInitializer: `
 - constJavaScriptconstconst

+ {{url}}`,
          redeclaredVariable: `
 - "{{symbol}}" JavaScript

+ {{url}}`,
          unexpectedToken: `
 - 


+ {{url}}`
        },
        type: {
          constAssign: `
{{location}} constJavaScriptvarlet

+ {{url}}`,
          notfunc: `
{{location}} "{{symbol}}" 
JavaScript

+ {{url}}`,
          notfuncObj: `
{{location}} "{{symbol}}" 
"{{obj}}""{{symbol}}"JavaScript

+ {{url}}`,
          readFromNull: `
{{location}} nullJavaScriptnull

+ {{url}}`,
          readFromUndefined: `
{{location}} undefinedundefined

+ {{url}}`
        }
      },
      libraryError: '{{location}} {{func}}p5js"{{error}}"{{func}}',
      location: "[{{file}}{{line}}]",
      misspelling: '{{location}} {{name}}"{{actualName}}"p5.js{{type}}{{actualName}}',
      misspelling_plural: `{{location}} {{name}}

{{suggestions}}`,
      misusedTopLevel: `p5.js{{symbolType}} {{symbolName}}sketchsetup()

+ {{url}}`,
      positions: {
        p_1: "",
        p_10: "",
        p_11: "",
        p_12: "",
        p_2: "",
        p_3: "",
        p_4: "",
        p_5: "",
        p_6: "",
        p_7: "",
        p_8: "",
        p_9: ""
      },
      pre: `
 p5.js {{message}}`,
      sketchReaderErrors: {
        reservedConst: `p5.js"{{symbol}}"

+ {{url}}`,
        reservedFunc: `p5.js"{{symbol}}"

+ {{url}}`
      },
      welcome: "p5.min.js",
      wrongPreload: '{{location}} "{{func}}"p5js"{{error}}"preload"{{func}}"preloadloadloadImageloadJSONloadFontloadStrings'
    }
  };
});

// node_modules/p5/translations/hi/translation.json
var translation_default5;
var init_translation5 = __esm(() => {
  translation_default5 = {
    fes: {
      autoplay: `        ('{{src}}'  )        ,    :    

+  : {{url}}`,
      checkUserDefinedFns: "       {{actualName}}   {{name}}              ",
      fileLoadError: {
        bytes: "            {{suggestion}}",
        font: "            {{suggestion}}",
        gif: " GIF           GIF 87a  89a      ",
        image: "            {{suggestion}}",
        json: "     JSON        {{suggestion}}",
        large: "        ,                ",
        strings: "             {{suggestion}}",
        suggestion: `        ({{filePath}})    ,     ,    

+  : {{url}}`,
        table: "             {{suggestion}}",
        xml: "     XML        {{suggestion}}"
      },
      friendlyParamError: {
        type_EMPTY_VAR: `{{location}} {{func}}() {{position}}    {{formatType}}     ,             ,         

+  :{{url}}`,
        type_TOO_FEW_ARGUMENTS: "{{location}} {{func}}()    {{minParams}}    ,     {{argCount}}.",
        type_TOO_MANY_ARGUMENTS: "{{location}} {{func}}() {{maxParams}}         ,    {{argCount}}.",
        type_WRONG_TYPE: "{{location}} {{func}}() {{position}}    {{formatType}}     ,   {{argType}}  "
      },
      globalErrors: {
        reference: {
          cannotAccess: `
{{location}} "{{symbol}}"                      

+  : {{url}}`,
          notDefined: `
{{location}} "{{symbol}}"               ,    ,   -   (JavaScript - )

+  : {{url}}`
        },
        stackSubseq: `[{{location}}] 
	 {{func}}()   {{line}}    
`,
        stackTop: `[{{location}}] 
	 {{func}}()   {{line}}  
`,
        syntax: {
          badReturnOrYield: `
 -   -                 ,       

+  : {{url}}`,
          invalidToken: `
 -   -               

+  : {{url}}`,
          missingInitializer: `
 -   -               ,                                       

+  : {{url}}`,
          redeclaredVariable: `
 -   - "{{symbol}}"                                  

+  : {{url}}`,
          unexpectedToken: `
 -   -          
            /          

+  : {{url}}`
        },
        type: {
          constAssign: `
{{location}}             ,                        ,      var  Let       

+  : {{url}}`,
          notfunc: `
{{location}} "{{symbol}}"        
, - ( - )      

+  : {{url}}`,
          notfuncObj: `
{{location}} "{{symbol}}"        
    "{{obj}}"  "{{symbol}}"   , - ( - )      

+  : {{url}}`,
          readFromNull: `
{{location}} null       .    null           

+  : {{url}}`,
          readFromUndefined: `
{{location}} undefined     .                      

 +  : {{url}}`
        }
      },
      libraryError: '{{location}}  {{func}}      p5js    "{{error}}"             ,   {{func}}           ',
      location: "[{{file}},  {{line}}]",
      misspelling: '{{location}}        "{{actualName}}"    "{{name}}"      p5.js  {{type}}           {{actualName}}  ',
      misspelling_plural: `{{location}}        "{{name}}"   
         : 
{{suggestions}}`,
      misusedTopLevel: `   p5.js  {{symbolName}} {{symbolType}}      ?   ,     -  setup()       

+  : {{url}}`,
      positions: {
        p_1: "",
        p_10: "",
        p_11: "",
        p_12: "",
        p_2: "",
        p_3: "",
        p_4: "",
        p_5: "",
        p_6: "",
        p_7: "",
        p_8: "",
        p_9: ""
      },
      pre: `
 p5.js  : {{message}}`,
      sketchReaderErrors: {
        reservedConst: `  p5.js   "{{symbol}}"    ,              

+  : {{url}}`,
        reservedFunc: `  p5.js   "{{symbol}}"    ,              

+  : {{url}}`
      },
      welcome: "!     .     , p5.min.js   ",
      wrongPreload: '{{location}}  "{{func}}"      p5js    "{{error}}"             ,   "{{func}}"                  (, , ,  )       '
    }
  };
});

// node_modules/p5/translations/ja/translation.json
var translation_default6;
var init_translation6 = __esm(() => {
  translation_default6 = {
    fes: {
      autoplay: `({{src}})

+ : {{url}}`,
      checkUserDefinedFns: "{{actualName}}  {{name}} ",
      fileLoadError: {
        bytes: " {{suggestion}}",
        font: " {{suggestion}}",
        gif: "GIFGIF 87a  89a ",
        image: " {{suggestion}}",
        json: "JSON {{suggestion}}",
        large: "",
        strings: " {{suggestion}}",
        suggestion: `({{filePath}})

+ : {{url}}`,
        table: " {{suggestion}}",
        xml: "XML {{suggestion}}"
      },
      friendlyParamError: {
        type_EMPTY_VAR: `{{location}} {{func}}(){{position}} {{formatType}} 

+ : {{url}}`,
        type_TOO_FEW_ARGUMENTS: "{{location}} {{func}}(){{minParams}}{{argCount}}",
        type_TOO_MANY_ARGUMENTS: "{{location}} {{func}}(){{maxParams}}{{argCount}}",
        type_WRONG_TYPE: "{{location}} {{func}}(){{position}} {{formatType}}{{argType}}"
      },
      globalErrors: {
        reference: {
          cannotAccess: `
{{location}} "{{symbol}}" 

+ : {{url}}`,
          notDefined: `
{{location}} "{{symbol}}" (JavaScript)

+  {{url}}`
        },
        stackSubseq: `[{{location}}] 
	 {{line}}( {{func}}() )
`,
        stackTop: `[{{location}}] 
	 {{line}}( {{func}}() )
`,
        syntax: {
          badReturnOrYield: `
 - returnreturn

+ : {{url}}`,
          invalidToken: `
 - JavaScript

+ : {{url}}`,
          missingInitializer: `
 - JavaScript const 

+ : {{url}}`,
          redeclaredVariable: `
 - "{{symbol}}" JavaScript

+ : {{url}}`,
          unexpectedToken: `
 - 


+ : {{url}}`
        },
        type: {
          constAssign: `
{{location}} JavaScript var  let 

+ : {{url}}`,
          notfunc: `
{{location}} "{{symbol}}" 
(JavaScript)

+ : {{url}}`,
          notfuncObj: `
{{location}} "{{symbol}}" 
{{obj}}  "{{symbol}}" (JavaScript)

+ : {{url}}`,
          readFromNull: `
{{location}} null JavaScriptnull 

+ : {{url}}`,
          readFromUndefined: `
{{location}} undefined  undefined 

+ : {{url}}`
        }
      },
      libraryError: '{{location}} {{func}} p5js "{{error}}"  {{func}} ',
      location: "[{{file}}, {{line}}]",
      misspelling: '{{location}} "{{actualName}}"  "{{name}}" p5.js {{type}}  {{actualName}} ',
      misspelling_plural: `{{location}}  "{{name}}" 
: 
{{suggestions}}`,
      misusedTopLevel: `p5.js {{symbolType}} {{symbolName}}  setup()

+ : {{url}}`,
      positions: {
        p_1: "1",
        p_10: "10",
        p_11: "11",
        p_12: "12",
        p_2: "2",
        p_3: "3",
        p_4: "4",
        p_5: "5",
        p_6: "6",
        p_7: "7",
        p_8: "8",
        p_9: "9"
      },
      pre: `
 p5.js: {{message}}`,
      sketchReaderErrors: {
        reservedConst: `p5.js "{{symbol}}" 

+ : {{url}}`,
        reservedFunc: `p5.js "{{symbol}}" 

+ : {{url}}`
      },
      welcome: "p5.min.js",
      wrongPreload: '{{location}} p5.js "{{error}}" preload "{{func}}" load(loadImageloadJSONloadFontloadStrings)preload'
    }
  };
});

// node_modules/p5/translations/dev.js
var exports_dev = {};
__export(exports_dev, {
  zh_translation: () => translation_default4,
  ko_translation: () => translation_default3,
  ja_translation: () => translation_default6,
  hi_translation: () => translation_default5,
  es_translation: () => translation_default2,
  en_translation: () => translation_default
});
var init_dev = __esm(() => {
  init_translation();
  init_translation2();
  init_translation3();
  init_translation4();
  init_translation5();
  init_translation6();
});

// node_modules/@japont/unicode-range/lib/index.js
var require_lib = __commonJS((exports) => {
  Object.defineProperty(exports, "__esModule", { value: true });
  var UnicodeRange = function() {
    function UnicodeRange2() {}
    UnicodeRange2.parse = function(arr2) {
      var result = new Set;
      for (var _i = 0, arr_1 = arr2;_i < arr_1.length; _i++) {
        var range2 = arr_1[_i];
        if (!UnicodeRange2.REGEXP.test(range2)) {
          throw new TypeError('"' + range2 + '" is invalid unicode-range.');
        }
        var _a = range2.match(UnicodeRange2.REGEXP), single = _a[1], start = _a[2], end = _a[3];
        if (single) {
          if (/\?[^?]+$/.test(single)) {
            throw new TypeError('"' + range2 + '" is invalid unicode-range.');
          }
          if (single.includes("?")) {
            var start_1 = single.replace(/\?/g, "0");
            var end_1 = single.replace(/\?/g, "F");
            var tmp = UnicodeRange2.parse(["U+" + start_1 + "-" + end_1]);
            for (var _b = 0, tmp_1 = tmp;_b < tmp_1.length; _b++) {
              var codePoint = tmp_1[_b];
              result.add(codePoint);
            }
          } else {
            result.add(parseInt(single, 16));
          }
        }
        if (start && end) {
          var startCodePoint = parseInt(start, 16);
          var endCodePoint = parseInt(end, 16);
          for (var codePoint = startCodePoint;codePoint <= endCodePoint; codePoint++) {
            result.add(codePoint);
          }
        }
      }
      return Array.from(result).sort(function(a, b2) {
        return a - b2;
      });
    };
    UnicodeRange2.stringify = function(arr2) {
      var sorted = Array.from(new Set(arr2)).sort(function(a, b2) {
        return a - b2;
      });
      var results = [];
      var rangeStart;
      for (var idx = 0;idx < sorted.length; idx++) {
        var current2 = sorted[idx];
        var prev = sorted[idx - 1];
        if (rangeStart && current2 - prev !== 1) {
          results.push(UnicodeRange2.rangeString(rangeStart, prev));
          rangeStart = current2;
        }
        if (!rangeStart) {
          rangeStart = current2;
        }
        if (idx === sorted.length - 1) {
          if (rangeStart === current2) {
            results.push(UnicodeRange2.rangeString(current2));
          } else {
            results.push(UnicodeRange2.rangeString(rangeStart, current2));
          }
        }
      }
      return results;
    };
    UnicodeRange2.rangeString = function(start, end) {
      if (!end || start === end) {
        return "U+" + start.toString(16);
      }
      return "U+" + start.toString(16) + "-" + end.toString(16);
    };
    UnicodeRange2.REGEXP = /^u\+(?:([0-9a-f]?[0-9a-f?]{1,5})|([0-9a-f]{1,6})-([0-9a-f]{1,6}))?$/i;
    return UnicodeRange2;
  }();
  exports.UnicodeRange = UnicodeRange;
});

// node_modules/@davepagurek/bezier-path/build/bezier-path.js
var require_bezier_path = __commonJS((exports, module) => {
  (function(t, e2) {
    typeof exports == "object" && typeof module == "object" ? module.exports = e2() : typeof define == "function" && define.amd ? define([], e2) : typeof exports == "object" ? exports.BezierPath = e2() : t.BezierPath = e2();
  })(self, () => (() => {
    var t = { 177: (t2, e3, s) => {
      Object.defineProperty(e3, "__esModule", { value: true }), e3.BezierPath = undefined;
      const i2 = s(558), h = s(188);
      e3.BezierPath = class {
        constructor(t3) {
          this.samples = [], this.segments = t3;
          const e4 = t3.map((t4) => t4.getTotalLength()), s2 = [0];
          for (let t4 = 1;t4 < e4.length; t4++)
            s2.push(s2[t4 - 1] + e4[t4 - 1]);
          this._totalLength = s2[s2.length - 1] + e4[e4.length - 1];
          const a = t3.map((t4) => Math.max(4, Math.ceil(t4.getTotalLength() / i2.BezierSegment.sampleSpacing()))), n2 = a.reduce((t4, e5) => t4 + e5), r = 1 / n2 / 10, o = this._totalLength / n2;
          this.samples.push({ dist: 0, pt: this.segments[0].A, tan: this.segments[0].tangentAtParameter(0), segIdx: 0, t: 0 }), t3.forEach((t4, e5) => {
            const i3 = a[e5], n3 = (0, h.times)(i3 + 1).map((t5) => t5 / i3), x = n3.map((e6) => t4.pointAtParameter(e6));
            let y;
            for (let e6 = 0;e6 < 4; e6++) {
              y = (0, h.times)(i3).map((t5) => Math.hypot(x[t5 + 1].x - x[t5].x, x[t5 + 1].y - x[t5].y));
              const e7 = y.map((t5) => t5 - o);
              let s3 = 0;
              for (let i4 = 1;i4 < n3.length - 1; i4++)
                s3 += e7[i4 - 1], n3[i4] -= r * s3, x[i4] = t4.pointAtParameter(n3[i4]);
            }
            let p2 = 0;
            x.slice(1).forEach((t5, i4) => {
              p2 += y[i4], this.samples.push({ dist: s2[e5] + p2, pt: t5, tan: this.segments[e5].tangentAtParameter(n3[i4 + 1]), segIdx: e5, t: n3[i4 + 1] });
            });
          }), this._jumps = [], this.segmentStartEnds = [{ start: 0, end: 0 }];
          for (let t4 = 1;t4 < this.samples.length; t4++) {
            const e5 = this.samples[t4 - 1], s3 = this.samples[t4];
            if (s3.segIdx === e5.segIdx ? this.segmentStartEnds[this.segmentStartEnds.length - 1].end = s3.dist : this.segmentStartEnds[s3.segIdx] = { start: s3.dist, end: s3.dist }, e5.segIdx !== s3.segIdx && (this.segments[e5.segIdx].D.x !== this.segments[s3.segIdx].A.x || this.segments[e5.segIdx].D.y !== this.segments[s3.segIdx].A.y)) {
              const i3 = (e5.dist + s3.dist) / 2, h2 = { dist: i3 - 0.00000001, pt: this.segments[e5.segIdx].D, tan: this.segments[e5.segIdx].tangentAtParameter(1), segIdx: e5.segIdx, t: 1 }, a2 = { dist: i3 + 0.00000001, pt: this.segments[s3.segIdx].A, tan: this.segments[s3.segIdx].tangentAtParameter(0), segIdx: s3.segIdx, t: 0 };
              this._jumps.push(i3), this.samples.splice(t4, 0, h2, a2), t4 += 2;
            }
          }
        }
        jumps() {
          return [...this._jumps];
        }
        getTotalLength() {
          return this._totalLength;
        }
        findClosestSampleIdx(t3) {
          let e4 = 0, s2 = this.samples.length - 1;
          for (;e4 < s2; ) {
            const i3 = Math.floor((e4 + s2) / 2);
            if (this.samples[i3].dist > t3)
              s2 = i3 - 1;
            else {
              if (!(this.samples[i3].dist < t3))
                return i3;
              e4 = i3 + 1;
            }
          }
          return Math.max(0, Math.min(this.samples.length - 1, Math.floor((e4 + s2) / 2)));
        }
        getPointAtLength(t3, e4 = false) {
          if (t3 <= 0)
            return this.samples[0].pt;
          if (t3 >= this._totalLength)
            return this.samples[this.samples.length - 1].pt;
          const s2 = this.findClosestSampleIdx(t3), i3 = this.samples[s2].dist < t3 ? Math.min(s2 + 1, this.samples.length - 1) : Math.max(0, s2 - 1), h2 = Math.abs(this.samples[i3].dist - this.samples[s2].dist) < 0.000001 ? 0 : (t3 - this.samples[s2].dist) / (this.samples[i3].dist - this.samples[s2].dist);
          if (e4 || this.samples[s2].segIdx > this.samples[i3].segIdx)
            return { x: (1 - h2) * this.samples[s2].pt.x + h2 * this.samples[i3].pt.x, y: (1 - h2) * this.samples[s2].pt.y + h2 * this.samples[i3].pt.y };
          if (this.samples[s2].segIdx !== this.samples[i3].segIdx) {
            if (h2 < 0.5) {
              const t4 = this.segments[this.samples[s2].segIdx], e5 = 2 * h2, i4 = (1 - e5) * this.samples[s2].t + e5;
              return t4.pointAtParameter(i4);
            }
            {
              const t4 = this.segments[this.samples[i3].segIdx], e5 = 2 * (h2 - 0.5) * this.samples[i3].t;
              return t4.pointAtParameter(e5);
            }
          }
          {
            const t4 = this.segments[this.samples[s2].segIdx], e5 = (1 - h2) * this.samples[s2].t + h2 * this.samples[i3].t;
            return t4.pointAtParameter(e5);
          }
        }
        getAngleAtLength(t3, e4 = false) {
          const s2 = this.getTangentAtLength(t3, e4);
          return Math.atan2(s2.y, s2.x);
        }
        getTangentAtLength(t3, e4 = false) {
          if (t3 <= 0)
            return this.samples[0].tan;
          if (t3 >= this._totalLength)
            return this.samples[this.samples.length - 1].tan;
          const s2 = this.findClosestSampleIdx(t3), i3 = this.samples[s2].dist < t3 ? Math.min(s2 + 1, this.samples.length - 1) : Math.max(0, s2 - 1), h2 = (t3 - this.samples[s2].dist) / (this.samples[i3].dist - this.samples[s2].dist);
          if (e4 || this.samples[s2].segIdx > this.samples[i3].segIdx) {
            let t4 = (1 - h2) * this.samples[s2].tan.x + h2 * this.samples[i3].tan.x, e5 = (1 - h2) * this.samples[s2].tan.y + h2 * this.samples[i3].tan.y;
            const a = Math.max(Math.hypot(t4, e5), 0.0001);
            return t4 /= a, e5 /= a, { x: t4, y: e5 };
          }
          if (this.samples[s2].segIdx !== this.samples[i3].segIdx) {
            if (h2 < 0.5) {
              const t4 = this.segments[this.samples[s2].segIdx], e5 = 2 * h2, i4 = (1 - e5) * this.samples[s2].t + e5;
              return t4.tangentAtParameter(i4);
            }
            {
              const t4 = this.segments[this.samples[i3].segIdx], e5 = 2 * (h2 - 0.5) * this.samples[i3].t;
              return t4.tangentAtParameter(e5);
            }
          }
          {
            const t4 = this.segments[this.samples[s2].segIdx], e5 = (1 - h2) * this.samples[s2].t + h2 * this.samples[i3].t;
            return t4.tangentAtParameter(e5);
          }
        }
      };
    }, 558: (t2, e3, s) => {
      Object.defineProperty(e3, "__esModule", { value: true }), e3.BezierSegment = undefined;
      const i2 = s(188);

      class h {
        constructor(t3, e4, s2, i3) {
          this._totalLength = undefined, this.A = t3, this.B = e4, this.C = s2, this.D = i3;
        }
        static sampleSpacing() {
          return 2;
        }
        tangentAtParameter(t3) {
          const e4 = Math.max(0, Math.min(1, t3));
          if (e4 === 0 || e4 === 1) {
            let t4, s3;
            e4 === 0 ? this.A.x === this.B.x && this.A.y === this.B.y ? (t4 = this.C.x - this.A.x, s3 = this.C.y - this.A.y) : (t4 = this.B.x - this.A.x, s3 = this.B.y - this.A.y) : this.D.x === this.C.x && this.D.y === this.C.y ? (t4 = this.D.x - this.B.x, s3 = this.D.y - this.B.y) : (t4 = this.D.x - this.C.x, s3 = this.D.y - this.C.y);
            const i4 = Math.hypot(t4, s3);
            return Math.abs(i4) > 0.0001 && (t4 /= i4, s3 /= i4), { x: t4, y: s3 };
          }
          const s2 = 1 - e4;
          let i3 = 3 * this.D.x * Math.pow(e4, 2) - 3 * this.C.x * Math.pow(e4, 2) + 6 * this.C.x * s2 * e4 - 6 * this.B.x * s2 * e4 + 3 * this.B.x * Math.pow(s2, 2) - 3 * this.A.x * Math.pow(s2, 2), h2 = 3 * this.D.y * Math.pow(e4, 2) - 3 * this.C.y * Math.pow(e4, 2) + 6 * this.C.y * s2 * e4 - 6 * this.B.y * s2 * e4 + 3 * this.B.y * Math.pow(s2, 2) - 3 * this.A.y * Math.pow(s2, 2);
          const a = Math.hypot(i3, h2);
          return Math.abs(a) > 0.0001 && (i3 /= a, h2 /= a), { x: i3, y: h2 };
        }
        isLinear() {
          return this.A.x === this.B.x && this.A.y === this.B.y && this.C.x === this.D.x && this.C.y === this.D.y;
        }
        pointAtParameter(t3) {
          const e4 = Math.max(0, Math.min(1, t3));
          return { x: Math.pow(1 - e4, 3) * this.A.x + 3 * Math.pow(1 - e4, 2) * e4 * this.B.x + 3 * (1 - e4) * Math.pow(e4, 2) * this.C.x + Math.pow(e4, 3) * this.D.x, y: Math.pow(1 - e4, 3) * this.A.y + 3 * Math.pow(1 - e4, 2) * e4 * this.B.y + 3 * (1 - e4) * Math.pow(e4, 2) * this.C.y + Math.pow(e4, 3) * this.D.y };
        }
        getTotalLength() {
          if (this._totalLength === undefined)
            if (this.isLinear())
              this._totalLength = Math.hypot(this.D.x - this.A.x, this.D.y - this.A.y);
            else {
              const t3 = Math.max(10, Math.ceil((Math.hypot(this.B.x - this.A.x, this.B.y - this.A.y) + Math.hypot(this.C.x - this.B.x, this.C.y - this.B.y) + Math.hypot(this.D.x - this.C.x, this.D.y - this.C.y)) / h.sampleSpacing())), e4 = (0, i2.times)(t3).map((e5) => this.pointAtParameter(e5 / (t3 - 1)));
              let s2 = 0;
              for (let t4 = 1;t4 < e4.length; t4++)
                s2 += Math.hypot(e4[t4].x - e4[t4 - 1].x, e4[t4].y - e4[t4 - 1].y);
              this._totalLength = s2;
            }
          return this._totalLength;
        }
      }
      e3.BezierSegment = h;
    }, 729: (t2, e3, s) => {
      Object.defineProperty(e3, "__esModule", { value: true }), e3.createFromCommands = e3.create = e3.createFromElement = e3.createFromCircle = e3.createFromLine = e3.createFromPath = undefined;
      const i2 = s(821), h = s(558), a = { M: ["x", "y"], m: ["dx", "dy"], H: ["x"], h: ["dx"], V: ["y"], v: ["dy"], L: ["x", "y"], l: ["dx", "dy"], Z: [], C: ["x1", "y1", "x2", "y2", "x", "y"], c: ["dx1", "dy1", "dx2", "dy2", "dx", "dy"], S: ["x2", "y2", "x", "y"], s: ["dx2", "dy2", "dx", "dy"], Q: ["x1", "y1", "x", "y"], q: ["dx1", "dy1", "dx", "dy"], T: ["x", "y"], t: ["dx", "dy"], A: ["rx", "ry", "rotation", "large-arc", "sweep", "x", "y"], a: ["rx", "ry", "rotation", "large-arc", "sweep", "dx", "dy"] };
      e3.createFromPath = (t3) => {
        const e4 = function(t4) {
          const e5 = t4.replace(/[\n\r]/g, "").replace(/-/g, " -").replace(/(\d*\.)(\d+)(?=\.)/g, "$1$2 ").replace(/(\d)([A-Za-z])/g, "$1 $2").replace(/([A-Za-z])(\d)/g, "$1 $2").trim().split(/\s*,|\s+/), s3 = [];
          let i3 = "", h2 = {};
          for (;e5.length > 0; ) {
            let t5 = e5.shift();
            a.hasOwnProperty(t5) ? i3 = t5 : e5.unshift(t5), h2 = { type: i3 }, a[i3].forEach((s4) => {
              t5 = e5.shift(), h2[s4] = parseFloat(t5);
            }), i3 === "M" ? i3 = "L" : i3 === "m" && (i3 = "l"), s3.push(h2);
          }
          return s3;
        }(t3.getAttribute("d"));
        if (e4.length < 2)
          throw new Error(`Path doesn't have enough commands: ${JSON.stringify(e4)}`);
        if (e4[0].type !== "M")
          throw new Error(`Path starts with ${e4[0].type} instead of M!`);
        let s2 = { x: e4[0].x, y: e4[0].y };
        e4.shift();
        const n2 = [];
        for (;e4.length > 0; ) {
          const t4 = e4.shift();
          if (t4.type === "C")
            n2.push(new h.BezierSegment(s2, { x: t4.x1, y: t4.y1 }, { x: t4.x2, y: t4.y2 }, { x: t4.x, y: t4.y })), s2 = { x: t4.x, y: t4.y };
          else if (t4.type === "L")
            n2.push(new h.BezierSegment(s2, s2, { x: t4.x, y: t4.y }, { x: t4.x, y: t4.y })), s2 = { x: t4.x, y: t4.y };
          else if (t4.type === "H")
            n2.push(new h.BezierSegment(s2, s2, { x: t4.x, y: s2.y }, { x: t4.x, y: s2.y })), s2 = { x: t4.x, y: s2.y };
          else if (t4.type === "V")
            n2.push(new h.BezierSegment(s2, s2, { x: s2.x, y: t4.y }, { x: s2.x, y: t4.y })), s2 = { x: s2.x, y: t4.y };
          else if (t4.type !== "Z")
            throw new Error(`Unsupported path command ${t4.type}; use only H, V, M, L, C, Z!`);
        }
        return new i2.BezierPath(n2);
      }, e3.createFromLine = (t3) => {
        const [e4, s2, a2, n2] = ["x1", "x2", "y1", "y2"].map((e5) => parseFloat(t3.getAttribute(e5) || "0"));
        return new i2.BezierPath([new h.BezierSegment({ x: e4, y: a2 }, { x: e4, y: a2 }, { x: s2, y: n2 }, { x: s2, y: n2 })]);
      }, e3.createFromCircle = (t3) => {
        const [e4, s2, a2] = ["cx", "cy", "r"].map((e5) => parseFloat(t3.getAttribute(e5) || "0")), n2 = 1.3;
        return new i2.BezierPath([new h.BezierSegment({ x: e4 - a2, y: s2 }, { x: e4 - a2, y: s2 - n2 * a2 }, { x: e4 + a2, y: s2 - n2 * a2 }, { x: e4 + a2, y: s2 }), new h.BezierSegment({ x: e4 + a2, y: s2 }, { x: e4 + a2, y: s2 + n2 * a2 }, { x: e4 - a2, y: s2 + n2 * a2 }, { x: e4 - a2, y: s2 })]);
      }, e3.createFromElement = (t3) => {
        const s2 = t3.tagName.toLowerCase();
        if (s2 === "path")
          return (0, e3.createFromPath)(t3);
        if (s2 === "line")
          return (0, e3.createFromLine)(t3);
        if (s2 === "circle")
          return (0, e3.createFromCircle)(t3);
        throw new Error(`Unsupported SVG tag: ${s2}`);
      }, e3.create = (t3) => {
        const e4 = [];
        for (let s2 = 1;s2 < t3.length; s2++) {
          const i3 = t3[s2 - 1], a2 = t3[s2];
          e4.push(new h.BezierSegment(i3.pt, i3.right || i3.pt, a2.left || a2.pt, a2.pt));
        }
        return new i2.BezierPath(e4);
      }, e3.createFromCommands = (t3) => {
        const e4 = t3.slice();
        if (e4.length < 2)
          throw new Error(`Path doesn't have enough commands: ${JSON.stringify(e4)}`);
        if (e4[0].type !== "M")
          throw new Error(`Path starts with ${e4[0].type} instead of M!`);
        let s2 = { x: e4[0].x, y: e4[0].y }, a2 = Object.assign({}, s2);
        const n2 = [];
        for (;e4.length > 0; ) {
          const t4 = e4.shift();
          if (t4.type === "M")
            a2 = { x: t4.x, y: t4.y }, s2 = a2;
          else if (t4.type === "C")
            n2.push(new h.BezierSegment(s2, { x: t4.x1, y: t4.y1 }, { x: t4.x2, y: t4.y2 }, { x: t4.x, y: t4.y })), s2 = { x: t4.x, y: t4.y };
          else if (t4.type === "L")
            t4.x === s2.x && t4.y === s2.y || n2.push(new h.BezierSegment(s2, s2, { x: t4.x, y: t4.y }, { x: t4.x, y: t4.y })), s2 = { x: t4.x, y: t4.y };
          else if (t4.type === "H")
            t4.x !== s2.x && n2.push(new h.BezierSegment(s2, s2, { x: t4.x, y: s2.y }, { x: t4.x, y: s2.y })), s2 = { x: t4.x, y: s2.y };
          else if (t4.type === "V")
            t4.y !== s2.y && n2.push(new h.BezierSegment(s2, s2, { x: s2.x, y: t4.y }, { x: s2.x, y: t4.y })), s2 = { x: s2.x, y: t4.y };
          else if (t4.type === "Q")
            n2.push(new h.BezierSegment(s2, { x: s2.x + 2 / 3 * (t4.x1 - s2.x), y: s2.y + 2 / 3 * (t4.y1 - s2.y) }, { x: t4.x + 2 / 3 * (t4.x1 - t4.x), y: t4.y + 2 / 3 * (t4.y1 - t4.y) }, { x: t4.x, y: t4.y })), s2 = { x: t4.x, y: t4.y };
          else {
            if (t4.type !== "Z")
              throw new Error(`Unsupported path command ${t4.type}; use only H, V, M, L, C, Z!`);
            Math.hypot(s2.x - a2.x, s2.y - a2.y) > 0 && n2.push(new h.BezierSegment(s2, s2, a2, a2));
          }
        }
        return new i2.BezierPath(n2);
      };
    }, 821: function(t2, e3, s) {
      var i2 = this && this.__createBinding || (Object.create ? function(t3, e4, s2, i3) {
        i3 === undefined && (i3 = s2);
        var h2 = Object.getOwnPropertyDescriptor(e4, s2);
        h2 && !("get" in h2 ? !e4.__esModule : h2.writable || h2.configurable) || (h2 = { enumerable: true, get: function() {
          return e4[s2];
        } }), Object.defineProperty(t3, i3, h2);
      } : function(t3, e4, s2, i3) {
        i3 === undefined && (i3 = s2), t3[i3] = e4[s2];
      }), h = this && this.__exportStar || function(t3, e4) {
        for (var s2 in t3)
          s2 === "default" || Object.prototype.hasOwnProperty.call(e4, s2) || i2(e4, t3, s2);
      };
      Object.defineProperty(e3, "__esModule", { value: true }), h(s(177), e3), h(s(558), e3), h(s(729), e3), h(s(856), e3);
    }, 856: (t2, e3) => {
      Object.defineProperty(e3, "__esModule", { value: true });
    }, 188: (t2, e3) => {
      Object.defineProperty(e3, "__esModule", { value: true }), e3.times = undefined, e3.times = function(t3) {
        const e4 = [];
        for (let s = 0;s < t3; s++)
          e4.push(s);
        return e4;
      };
    } }, e2 = {};
    return function s(i2) {
      var h = e2[i2];
      if (h !== undefined)
        return h.exports;
      var a = e2[i2] = { exports: {} };
      return t[i2].call(a.exports, a, a.exports, s), a.exports;
    }(821);
  })());
});

// node_modules/estraverse/estraverse.js
var require_estraverse = __commonJS((exports) => {
  (function clone(exports2) {
    var Syntax, VisitorOption, VisitorKeys, BREAK, SKIP, REMOVE2;
    function deepCopy(obj) {
      var ret = {}, key, val;
      for (key in obj) {
        if (obj.hasOwnProperty(key)) {
          val = obj[key];
          if (typeof val === "object" && val !== null) {
            ret[key] = deepCopy(val);
          } else {
            ret[key] = val;
          }
        }
      }
      return ret;
    }
    function upperBound(array2, func) {
      var diff, len, i2, current2;
      len = array2.length;
      i2 = 0;
      while (len) {
        diff = len >>> 1;
        current2 = i2 + diff;
        if (func(array2[current2])) {
          len = diff;
        } else {
          i2 = current2 + 1;
          len -= diff + 1;
        }
      }
      return i2;
    }
    Syntax = {
      AssignmentExpression: "AssignmentExpression",
      AssignmentPattern: "AssignmentPattern",
      ArrayExpression: "ArrayExpression",
      ArrayPattern: "ArrayPattern",
      ArrowFunctionExpression: "ArrowFunctionExpression",
      AwaitExpression: "AwaitExpression",
      BlockStatement: "BlockStatement",
      BinaryExpression: "BinaryExpression",
      BreakStatement: "BreakStatement",
      CallExpression: "CallExpression",
      CatchClause: "CatchClause",
      ChainExpression: "ChainExpression",
      ClassBody: "ClassBody",
      ClassDeclaration: "ClassDeclaration",
      ClassExpression: "ClassExpression",
      ComprehensionBlock: "ComprehensionBlock",
      ComprehensionExpression: "ComprehensionExpression",
      ConditionalExpression: "ConditionalExpression",
      ContinueStatement: "ContinueStatement",
      DebuggerStatement: "DebuggerStatement",
      DirectiveStatement: "DirectiveStatement",
      DoWhileStatement: "DoWhileStatement",
      EmptyStatement: "EmptyStatement",
      ExportAllDeclaration: "ExportAllDeclaration",
      ExportDefaultDeclaration: "ExportDefaultDeclaration",
      ExportNamedDeclaration: "ExportNamedDeclaration",
      ExportSpecifier: "ExportSpecifier",
      ExpressionStatement: "ExpressionStatement",
      ForStatement: "ForStatement",
      ForInStatement: "ForInStatement",
      ForOfStatement: "ForOfStatement",
      FunctionDeclaration: "FunctionDeclaration",
      FunctionExpression: "FunctionExpression",
      GeneratorExpression: "GeneratorExpression",
      Identifier: "Identifier",
      IfStatement: "IfStatement",
      ImportExpression: "ImportExpression",
      ImportDeclaration: "ImportDeclaration",
      ImportDefaultSpecifier: "ImportDefaultSpecifier",
      ImportNamespaceSpecifier: "ImportNamespaceSpecifier",
      ImportSpecifier: "ImportSpecifier",
      Literal: "Literal",
      LabeledStatement: "LabeledStatement",
      LogicalExpression: "LogicalExpression",
      MemberExpression: "MemberExpression",
      MetaProperty: "MetaProperty",
      MethodDefinition: "MethodDefinition",
      ModuleSpecifier: "ModuleSpecifier",
      NewExpression: "NewExpression",
      ObjectExpression: "ObjectExpression",
      ObjectPattern: "ObjectPattern",
      PrivateIdentifier: "PrivateIdentifier",
      Program: "Program",
      Property: "Property",
      PropertyDefinition: "PropertyDefinition",
      RestElement: "RestElement",
      ReturnStatement: "ReturnStatement",
      SequenceExpression: "SequenceExpression",
      SpreadElement: "SpreadElement",
      Super: "Super",
      SwitchStatement: "SwitchStatement",
      SwitchCase: "SwitchCase",
      TaggedTemplateExpression: "TaggedTemplateExpression",
      TemplateElement: "TemplateElement",
      TemplateLiteral: "TemplateLiteral",
      ThisExpression: "ThisExpression",
      ThrowStatement: "ThrowStatement",
      TryStatement: "TryStatement",
      UnaryExpression: "UnaryExpression",
      UpdateExpression: "UpdateExpression",
      VariableDeclaration: "VariableDeclaration",
      VariableDeclarator: "VariableDeclarator",
      WhileStatement: "WhileStatement",
      WithStatement: "WithStatement",
      YieldExpression: "YieldExpression"
    };
    VisitorKeys = {
      AssignmentExpression: ["left", "right"],
      AssignmentPattern: ["left", "right"],
      ArrayExpression: ["elements"],
      ArrayPattern: ["elements"],
      ArrowFunctionExpression: ["params", "body"],
      AwaitExpression: ["argument"],
      BlockStatement: ["body"],
      BinaryExpression: ["left", "right"],
      BreakStatement: ["label"],
      CallExpression: ["callee", "arguments"],
      CatchClause: ["param", "body"],
      ChainExpression: ["expression"],
      ClassBody: ["body"],
      ClassDeclaration: ["id", "superClass", "body"],
      ClassExpression: ["id", "superClass", "body"],
      ComprehensionBlock: ["left", "right"],
      ComprehensionExpression: ["blocks", "filter", "body"],
      ConditionalExpression: ["test", "consequent", "alternate"],
      ContinueStatement: ["label"],
      DebuggerStatement: [],
      DirectiveStatement: [],
      DoWhileStatement: ["body", "test"],
      EmptyStatement: [],
      ExportAllDeclaration: ["source"],
      ExportDefaultDeclaration: ["declaration"],
      ExportNamedDeclaration: ["declaration", "specifiers", "source"],
      ExportSpecifier: ["exported", "local"],
      ExpressionStatement: ["expression"],
      ForStatement: ["init", "test", "update", "body"],
      ForInStatement: ["left", "right", "body"],
      ForOfStatement: ["left", "right", "body"],
      FunctionDeclaration: ["id", "params", "body"],
      FunctionExpression: ["id", "params", "body"],
      GeneratorExpression: ["blocks", "filter", "body"],
      Identifier: [],
      IfStatement: ["test", "consequent", "alternate"],
      ImportExpression: ["source"],
      ImportDeclaration: ["specifiers", "source"],
      ImportDefaultSpecifier: ["local"],
      ImportNamespaceSpecifier: ["local"],
      ImportSpecifier: ["imported", "local"],
      Literal: [],
      LabeledStatement: ["label", "body"],
      LogicalExpression: ["left", "right"],
      MemberExpression: ["object", "property"],
      MetaProperty: ["meta", "property"],
      MethodDefinition: ["key", "value"],
      ModuleSpecifier: [],
      NewExpression: ["callee", "arguments"],
      ObjectExpression: ["properties"],
      ObjectPattern: ["properties"],
      PrivateIdentifier: [],
      Program: ["body"],
      Property: ["key", "value"],
      PropertyDefinition: ["key", "value"],
      RestElement: ["argument"],
      ReturnStatement: ["argument"],
      SequenceExpression: ["expressions"],
      SpreadElement: ["argument"],
      Super: [],
      SwitchStatement: ["discriminant", "cases"],
      SwitchCase: ["test", "consequent"],
      TaggedTemplateExpression: ["tag", "quasi"],
      TemplateElement: [],
      TemplateLiteral: ["quasis", "expressions"],
      ThisExpression: [],
      ThrowStatement: ["argument"],
      TryStatement: ["block", "handler", "finalizer"],
      UnaryExpression: ["argument"],
      UpdateExpression: ["argument"],
      VariableDeclaration: ["declarations"],
      VariableDeclarator: ["id", "init"],
      WhileStatement: ["test", "body"],
      WithStatement: ["object", "body"],
      YieldExpression: ["argument"]
    };
    BREAK = {};
    SKIP = {};
    REMOVE2 = {};
    VisitorOption = {
      Break: BREAK,
      Skip: SKIP,
      Remove: REMOVE2
    };
    function Reference(parent, key) {
      this.parent = parent;
      this.key = key;
    }
    Reference.prototype.replace = function replace(node) {
      this.parent[this.key] = node;
    };
    Reference.prototype.remove = function remove() {
      if (Array.isArray(this.parent)) {
        this.parent.splice(this.key, 1);
        return true;
      } else {
        this.replace(null);
        return false;
      }
    };
    function Element2(node, path2, wrap, ref2) {
      this.node = node;
      this.path = path2;
      this.wrap = wrap;
      this.ref = ref2;
    }
    function Controller() {}
    Controller.prototype.path = function path() {
      var i2, iz, j, jz, result, element2;
      function addToPath(result2, path2) {
        if (Array.isArray(path2)) {
          for (j = 0, jz = path2.length;j < jz; ++j) {
            result2.push(path2[j]);
          }
        } else {
          result2.push(path2);
        }
      }
      if (!this.__current.path) {
        return null;
      }
      result = [];
      for (i2 = 2, iz = this.__leavelist.length;i2 < iz; ++i2) {
        element2 = this.__leavelist[i2];
        addToPath(result, element2.path);
      }
      addToPath(result, this.__current.path);
      return result;
    };
    Controller.prototype.type = function() {
      var node = this.current();
      return node.type || this.__current.wrap;
    };
    Controller.prototype.parents = function parents() {
      var i2, iz, result;
      result = [];
      for (i2 = 1, iz = this.__leavelist.length;i2 < iz; ++i2) {
        result.push(this.__leavelist[i2].node);
      }
      return result;
    };
    Controller.prototype.current = function current() {
      return this.__current.node;
    };
    Controller.prototype.__execute = function __execute(callback, element2) {
      var previous, result;
      result = undefined;
      previous = this.__current;
      this.__current = element2;
      this.__state = null;
      if (callback) {
        result = callback.call(this, element2.node, this.__leavelist[this.__leavelist.length - 1].node);
      }
      this.__current = previous;
      return result;
    };
    Controller.prototype.notify = function notify(flag) {
      this.__state = flag;
    };
    Controller.prototype.skip = function() {
      this.notify(SKIP);
    };
    Controller.prototype["break"] = function() {
      this.notify(BREAK);
    };
    Controller.prototype.remove = function() {
      this.notify(REMOVE2);
    };
    Controller.prototype.__initialize = function(root, visitor) {
      this.visitor = visitor;
      this.root = root;
      this.__worklist = [];
      this.__leavelist = [];
      this.__current = null;
      this.__state = null;
      this.__fallback = null;
      if (visitor.fallback === "iteration") {
        this.__fallback = Object.keys;
      } else if (typeof visitor.fallback === "function") {
        this.__fallback = visitor.fallback;
      }
      this.__keys = VisitorKeys;
      if (visitor.keys) {
        this.__keys = Object.assign(Object.create(this.__keys), visitor.keys);
      }
    };
    function isNode(node) {
      if (node == null) {
        return false;
      }
      return typeof node === "object" && typeof node.type === "string";
    }
    function isProperty(nodeType, key) {
      return (nodeType === Syntax.ObjectExpression || nodeType === Syntax.ObjectPattern) && key === "properties";
    }
    function candidateExistsInLeaveList(leavelist, candidate) {
      for (var i2 = leavelist.length - 1;i2 >= 0; --i2) {
        if (leavelist[i2].node === candidate) {
          return true;
        }
      }
      return false;
    }
    Controller.prototype.traverse = function traverse(root, visitor) {
      var worklist, leavelist, element2, node, nodeType, ret, key, current2, current22, candidates, candidate, sentinel;
      this.__initialize(root, visitor);
      sentinel = {};
      worklist = this.__worklist;
      leavelist = this.__leavelist;
      worklist.push(new Element2(root, null, null, null));
      leavelist.push(new Element2(null, null, null, null));
      while (worklist.length) {
        element2 = worklist.pop();
        if (element2 === sentinel) {
          element2 = leavelist.pop();
          ret = this.__execute(visitor.leave, element2);
          if (this.__state === BREAK || ret === BREAK) {
            return;
          }
          continue;
        }
        if (element2.node) {
          ret = this.__execute(visitor.enter, element2);
          if (this.__state === BREAK || ret === BREAK) {
            return;
          }
          worklist.push(sentinel);
          leavelist.push(element2);
          if (this.__state === SKIP || ret === SKIP) {
            continue;
          }
          node = element2.node;
          nodeType = node.type || element2.wrap;
          candidates = this.__keys[nodeType];
          if (!candidates) {
            if (this.__fallback) {
              candidates = this.__fallback(node);
            } else {
              throw new Error("Unknown node type " + nodeType + ".");
            }
          }
          current2 = candidates.length;
          while ((current2 -= 1) >= 0) {
            key = candidates[current2];
            candidate = node[key];
            if (!candidate) {
              continue;
            }
            if (Array.isArray(candidate)) {
              current22 = candidate.length;
              while ((current22 -= 1) >= 0) {
                if (!candidate[current22]) {
                  continue;
                }
                if (candidateExistsInLeaveList(leavelist, candidate[current22])) {
                  continue;
                }
                if (isProperty(nodeType, candidates[current2])) {
                  element2 = new Element2(candidate[current22], [key, current22], "Property", null);
                } else if (isNode(candidate[current22])) {
                  element2 = new Element2(candidate[current22], [key, current22], null, null);
                } else {
                  continue;
                }
                worklist.push(element2);
              }
            } else if (isNode(candidate)) {
              if (candidateExistsInLeaveList(leavelist, candidate)) {
                continue;
              }
              worklist.push(new Element2(candidate, key, null, null));
            }
          }
        }
      }
    };
    Controller.prototype.replace = function replace(root, visitor) {
      var worklist, leavelist, node, nodeType, target, element2, current2, current22, candidates, candidate, sentinel, outer, key;
      function removeElem(element3) {
        var i2, key2, nextElem, parent;
        if (element3.ref.remove()) {
          key2 = element3.ref.key;
          parent = element3.ref.parent;
          i2 = worklist.length;
          while (i2--) {
            nextElem = worklist[i2];
            if (nextElem.ref && nextElem.ref.parent === parent) {
              if (nextElem.ref.key < key2) {
                break;
              }
              --nextElem.ref.key;
            }
          }
        }
      }
      this.__initialize(root, visitor);
      sentinel = {};
      worklist = this.__worklist;
      leavelist = this.__leavelist;
      outer = {
        root
      };
      element2 = new Element2(root, null, null, new Reference(outer, "root"));
      worklist.push(element2);
      leavelist.push(element2);
      while (worklist.length) {
        element2 = worklist.pop();
        if (element2 === sentinel) {
          element2 = leavelist.pop();
          target = this.__execute(visitor.leave, element2);
          if (target !== undefined && target !== BREAK && target !== SKIP && target !== REMOVE2) {
            element2.ref.replace(target);
          }
          if (this.__state === REMOVE2 || target === REMOVE2) {
            removeElem(element2);
          }
          if (this.__state === BREAK || target === BREAK) {
            return outer.root;
          }
          continue;
        }
        target = this.__execute(visitor.enter, element2);
        if (target !== undefined && target !== BREAK && target !== SKIP && target !== REMOVE2) {
          element2.ref.replace(target);
          element2.node = target;
        }
        if (this.__state === REMOVE2 || target === REMOVE2) {
          removeElem(element2);
          element2.node = null;
        }
        if (this.__state === BREAK || target === BREAK) {
          return outer.root;
        }
        node = element2.node;
        if (!node) {
          continue;
        }
        worklist.push(sentinel);
        leavelist.push(element2);
        if (this.__state === SKIP || target === SKIP) {
          continue;
        }
        nodeType = node.type || element2.wrap;
        candidates = this.__keys[nodeType];
        if (!candidates) {
          if (this.__fallback) {
            candidates = this.__fallback(node);
          } else {
            throw new Error("Unknown node type " + nodeType + ".");
          }
        }
        current2 = candidates.length;
        while ((current2 -= 1) >= 0) {
          key = candidates[current2];
          candidate = node[key];
          if (!candidate) {
            continue;
          }
          if (Array.isArray(candidate)) {
            current22 = candidate.length;
            while ((current22 -= 1) >= 0) {
              if (!candidate[current22]) {
                continue;
              }
              if (isProperty(nodeType, candidates[current2])) {
                element2 = new Element2(candidate[current22], [key, current22], "Property", new Reference(candidate, current22));
              } else if (isNode(candidate[current22])) {
                element2 = new Element2(candidate[current22], [key, current22], null, new Reference(candidate, current22));
              } else {
                continue;
              }
              worklist.push(element2);
            }
          } else if (isNode(candidate)) {
            worklist.push(new Element2(candidate, key, null, new Reference(node, key)));
          }
        }
      }
      return outer.root;
    };
    function traverse(root, visitor) {
      var controller = new Controller;
      return controller.traverse(root, visitor);
    }
    function replace(root, visitor) {
      var controller = new Controller;
      return controller.replace(root, visitor);
    }
    function extendCommentRange(comment, tokens) {
      var target;
      target = upperBound(tokens, function search(token) {
        return token.range[0] > comment.range[0];
      });
      comment.extendedRange = [comment.range[0], comment.range[1]];
      if (target !== tokens.length) {
        comment.extendedRange[1] = tokens[target].range[0];
      }
      target -= 1;
      if (target >= 0) {
        comment.extendedRange[0] = tokens[target].range[1];
      }
      return comment;
    }
    function attachComments(tree, providedComments, tokens) {
      var comments = [], comment, len, i2, cursor;
      if (!tree.range) {
        throw new Error("attachComments needs range information");
      }
      if (!tokens.length) {
        if (providedComments.length) {
          for (i2 = 0, len = providedComments.length;i2 < len; i2 += 1) {
            comment = deepCopy(providedComments[i2]);
            comment.extendedRange = [0, tree.range[0]];
            comments.push(comment);
          }
          tree.leadingComments = comments;
        }
        return tree;
      }
      for (i2 = 0, len = providedComments.length;i2 < len; i2 += 1) {
        comments.push(extendCommentRange(deepCopy(providedComments[i2]), tokens));
      }
      cursor = 0;
      traverse(tree, {
        enter: function(node) {
          var comment2;
          while (cursor < comments.length) {
            comment2 = comments[cursor];
            if (comment2.extendedRange[1] > node.range[0]) {
              break;
            }
            if (comment2.extendedRange[1] === node.range[0]) {
              if (!node.leadingComments) {
                node.leadingComments = [];
              }
              node.leadingComments.push(comment2);
              comments.splice(cursor, 1);
            } else {
              cursor += 1;
            }
          }
          if (cursor === comments.length) {
            return VisitorOption.Break;
          }
          if (comments[cursor].extendedRange[0] > node.range[1]) {
            return VisitorOption.Skip;
          }
        }
      });
      cursor = 0;
      traverse(tree, {
        leave: function(node) {
          var comment2;
          while (cursor < comments.length) {
            comment2 = comments[cursor];
            if (node.range[1] < comment2.extendedRange[0]) {
              break;
            }
            if (node.range[1] === comment2.extendedRange[0]) {
              if (!node.trailingComments) {
                node.trailingComments = [];
              }
              node.trailingComments.push(comment2);
              comments.splice(cursor, 1);
            } else {
              cursor += 1;
            }
          }
          if (cursor === comments.length) {
            return VisitorOption.Break;
          }
          if (comments[cursor].extendedRange[0] > node.range[1]) {
            return VisitorOption.Skip;
          }
        }
      });
      return tree;
    }
    exports2.Syntax = Syntax;
    exports2.traverse = traverse;
    exports2.replace = replace;
    exports2.attachComments = attachComments;
    exports2.VisitorKeys = VisitorKeys;
    exports2.VisitorOption = VisitorOption;
    exports2.Controller = Controller;
    exports2.cloneEnvironment = function() {
      return clone({});
    };
    return exports2;
  })(exports);
});

// node_modules/esutils/lib/ast.js
var require_ast = __commonJS((exports, module) => {
  (function() {
    function isExpression(node) {
      if (node == null) {
        return false;
      }
      switch (node.type) {
        case "ArrayExpression":
        case "AssignmentExpression":
        case "BinaryExpression":
        case "CallExpression":
        case "ConditionalExpression":
        case "FunctionExpression":
        case "Identifier":
        case "Literal":
        case "LogicalExpression":
        case "MemberExpression":
        case "NewExpression":
        case "ObjectExpression":
        case "SequenceExpression":
        case "ThisExpression":
        case "UnaryExpression":
        case "UpdateExpression":
          return true;
      }
      return false;
    }
    function isIterationStatement(node) {
      if (node == null) {
        return false;
      }
      switch (node.type) {
        case "DoWhileStatement":
        case "ForInStatement":
        case "ForStatement":
        case "WhileStatement":
          return true;
      }
      return false;
    }
    function isStatement(node) {
      if (node == null) {
        return false;
      }
      switch (node.type) {
        case "BlockStatement":
        case "BreakStatement":
        case "ContinueStatement":
        case "DebuggerStatement":
        case "DoWhileStatement":
        case "EmptyStatement":
        case "ExpressionStatement":
        case "ForInStatement":
        case "ForStatement":
        case "IfStatement":
        case "LabeledStatement":
        case "ReturnStatement":
        case "SwitchStatement":
        case "ThrowStatement":
        case "TryStatement":
        case "VariableDeclaration":
        case "WhileStatement":
        case "WithStatement":
          return true;
      }
      return false;
    }
    function isSourceElement(node) {
      return isStatement(node) || node != null && node.type === "FunctionDeclaration";
    }
    function trailingStatement(node) {
      switch (node.type) {
        case "IfStatement":
          if (node.alternate != null) {
            return node.alternate;
          }
          return node.consequent;
        case "LabeledStatement":
        case "ForStatement":
        case "ForInStatement":
        case "WhileStatement":
        case "WithStatement":
          return node.body;
      }
      return null;
    }
    function isProblematicIfStatement(node) {
      var current2;
      if (node.type !== "IfStatement") {
        return false;
      }
      if (node.alternate == null) {
        return false;
      }
      current2 = node.consequent;
      do {
        if (current2.type === "IfStatement") {
          if (current2.alternate == null) {
            return true;
          }
        }
        current2 = trailingStatement(current2);
      } while (current2);
      return false;
    }
    module.exports = {
      isExpression,
      isStatement,
      isIterationStatement,
      isSourceElement,
      isProblematicIfStatement,
      trailingStatement
    };
  })();
});

// node_modules/esutils/lib/code.js
var require_code = __commonJS((exports, module) => {
  (function() {
    var ES6Regex, ES5Regex, NON_ASCII_WHITESPACES, IDENTIFIER_START, IDENTIFIER_PART, ch;
    ES5Regex = {
      NonAsciiIdentifierStart: /[\xAA\xB5\xBA\xC0-\xD6\xD8-\xF6\xF8-\u02C1\u02C6-\u02D1\u02E0-\u02E4\u02EC\u02EE\u0370-\u0374\u0376\u0377\u037A-\u037D\u037F\u0386\u0388-\u038A\u038C\u038E-\u03A1\u03A3-\u03F5\u03F7-\u0481\u048A-\u052F\u0531-\u0556\u0559\u0561-\u0587\u05D0-\u05EA\u05F0-\u05F2\u0620-\u064A\u066E\u066F\u0671-\u06D3\u06D5\u06E5\u06E6\u06EE\u06EF\u06FA-\u06FC\u06FF\u0710\u0712-\u072F\u074D-\u07A5\u07B1\u07CA-\u07EA\u07F4\u07F5\u07FA\u0800-\u0815\u081A\u0824\u0828\u0840-\u0858\u08A0-\u08B4\u08B6-\u08BD\u0904-\u0939\u093D\u0950\u0958-\u0961\u0971-\u0980\u0985-\u098C\u098F\u0990\u0993-\u09A8\u09AA-\u09B0\u09B2\u09B6-\u09B9\u09BD\u09CE\u09DC\u09DD\u09DF-\u09E1\u09F0\u09F1\u0A05-\u0A0A\u0A0F\u0A10\u0A13-\u0A28\u0A2A-\u0A30\u0A32\u0A33\u0A35\u0A36\u0A38\u0A39\u0A59-\u0A5C\u0A5E\u0A72-\u0A74\u0A85-\u0A8D\u0A8F-\u0A91\u0A93-\u0AA8\u0AAA-\u0AB0\u0AB2\u0AB3\u0AB5-\u0AB9\u0ABD\u0AD0\u0AE0\u0AE1\u0AF9\u0B05-\u0B0C\u0B0F\u0B10\u0B13-\u0B28\u0B2A-\u0B30\u0B32\u0B33\u0B35-\u0B39\u0B3D\u0B5C\u0B5D\u0B5F-\u0B61\u0B71\u0B83\u0B85-\u0B8A\u0B8E-\u0B90\u0B92-\u0B95\u0B99\u0B9A\u0B9C\u0B9E\u0B9F\u0BA3\u0BA4\u0BA8-\u0BAA\u0BAE-\u0BB9\u0BD0\u0C05-\u0C0C\u0C0E-\u0C10\u0C12-\u0C28\u0C2A-\u0C39\u0C3D\u0C58-\u0C5A\u0C60\u0C61\u0C80\u0C85-\u0C8C\u0C8E-\u0C90\u0C92-\u0CA8\u0CAA-\u0CB3\u0CB5-\u0CB9\u0CBD\u0CDE\u0CE0\u0CE1\u0CF1\u0CF2\u0D05-\u0D0C\u0D0E-\u0D10\u0D12-\u0D3A\u0D3D\u0D4E\u0D54-\u0D56\u0D5F-\u0D61\u0D7A-\u0D7F\u0D85-\u0D96\u0D9A-\u0DB1\u0DB3-\u0DBB\u0DBD\u0DC0-\u0DC6\u0E01-\u0E30\u0E32\u0E33\u0E40-\u0E46\u0E81\u0E82\u0E84\u0E87\u0E88\u0E8A\u0E8D\u0E94-\u0E97\u0E99-\u0E9F\u0EA1-\u0EA3\u0EA5\u0EA7\u0EAA\u0EAB\u0EAD-\u0EB0\u0EB2\u0EB3\u0EBD\u0EC0-\u0EC4\u0EC6\u0EDC-\u0EDF\u0F00\u0F40-\u0F47\u0F49-\u0F6C\u0F88-\u0F8C\u1000-\u102A\u103F\u1050-\u1055\u105A-\u105D\u1061\u1065\u1066\u106E-\u1070\u1075-\u1081\u108E\u10A0-\u10C5\u10C7\u10CD\u10D0-\u10FA\u10FC-\u1248\u124A-\u124D\u1250-\u1256\u1258\u125A-\u125D\u1260-\u1288\u128A-\u128D\u1290-\u12B0\u12B2-\u12B5\u12B8-\u12BE\u12C0\u12C2-\u12C5\u12C8-\u12D6\u12D8-\u1310\u1312-\u1315\u1318-\u135A\u1380-\u138F\u13A0-\u13F5\u13F8-\u13FD\u1401-\u166C\u166F-\u167F\u1681-\u169A\u16A0-\u16EA\u16EE-\u16F8\u1700-\u170C\u170E-\u1711\u1720-\u1731\u1740-\u1751\u1760-\u176C\u176E-\u1770\u1780-\u17B3\u17D7\u17DC\u1820-\u1877\u1880-\u1884\u1887-\u18A8\u18AA\u18B0-\u18F5\u1900-\u191E\u1950-\u196D\u1970-\u1974\u1980-\u19AB\u19B0-\u19C9\u1A00-\u1A16\u1A20-\u1A54\u1AA7\u1B05-\u1B33\u1B45-\u1B4B\u1B83-\u1BA0\u1BAE\u1BAF\u1BBA-\u1BE5\u1C00-\u1C23\u1C4D-\u1C4F\u1C5A-\u1C7D\u1C80-\u1C88\u1CE9-\u1CEC\u1CEE-\u1CF1\u1CF5\u1CF6\u1D00-\u1DBF\u1E00-\u1F15\u1F18-\u1F1D\u1F20-\u1F45\u1F48-\u1F4D\u1F50-\u1F57\u1F59\u1F5B\u1F5D\u1F5F-\u1F7D\u1F80-\u1FB4\u1FB6-\u1FBC\u1FBE\u1FC2-\u1FC4\u1FC6-\u1FCC\u1FD0-\u1FD3\u1FD6-\u1FDB\u1FE0-\u1FEC\u1FF2-\u1FF4\u1FF6-\u1FFC\u2071\u207F\u2090-\u209C\u2102\u2107\u210A-\u2113\u2115\u2119-\u211D\u2124\u2126\u2128\u212A-\u212D\u212F-\u2139\u213C-\u213F\u2145-\u2149\u214E\u2160-\u2188\u2C00-\u2C2E\u2C30-\u2C5E\u2C60-\u2CE4\u2CEB-\u2CEE\u2CF2\u2CF3\u2D00-\u2D25\u2D27\u2D2D\u2D30-\u2D67\u2D6F\u2D80-\u2D96\u2DA0-\u2DA6\u2DA8-\u2DAE\u2DB0-\u2DB6\u2DB8-\u2DBE\u2DC0-\u2DC6\u2DC8-\u2DCE\u2DD0-\u2DD6\u2DD8-\u2DDE\u2E2F\u3005-\u3007\u3021-\u3029\u3031-\u3035\u3038-\u303C\u3041-\u3096\u309D-\u309F\u30A1-\u30FA\u30FC-\u30FF\u3105-\u312D\u3131-\u318E\u31A0-\u31BA\u31F0-\u31FF\u3400-\u4DB5\u4E00-\u9FD5\uA000-\uA48C\uA4D0-\uA4FD\uA500-\uA60C\uA610-\uA61F\uA62A\uA62B\uA640-\uA66E\uA67F-\uA69D\uA6A0-\uA6EF\uA717-\uA71F\uA722-\uA788\uA78B-\uA7AE\uA7B0-\uA7B7\uA7F7-\uA801\uA803-\uA805\uA807-\uA80A\uA80C-\uA822\uA840-\uA873\uA882-\uA8B3\uA8F2-\uA8F7\uA8FB\uA8FD\uA90A-\uA925\uA930-\uA946\uA960-\uA97C\uA984-\uA9B2\uA9CF\uA9E0-\uA9E4\uA9E6-\uA9EF\uA9FA-\uA9FE\uAA00-\uAA28\uAA40-\uAA42\uAA44-\uAA4B\uAA60-\uAA76\uAA7A\uAA7E-\uAAAF\uAAB1\uAAB5\uAAB6\uAAB9-\uAABD\uAAC0\uAAC2\uAADB-\uAADD\uAAE0-\uAAEA\uAAF2-\uAAF4\uAB01-\uAB06\uAB09-\uAB0E\uAB11-\uAB16\uAB20-\uAB26\uAB28-\uAB2E\uAB30-\uAB5A\uAB5C-\uAB65\uAB70-\uABE2\uAC00-\uD7A3\uD7B0-\uD7C6\uD7CB-\uD7FB\uF900-\uFA6D\uFA70-\uFAD9\uFB00-\uFB06\uFB13-\uFB17\uFB1D\uFB1F-\uFB28\uFB2A-\uFB36\uFB38-\uFB3C\uFB3E\uFB40\uFB41\uFB43\uFB44\uFB46-\uFBB1\uFBD3-\uFD3D\uFD50-\uFD8F\uFD92-\uFDC7\uFDF0-\uFDFB\uFE70-\uFE74\uFE76-\uFEFC\uFF21-\uFF3A\uFF41-\uFF5A\uFF66-\uFFBE\uFFC2-\uFFC7\uFFCA-\uFFCF\uFFD2-\uFFD7\uFFDA-\uFFDC]/,
      NonAsciiIdentifierPart: /[\xAA\xB5\xBA\xC0-\xD6\xD8-\xF6\xF8-\u02C1\u02C6-\u02D1\u02E0-\u02E4\u02EC\u02EE\u0300-\u0374\u0376\u0377\u037A-\u037D\u037F\u0386\u0388-\u038A\u038C\u038E-\u03A1\u03A3-\u03F5\u03F7-\u0481\u0483-\u0487\u048A-\u052F\u0531-\u0556\u0559\u0561-\u0587\u0591-\u05BD\u05BF\u05C1\u05C2\u05C4\u05C5\u05C7\u05D0-\u05EA\u05F0-\u05F2\u0610-\u061A\u0620-\u0669\u066E-\u06D3\u06D5-\u06DC\u06DF-\u06E8\u06EA-\u06FC\u06FF\u0710-\u074A\u074D-\u07B1\u07C0-\u07F5\u07FA\u0800-\u082D\u0840-\u085B\u08A0-\u08B4\u08B6-\u08BD\u08D4-\u08E1\u08E3-\u0963\u0966-\u096F\u0971-\u0983\u0985-\u098C\u098F\u0990\u0993-\u09A8\u09AA-\u09B0\u09B2\u09B6-\u09B9\u09BC-\u09C4\u09C7\u09C8\u09CB-\u09CE\u09D7\u09DC\u09DD\u09DF-\u09E3\u09E6-\u09F1\u0A01-\u0A03\u0A05-\u0A0A\u0A0F\u0A10\u0A13-\u0A28\u0A2A-\u0A30\u0A32\u0A33\u0A35\u0A36\u0A38\u0A39\u0A3C\u0A3E-\u0A42\u0A47\u0A48\u0A4B-\u0A4D\u0A51\u0A59-\u0A5C\u0A5E\u0A66-\u0A75\u0A81-\u0A83\u0A85-\u0A8D\u0A8F-\u0A91\u0A93-\u0AA8\u0AAA-\u0AB0\u0AB2\u0AB3\u0AB5-\u0AB9\u0ABC-\u0AC5\u0AC7-\u0AC9\u0ACB-\u0ACD\u0AD0\u0AE0-\u0AE3\u0AE6-\u0AEF\u0AF9\u0B01-\u0B03\u0B05-\u0B0C\u0B0F\u0B10\u0B13-\u0B28\u0B2A-\u0B30\u0B32\u0B33\u0B35-\u0B39\u0B3C-\u0B44\u0B47\u0B48\u0B4B-\u0B4D\u0B56\u0B57\u0B5C\u0B5D\u0B5F-\u0B63\u0B66-\u0B6F\u0B71\u0B82\u0B83\u0B85-\u0B8A\u0B8E-\u0B90\u0B92-\u0B95\u0B99\u0B9A\u0B9C\u0B9E\u0B9F\u0BA3\u0BA4\u0BA8-\u0BAA\u0BAE-\u0BB9\u0BBE-\u0BC2\u0BC6-\u0BC8\u0BCA-\u0BCD\u0BD0\u0BD7\u0BE6-\u0BEF\u0C00-\u0C03\u0C05-\u0C0C\u0C0E-\u0C10\u0C12-\u0C28\u0C2A-\u0C39\u0C3D-\u0C44\u0C46-\u0C48\u0C4A-\u0C4D\u0C55\u0C56\u0C58-\u0C5A\u0C60-\u0C63\u0C66-\u0C6F\u0C80-\u0C83\u0C85-\u0C8C\u0C8E-\u0C90\u0C92-\u0CA8\u0CAA-\u0CB3\u0CB5-\u0CB9\u0CBC-\u0CC4\u0CC6-\u0CC8\u0CCA-\u0CCD\u0CD5\u0CD6\u0CDE\u0CE0-\u0CE3\u0CE6-\u0CEF\u0CF1\u0CF2\u0D01-\u0D03\u0D05-\u0D0C\u0D0E-\u0D10\u0D12-\u0D3A\u0D3D-\u0D44\u0D46-\u0D48\u0D4A-\u0D4E\u0D54-\u0D57\u0D5F-\u0D63\u0D66-\u0D6F\u0D7A-\u0D7F\u0D82\u0D83\u0D85-\u0D96\u0D9A-\u0DB1\u0DB3-\u0DBB\u0DBD\u0DC0-\u0DC6\u0DCA\u0DCF-\u0DD4\u0DD6\u0DD8-\u0DDF\u0DE6-\u0DEF\u0DF2\u0DF3\u0E01-\u0E3A\u0E40-\u0E4E\u0E50-\u0E59\u0E81\u0E82\u0E84\u0E87\u0E88\u0E8A\u0E8D\u0E94-\u0E97\u0E99-\u0E9F\u0EA1-\u0EA3\u0EA5\u0EA7\u0EAA\u0EAB\u0EAD-\u0EB9\u0EBB-\u0EBD\u0EC0-\u0EC4\u0EC6\u0EC8-\u0ECD\u0ED0-\u0ED9\u0EDC-\u0EDF\u0F00\u0F18\u0F19\u0F20-\u0F29\u0F35\u0F37\u0F39\u0F3E-\u0F47\u0F49-\u0F6C\u0F71-\u0F84\u0F86-\u0F97\u0F99-\u0FBC\u0FC6\u1000-\u1049\u1050-\u109D\u10A0-\u10C5\u10C7\u10CD\u10D0-\u10FA\u10FC-\u1248\u124A-\u124D\u1250-\u1256\u1258\u125A-\u125D\u1260-\u1288\u128A-\u128D\u1290-\u12B0\u12B2-\u12B5\u12B8-\u12BE\u12C0\u12C2-\u12C5\u12C8-\u12D6\u12D8-\u1310\u1312-\u1315\u1318-\u135A\u135D-\u135F\u1380-\u138F\u13A0-\u13F5\u13F8-\u13FD\u1401-\u166C\u166F-\u167F\u1681-\u169A\u16A0-\u16EA\u16EE-\u16F8\u1700-\u170C\u170E-\u1714\u1720-\u1734\u1740-\u1753\u1760-\u176C\u176E-\u1770\u1772\u1773\u1780-\u17D3\u17D7\u17DC\u17DD\u17E0-\u17E9\u180B-\u180D\u1810-\u1819\u1820-\u1877\u1880-\u18AA\u18B0-\u18F5\u1900-\u191E\u1920-\u192B\u1930-\u193B\u1946-\u196D\u1970-\u1974\u1980-\u19AB\u19B0-\u19C9\u19D0-\u19D9\u1A00-\u1A1B\u1A20-\u1A5E\u1A60-\u1A7C\u1A7F-\u1A89\u1A90-\u1A99\u1AA7\u1AB0-\u1ABD\u1B00-\u1B4B\u1B50-\u1B59\u1B6B-\u1B73\u1B80-\u1BF3\u1C00-\u1C37\u1C40-\u1C49\u1C4D-\u1C7D\u1C80-\u1C88\u1CD0-\u1CD2\u1CD4-\u1CF6\u1CF8\u1CF9\u1D00-\u1DF5\u1DFB-\u1F15\u1F18-\u1F1D\u1F20-\u1F45\u1F48-\u1F4D\u1F50-\u1F57\u1F59\u1F5B\u1F5D\u1F5F-\u1F7D\u1F80-\u1FB4\u1FB6-\u1FBC\u1FBE\u1FC2-\u1FC4\u1FC6-\u1FCC\u1FD0-\u1FD3\u1FD6-\u1FDB\u1FE0-\u1FEC\u1FF2-\u1FF4\u1FF6-\u1FFC\u200C\u200D\u203F\u2040\u2054\u2071\u207F\u2090-\u209C\u20D0-\u20DC\u20E1\u20E5-\u20F0\u2102\u2107\u210A-\u2113\u2115\u2119-\u211D\u2124\u2126\u2128\u212A-\u212D\u212F-\u2139\u213C-\u213F\u2145-\u2149\u214E\u2160-\u2188\u2C00-\u2C2E\u2C30-\u2C5E\u2C60-\u2CE4\u2CEB-\u2CF3\u2D00-\u2D25\u2D27\u2D2D\u2D30-\u2D67\u2D6F\u2D7F-\u2D96\u2DA0-\u2DA6\u2DA8-\u2DAE\u2DB0-\u2DB6\u2DB8-\u2DBE\u2DC0-\u2DC6\u2DC8-\u2DCE\u2DD0-\u2DD6\u2DD8-\u2DDE\u2DE0-\u2DFF\u2E2F\u3005-\u3007\u3021-\u302F\u3031-\u3035\u3038-\u303C\u3041-\u3096\u3099\u309A\u309D-\u309F\u30A1-\u30FA\u30FC-\u30FF\u3105-\u312D\u3131-\u318E\u31A0-\u31BA\u31F0-\u31FF\u3400-\u4DB5\u4E00-\u9FD5\uA000-\uA48C\uA4D0-\uA4FD\uA500-\uA60C\uA610-\uA62B\uA640-\uA66F\uA674-\uA67D\uA67F-\uA6F1\uA717-\uA71F\uA722-\uA788\uA78B-\uA7AE\uA7B0-\uA7B7\uA7F7-\uA827\uA840-\uA873\uA880-\uA8C5\uA8D0-\uA8D9\uA8E0-\uA8F7\uA8FB\uA8FD\uA900-\uA92D\uA930-\uA953\uA960-\uA97C\uA980-\uA9C0\uA9CF-\uA9D9\uA9E0-\uA9FE\uAA00-\uAA36\uAA40-\uAA4D\uAA50-\uAA59\uAA60-\uAA76\uAA7A-\uAAC2\uAADB-\uAADD\uAAE0-\uAAEF\uAAF2-\uAAF6\uAB01-\uAB06\uAB09-\uAB0E\uAB11-\uAB16\uAB20-\uAB26\uAB28-\uAB2E\uAB30-\uAB5A\uAB5C-\uAB65\uAB70-\uABEA\uABEC\uABED\uABF0-\uABF9\uAC00-\uD7A3\uD7B0-\uD7C6\uD7CB-\uD7FB\uF900-\uFA6D\uFA70-\uFAD9\uFB00-\uFB06\uFB13-\uFB17\uFB1D-\uFB28\uFB2A-\uFB36\uFB38-\uFB3C\uFB3E\uFB40\uFB41\uFB43\uFB44\uFB46-\uFBB1\uFBD3-\uFD3D\uFD50-\uFD8F\uFD92-\uFDC7\uFDF0-\uFDFB\uFE00-\uFE0F\uFE20-\uFE2F\uFE33\uFE34\uFE4D-\uFE4F\uFE70-\uFE74\uFE76-\uFEFC\uFF10-\uFF19\uFF21-\uFF3A\uFF3F\uFF41-\uFF5A\uFF66-\uFFBE\uFFC2-\uFFC7\uFFCA-\uFFCF\uFFD2-\uFFD7\uFFDA-\uFFDC]/
    };
    ES6Regex = {
      NonAsciiIdentifierStart: /[\xAA\xB5\xBA\xC0-\xD6\xD8-\xF6\xF8-\u02C1\u02C6-\u02D1\u02E0-\u02E4\u02EC\u02EE\u0370-\u0374\u0376\u0377\u037A-\u037D\u037F\u0386\u0388-\u038A\u038C\u038E-\u03A1\u03A3-\u03F5\u03F7-\u0481\u048A-\u052F\u0531-\u0556\u0559\u0561-\u0587\u05D0-\u05EA\u05F0-\u05F2\u0620-\u064A\u066E\u066F\u0671-\u06D3\u06D5\u06E5\u06E6\u06EE\u06EF\u06FA-\u06FC\u06FF\u0710\u0712-\u072F\u074D-\u07A5\u07B1\u07CA-\u07EA\u07F4\u07F5\u07FA\u0800-\u0815\u081A\u0824\u0828\u0840-\u0858\u08A0-\u08B4\u08B6-\u08BD\u0904-\u0939\u093D\u0950\u0958-\u0961\u0971-\u0980\u0985-\u098C\u098F\u0990\u0993-\u09A8\u09AA-\u09B0\u09B2\u09B6-\u09B9\u09BD\u09CE\u09DC\u09DD\u09DF-\u09E1\u09F0\u09F1\u0A05-\u0A0A\u0A0F\u0A10\u0A13-\u0A28\u0A2A-\u0A30\u0A32\u0A33\u0A35\u0A36\u0A38\u0A39\u0A59-\u0A5C\u0A5E\u0A72-\u0A74\u0A85-\u0A8D\u0A8F-\u0A91\u0A93-\u0AA8\u0AAA-\u0AB0\u0AB2\u0AB3\u0AB5-\u0AB9\u0ABD\u0AD0\u0AE0\u0AE1\u0AF9\u0B05-\u0B0C\u0B0F\u0B10\u0B13-\u0B28\u0B2A-\u0B30\u0B32\u0B33\u0B35-\u0B39\u0B3D\u0B5C\u0B5D\u0B5F-\u0B61\u0B71\u0B83\u0B85-\u0B8A\u0B8E-\u0B90\u0B92-\u0B95\u0B99\u0B9A\u0B9C\u0B9E\u0B9F\u0BA3\u0BA4\u0BA8-\u0BAA\u0BAE-\u0BB9\u0BD0\u0C05-\u0C0C\u0C0E-\u0C10\u0C12-\u0C28\u0C2A-\u0C39\u0C3D\u0C58-\u0C5A\u0C60\u0C61\u0C80\u0C85-\u0C8C\u0C8E-\u0C90\u0C92-\u0CA8\u0CAA-\u0CB3\u0CB5-\u0CB9\u0CBD\u0CDE\u0CE0\u0CE1\u0CF1\u0CF2\u0D05-\u0D0C\u0D0E-\u0D10\u0D12-\u0D3A\u0D3D\u0D4E\u0D54-\u0D56\u0D5F-\u0D61\u0D7A-\u0D7F\u0D85-\u0D96\u0D9A-\u0DB1\u0DB3-\u0DBB\u0DBD\u0DC0-\u0DC6\u0E01-\u0E30\u0E32\u0E33\u0E40-\u0E46\u0E81\u0E82\u0E84\u0E87\u0E88\u0E8A\u0E8D\u0E94-\u0E97\u0E99-\u0E9F\u0EA1-\u0EA3\u0EA5\u0EA7\u0EAA\u0EAB\u0EAD-\u0EB0\u0EB2\u0EB3\u0EBD\u0EC0-\u0EC4\u0EC6\u0EDC-\u0EDF\u0F00\u0F40-\u0F47\u0F49-\u0F6C\u0F88-\u0F8C\u1000-\u102A\u103F\u1050-\u1055\u105A-\u105D\u1061\u1065\u1066\u106E-\u1070\u1075-\u1081\u108E\u10A0-\u10C5\u10C7\u10CD\u10D0-\u10FA\u10FC-\u1248\u124A-\u124D\u1250-\u1256\u1258\u125A-\u125D\u1260-\u1288\u128A-\u128D\u1290-\u12B0\u12B2-\u12B5\u12B8-\u12BE\u12C0\u12C2-\u12C5\u12C8-\u12D6\u12D8-\u1310\u1312-\u1315\u1318-\u135A\u1380-\u138F\u13A0-\u13F5\u13F8-\u13FD\u1401-\u166C\u166F-\u167F\u1681-\u169A\u16A0-\u16EA\u16EE-\u16F8\u1700-\u170C\u170E-\u1711\u1720-\u1731\u1740-\u1751\u1760-\u176C\u176E-\u1770\u1780-\u17B3\u17D7\u17DC\u1820-\u1877\u1880-\u18A8\u18AA\u18B0-\u18F5\u1900-\u191E\u1950-\u196D\u1970-\u1974\u1980-\u19AB\u19B0-\u19C9\u1A00-\u1A16\u1A20-\u1A54\u1AA7\u1B05-\u1B33\u1B45-\u1B4B\u1B83-\u1BA0\u1BAE\u1BAF\u1BBA-\u1BE5\u1C00-\u1C23\u1C4D-\u1C4F\u1C5A-\u1C7D\u1C80-\u1C88\u1CE9-\u1CEC\u1CEE-\u1CF1\u1CF5\u1CF6\u1D00-\u1DBF\u1E00-\u1F15\u1F18-\u1F1D\u1F20-\u1F45\u1F48-\u1F4D\u1F50-\u1F57\u1F59\u1F5B\u1F5D\u1F5F-\u1F7D\u1F80-\u1FB4\u1FB6-\u1FBC\u1FBE\u1FC2-\u1FC4\u1FC6-\u1FCC\u1FD0-\u1FD3\u1FD6-\u1FDB\u1FE0-\u1FEC\u1FF2-\u1FF4\u1FF6-\u1FFC\u2071\u207F\u2090-\u209C\u2102\u2107\u210A-\u2113\u2115\u2118-\u211D\u2124\u2126\u2128\u212A-\u2139\u213C-\u213F\u2145-\u2149\u214E\u2160-\u2188\u2C00-\u2C2E\u2C30-\u2C5E\u2C60-\u2CE4\u2CEB-\u2CEE\u2CF2\u2CF3\u2D00-\u2D25\u2D27\u2D2D\u2D30-\u2D67\u2D6F\u2D80-\u2D96\u2DA0-\u2DA6\u2DA8-\u2DAE\u2DB0-\u2DB6\u2DB8-\u2DBE\u2DC0-\u2DC6\u2DC8-\u2DCE\u2DD0-\u2DD6\u2DD8-\u2DDE\u3005-\u3007\u3021-\u3029\u3031-\u3035\u3038-\u303C\u3041-\u3096\u309B-\u309F\u30A1-\u30FA\u30FC-\u30FF\u3105-\u312D\u3131-\u318E\u31A0-\u31BA\u31F0-\u31FF\u3400-\u4DB5\u4E00-\u9FD5\uA000-\uA48C\uA4D0-\uA4FD\uA500-\uA60C\uA610-\uA61F\uA62A\uA62B\uA640-\uA66E\uA67F-\uA69D\uA6A0-\uA6EF\uA717-\uA71F\uA722-\uA788\uA78B-\uA7AE\uA7B0-\uA7B7\uA7F7-\uA801\uA803-\uA805\uA807-\uA80A\uA80C-\uA822\uA840-\uA873\uA882-\uA8B3\uA8F2-\uA8F7\uA8FB\uA8FD\uA90A-\uA925\uA930-\uA946\uA960-\uA97C\uA984-\uA9B2\uA9CF\uA9E0-\uA9E4\uA9E6-\uA9EF\uA9FA-\uA9FE\uAA00-\uAA28\uAA40-\uAA42\uAA44-\uAA4B\uAA60-\uAA76\uAA7A\uAA7E-\uAAAF\uAAB1\uAAB5\uAAB6\uAAB9-\uAABD\uAAC0\uAAC2\uAADB-\uAADD\uAAE0-\uAAEA\uAAF2-\uAAF4\uAB01-\uAB06\uAB09-\uAB0E\uAB11-\uAB16\uAB20-\uAB26\uAB28-\uAB2E\uAB30-\uAB5A\uAB5C-\uAB65\uAB70-\uABE2\uAC00-\uD7A3\uD7B0-\uD7C6\uD7CB-\uD7FB\uF900-\uFA6D\uFA70-\uFAD9\uFB00-\uFB06\uFB13-\uFB17\uFB1D\uFB1F-\uFB28\uFB2A-\uFB36\uFB38-\uFB3C\uFB3E\uFB40\uFB41\uFB43\uFB44\uFB46-\uFBB1\uFBD3-\uFD3D\uFD50-\uFD8F\uFD92-\uFDC7\uFDF0-\uFDFB\uFE70-\uFE74\uFE76-\uFEFC\uFF21-\uFF3A\uFF41-\uFF5A\uFF66-\uFFBE\uFFC2-\uFFC7\uFFCA-\uFFCF\uFFD2-\uFFD7\uFFDA-\uFFDC]|\uD800[\uDC00-\uDC0B\uDC0D-\uDC26\uDC28-\uDC3A\uDC3C\uDC3D\uDC3F-\uDC4D\uDC50-\uDC5D\uDC80-\uDCFA\uDD40-\uDD74\uDE80-\uDE9C\uDEA0-\uDED0\uDF00-\uDF1F\uDF30-\uDF4A\uDF50-\uDF75\uDF80-\uDF9D\uDFA0-\uDFC3\uDFC8-\uDFCF\uDFD1-\uDFD5]|\uD801[\uDC00-\uDC9D\uDCB0-\uDCD3\uDCD8-\uDCFB\uDD00-\uDD27\uDD30-\uDD63\uDE00-\uDF36\uDF40-\uDF55\uDF60-\uDF67]|\uD802[\uDC00-\uDC05\uDC08\uDC0A-\uDC35\uDC37\uDC38\uDC3C\uDC3F-\uDC55\uDC60-\uDC76\uDC80-\uDC9E\uDCE0-\uDCF2\uDCF4\uDCF5\uDD00-\uDD15\uDD20-\uDD39\uDD80-\uDDB7\uDDBE\uDDBF\uDE00\uDE10-\uDE13\uDE15-\uDE17\uDE19-\uDE33\uDE60-\uDE7C\uDE80-\uDE9C\uDEC0-\uDEC7\uDEC9-\uDEE4\uDF00-\uDF35\uDF40-\uDF55\uDF60-\uDF72\uDF80-\uDF91]|\uD803[\uDC00-\uDC48\uDC80-\uDCB2\uDCC0-\uDCF2]|\uD804[\uDC03-\uDC37\uDC83-\uDCAF\uDCD0-\uDCE8\uDD03-\uDD26\uDD50-\uDD72\uDD76\uDD83-\uDDB2\uDDC1-\uDDC4\uDDDA\uDDDC\uDE00-\uDE11\uDE13-\uDE2B\uDE80-\uDE86\uDE88\uDE8A-\uDE8D\uDE8F-\uDE9D\uDE9F-\uDEA8\uDEB0-\uDEDE\uDF05-\uDF0C\uDF0F\uDF10\uDF13-\uDF28\uDF2A-\uDF30\uDF32\uDF33\uDF35-\uDF39\uDF3D\uDF50\uDF5D-\uDF61]|\uD805[\uDC00-\uDC34\uDC47-\uDC4A\uDC80-\uDCAF\uDCC4\uDCC5\uDCC7\uDD80-\uDDAE\uDDD8-\uDDDB\uDE00-\uDE2F\uDE44\uDE80-\uDEAA\uDF00-\uDF19]|\uD806[\uDCA0-\uDCDF\uDCFF\uDEC0-\uDEF8]|\uD807[\uDC00-\uDC08\uDC0A-\uDC2E\uDC40\uDC72-\uDC8F]|\uD808[\uDC00-\uDF99]|\uD809[\uDC00-\uDC6E\uDC80-\uDD43]|[\uD80C\uD81C-\uD820\uD840-\uD868\uD86A-\uD86C\uD86F-\uD872][\uDC00-\uDFFF]|\uD80D[\uDC00-\uDC2E]|\uD811[\uDC00-\uDE46]|\uD81A[\uDC00-\uDE38\uDE40-\uDE5E\uDED0-\uDEED\uDF00-\uDF2F\uDF40-\uDF43\uDF63-\uDF77\uDF7D-\uDF8F]|\uD81B[\uDF00-\uDF44\uDF50\uDF93-\uDF9F\uDFE0]|\uD821[\uDC00-\uDFEC]|\uD822[\uDC00-\uDEF2]|\uD82C[\uDC00\uDC01]|\uD82F[\uDC00-\uDC6A\uDC70-\uDC7C\uDC80-\uDC88\uDC90-\uDC99]|\uD835[\uDC00-\uDC54\uDC56-\uDC9C\uDC9E\uDC9F\uDCA2\uDCA5\uDCA6\uDCA9-\uDCAC\uDCAE-\uDCB9\uDCBB\uDCBD-\uDCC3\uDCC5-\uDD05\uDD07-\uDD0A\uDD0D-\uDD14\uDD16-\uDD1C\uDD1E-\uDD39\uDD3B-\uDD3E\uDD40-\uDD44\uDD46\uDD4A-\uDD50\uDD52-\uDEA5\uDEA8-\uDEC0\uDEC2-\uDEDA\uDEDC-\uDEFA\uDEFC-\uDF14\uDF16-\uDF34\uDF36-\uDF4E\uDF50-\uDF6E\uDF70-\uDF88\uDF8A-\uDFA8\uDFAA-\uDFC2\uDFC4-\uDFCB]|\uD83A[\uDC00-\uDCC4\uDD00-\uDD43]|\uD83B[\uDE00-\uDE03\uDE05-\uDE1F\uDE21\uDE22\uDE24\uDE27\uDE29-\uDE32\uDE34-\uDE37\uDE39\uDE3B\uDE42\uDE47\uDE49\uDE4B\uDE4D-\uDE4F\uDE51\uDE52\uDE54\uDE57\uDE59\uDE5B\uDE5D\uDE5F\uDE61\uDE62\uDE64\uDE67-\uDE6A\uDE6C-\uDE72\uDE74-\uDE77\uDE79-\uDE7C\uDE7E\uDE80-\uDE89\uDE8B-\uDE9B\uDEA1-\uDEA3\uDEA5-\uDEA9\uDEAB-\uDEBB]|\uD869[\uDC00-\uDED6\uDF00-\uDFFF]|\uD86D[\uDC00-\uDF34\uDF40-\uDFFF]|\uD86E[\uDC00-\uDC1D\uDC20-\uDFFF]|\uD873[\uDC00-\uDEA1]|\uD87E[\uDC00-\uDE1D]/,
      NonAsciiIdentifierPart: /[\xAA\xB5\xB7\xBA\xC0-\xD6\xD8-\xF6\xF8-\u02C1\u02C6-\u02D1\u02E0-\u02E4\u02EC\u02EE\u0300-\u0374\u0376\u0377\u037A-\u037D\u037F\u0386-\u038A\u038C\u038E-\u03A1\u03A3-\u03F5\u03F7-\u0481\u0483-\u0487\u048A-\u052F\u0531-\u0556\u0559\u0561-\u0587\u0591-\u05BD\u05BF\u05C1\u05C2\u05C4\u05C5\u05C7\u05D0-\u05EA\u05F0-\u05F2\u0610-\u061A\u0620-\u0669\u066E-\u06D3\u06D5-\u06DC\u06DF-\u06E8\u06EA-\u06FC\u06FF\u0710-\u074A\u074D-\u07B1\u07C0-\u07F5\u07FA\u0800-\u082D\u0840-\u085B\u08A0-\u08B4\u08B6-\u08BD\u08D4-\u08E1\u08E3-\u0963\u0966-\u096F\u0971-\u0983\u0985-\u098C\u098F\u0990\u0993-\u09A8\u09AA-\u09B0\u09B2\u09B6-\u09B9\u09BC-\u09C4\u09C7\u09C8\u09CB-\u09CE\u09D7\u09DC\u09DD\u09DF-\u09E3\u09E6-\u09F1\u0A01-\u0A03\u0A05-\u0A0A\u0A0F\u0A10\u0A13-\u0A28\u0A2A-\u0A30\u0A32\u0A33\u0A35\u0A36\u0A38\u0A39\u0A3C\u0A3E-\u0A42\u0A47\u0A48\u0A4B-\u0A4D\u0A51\u0A59-\u0A5C\u0A5E\u0A66-\u0A75\u0A81-\u0A83\u0A85-\u0A8D\u0A8F-\u0A91\u0A93-\u0AA8\u0AAA-\u0AB0\u0AB2\u0AB3\u0AB5-\u0AB9\u0ABC-\u0AC5\u0AC7-\u0AC9\u0ACB-\u0ACD\u0AD0\u0AE0-\u0AE3\u0AE6-\u0AEF\u0AF9\u0B01-\u0B03\u0B05-\u0B0C\u0B0F\u0B10\u0B13-\u0B28\u0B2A-\u0B30\u0B32\u0B33\u0B35-\u0B39\u0B3C-\u0B44\u0B47\u0B48\u0B4B-\u0B4D\u0B56\u0B57\u0B5C\u0B5D\u0B5F-\u0B63\u0B66-\u0B6F\u0B71\u0B82\u0B83\u0B85-\u0B8A\u0B8E-\u0B90\u0B92-\u0B95\u0B99\u0B9A\u0B9C\u0B9E\u0B9F\u0BA3\u0BA4\u0BA8-\u0BAA\u0BAE-\u0BB9\u0BBE-\u0BC2\u0BC6-\u0BC8\u0BCA-\u0BCD\u0BD0\u0BD7\u0BE6-\u0BEF\u0C00-\u0C03\u0C05-\u0C0C\u0C0E-\u0C10\u0C12-\u0C28\u0C2A-\u0C39\u0C3D-\u0C44\u0C46-\u0C48\u0C4A-\u0C4D\u0C55\u0C56\u0C58-\u0C5A\u0C60-\u0C63\u0C66-\u0C6F\u0C80-\u0C83\u0C85-\u0C8C\u0C8E-\u0C90\u0C92-\u0CA8\u0CAA-\u0CB3\u0CB5-\u0CB9\u0CBC-\u0CC4\u0CC6-\u0CC8\u0CCA-\u0CCD\u0CD5\u0CD6\u0CDE\u0CE0-\u0CE3\u0CE6-\u0CEF\u0CF1\u0CF2\u0D01-\u0D03\u0D05-\u0D0C\u0D0E-\u0D10\u0D12-\u0D3A\u0D3D-\u0D44\u0D46-\u0D48\u0D4A-\u0D4E\u0D54-\u0D57\u0D5F-\u0D63\u0D66-\u0D6F\u0D7A-\u0D7F\u0D82\u0D83\u0D85-\u0D96\u0D9A-\u0DB1\u0DB3-\u0DBB\u0DBD\u0DC0-\u0DC6\u0DCA\u0DCF-\u0DD4\u0DD6\u0DD8-\u0DDF\u0DE6-\u0DEF\u0DF2\u0DF3\u0E01-\u0E3A\u0E40-\u0E4E\u0E50-\u0E59\u0E81\u0E82\u0E84\u0E87\u0E88\u0E8A\u0E8D\u0E94-\u0E97\u0E99-\u0E9F\u0EA1-\u0EA3\u0EA5\u0EA7\u0EAA\u0EAB\u0EAD-\u0EB9\u0EBB-\u0EBD\u0EC0-\u0EC4\u0EC6\u0EC8-\u0ECD\u0ED0-\u0ED9\u0EDC-\u0EDF\u0F00\u0F18\u0F19\u0F20-\u0F29\u0F35\u0F37\u0F39\u0F3E-\u0F47\u0F49-\u0F6C\u0F71-\u0F84\u0F86-\u0F97\u0F99-\u0FBC\u0FC6\u1000-\u1049\u1050-\u109D\u10A0-\u10C5\u10C7\u10CD\u10D0-\u10FA\u10FC-\u1248\u124A-\u124D\u1250-\u1256\u1258\u125A-\u125D\u1260-\u1288\u128A-\u128D\u1290-\u12B0\u12B2-\u12B5\u12B8-\u12BE\u12C0\u12C2-\u12C5\u12C8-\u12D6\u12D8-\u1310\u1312-\u1315\u1318-\u135A\u135D-\u135F\u1369-\u1371\u1380-\u138F\u13A0-\u13F5\u13F8-\u13FD\u1401-\u166C\u166F-\u167F\u1681-\u169A\u16A0-\u16EA\u16EE-\u16F8\u1700-\u170C\u170E-\u1714\u1720-\u1734\u1740-\u1753\u1760-\u176C\u176E-\u1770\u1772\u1773\u1780-\u17D3\u17D7\u17DC\u17DD\u17E0-\u17E9\u180B-\u180D\u1810-\u1819\u1820-\u1877\u1880-\u18AA\u18B0-\u18F5\u1900-\u191E\u1920-\u192B\u1930-\u193B\u1946-\u196D\u1970-\u1974\u1980-\u19AB\u19B0-\u19C9\u19D0-\u19DA\u1A00-\u1A1B\u1A20-\u1A5E\u1A60-\u1A7C\u1A7F-\u1A89\u1A90-\u1A99\u1AA7\u1AB0-\u1ABD\u1B00-\u1B4B\u1B50-\u1B59\u1B6B-\u1B73\u1B80-\u1BF3\u1C00-\u1C37\u1C40-\u1C49\u1C4D-\u1C7D\u1C80-\u1C88\u1CD0-\u1CD2\u1CD4-\u1CF6\u1CF8\u1CF9\u1D00-\u1DF5\u1DFB-\u1F15\u1F18-\u1F1D\u1F20-\u1F45\u1F48-\u1F4D\u1F50-\u1F57\u1F59\u1F5B\u1F5D\u1F5F-\u1F7D\u1F80-\u1FB4\u1FB6-\u1FBC\u1FBE\u1FC2-\u1FC4\u1FC6-\u1FCC\u1FD0-\u1FD3\u1FD6-\u1FDB\u1FE0-\u1FEC\u1FF2-\u1FF4\u1FF6-\u1FFC\u200C\u200D\u203F\u2040\u2054\u2071\u207F\u2090-\u209C\u20D0-\u20DC\u20E1\u20E5-\u20F0\u2102\u2107\u210A-\u2113\u2115\u2118-\u211D\u2124\u2126\u2128\u212A-\u2139\u213C-\u213F\u2145-\u2149\u214E\u2160-\u2188\u2C00-\u2C2E\u2C30-\u2C5E\u2C60-\u2CE4\u2CEB-\u2CF3\u2D00-\u2D25\u2D27\u2D2D\u2D30-\u2D67\u2D6F\u2D7F-\u2D96\u2DA0-\u2DA6\u2DA8-\u2DAE\u2DB0-\u2DB6\u2DB8-\u2DBE\u2DC0-\u2DC6\u2DC8-\u2DCE\u2DD0-\u2DD6\u2DD8-\u2DDE\u2DE0-\u2DFF\u3005-\u3007\u3021-\u302F\u3031-\u3035\u3038-\u303C\u3041-\u3096\u3099-\u309F\u30A1-\u30FA\u30FC-\u30FF\u3105-\u312D\u3131-\u318E\u31A0-\u31BA\u31F0-\u31FF\u3400-\u4DB5\u4E00-\u9FD5\uA000-\uA48C\uA4D0-\uA4FD\uA500-\uA60C\uA610-\uA62B\uA640-\uA66F\uA674-\uA67D\uA67F-\uA6F1\uA717-\uA71F\uA722-\uA788\uA78B-\uA7AE\uA7B0-\uA7B7\uA7F7-\uA827\uA840-\uA873\uA880-\uA8C5\uA8D0-\uA8D9\uA8E0-\uA8F7\uA8FB\uA8FD\uA900-\uA92D\uA930-\uA953\uA960-\uA97C\uA980-\uA9C0\uA9CF-\uA9D9\uA9E0-\uA9FE\uAA00-\uAA36\uAA40-\uAA4D\uAA50-\uAA59\uAA60-\uAA76\uAA7A-\uAAC2\uAADB-\uAADD\uAAE0-\uAAEF\uAAF2-\uAAF6\uAB01-\uAB06\uAB09-\uAB0E\uAB11-\uAB16\uAB20-\uAB26\uAB28-\uAB2E\uAB30-\uAB5A\uAB5C-\uAB65\uAB70-\uABEA\uABEC\uABED\uABF0-\uABF9\uAC00-\uD7A3\uD7B0-\uD7C6\uD7CB-\uD7FB\uF900-\uFA6D\uFA70-\uFAD9\uFB00-\uFB06\uFB13-\uFB17\uFB1D-\uFB28\uFB2A-\uFB36\uFB38-\uFB3C\uFB3E\uFB40\uFB41\uFB43\uFB44\uFB46-\uFBB1\uFBD3-\uFD3D\uFD50-\uFD8F\uFD92-\uFDC7\uFDF0-\uFDFB\uFE00-\uFE0F\uFE20-\uFE2F\uFE33\uFE34\uFE4D-\uFE4F\uFE70-\uFE74\uFE76-\uFEFC\uFF10-\uFF19\uFF21-\uFF3A\uFF3F\uFF41-\uFF5A\uFF66-\uFFBE\uFFC2-\uFFC7\uFFCA-\uFFCF\uFFD2-\uFFD7\uFFDA-\uFFDC]|\uD800[\uDC00-\uDC0B\uDC0D-\uDC26\uDC28-\uDC3A\uDC3C\uDC3D\uDC3F-\uDC4D\uDC50-\uDC5D\uDC80-\uDCFA\uDD40-\uDD74\uDDFD\uDE80-\uDE9C\uDEA0-\uDED0\uDEE0\uDF00-\uDF1F\uDF30-\uDF4A\uDF50-\uDF7A\uDF80-\uDF9D\uDFA0-\uDFC3\uDFC8-\uDFCF\uDFD1-\uDFD5]|\uD801[\uDC00-\uDC9D\uDCA0-\uDCA9\uDCB0-\uDCD3\uDCD8-\uDCFB\uDD00-\uDD27\uDD30-\uDD63\uDE00-\uDF36\uDF40-\uDF55\uDF60-\uDF67]|\uD802[\uDC00-\uDC05\uDC08\uDC0A-\uDC35\uDC37\uDC38\uDC3C\uDC3F-\uDC55\uDC60-\uDC76\uDC80-\uDC9E\uDCE0-\uDCF2\uDCF4\uDCF5\uDD00-\uDD15\uDD20-\uDD39\uDD80-\uDDB7\uDDBE\uDDBF\uDE00-\uDE03\uDE05\uDE06\uDE0C-\uDE13\uDE15-\uDE17\uDE19-\uDE33\uDE38-\uDE3A\uDE3F\uDE60-\uDE7C\uDE80-\uDE9C\uDEC0-\uDEC7\uDEC9-\uDEE6\uDF00-\uDF35\uDF40-\uDF55\uDF60-\uDF72\uDF80-\uDF91]|\uD803[\uDC00-\uDC48\uDC80-\uDCB2\uDCC0-\uDCF2]|\uD804[\uDC00-\uDC46\uDC66-\uDC6F\uDC7F-\uDCBA\uDCD0-\uDCE8\uDCF0-\uDCF9\uDD00-\uDD34\uDD36-\uDD3F\uDD50-\uDD73\uDD76\uDD80-\uDDC4\uDDCA-\uDDCC\uDDD0-\uDDDA\uDDDC\uDE00-\uDE11\uDE13-\uDE37\uDE3E\uDE80-\uDE86\uDE88\uDE8A-\uDE8D\uDE8F-\uDE9D\uDE9F-\uDEA8\uDEB0-\uDEEA\uDEF0-\uDEF9\uDF00-\uDF03\uDF05-\uDF0C\uDF0F\uDF10\uDF13-\uDF28\uDF2A-\uDF30\uDF32\uDF33\uDF35-\uDF39\uDF3C-\uDF44\uDF47\uDF48\uDF4B-\uDF4D\uDF50\uDF57\uDF5D-\uDF63\uDF66-\uDF6C\uDF70-\uDF74]|\uD805[\uDC00-\uDC4A\uDC50-\uDC59\uDC80-\uDCC5\uDCC7\uDCD0-\uDCD9\uDD80-\uDDB5\uDDB8-\uDDC0\uDDD8-\uDDDD\uDE00-\uDE40\uDE44\uDE50-\uDE59\uDE80-\uDEB7\uDEC0-\uDEC9\uDF00-\uDF19\uDF1D-\uDF2B\uDF30-\uDF39]|\uD806[\uDCA0-\uDCE9\uDCFF\uDEC0-\uDEF8]|\uD807[\uDC00-\uDC08\uDC0A-\uDC36\uDC38-\uDC40\uDC50-\uDC59\uDC72-\uDC8F\uDC92-\uDCA7\uDCA9-\uDCB6]|\uD808[\uDC00-\uDF99]|\uD809[\uDC00-\uDC6E\uDC80-\uDD43]|[\uD80C\uD81C-\uD820\uD840-\uD868\uD86A-\uD86C\uD86F-\uD872][\uDC00-\uDFFF]|\uD80D[\uDC00-\uDC2E]|\uD811[\uDC00-\uDE46]|\uD81A[\uDC00-\uDE38\uDE40-\uDE5E\uDE60-\uDE69\uDED0-\uDEED\uDEF0-\uDEF4\uDF00-\uDF36\uDF40-\uDF43\uDF50-\uDF59\uDF63-\uDF77\uDF7D-\uDF8F]|\uD81B[\uDF00-\uDF44\uDF50-\uDF7E\uDF8F-\uDF9F\uDFE0]|\uD821[\uDC00-\uDFEC]|\uD822[\uDC00-\uDEF2]|\uD82C[\uDC00\uDC01]|\uD82F[\uDC00-\uDC6A\uDC70-\uDC7C\uDC80-\uDC88\uDC90-\uDC99\uDC9D\uDC9E]|\uD834[\uDD65-\uDD69\uDD6D-\uDD72\uDD7B-\uDD82\uDD85-\uDD8B\uDDAA-\uDDAD\uDE42-\uDE44]|\uD835[\uDC00-\uDC54\uDC56-\uDC9C\uDC9E\uDC9F\uDCA2\uDCA5\uDCA6\uDCA9-\uDCAC\uDCAE-\uDCB9\uDCBB\uDCBD-\uDCC3\uDCC5-\uDD05\uDD07-\uDD0A\uDD0D-\uDD14\uDD16-\uDD1C\uDD1E-\uDD39\uDD3B-\uDD3E\uDD40-\uDD44\uDD46\uDD4A-\uDD50\uDD52-\uDEA5\uDEA8-\uDEC0\uDEC2-\uDEDA\uDEDC-\uDEFA\uDEFC-\uDF14\uDF16-\uDF34\uDF36-\uDF4E\uDF50-\uDF6E\uDF70-\uDF88\uDF8A-\uDFA8\uDFAA-\uDFC2\uDFC4-\uDFCB\uDFCE-\uDFFF]|\uD836[\uDE00-\uDE36\uDE3B-\uDE6C\uDE75\uDE84\uDE9B-\uDE9F\uDEA1-\uDEAF]|\uD838[\uDC00-\uDC06\uDC08-\uDC18\uDC1B-\uDC21\uDC23\uDC24\uDC26-\uDC2A]|\uD83A[\uDC00-\uDCC4\uDCD0-\uDCD6\uDD00-\uDD4A\uDD50-\uDD59]|\uD83B[\uDE00-\uDE03\uDE05-\uDE1F\uDE21\uDE22\uDE24\uDE27\uDE29-\uDE32\uDE34-\uDE37\uDE39\uDE3B\uDE42\uDE47\uDE49\uDE4B\uDE4D-\uDE4F\uDE51\uDE52\uDE54\uDE57\uDE59\uDE5B\uDE5D\uDE5F\uDE61\uDE62\uDE64\uDE67-\uDE6A\uDE6C-\uDE72\uDE74-\uDE77\uDE79-\uDE7C\uDE7E\uDE80-\uDE89\uDE8B-\uDE9B\uDEA1-\uDEA3\uDEA5-\uDEA9\uDEAB-\uDEBB]|\uD869[\uDC00-\uDED6\uDF00-\uDFFF]|\uD86D[\uDC00-\uDF34\uDF40-\uDFFF]|\uD86E[\uDC00-\uDC1D\uDC20-\uDFFF]|\uD873[\uDC00-\uDEA1]|\uD87E[\uDC00-\uDE1D]|\uDB40[\uDD00-\uDDEF]/
    };
    function isDecimalDigit2(ch2) {
      return 48 <= ch2 && ch2 <= 57;
    }
    function isHexDigit2(ch2) {
      return 48 <= ch2 && ch2 <= 57 || 97 <= ch2 && ch2 <= 102 || 65 <= ch2 && ch2 <= 70;
    }
    function isOctalDigit2(ch2) {
      return ch2 >= 48 && ch2 <= 55;
    }
    NON_ASCII_WHITESPACES = [
      5760,
      8192,
      8193,
      8194,
      8195,
      8196,
      8197,
      8198,
      8199,
      8200,
      8201,
      8202,
      8239,
      8287,
      12288,
      65279
    ];
    function isWhiteSpace(ch2) {
      return ch2 === 32 || ch2 === 9 || ch2 === 11 || ch2 === 12 || ch2 === 160 || ch2 >= 5760 && NON_ASCII_WHITESPACES.indexOf(ch2) >= 0;
    }
    function isLineTerminator(ch2) {
      return ch2 === 10 || ch2 === 13 || ch2 === 8232 || ch2 === 8233;
    }
    function fromCodePoint(cp) {
      if (cp <= 65535) {
        return String.fromCharCode(cp);
      }
      var cu1 = String.fromCharCode(Math.floor((cp - 65536) / 1024) + 55296);
      var cu2 = String.fromCharCode((cp - 65536) % 1024 + 56320);
      return cu1 + cu2;
    }
    IDENTIFIER_START = new Array(128);
    for (ch = 0;ch < 128; ++ch) {
      IDENTIFIER_START[ch] = ch >= 97 && ch <= 122 || ch >= 65 && ch <= 90 || ch === 36 || ch === 95;
    }
    IDENTIFIER_PART = new Array(128);
    for (ch = 0;ch < 128; ++ch) {
      IDENTIFIER_PART[ch] = ch >= 97 && ch <= 122 || ch >= 65 && ch <= 90 || ch >= 48 && ch <= 57 || ch === 36 || ch === 95;
    }
    function isIdentifierStartES5(ch2) {
      return ch2 < 128 ? IDENTIFIER_START[ch2] : ES5Regex.NonAsciiIdentifierStart.test(fromCodePoint(ch2));
    }
    function isIdentifierPartES5(ch2) {
      return ch2 < 128 ? IDENTIFIER_PART[ch2] : ES5Regex.NonAsciiIdentifierPart.test(fromCodePoint(ch2));
    }
    function isIdentifierStartES6(ch2) {
      return ch2 < 128 ? IDENTIFIER_START[ch2] : ES6Regex.NonAsciiIdentifierStart.test(fromCodePoint(ch2));
    }
    function isIdentifierPartES6(ch2) {
      return ch2 < 128 ? IDENTIFIER_PART[ch2] : ES6Regex.NonAsciiIdentifierPart.test(fromCodePoint(ch2));
    }
    module.exports = {
      isDecimalDigit: isDecimalDigit2,
      isHexDigit: isHexDigit2,
      isOctalDigit: isOctalDigit2,
      isWhiteSpace,
      isLineTerminator,
      isIdentifierStartES5,
      isIdentifierPartES5,
      isIdentifierStartES6,
      isIdentifierPartES6
    };
  })();
});

// node_modules/esutils/lib/keyword.js
var require_keyword = __commonJS((exports, module) => {
  (function() {
    var code = require_code();
    function isStrictModeReservedWordES6(id) {
      switch (id) {
        case "implements":
        case "interface":
        case "package":
        case "private":
        case "protected":
        case "public":
        case "static":
        case "let":
          return true;
        default:
          return false;
      }
    }
    function isKeywordES5(id, strict) {
      if (!strict && id === "yield") {
        return false;
      }
      return isKeywordES6(id, strict);
    }
    function isKeywordES6(id, strict) {
      if (strict && isStrictModeReservedWordES6(id)) {
        return true;
      }
      switch (id.length) {
        case 2:
          return id === "if" || id === "in" || id === "do";
        case 3:
          return id === "var" || id === "for" || id === "new" || id === "try";
        case 4:
          return id === "this" || id === "else" || id === "case" || id === "void" || id === "with" || id === "enum";
        case 5:
          return id === "while" || id === "break" || id === "catch" || id === "throw" || id === "const" || id === "yield" || id === "class" || id === "super";
        case 6:
          return id === "return" || id === "typeof" || id === "delete" || id === "switch" || id === "export" || id === "import";
        case 7:
          return id === "default" || id === "finally" || id === "extends";
        case 8:
          return id === "function" || id === "continue" || id === "debugger";
        case 10:
          return id === "instanceof";
        default:
          return false;
      }
    }
    function isReservedWordES5(id, strict) {
      return id === "null" || id === "true" || id === "false" || isKeywordES5(id, strict);
    }
    function isReservedWordES6(id, strict) {
      return id === "null" || id === "true" || id === "false" || isKeywordES6(id, strict);
    }
    function isRestrictedWord(id) {
      return id === "eval" || id === "arguments";
    }
    function isIdentifierNameES5(id) {
      var i2, iz, ch;
      if (id.length === 0) {
        return false;
      }
      ch = id.charCodeAt(0);
      if (!code.isIdentifierStartES5(ch)) {
        return false;
      }
      for (i2 = 1, iz = id.length;i2 < iz; ++i2) {
        ch = id.charCodeAt(i2);
        if (!code.isIdentifierPartES5(ch)) {
          return false;
        }
      }
      return true;
    }
    function decodeUtf16(lead, trail) {
      return (lead - 55296) * 1024 + (trail - 56320) + 65536;
    }
    function isIdentifierNameES6(id) {
      var i2, iz, ch, lowCh, check2;
      if (id.length === 0) {
        return false;
      }
      check2 = code.isIdentifierStartES6;
      for (i2 = 0, iz = id.length;i2 < iz; ++i2) {
        ch = id.charCodeAt(i2);
        if (55296 <= ch && ch <= 56319) {
          ++i2;
          if (i2 >= iz) {
            return false;
          }
          lowCh = id.charCodeAt(i2);
          if (!(56320 <= lowCh && lowCh <= 57343)) {
            return false;
          }
          ch = decodeUtf16(ch, lowCh);
        }
        if (!check2(ch)) {
          return false;
        }
        check2 = code.isIdentifierPartES6;
      }
      return true;
    }
    function isIdentifierES5(id, strict) {
      return isIdentifierNameES5(id) && !isReservedWordES5(id, strict);
    }
    function isIdentifierES6(id, strict) {
      return isIdentifierNameES6(id) && !isReservedWordES6(id, strict);
    }
    module.exports = {
      isKeywordES5,
      isKeywordES6,
      isReservedWordES5,
      isReservedWordES6,
      isRestrictedWord,
      isIdentifierNameES5,
      isIdentifierNameES6,
      isIdentifierES5,
      isIdentifierES6
    };
  })();
});

// node_modules/esutils/lib/utils.js
var require_utils = __commonJS((exports) => {
  (function() {
    exports.ast = require_ast();
    exports.code = require_code();
    exports.keyword = require_keyword();
  })();
});

// node_modules/source-map/lib/base64.js
var require_base64 = __commonJS((exports) => {
  var intToCharMap = "ABCDEFGHIJKLMNOPQRSTUVWXYZabcdefghijklmnopqrstuvwxyz0123456789+/".split("");
  exports.encode = function(number4) {
    if (0 <= number4 && number4 < intToCharMap.length) {
      return intToCharMap[number4];
    }
    throw new TypeError("Must be between 0 and 63: " + number4);
  };
  exports.decode = function(charCode) {
    var bigA = 65;
    var bigZ = 90;
    var littleA = 97;
    var littleZ = 122;
    var zero2 = 48;
    var nine = 57;
    var plus = 43;
    var slash = 47;
    var littleOffset = 26;
    var numberOffset = 52;
    if (bigA <= charCode && charCode <= bigZ) {
      return charCode - bigA;
    }
    if (littleA <= charCode && charCode <= littleZ) {
      return charCode - littleA + littleOffset;
    }
    if (zero2 <= charCode && charCode <= nine) {
      return charCode - zero2 + numberOffset;
    }
    if (charCode == plus) {
      return 62;
    }
    if (charCode == slash) {
      return 63;
    }
    return -1;
  };
});

// node_modules/source-map/lib/base64-vlq.js
var require_base64_vlq = __commonJS((exports) => {
  var base643 = require_base64();
  var VLQ_BASE_SHIFT = 5;
  var VLQ_BASE = 1 << VLQ_BASE_SHIFT;
  var VLQ_BASE_MASK = VLQ_BASE - 1;
  var VLQ_CONTINUATION_BIT = VLQ_BASE;
  function toVLQSigned(aValue) {
    return aValue < 0 ? (-aValue << 1) + 1 : (aValue << 1) + 0;
  }
  function fromVLQSigned(aValue) {
    var isNegative = (aValue & 1) === 1;
    var shifted = aValue >> 1;
    return isNegative ? -shifted : shifted;
  }
  exports.encode = function base64VLQ_encode(aValue) {
    var encoded = "";
    var digit;
    var vlq = toVLQSigned(aValue);
    do {
      digit = vlq & VLQ_BASE_MASK;
      vlq >>>= VLQ_BASE_SHIFT;
      if (vlq > 0) {
        digit |= VLQ_CONTINUATION_BIT;
      }
      encoded += base643.encode(digit);
    } while (vlq > 0);
    return encoded;
  };
  exports.decode = function base64VLQ_decode(aStr, aIndex, aOutParam) {
    var strLen = aStr.length;
    var result = 0;
    var shift = 0;
    var continuation, digit;
    do {
      if (aIndex >= strLen) {
        throw new Error("Expected more digits in base 64 VLQ value.");
      }
      digit = base643.decode(aStr.charCodeAt(aIndex++));
      if (digit === -1) {
        throw new Error("Invalid base64 digit: " + aStr.charAt(aIndex - 1));
      }
      continuation = !!(digit & VLQ_CONTINUATION_BIT);
      digit &= VLQ_BASE_MASK;
      result = result + (digit << shift);
      shift += VLQ_BASE_SHIFT;
    } while (continuation);
    aOutParam.value = fromVLQSigned(result);
    aOutParam.rest = aIndex;
  };
});

// node_modules/source-map/lib/util.js
var require_util = __commonJS((exports) => {
  function getArg(aArgs, aName, aDefaultValue) {
    if (aName in aArgs) {
      return aArgs[aName];
    } else if (arguments.length === 3) {
      return aDefaultValue;
    } else {
      throw new Error('"' + aName + '" is a required argument.');
    }
  }
  exports.getArg = getArg;
  var urlRegexp = /^(?:([\w+\-.]+):)?\/\/(?:(\w+:\w+)@)?([\w.-]*)(?::(\d+))?(.*)$/;
  var dataUrlRegexp = /^data:.+\,.+$/;
  function urlParse(aUrl) {
    var match = aUrl.match(urlRegexp);
    if (!match) {
      return null;
    }
    return {
      scheme: match[1],
      auth: match[2],
      host: match[3],
      port: match[4],
      path: match[5]
    };
  }
  exports.urlParse = urlParse;
  function urlGenerate(aParsedUrl) {
    var url2 = "";
    if (aParsedUrl.scheme) {
      url2 += aParsedUrl.scheme + ":";
    }
    url2 += "//";
    if (aParsedUrl.auth) {
      url2 += aParsedUrl.auth + "@";
    }
    if (aParsedUrl.host) {
      url2 += aParsedUrl.host;
    }
    if (aParsedUrl.port) {
      url2 += ":" + aParsedUrl.port;
    }
    if (aParsedUrl.path) {
      url2 += aParsedUrl.path;
    }
    return url2;
  }
  exports.urlGenerate = urlGenerate;
  function normalize(aPath) {
    var path2 = aPath;
    var url2 = urlParse(aPath);
    if (url2) {
      if (!url2.path) {
        return aPath;
      }
      path2 = url2.path;
    }
    var isAbsolute = exports.isAbsolute(path2);
    var parts = path2.split(/\/+/);
    for (var part, up = 0, i2 = parts.length - 1;i2 >= 0; i2--) {
      part = parts[i2];
      if (part === ".") {
        parts.splice(i2, 1);
      } else if (part === "..") {
        up++;
      } else if (up > 0) {
        if (part === "") {
          parts.splice(i2 + 1, up);
          up = 0;
        } else {
          parts.splice(i2, 2);
          up--;
        }
      }
    }
    path2 = parts.join("/");
    if (path2 === "") {
      path2 = isAbsolute ? "/" : ".";
    }
    if (url2) {
      url2.path = path2;
      return urlGenerate(url2);
    }
    return path2;
  }
  exports.normalize = normalize;
  function join(aRoot, aPath) {
    if (aRoot === "") {
      aRoot = ".";
    }
    if (aPath === "") {
      aPath = ".";
    }
    var aPathUrl = urlParse(aPath);
    var aRootUrl = urlParse(aRoot);
    if (aRootUrl) {
      aRoot = aRootUrl.path || "/";
    }
    if (aPathUrl && !aPathUrl.scheme) {
      if (aRootUrl) {
        aPathUrl.scheme = aRootUrl.scheme;
      }
      return urlGenerate(aPathUrl);
    }
    if (aPathUrl || aPath.match(dataUrlRegexp)) {
      return aPath;
    }
    if (aRootUrl && !aRootUrl.host && !aRootUrl.path) {
      aRootUrl.host = aPath;
      return urlGenerate(aRootUrl);
    }
    var joined = aPath.charAt(0) === "/" ? aPath : normalize(aRoot.replace(/\/+$/, "") + "/" + aPath);
    if (aRootUrl) {
      aRootUrl.path = joined;
      return urlGenerate(aRootUrl);
    }
    return joined;
  }
  exports.join = join;
  exports.isAbsolute = function(aPath) {
    return aPath.charAt(0) === "/" || urlRegexp.test(aPath);
  };
  function relative(aRoot, aPath) {
    if (aRoot === "") {
      aRoot = ".";
    }
    aRoot = aRoot.replace(/\/$/, "");
    var level = 0;
    while (aPath.indexOf(aRoot + "/") !== 0) {
      var index = aRoot.lastIndexOf("/");
      if (index < 0) {
        return aPath;
      }
      aRoot = aRoot.slice(0, index);
      if (aRoot.match(/^([^\/]+:\/)?\/*$/)) {
        return aPath;
      }
      ++level;
    }
    return Array(level + 1).join("../") + aPath.substr(aRoot.length + 1);
  }
  exports.relative = relative;
  var supportsNullProto = function() {
    var obj = Object.create(null);
    return !("__proto__" in obj);
  }();
  function identity(s) {
    return s;
  }
  function toSetString(aStr) {
    if (isProtoString(aStr)) {
      return "$" + aStr;
    }
    return aStr;
  }
  exports.toSetString = supportsNullProto ? identity : toSetString;
  function fromSetString(aStr) {
    if (isProtoString(aStr)) {
      return aStr.slice(1);
    }
    return aStr;
  }
  exports.fromSetString = supportsNullProto ? identity : fromSetString;
  function isProtoString(s) {
    if (!s) {
      return false;
    }
    var length = s.length;
    if (length < 9) {
      return false;
    }
    if (s.charCodeAt(length - 1) !== 95 || s.charCodeAt(length - 2) !== 95 || s.charCodeAt(length - 3) !== 111 || s.charCodeAt(length - 4) !== 116 || s.charCodeAt(length - 5) !== 111 || s.charCodeAt(length - 6) !== 114 || s.charCodeAt(length - 7) !== 112 || s.charCodeAt(length - 8) !== 95 || s.charCodeAt(length - 9) !== 95) {
      return false;
    }
    for (var i2 = length - 10;i2 >= 0; i2--) {
      if (s.charCodeAt(i2) !== 36) {
        return false;
      }
    }
    return true;
  }
  function compareByOriginalPositions(mappingA, mappingB, onlyCompareOriginal) {
    var cmp = strcmp(mappingA.source, mappingB.source);
    if (cmp !== 0) {
      return cmp;
    }
    cmp = mappingA.originalLine - mappingB.originalLine;
    if (cmp !== 0) {
      return cmp;
    }
    cmp = mappingA.originalColumn - mappingB.originalColumn;
    if (cmp !== 0 || onlyCompareOriginal) {
      return cmp;
    }
    cmp = mappingA.generatedColumn - mappingB.generatedColumn;
    if (cmp !== 0) {
      return cmp;
    }
    cmp = mappingA.generatedLine - mappingB.generatedLine;
    if (cmp !== 0) {
      return cmp;
    }
    return strcmp(mappingA.name, mappingB.name);
  }
  exports.compareByOriginalPositions = compareByOriginalPositions;
  function compareByGeneratedPositionsDeflated(mappingA, mappingB, onlyCompareGenerated) {
    var cmp = mappingA.generatedLine - mappingB.generatedLine;
    if (cmp !== 0) {
      return cmp;
    }
    cmp = mappingA.generatedColumn - mappingB.generatedColumn;
    if (cmp !== 0 || onlyCompareGenerated) {
      return cmp;
    }
    cmp = strcmp(mappingA.source, mappingB.source);
    if (cmp !== 0) {
      return cmp;
    }
    cmp = mappingA.originalLine - mappingB.originalLine;
    if (cmp !== 0) {
      return cmp;
    }
    cmp = mappingA.originalColumn - mappingB.originalColumn;
    if (cmp !== 0) {
      return cmp;
    }
    return strcmp(mappingA.name, mappingB.name);
  }
  exports.compareByGeneratedPositionsDeflated = compareByGeneratedPositionsDeflated;
  function strcmp(aStr1, aStr2) {
    if (aStr1 === aStr2) {
      return 0;
    }
    if (aStr1 === null) {
      return 1;
    }
    if (aStr2 === null) {
      return -1;
    }
    if (aStr1 > aStr2) {
      return 1;
    }
    return -1;
  }
  function compareByGeneratedPositionsInflated(mappingA, mappingB) {
    var cmp = mappingA.generatedLine - mappingB.generatedLine;
    if (cmp !== 0) {
      return cmp;
    }
    cmp = mappingA.generatedColumn - mappingB.generatedColumn;
    if (cmp !== 0) {
      return cmp;
    }
    cmp = strcmp(mappingA.source, mappingB.source);
    if (cmp !== 0) {
      return cmp;
    }
    cmp = mappingA.originalLine - mappingB.originalLine;
    if (cmp !== 0) {
      return cmp;
    }
    cmp = mappingA.originalColumn - mappingB.originalColumn;
    if (cmp !== 0) {
      return cmp;
    }
    return strcmp(mappingA.name, mappingB.name);
  }
  exports.compareByGeneratedPositionsInflated = compareByGeneratedPositionsInflated;
  function parseSourceMapInput(str) {
    return JSON.parse(str.replace(/^\)]}'[^\n]*\n/, ""));
  }
  exports.parseSourceMapInput = parseSourceMapInput;
  function computeSourceURL(sourceRoot, sourceURL, sourceMapURL) {
    sourceURL = sourceURL || "";
    if (sourceRoot) {
      if (sourceRoot[sourceRoot.length - 1] !== "/" && sourceURL[0] !== "/") {
        sourceRoot += "/";
      }
      sourceURL = sourceRoot + sourceURL;
    }
    if (sourceMapURL) {
      var parsed = urlParse(sourceMapURL);
      if (!parsed) {
        throw new Error("sourceMapURL could not be parsed");
      }
      if (parsed.path) {
        var index = parsed.path.lastIndexOf("/");
        if (index >= 0) {
          parsed.path = parsed.path.substring(0, index + 1);
        }
      }
      sourceURL = join(urlGenerate(parsed), sourceURL);
    }
    return normalize(sourceURL);
  }
  exports.computeSourceURL = computeSourceURL;
});

// node_modules/source-map/lib/array-set.js
var require_array_set = __commonJS((exports) => {
  var util = require_util();
  var has = Object.prototype.hasOwnProperty;
  var hasNativeMap = typeof Map !== "undefined";
  function ArraySet() {
    this._array = [];
    this._set = hasNativeMap ? new Map : Object.create(null);
  }
  ArraySet.fromArray = function ArraySet_fromArray(aArray, aAllowDuplicates) {
    var set3 = new ArraySet;
    for (var i2 = 0, len = aArray.length;i2 < len; i2++) {
      set3.add(aArray[i2], aAllowDuplicates);
    }
    return set3;
  };
  ArraySet.prototype.size = function ArraySet_size() {
    return hasNativeMap ? this._set.size : Object.getOwnPropertyNames(this._set).length;
  };
  ArraySet.prototype.add = function ArraySet_add(aStr, aAllowDuplicates) {
    var sStr = hasNativeMap ? aStr : util.toSetString(aStr);
    var isDuplicate = hasNativeMap ? this.has(aStr) : has.call(this._set, sStr);
    var idx = this._array.length;
    if (!isDuplicate || aAllowDuplicates) {
      this._array.push(aStr);
    }
    if (!isDuplicate) {
      if (hasNativeMap) {
        this._set.set(aStr, idx);
      } else {
        this._set[sStr] = idx;
      }
    }
  };
  ArraySet.prototype.has = function ArraySet_has(aStr) {
    if (hasNativeMap) {
      return this._set.has(aStr);
    } else {
      var sStr = util.toSetString(aStr);
      return has.call(this._set, sStr);
    }
  };
  ArraySet.prototype.indexOf = function ArraySet_indexOf(aStr) {
    if (hasNativeMap) {
      var idx = this._set.get(aStr);
      if (idx >= 0) {
        return idx;
      }
    } else {
      var sStr = util.toSetString(aStr);
      if (has.call(this._set, sStr)) {
        return this._set[sStr];
      }
    }
    throw new Error('"' + aStr + '" is not in the set.');
  };
  ArraySet.prototype.at = function ArraySet_at(aIdx) {
    if (aIdx >= 0 && aIdx < this._array.length) {
      return this._array[aIdx];
    }
    throw new Error("No element indexed by " + aIdx);
  };
  ArraySet.prototype.toArray = function ArraySet_toArray() {
    return this._array.slice();
  };
  exports.ArraySet = ArraySet;
});

// node_modules/source-map/lib/mapping-list.js
var require_mapping_list = __commonJS((exports) => {
  var util = require_util();
  function generatedPositionAfter(mappingA, mappingB) {
    var lineA = mappingA.generatedLine;
    var lineB = mappingB.generatedLine;
    var columnA = mappingA.generatedColumn;
    var columnB = mappingB.generatedColumn;
    return lineB > lineA || lineB == lineA && columnB >= columnA || util.compareByGeneratedPositionsInflated(mappingA, mappingB) <= 0;
  }
  function MappingList() {
    this._array = [];
    this._sorted = true;
    this._last = { generatedLine: -1, generatedColumn: 0 };
  }
  MappingList.prototype.unsortedForEach = function MappingList_forEach(aCallback, aThisArg) {
    this._array.forEach(aCallback, aThisArg);
  };
  MappingList.prototype.add = function MappingList_add(aMapping) {
    if (generatedPositionAfter(this._last, aMapping)) {
      this._last = aMapping;
      this._array.push(aMapping);
    } else {
      this._sorted = false;
      this._array.push(aMapping);
    }
  };
  MappingList.prototype.toArray = function MappingList_toArray() {
    if (!this._sorted) {
      this._array.sort(util.compareByGeneratedPositionsInflated);
      this._sorted = true;
    }
    return this._array;
  };
  exports.MappingList = MappingList;
});

// node_modules/source-map/lib/source-map-generator.js
var require_source_map_generator = __commonJS((exports) => {
  var base64VLQ = require_base64_vlq();
  var util = require_util();
  var ArraySet = require_array_set().ArraySet;
  var MappingList = require_mapping_list().MappingList;
  function SourceMapGenerator(aArgs) {
    if (!aArgs) {
      aArgs = {};
    }
    this._file = util.getArg(aArgs, "file", null);
    this._sourceRoot = util.getArg(aArgs, "sourceRoot", null);
    this._skipValidation = util.getArg(aArgs, "skipValidation", false);
    this._sources = new ArraySet;
    this._names = new ArraySet;
    this._mappings = new MappingList;
    this._sourcesContents = null;
  }
  SourceMapGenerator.prototype._version = 3;
  SourceMapGenerator.fromSourceMap = function SourceMapGenerator_fromSourceMap(aSourceMapConsumer) {
    var sourceRoot = aSourceMapConsumer.sourceRoot;
    var generator = new SourceMapGenerator({
      file: aSourceMapConsumer.file,
      sourceRoot
    });
    aSourceMapConsumer.eachMapping(function(mapping) {
      var newMapping = {
        generated: {
          line: mapping.generatedLine,
          column: mapping.generatedColumn
        }
      };
      if (mapping.source != null) {
        newMapping.source = mapping.source;
        if (sourceRoot != null) {
          newMapping.source = util.relative(sourceRoot, newMapping.source);
        }
        newMapping.original = {
          line: mapping.originalLine,
          column: mapping.originalColumn
        };
        if (mapping.name != null) {
          newMapping.name = mapping.name;
        }
      }
      generator.addMapping(newMapping);
    });
    aSourceMapConsumer.sources.forEach(function(sourceFile) {
      var sourceRelative = sourceFile;
      if (sourceRoot !== null) {
        sourceRelative = util.relative(sourceRoot, sourceFile);
      }
      if (!generator._sources.has(sourceRelative)) {
        generator._sources.add(sourceRelative);
      }
      var content = aSourceMapConsumer.sourceContentFor(sourceFile);
      if (content != null) {
        generator.setSourceContent(sourceFile, content);
      }
    });
    return generator;
  };
  SourceMapGenerator.prototype.addMapping = function SourceMapGenerator_addMapping(aArgs) {
    var generated = util.getArg(aArgs, "generated");
    var original = util.getArg(aArgs, "original", null);
    var source = util.getArg(aArgs, "source", null);
    var name = util.getArg(aArgs, "name", null);
    if (!this._skipValidation) {
      this._validateMapping(generated, original, source, name);
    }
    if (source != null) {
      source = String(source);
      if (!this._sources.has(source)) {
        this._sources.add(source);
      }
    }
    if (name != null) {
      name = String(name);
      if (!this._names.has(name)) {
        this._names.add(name);
      }
    }
    this._mappings.add({
      generatedLine: generated.line,
      generatedColumn: generated.column,
      originalLine: original != null && original.line,
      originalColumn: original != null && original.column,
      source,
      name
    });
  };
  SourceMapGenerator.prototype.setSourceContent = function SourceMapGenerator_setSourceContent(aSourceFile, aSourceContent) {
    var source = aSourceFile;
    if (this._sourceRoot != null) {
      source = util.relative(this._sourceRoot, source);
    }
    if (aSourceContent != null) {
      if (!this._sourcesContents) {
        this._sourcesContents = Object.create(null);
      }
      this._sourcesContents[util.toSetString(source)] = aSourceContent;
    } else if (this._sourcesContents) {
      delete this._sourcesContents[util.toSetString(source)];
      if (Object.keys(this._sourcesContents).length === 0) {
        this._sourcesContents = null;
      }
    }
  };
  SourceMapGenerator.prototype.applySourceMap = function SourceMapGenerator_applySourceMap(aSourceMapConsumer, aSourceFile, aSourceMapPath) {
    var sourceFile = aSourceFile;
    if (aSourceFile == null) {
      if (aSourceMapConsumer.file == null) {
        throw new Error("SourceMapGenerator.prototype.applySourceMap requires either an explicit source file, " + `or the source map's "file" property. Both were omitted.`);
      }
      sourceFile = aSourceMapConsumer.file;
    }
    var sourceRoot = this._sourceRoot;
    if (sourceRoot != null) {
      sourceFile = util.relative(sourceRoot, sourceFile);
    }
    var newSources = new ArraySet;
    var newNames = new ArraySet;
    this._mappings.unsortedForEach(function(mapping) {
      if (mapping.source === sourceFile && mapping.originalLine != null) {
        var original = aSourceMapConsumer.originalPositionFor({
          line: mapping.originalLine,
          column: mapping.originalColumn
        });
        if (original.source != null) {
          mapping.source = original.source;
          if (aSourceMapPath != null) {
            mapping.source = util.join(aSourceMapPath, mapping.source);
          }
          if (sourceRoot != null) {
            mapping.source = util.relative(sourceRoot, mapping.source);
          }
          mapping.originalLine = original.line;
          mapping.originalColumn = original.column;
          if (original.name != null) {
            mapping.name = original.name;
          }
        }
      }
      var source = mapping.source;
      if (source != null && !newSources.has(source)) {
        newSources.add(source);
      }
      var name = mapping.name;
      if (name != null && !newNames.has(name)) {
        newNames.add(name);
      }
    }, this);
    this._sources = newSources;
    this._names = newNames;
    aSourceMapConsumer.sources.forEach(function(sourceFile2) {
      var content = aSourceMapConsumer.sourceContentFor(sourceFile2);
      if (content != null) {
        if (aSourceMapPath != null) {
          sourceFile2 = util.join(aSourceMapPath, sourceFile2);
        }
        if (sourceRoot != null) {
          sourceFile2 = util.relative(sourceRoot, sourceFile2);
        }
        this.setSourceContent(sourceFile2, content);
      }
    }, this);
  };
  SourceMapGenerator.prototype._validateMapping = function SourceMapGenerator_validateMapping(aGenerated, aOriginal, aSource, aName) {
    if (aOriginal && typeof aOriginal.line !== "number" && typeof aOriginal.column !== "number") {
      throw new Error("original.line and original.column are not numbers -- you probably meant to omit " + "the original mapping entirely and only map the generated position. If so, pass " + "null for the original mapping instead of an object with empty or null values.");
    }
    if (aGenerated && "line" in aGenerated && "column" in aGenerated && aGenerated.line > 0 && aGenerated.column >= 0 && !aOriginal && !aSource && !aName) {
      return;
    } else if (aGenerated && "line" in aGenerated && "column" in aGenerated && aOriginal && "line" in aOriginal && "column" in aOriginal && aGenerated.line > 0 && aGenerated.column >= 0 && aOriginal.line > 0 && aOriginal.column >= 0 && aSource) {
      return;
    } else {
      throw new Error("Invalid mapping: " + JSON.stringify({
        generated: aGenerated,
        source: aSource,
        original: aOriginal,
        name: aName
      }));
    }
  };
  SourceMapGenerator.prototype._serializeMappings = function SourceMapGenerator_serializeMappings() {
    var previousGeneratedColumn = 0;
    var previousGeneratedLine = 1;
    var previousOriginalColumn = 0;
    var previousOriginalLine = 0;
    var previousName = 0;
    var previousSource = 0;
    var result = "";
    var next;
    var mapping;
    var nameIdx;
    var sourceIdx;
    var mappings = this._mappings.toArray();
    for (var i2 = 0, len = mappings.length;i2 < len; i2++) {
      mapping = mappings[i2];
      next = "";
      if (mapping.generatedLine !== previousGeneratedLine) {
        previousGeneratedColumn = 0;
        while (mapping.generatedLine !== previousGeneratedLine) {
          next += ";";
          previousGeneratedLine++;
        }
      } else {
        if (i2 > 0) {
          if (!util.compareByGeneratedPositionsInflated(mapping, mappings[i2 - 1])) {
            continue;
          }
          next += ",";
        }
      }
      next += base64VLQ.encode(mapping.generatedColumn - previousGeneratedColumn);
      previousGeneratedColumn = mapping.generatedColumn;
      if (mapping.source != null) {
        sourceIdx = this._sources.indexOf(mapping.source);
        next += base64VLQ.encode(sourceIdx - previousSource);
        previousSource = sourceIdx;
        next += base64VLQ.encode(mapping.originalLine - 1 - previousOriginalLine);
        previousOriginalLine = mapping.originalLine - 1;
        next += base64VLQ.encode(mapping.originalColumn - previousOriginalColumn);
        previousOriginalColumn = mapping.originalColumn;
        if (mapping.name != null) {
          nameIdx = this._names.indexOf(mapping.name);
          next += base64VLQ.encode(nameIdx - previousName);
          previousName = nameIdx;
        }
      }
      result += next;
    }
    return result;
  };
  SourceMapGenerator.prototype._generateSourcesContent = function SourceMapGenerator_generateSourcesContent(aSources, aSourceRoot) {
    return aSources.map(function(source) {
      if (!this._sourcesContents) {
        return null;
      }
      if (aSourceRoot != null) {
        source = util.relative(aSourceRoot, source);
      }
      var key = util.toSetString(source);
      return Object.prototype.hasOwnProperty.call(this._sourcesContents, key) ? this._sourcesContents[key] : null;
    }, this);
  };
  SourceMapGenerator.prototype.toJSON = function SourceMapGenerator_toJSON() {
    var map3 = {
      version: this._version,
      sources: this._sources.toArray(),
      names: this._names.toArray(),
      mappings: this._serializeMappings()
    };
    if (this._file != null) {
      map3.file = this._file;
    }
    if (this._sourceRoot != null) {
      map3.sourceRoot = this._sourceRoot;
    }
    if (this._sourcesContents) {
      map3.sourcesContent = this._generateSourcesContent(map3.sources, map3.sourceRoot);
    }
    return map3;
  };
  SourceMapGenerator.prototype.toString = function SourceMapGenerator_toString() {
    return JSON.stringify(this.toJSON());
  };
  exports.SourceMapGenerator = SourceMapGenerator;
});

// node_modules/source-map/lib/binary-search.js
var require_binary_search = __commonJS((exports) => {
  exports.GREATEST_LOWER_BOUND = 1;
  exports.LEAST_UPPER_BOUND = 2;
  function recursiveSearch(aLow, aHigh, aNeedle, aHaystack, aCompare, aBias) {
    var mid = Math.floor((aHigh - aLow) / 2) + aLow;
    var cmp = aCompare(aNeedle, aHaystack[mid], true);
    if (cmp === 0) {
      return mid;
    } else if (cmp > 0) {
      if (aHigh - mid > 1) {
        return recursiveSearch(mid, aHigh, aNeedle, aHaystack, aCompare, aBias);
      }
      if (aBias == exports.LEAST_UPPER_BOUND) {
        return aHigh < aHaystack.length ? aHigh : -1;
      } else {
        return mid;
      }
    } else {
      if (mid - aLow > 1) {
        return recursiveSearch(aLow, mid, aNeedle, aHaystack, aCompare, aBias);
      }
      if (aBias == exports.LEAST_UPPER_BOUND) {
        return mid;
      } else {
        return aLow < 0 ? -1 : aLow;
      }
    }
  }
  exports.search = function search(aNeedle, aHaystack, aCompare, aBias) {
    if (aHaystack.length === 0) {
      return -1;
    }
    var index = recursiveSearch(-1, aHaystack.length, aNeedle, aHaystack, aCompare, aBias || exports.GREATEST_LOWER_BOUND);
    if (index < 0) {
      return -1;
    }
    while (index - 1 >= 0) {
      if (aCompare(aHaystack[index], aHaystack[index - 1], true) !== 0) {
        break;
      }
      --index;
    }
    return index;
  };
});

// node_modules/source-map/lib/quick-sort.js
var require_quick_sort = __commonJS((exports) => {
  function swap(ary, x, y) {
    var temp = ary[x];
    ary[x] = ary[y];
    ary[y] = temp;
  }
  function randomIntInRange(low, high) {
    return Math.round(low + Math.random() * (high - low));
  }
  function doQuickSort(ary, comparator, p2, r) {
    if (p2 < r) {
      var pivotIndex = randomIntInRange(p2, r);
      var i2 = p2 - 1;
      swap(ary, pivotIndex, r);
      var pivot = ary[r];
      for (var j = p2;j < r; j++) {
        if (comparator(ary[j], pivot) <= 0) {
          i2 += 1;
          swap(ary, i2, j);
        }
      }
      swap(ary, i2 + 1, j);
      var q = i2 + 1;
      doQuickSort(ary, comparator, p2, q - 1);
      doQuickSort(ary, comparator, q + 1, r);
    }
  }
  exports.quickSort = function(ary, comparator) {
    doQuickSort(ary, comparator, 0, ary.length - 1);
  };
});

// node_modules/source-map/lib/source-map-consumer.js
var require_source_map_consumer = __commonJS((exports) => {
  var util = require_util();
  var binarySearch = require_binary_search();
  var ArraySet = require_array_set().ArraySet;
  var base64VLQ = require_base64_vlq();
  var quickSort = require_quick_sort().quickSort;
  function SourceMapConsumer(aSourceMap, aSourceMapURL) {
    var sourceMap = aSourceMap;
    if (typeof aSourceMap === "string") {
      sourceMap = util.parseSourceMapInput(aSourceMap);
    }
    return sourceMap.sections != null ? new IndexedSourceMapConsumer(sourceMap, aSourceMapURL) : new BasicSourceMapConsumer(sourceMap, aSourceMapURL);
  }
  SourceMapConsumer.fromSourceMap = function(aSourceMap, aSourceMapURL) {
    return BasicSourceMapConsumer.fromSourceMap(aSourceMap, aSourceMapURL);
  };
  SourceMapConsumer.prototype._version = 3;
  SourceMapConsumer.prototype.__generatedMappings = null;
  Object.defineProperty(SourceMapConsumer.prototype, "_generatedMappings", {
    configurable: true,
    enumerable: true,
    get: function() {
      if (!this.__generatedMappings) {
        this._parseMappings(this._mappings, this.sourceRoot);
      }
      return this.__generatedMappings;
    }
  });
  SourceMapConsumer.prototype.__originalMappings = null;
  Object.defineProperty(SourceMapConsumer.prototype, "_originalMappings", {
    configurable: true,
    enumerable: true,
    get: function() {
      if (!this.__originalMappings) {
        this._parseMappings(this._mappings, this.sourceRoot);
      }
      return this.__originalMappings;
    }
  });
  SourceMapConsumer.prototype._charIsMappingSeparator = function SourceMapConsumer_charIsMappingSeparator(aStr, index) {
    var c = aStr.charAt(index);
    return c === ";" || c === ",";
  };
  SourceMapConsumer.prototype._parseMappings = function SourceMapConsumer_parseMappings(aStr, aSourceRoot) {
    throw new Error("Subclasses must implement _parseMappings");
  };
  SourceMapConsumer.GENERATED_ORDER = 1;
  SourceMapConsumer.ORIGINAL_ORDER = 2;
  SourceMapConsumer.GREATEST_LOWER_BOUND = 1;
  SourceMapConsumer.LEAST_UPPER_BOUND = 2;
  SourceMapConsumer.prototype.eachMapping = function SourceMapConsumer_eachMapping(aCallback, aContext, aOrder) {
    var context = aContext || null;
    var order = aOrder || SourceMapConsumer.GENERATED_ORDER;
    var mappings;
    switch (order) {
      case SourceMapConsumer.GENERATED_ORDER:
        mappings = this._generatedMappings;
        break;
      case SourceMapConsumer.ORIGINAL_ORDER:
        mappings = this._originalMappings;
        break;
      default:
        throw new Error("Unknown order of iteration.");
    }
    var sourceRoot = this.sourceRoot;
    mappings.map(function(mapping) {
      var source = mapping.source === null ? null : this._sources.at(mapping.source);
      source = util.computeSourceURL(sourceRoot, source, this._sourceMapURL);
      return {
        source,
        generatedLine: mapping.generatedLine,
        generatedColumn: mapping.generatedColumn,
        originalLine: mapping.originalLine,
        originalColumn: mapping.originalColumn,
        name: mapping.name === null ? null : this._names.at(mapping.name)
      };
    }, this).forEach(aCallback, context);
  };
  SourceMapConsumer.prototype.allGeneratedPositionsFor = function SourceMapConsumer_allGeneratedPositionsFor(aArgs) {
    var line = util.getArg(aArgs, "line");
    var needle = {
      source: util.getArg(aArgs, "source"),
      originalLine: line,
      originalColumn: util.getArg(aArgs, "column", 0)
    };
    needle.source = this._findSourceIndex(needle.source);
    if (needle.source < 0) {
      return [];
    }
    var mappings = [];
    var index = this._findMapping(needle, this._originalMappings, "originalLine", "originalColumn", util.compareByOriginalPositions, binarySearch.LEAST_UPPER_BOUND);
    if (index >= 0) {
      var mapping = this._originalMappings[index];
      if (aArgs.column === undefined) {
        var originalLine = mapping.originalLine;
        while (mapping && mapping.originalLine === originalLine) {
          mappings.push({
            line: util.getArg(mapping, "generatedLine", null),
            column: util.getArg(mapping, "generatedColumn", null),
            lastColumn: util.getArg(mapping, "lastGeneratedColumn", null)
          });
          mapping = this._originalMappings[++index];
        }
      } else {
        var originalColumn = mapping.originalColumn;
        while (mapping && mapping.originalLine === line && mapping.originalColumn == originalColumn) {
          mappings.push({
            line: util.getArg(mapping, "generatedLine", null),
            column: util.getArg(mapping, "generatedColumn", null),
            lastColumn: util.getArg(mapping, "lastGeneratedColumn", null)
          });
          mapping = this._originalMappings[++index];
        }
      }
    }
    return mappings;
  };
  exports.SourceMapConsumer = SourceMapConsumer;
  function BasicSourceMapConsumer(aSourceMap, aSourceMapURL) {
    var sourceMap = aSourceMap;
    if (typeof aSourceMap === "string") {
      sourceMap = util.parseSourceMapInput(aSourceMap);
    }
    var version3 = util.getArg(sourceMap, "version");
    var sources = util.getArg(sourceMap, "sources");
    var names = util.getArg(sourceMap, "names", []);
    var sourceRoot = util.getArg(sourceMap, "sourceRoot", null);
    var sourcesContent = util.getArg(sourceMap, "sourcesContent", null);
    var mappings = util.getArg(sourceMap, "mappings");
    var file3 = util.getArg(sourceMap, "file", null);
    if (version3 != this._version) {
      throw new Error("Unsupported version: " + version3);
    }
    if (sourceRoot) {
      sourceRoot = util.normalize(sourceRoot);
    }
    sources = sources.map(String).map(util.normalize).map(function(source) {
      return sourceRoot && util.isAbsolute(sourceRoot) && util.isAbsolute(source) ? util.relative(sourceRoot, source) : source;
    });
    this._names = ArraySet.fromArray(names.map(String), true);
    this._sources = ArraySet.fromArray(sources, true);
    this._absoluteSources = this._sources.toArray().map(function(s) {
      return util.computeSourceURL(sourceRoot, s, aSourceMapURL);
    });
    this.sourceRoot = sourceRoot;
    this.sourcesContent = sourcesContent;
    this._mappings = mappings;
    this._sourceMapURL = aSourceMapURL;
    this.file = file3;
  }
  BasicSourceMapConsumer.prototype = Object.create(SourceMapConsumer.prototype);
  BasicSourceMapConsumer.prototype.consumer = SourceMapConsumer;
  BasicSourceMapConsumer.prototype._findSourceIndex = function(aSource) {
    var relativeSource = aSource;
    if (this.sourceRoot != null) {
      relativeSource = util.relative(this.sourceRoot, relativeSource);
    }
    if (this._sources.has(relativeSource)) {
      return this._sources.indexOf(relativeSource);
    }
    var i2;
    for (i2 = 0;i2 < this._absoluteSources.length; ++i2) {
      if (this._absoluteSources[i2] == aSource) {
        return i2;
      }
    }
    return -1;
  };
  BasicSourceMapConsumer.fromSourceMap = function SourceMapConsumer_fromSourceMap(aSourceMap, aSourceMapURL) {
    var smc = Object.create(BasicSourceMapConsumer.prototype);
    var names = smc._names = ArraySet.fromArray(aSourceMap._names.toArray(), true);
    var sources = smc._sources = ArraySet.fromArray(aSourceMap._sources.toArray(), true);
    smc.sourceRoot = aSourceMap._sourceRoot;
    smc.sourcesContent = aSourceMap._generateSourcesContent(smc._sources.toArray(), smc.sourceRoot);
    smc.file = aSourceMap._file;
    smc._sourceMapURL = aSourceMapURL;
    smc._absoluteSources = smc._sources.toArray().map(function(s) {
      return util.computeSourceURL(smc.sourceRoot, s, aSourceMapURL);
    });
    var generatedMappings = aSourceMap._mappings.toArray().slice();
    var destGeneratedMappings = smc.__generatedMappings = [];
    var destOriginalMappings = smc.__originalMappings = [];
    for (var i2 = 0, length = generatedMappings.length;i2 < length; i2++) {
      var srcMapping = generatedMappings[i2];
      var destMapping = new Mapping;
      destMapping.generatedLine = srcMapping.generatedLine;
      destMapping.generatedColumn = srcMapping.generatedColumn;
      if (srcMapping.source) {
        destMapping.source = sources.indexOf(srcMapping.source);
        destMapping.originalLine = srcMapping.originalLine;
        destMapping.originalColumn = srcMapping.originalColumn;
        if (srcMapping.name) {
          destMapping.name = names.indexOf(srcMapping.name);
        }
        destOriginalMappings.push(destMapping);
      }
      destGeneratedMappings.push(destMapping);
    }
    quickSort(smc.__originalMappings, util.compareByOriginalPositions);
    return smc;
  };
  BasicSourceMapConsumer.prototype._version = 3;
  Object.defineProperty(BasicSourceMapConsumer.prototype, "sources", {
    get: function() {
      return this._absoluteSources.slice();
    }
  });
  function Mapping() {
    this.generatedLine = 0;
    this.generatedColumn = 0;
    this.source = null;
    this.originalLine = null;
    this.originalColumn = null;
    this.name = null;
  }
  BasicSourceMapConsumer.prototype._parseMappings = function SourceMapConsumer_parseMappings(aStr, aSourceRoot) {
    var generatedLine = 1;
    var previousGeneratedColumn = 0;
    var previousOriginalLine = 0;
    var previousOriginalColumn = 0;
    var previousSource = 0;
    var previousName = 0;
    var length = aStr.length;
    var index = 0;
    var cachedSegments = {};
    var temp = {};
    var originalMappings = [];
    var generatedMappings = [];
    var mapping, str, segment, end, value;
    while (index < length) {
      if (aStr.charAt(index) === ";") {
        generatedLine++;
        index++;
        previousGeneratedColumn = 0;
      } else if (aStr.charAt(index) === ",") {
        index++;
      } else {
        mapping = new Mapping;
        mapping.generatedLine = generatedLine;
        for (end = index;end < length; end++) {
          if (this._charIsMappingSeparator(aStr, end)) {
            break;
          }
        }
        str = aStr.slice(index, end);
        segment = cachedSegments[str];
        if (segment) {
          index += str.length;
        } else {
          segment = [];
          while (index < end) {
            base64VLQ.decode(aStr, index, temp);
            value = temp.value;
            index = temp.rest;
            segment.push(value);
          }
          if (segment.length === 2) {
            throw new Error("Found a source, but no line and column");
          }
          if (segment.length === 3) {
            throw new Error("Found a source and line, but no column");
          }
          cachedSegments[str] = segment;
        }
        mapping.generatedColumn = previousGeneratedColumn + segment[0];
        previousGeneratedColumn = mapping.generatedColumn;
        if (segment.length > 1) {
          mapping.source = previousSource + segment[1];
          previousSource += segment[1];
          mapping.originalLine = previousOriginalLine + segment[2];
          previousOriginalLine = mapping.originalLine;
          mapping.originalLine += 1;
          mapping.originalColumn = previousOriginalColumn + segment[3];
          previousOriginalColumn = mapping.originalColumn;
          if (segment.length > 4) {
            mapping.name = previousName + segment[4];
            previousName += segment[4];
          }
        }
        generatedMappings.push(mapping);
        if (typeof mapping.originalLine === "number") {
          originalMappings.push(mapping);
        }
      }
    }
    quickSort(generatedMappings, util.compareByGeneratedPositionsDeflated);
    this.__generatedMappings = generatedMappings;
    quickSort(originalMappings, util.compareByOriginalPositions);
    this.__originalMappings = originalMappings;
  };
  BasicSourceMapConsumer.prototype._findMapping = function SourceMapConsumer_findMapping(aNeedle, aMappings, aLineName, aColumnName, aComparator, aBias) {
    if (aNeedle[aLineName] <= 0) {
      throw new TypeError("Line must be greater than or equal to 1, got " + aNeedle[aLineName]);
    }
    if (aNeedle[aColumnName] < 0) {
      throw new TypeError("Column must be greater than or equal to 0, got " + aNeedle[aColumnName]);
    }
    return binarySearch.search(aNeedle, aMappings, aComparator, aBias);
  };
  BasicSourceMapConsumer.prototype.computeColumnSpans = function SourceMapConsumer_computeColumnSpans() {
    for (var index = 0;index < this._generatedMappings.length; ++index) {
      var mapping = this._generatedMappings[index];
      if (index + 1 < this._generatedMappings.length) {
        var nextMapping = this._generatedMappings[index + 1];
        if (mapping.generatedLine === nextMapping.generatedLine) {
          mapping.lastGeneratedColumn = nextMapping.generatedColumn - 1;
          continue;
        }
      }
      mapping.lastGeneratedColumn = Infinity;
    }
  };
  BasicSourceMapConsumer.prototype.originalPositionFor = function SourceMapConsumer_originalPositionFor(aArgs) {
    var needle = {
      generatedLine: util.getArg(aArgs, "line"),
      generatedColumn: util.getArg(aArgs, "column")
    };
    var index = this._findMapping(needle, this._generatedMappings, "generatedLine", "generatedColumn", util.compareByGeneratedPositionsDeflated, util.getArg(aArgs, "bias", SourceMapConsumer.GREATEST_LOWER_BOUND));
    if (index >= 0) {
      var mapping = this._generatedMappings[index];
      if (mapping.generatedLine === needle.generatedLine) {
        var source = util.getArg(mapping, "source", null);
        if (source !== null) {
          source = this._sources.at(source);
          source = util.computeSourceURL(this.sourceRoot, source, this._sourceMapURL);
        }
        var name = util.getArg(mapping, "name", null);
        if (name !== null) {
          name = this._names.at(name);
        }
        return {
          source,
          line: util.getArg(mapping, "originalLine", null),
          column: util.getArg(mapping, "originalColumn", null),
          name
        };
      }
    }
    return {
      source: null,
      line: null,
      column: null,
      name: null
    };
  };
  BasicSourceMapConsumer.prototype.hasContentsOfAllSources = function BasicSourceMapConsumer_hasContentsOfAllSources() {
    if (!this.sourcesContent) {
      return false;
    }
    return this.sourcesContent.length >= this._sources.size() && !this.sourcesContent.some(function(sc) {
      return sc == null;
    });
  };
  BasicSourceMapConsumer.prototype.sourceContentFor = function SourceMapConsumer_sourceContentFor(aSource, nullOnMissing) {
    if (!this.sourcesContent) {
      return null;
    }
    var index = this._findSourceIndex(aSource);
    if (index >= 0) {
      return this.sourcesContent[index];
    }
    var relativeSource = aSource;
    if (this.sourceRoot != null) {
      relativeSource = util.relative(this.sourceRoot, relativeSource);
    }
    var url2;
    if (this.sourceRoot != null && (url2 = util.urlParse(this.sourceRoot))) {
      var fileUriAbsPath = relativeSource.replace(/^file:\/\//, "");
      if (url2.scheme == "file" && this._sources.has(fileUriAbsPath)) {
        return this.sourcesContent[this._sources.indexOf(fileUriAbsPath)];
      }
      if ((!url2.path || url2.path == "/") && this._sources.has("/" + relativeSource)) {
        return this.sourcesContent[this._sources.indexOf("/" + relativeSource)];
      }
    }
    if (nullOnMissing) {
      return null;
    } else {
      throw new Error('"' + relativeSource + '" is not in the SourceMap.');
    }
  };
  BasicSourceMapConsumer.prototype.generatedPositionFor = function SourceMapConsumer_generatedPositionFor(aArgs) {
    var source = util.getArg(aArgs, "source");
    source = this._findSourceIndex(source);
    if (source < 0) {
      return {
        line: null,
        column: null,
        lastColumn: null
      };
    }
    var needle = {
      source,
      originalLine: util.getArg(aArgs, "line"),
      originalColumn: util.getArg(aArgs, "column")
    };
    var index = this._findMapping(needle, this._originalMappings, "originalLine", "originalColumn", util.compareByOriginalPositions, util.getArg(aArgs, "bias", SourceMapConsumer.GREATEST_LOWER_BOUND));
    if (index >= 0) {
      var mapping = this._originalMappings[index];
      if (mapping.source === needle.source) {
        return {
          line: util.getArg(mapping, "generatedLine", null),
          column: util.getArg(mapping, "generatedColumn", null),
          lastColumn: util.getArg(mapping, "lastGeneratedColumn", null)
        };
      }
    }
    return {
      line: null,
      column: null,
      lastColumn: null
    };
  };
  exports.BasicSourceMapConsumer = BasicSourceMapConsumer;
  function IndexedSourceMapConsumer(aSourceMap, aSourceMapURL) {
    var sourceMap = aSourceMap;
    if (typeof aSourceMap === "string") {
      sourceMap = util.parseSourceMapInput(aSourceMap);
    }
    var version3 = util.getArg(sourceMap, "version");
    var sections = util.getArg(sourceMap, "sections");
    if (version3 != this._version) {
      throw new Error("Unsupported version: " + version3);
    }
    this._sources = new ArraySet;
    this._names = new ArraySet;
    var lastOffset = {
      line: -1,
      column: 0
    };
    this._sections = sections.map(function(s) {
      if (s.url) {
        throw new Error("Support for url field in sections not implemented.");
      }
      var offset2 = util.getArg(s, "offset");
      var offsetLine = util.getArg(offset2, "line");
      var offsetColumn = util.getArg(offset2, "column");
      if (offsetLine < lastOffset.line || offsetLine === lastOffset.line && offsetColumn < lastOffset.column) {
        throw new Error("Section offsets must be ordered and non-overlapping.");
      }
      lastOffset = offset2;
      return {
        generatedOffset: {
          generatedLine: offsetLine + 1,
          generatedColumn: offsetColumn + 1
        },
        consumer: new SourceMapConsumer(util.getArg(s, "map"), aSourceMapURL)
      };
    });
  }
  IndexedSourceMapConsumer.prototype = Object.create(SourceMapConsumer.prototype);
  IndexedSourceMapConsumer.prototype.constructor = SourceMapConsumer;
  IndexedSourceMapConsumer.prototype._version = 3;
  Object.defineProperty(IndexedSourceMapConsumer.prototype, "sources", {
    get: function() {
      var sources = [];
      for (var i2 = 0;i2 < this._sections.length; i2++) {
        for (var j = 0;j < this._sections[i2].consumer.sources.length; j++) {
          sources.push(this._sections[i2].consumer.sources[j]);
        }
      }
      return sources;
    }
  });
  IndexedSourceMapConsumer.prototype.originalPositionFor = function IndexedSourceMapConsumer_originalPositionFor(aArgs) {
    var needle = {
      generatedLine: util.getArg(aArgs, "line"),
      generatedColumn: util.getArg(aArgs, "column")
    };
    var sectionIndex = binarySearch.search(needle, this._sections, function(needle2, section2) {
      var cmp = needle2.generatedLine - section2.generatedOffset.generatedLine;
      if (cmp) {
        return cmp;
      }
      return needle2.generatedColumn - section2.generatedOffset.generatedColumn;
    });
    var section = this._sections[sectionIndex];
    if (!section) {
      return {
        source: null,
        line: null,
        column: null,
        name: null
      };
    }
    return section.consumer.originalPositionFor({
      line: needle.generatedLine - (section.generatedOffset.generatedLine - 1),
      column: needle.generatedColumn - (section.generatedOffset.generatedLine === needle.generatedLine ? section.generatedOffset.generatedColumn - 1 : 0),
      bias: aArgs.bias
    });
  };
  IndexedSourceMapConsumer.prototype.hasContentsOfAllSources = function IndexedSourceMapConsumer_hasContentsOfAllSources() {
    return this._sections.every(function(s) {
      return s.consumer.hasContentsOfAllSources();
    });
  };
  IndexedSourceMapConsumer.prototype.sourceContentFor = function IndexedSourceMapConsumer_sourceContentFor(aSource, nullOnMissing) {
    for (var i2 = 0;i2 < this._sections.length; i2++) {
      var section = this._sections[i2];
      var content = section.consumer.sourceContentFor(aSource, true);
      if (content) {
        return content;
      }
    }
    if (nullOnMissing) {
      return null;
    } else {
      throw new Error('"' + aSource + '" is not in the SourceMap.');
    }
  };
  IndexedSourceMapConsumer.prototype.generatedPositionFor = function IndexedSourceMapConsumer_generatedPositionFor(aArgs) {
    for (var i2 = 0;i2 < this._sections.length; i2++) {
      var section = this._sections[i2];
      if (section.consumer._findSourceIndex(util.getArg(aArgs, "source")) === -1) {
        continue;
      }
      var generatedPosition = section.consumer.generatedPositionFor(aArgs);
      if (generatedPosition) {
        var ret = {
          line: generatedPosition.line + (section.generatedOffset.generatedLine - 1),
          column: generatedPosition.column + (section.generatedOffset.generatedLine === generatedPosition.line ? section.generatedOffset.generatedColumn - 1 : 0)
        };
        return ret;
      }
    }
    return {
      line: null,
      column: null
    };
  };
  IndexedSourceMapConsumer.prototype._parseMappings = function IndexedSourceMapConsumer_parseMappings(aStr, aSourceRoot) {
    this.__generatedMappings = [];
    this.__originalMappings = [];
    for (var i2 = 0;i2 < this._sections.length; i2++) {
      var section = this._sections[i2];
      var sectionMappings = section.consumer._generatedMappings;
      for (var j = 0;j < sectionMappings.length; j++) {
        var mapping = sectionMappings[j];
        var source = section.consumer._sources.at(mapping.source);
        source = util.computeSourceURL(section.consumer.sourceRoot, source, this._sourceMapURL);
        this._sources.add(source);
        source = this._sources.indexOf(source);
        var name = null;
        if (mapping.name) {
          name = section.consumer._names.at(mapping.name);
          this._names.add(name);
          name = this._names.indexOf(name);
        }
        var adjustedMapping = {
          source,
          generatedLine: mapping.generatedLine + (section.generatedOffset.generatedLine - 1),
          generatedColumn: mapping.generatedColumn + (section.generatedOffset.generatedLine === mapping.generatedLine ? section.generatedOffset.generatedColumn - 1 : 0),
          originalLine: mapping.originalLine,
          originalColumn: mapping.originalColumn,
          name
        };
        this.__generatedMappings.push(adjustedMapping);
        if (typeof adjustedMapping.originalLine === "number") {
          this.__originalMappings.push(adjustedMapping);
        }
      }
    }
    quickSort(this.__generatedMappings, util.compareByGeneratedPositionsDeflated);
    quickSort(this.__originalMappings, util.compareByOriginalPositions);
  };
  exports.IndexedSourceMapConsumer = IndexedSourceMapConsumer;
});

// node_modules/source-map/lib/source-node.js
var require_source_node = __commonJS((exports) => {
  var SourceMapGenerator = require_source_map_generator().SourceMapGenerator;
  var util = require_util();
  var REGEX_NEWLINE = /(\r?\n)/;
  var NEWLINE_CODE = 10;
  var isSourceNode = "$$$isSourceNode$$$";
  function SourceNode(aLine, aColumn, aSource, aChunks, aName) {
    this.children = [];
    this.sourceContents = {};
    this.line = aLine == null ? null : aLine;
    this.column = aColumn == null ? null : aColumn;
    this.source = aSource == null ? null : aSource;
    this.name = aName == null ? null : aName;
    this[isSourceNode] = true;
    if (aChunks != null)
      this.add(aChunks);
  }
  SourceNode.fromStringWithSourceMap = function SourceNode_fromStringWithSourceMap(aGeneratedCode, aSourceMapConsumer, aRelativePath) {
    var node = new SourceNode;
    var remainingLines = aGeneratedCode.split(REGEX_NEWLINE);
    var remainingLinesIndex = 0;
    var shiftNextLine = function() {
      var lineContents = getNextLine();
      var newLine = getNextLine() || "";
      return lineContents + newLine;
      function getNextLine() {
        return remainingLinesIndex < remainingLines.length ? remainingLines[remainingLinesIndex++] : undefined;
      }
    };
    var lastGeneratedLine = 1, lastGeneratedColumn = 0;
    var lastMapping = null;
    aSourceMapConsumer.eachMapping(function(mapping) {
      if (lastMapping !== null) {
        if (lastGeneratedLine < mapping.generatedLine) {
          addMappingWithCode(lastMapping, shiftNextLine());
          lastGeneratedLine++;
          lastGeneratedColumn = 0;
        } else {
          var nextLine = remainingLines[remainingLinesIndex] || "";
          var code = nextLine.substr(0, mapping.generatedColumn - lastGeneratedColumn);
          remainingLines[remainingLinesIndex] = nextLine.substr(mapping.generatedColumn - lastGeneratedColumn);
          lastGeneratedColumn = mapping.generatedColumn;
          addMappingWithCode(lastMapping, code);
          lastMapping = mapping;
          return;
        }
      }
      while (lastGeneratedLine < mapping.generatedLine) {
        node.add(shiftNextLine());
        lastGeneratedLine++;
      }
      if (lastGeneratedColumn < mapping.generatedColumn) {
        var nextLine = remainingLines[remainingLinesIndex] || "";
        node.add(nextLine.substr(0, mapping.generatedColumn));
        remainingLines[remainingLinesIndex] = nextLine.substr(mapping.generatedColumn);
        lastGeneratedColumn = mapping.generatedColumn;
      }
      lastMapping = mapping;
    }, this);
    if (remainingLinesIndex < remainingLines.length) {
      if (lastMapping) {
        addMappingWithCode(lastMapping, shiftNextLine());
      }
      node.add(remainingLines.splice(remainingLinesIndex).join(""));
    }
    aSourceMapConsumer.sources.forEach(function(sourceFile) {
      var content = aSourceMapConsumer.sourceContentFor(sourceFile);
      if (content != null) {
        if (aRelativePath != null) {
          sourceFile = util.join(aRelativePath, sourceFile);
        }
        node.setSourceContent(sourceFile, content);
      }
    });
    return node;
    function addMappingWithCode(mapping, code) {
      if (mapping === null || mapping.source === undefined) {
        node.add(code);
      } else {
        var source = aRelativePath ? util.join(aRelativePath, mapping.source) : mapping.source;
        node.add(new SourceNode(mapping.originalLine, mapping.originalColumn, source, code, mapping.name));
      }
    }
  };
  SourceNode.prototype.add = function SourceNode_add(aChunk) {
    if (Array.isArray(aChunk)) {
      aChunk.forEach(function(chunk) {
        this.add(chunk);
      }, this);
    } else if (aChunk[isSourceNode] || typeof aChunk === "string") {
      if (aChunk) {
        this.children.push(aChunk);
      }
    } else {
      throw new TypeError("Expected a SourceNode, string, or an array of SourceNodes and strings. Got " + aChunk);
    }
    return this;
  };
  SourceNode.prototype.prepend = function SourceNode_prepend(aChunk) {
    if (Array.isArray(aChunk)) {
      for (var i2 = aChunk.length - 1;i2 >= 0; i2--) {
        this.prepend(aChunk[i2]);
      }
    } else if (aChunk[isSourceNode] || typeof aChunk === "string") {
      this.children.unshift(aChunk);
    } else {
      throw new TypeError("Expected a SourceNode, string, or an array of SourceNodes and strings. Got " + aChunk);
    }
    return this;
  };
  SourceNode.prototype.walk = function SourceNode_walk(aFn) {
    var chunk;
    for (var i2 = 0, len = this.children.length;i2 < len; i2++) {
      chunk = this.children[i2];
      if (chunk[isSourceNode]) {
        chunk.walk(aFn);
      } else {
        if (chunk !== "") {
          aFn(chunk, {
            source: this.source,
            line: this.line,
            column: this.column,
            name: this.name
          });
        }
      }
    }
  };
  SourceNode.prototype.join = function SourceNode_join(aSep) {
    var newChildren;
    var i2;
    var len = this.children.length;
    if (len > 0) {
      newChildren = [];
      for (i2 = 0;i2 < len - 1; i2++) {
        newChildren.push(this.children[i2]);
        newChildren.push(aSep);
      }
      newChildren.push(this.children[i2]);
      this.children = newChildren;
    }
    return this;
  };
  SourceNode.prototype.replaceRight = function SourceNode_replaceRight(aPattern, aReplacement) {
    var lastChild = this.children[this.children.length - 1];
    if (lastChild[isSourceNode]) {
      lastChild.replaceRight(aPattern, aReplacement);
    } else if (typeof lastChild === "string") {
      this.children[this.children.length - 1] = lastChild.replace(aPattern, aReplacement);
    } else {
      this.children.push("".replace(aPattern, aReplacement));
    }
    return this;
  };
  SourceNode.prototype.setSourceContent = function SourceNode_setSourceContent(aSourceFile, aSourceContent) {
    this.sourceContents[util.toSetString(aSourceFile)] = aSourceContent;
  };
  SourceNode.prototype.walkSourceContents = function SourceNode_walkSourceContents(aFn) {
    for (var i2 = 0, len = this.children.length;i2 < len; i2++) {
      if (this.children[i2][isSourceNode]) {
        this.children[i2].walkSourceContents(aFn);
      }
    }
    var sources = Object.keys(this.sourceContents);
    for (var i2 = 0, len = sources.length;i2 < len; i2++) {
      aFn(util.fromSetString(sources[i2]), this.sourceContents[sources[i2]]);
    }
  };
  SourceNode.prototype.toString = function SourceNode_toString() {
    var str = "";
    this.walk(function(chunk) {
      str += chunk;
    });
    return str;
  };
  SourceNode.prototype.toStringWithSourceMap = function SourceNode_toStringWithSourceMap(aArgs) {
    var generated = {
      code: "",
      line: 1,
      column: 0
    };
    var map3 = new SourceMapGenerator(aArgs);
    var sourceMappingActive = false;
    var lastOriginalSource = null;
    var lastOriginalLine = null;
    var lastOriginalColumn = null;
    var lastOriginalName = null;
    this.walk(function(chunk, original) {
      generated.code += chunk;
      if (original.source !== null && original.line !== null && original.column !== null) {
        if (lastOriginalSource !== original.source || lastOriginalLine !== original.line || lastOriginalColumn !== original.column || lastOriginalName !== original.name) {
          map3.addMapping({
            source: original.source,
            original: {
              line: original.line,
              column: original.column
            },
            generated: {
              line: generated.line,
              column: generated.column
            },
            name: original.name
          });
        }
        lastOriginalSource = original.source;
        lastOriginalLine = original.line;
        lastOriginalColumn = original.column;
        lastOriginalName = original.name;
        sourceMappingActive = true;
      } else if (sourceMappingActive) {
        map3.addMapping({
          generated: {
            line: generated.line,
            column: generated.column
          }
        });
        lastOriginalSource = null;
        sourceMappingActive = false;
      }
      for (var idx = 0, length = chunk.length;idx < length; idx++) {
        if (chunk.charCodeAt(idx) === NEWLINE_CODE) {
          generated.line++;
          generated.column = 0;
          if (idx + 1 === length) {
            lastOriginalSource = null;
            sourceMappingActive = false;
          } else if (sourceMappingActive) {
            map3.addMapping({
              source: original.source,
              original: {
                line: original.line,
                column: original.column
              },
              generated: {
                line: generated.line,
                column: generated.column
              },
              name: original.name
            });
          }
        } else {
          generated.column++;
        }
      }
    });
    this.walkSourceContents(function(sourceFile, sourceContent) {
      map3.setSourceContent(sourceFile, sourceContent);
    });
    return { code: generated.code, map: map3 };
  };
  exports.SourceNode = SourceNode;
});

// node_modules/source-map/source-map.js
var require_source_map = __commonJS((exports) => {
  exports.SourceMapGenerator = require_source_map_generator().SourceMapGenerator;
  exports.SourceMapConsumer = require_source_map_consumer().SourceMapConsumer;
  exports.SourceNode = require_source_node().SourceNode;
});

// node_modules/escodegen/package.json
var require_package = __commonJS((exports, module) => {
  module.exports = {
    name: "escodegen",
    description: "ECMAScript code generator",
    homepage: "http://github.com/estools/escodegen",
    main: "escodegen.js",
    bin: {
      esgenerate: "./bin/esgenerate.js",
      escodegen: "./bin/escodegen.js"
    },
    files: [
      "LICENSE.BSD",
      "README.md",
      "bin",
      "escodegen.js",
      "package.json"
    ],
    version: "2.1.0",
    engines: {
      node: ">=6.0"
    },
    maintainers: [
      {
        name: "Yusuke Suzuki",
        email: "utatane.tea@gmail.com",
        web: "http://github.com/Constellation"
      }
    ],
    repository: {
      type: "git",
      url: "http://github.com/estools/escodegen.git"
    },
    dependencies: {
      estraverse: "^5.2.0",
      esutils: "^2.0.2",
      esprima: "^4.0.1"
    },
    optionalDependencies: {
      "source-map": "~0.6.1"
    },
    devDependencies: {
      acorn: "^8.0.4",
      bluebird: "^3.4.7",
      "bower-registry-client": "^1.0.0",
      chai: "^4.2.0",
      "chai-exclude": "^2.0.2",
      "commonjs-everywhere": "^0.9.7",
      gulp: "^4.0.2",
      "gulp-eslint": "^6.0.0",
      "gulp-mocha": "^7.0.2",
      minimist: "^1.2.5",
      optionator: "^0.9.1",
      semver: "^7.3.4"
    },
    license: "BSD-2-Clause",
    scripts: {
      test: "gulp travis",
      "unit-test": "gulp test",
      lint: "gulp lint",
      release: "node tools/release.js",
      "build-min": "./node_modules/.bin/cjsify -ma path: tools/entry-point.js > escodegen.browser.min.js",
      build: "./node_modules/.bin/cjsify -a path: tools/entry-point.js > escodegen.browser.js"
    }
  };
});

// node_modules/escodegen/escodegen.js
var require_escodegen = __commonJS((exports) => {
  (function() {
    var Syntax, Precedence, BinaryPrecedence, SourceNode, estraverse, esutils, base2, indent, json2, renumber, hexadecimal, quotes, escapeless, newline, space, parentheses, semicolons, safeConcatenation, directive, extra, parse10, sourceMap, sourceCode, preserveBlankLines, FORMAT_MINIFY, FORMAT_DEFAULTS;
    estraverse = require_estraverse();
    esutils = require_utils();
    Syntax = estraverse.Syntax;
    function isExpression(node) {
      return CodeGenerator.Expression.hasOwnProperty(node.type);
    }
    function isStatement(node) {
      return CodeGenerator.Statement.hasOwnProperty(node.type);
    }
    Precedence = {
      Sequence: 0,
      Yield: 1,
      Assignment: 1,
      Conditional: 2,
      ArrowFunction: 2,
      Coalesce: 3,
      LogicalOR: 4,
      LogicalAND: 5,
      BitwiseOR: 6,
      BitwiseXOR: 7,
      BitwiseAND: 8,
      Equality: 9,
      Relational: 10,
      BitwiseSHIFT: 11,
      Additive: 12,
      Multiplicative: 13,
      Exponentiation: 14,
      Await: 15,
      Unary: 15,
      Postfix: 16,
      OptionalChaining: 17,
      Call: 18,
      New: 19,
      TaggedTemplate: 20,
      Member: 21,
      Primary: 22
    };
    BinaryPrecedence = {
      "??": Precedence.Coalesce,
      "||": Precedence.LogicalOR,
      "&&": Precedence.LogicalAND,
      "|": Precedence.BitwiseOR,
      "^": Precedence.BitwiseXOR,
      "&": Precedence.BitwiseAND,
      "==": Precedence.Equality,
      "!=": Precedence.Equality,
      "===": Precedence.Equality,
      "!==": Precedence.Equality,
      is: Precedence.Equality,
      isnt: Precedence.Equality,
      "<": Precedence.Relational,
      ">": Precedence.Relational,
      "<=": Precedence.Relational,
      ">=": Precedence.Relational,
      in: Precedence.Relational,
      instanceof: Precedence.Relational,
      "<<": Precedence.BitwiseSHIFT,
      ">>": Precedence.BitwiseSHIFT,
      ">>>": Precedence.BitwiseSHIFT,
      "+": Precedence.Additive,
      "-": Precedence.Additive,
      "*": Precedence.Multiplicative,
      "%": Precedence.Multiplicative,
      "/": Precedence.Multiplicative,
      "**": Precedence.Exponentiation
    };
    var F_ALLOW_IN = 1, F_ALLOW_CALL = 1 << 1, F_ALLOW_UNPARATH_NEW = 1 << 2, F_FUNC_BODY = 1 << 3, F_DIRECTIVE_CTX = 1 << 4, F_SEMICOLON_OPT = 1 << 5, F_FOUND_COALESCE = 1 << 6;
    var E_FTT = F_ALLOW_CALL | F_ALLOW_UNPARATH_NEW, E_TTF = F_ALLOW_IN | F_ALLOW_CALL, E_TTT = F_ALLOW_IN | F_ALLOW_CALL | F_ALLOW_UNPARATH_NEW, E_TFF = F_ALLOW_IN, E_FFT = F_ALLOW_UNPARATH_NEW, E_TFT = F_ALLOW_IN | F_ALLOW_UNPARATH_NEW;
    var S_TFFF = F_ALLOW_IN, S_TFFT = F_ALLOW_IN | F_SEMICOLON_OPT, S_FFFF = 0, S_TFTF = F_ALLOW_IN | F_DIRECTIVE_CTX, S_TTFF = F_ALLOW_IN | F_FUNC_BODY;
    function getDefaultOptions() {
      return {
        indent: null,
        base: null,
        parse: null,
        comment: false,
        format: {
          indent: {
            style: "    ",
            base: 0,
            adjustMultilineComment: false
          },
          newline: `
`,
          space: " ",
          json: false,
          renumber: false,
          hexadecimal: false,
          quotes: "single",
          escapeless: false,
          compact: false,
          parentheses: true,
          semicolons: true,
          safeConcatenation: false,
          preserveBlankLines: false
        },
        moz: {
          comprehensionExpressionStartsWithAssignment: false,
          starlessGenerator: false
        },
        sourceMap: null,
        sourceMapRoot: null,
        sourceMapWithCode: false,
        directive: false,
        raw: true,
        verbatim: null,
        sourceCode: null
      };
    }
    function stringRepeat(str, num) {
      var result = "";
      for (num |= 0;num > 0; num >>>= 1, str += str) {
        if (num & 1) {
          result += str;
        }
      }
      return result;
    }
    function hasLineTerminator(str) {
      return /[\r\n]/g.test(str);
    }
    function endsWithLineTerminator(str) {
      var len = str.length;
      return len && esutils.code.isLineTerminator(str.charCodeAt(len - 1));
    }
    function merge2(target, override) {
      var key;
      for (key in override) {
        if (override.hasOwnProperty(key)) {
          target[key] = override[key];
        }
      }
      return target;
    }
    function updateDeeply(target, override) {
      var key, val;
      function isHashObject(target2) {
        return typeof target2 === "object" && target2 instanceof Object && !(target2 instanceof RegExp);
      }
      for (key in override) {
        if (override.hasOwnProperty(key)) {
          val = override[key];
          if (isHashObject(val)) {
            if (isHashObject(target[key])) {
              updateDeeply(target[key], val);
            } else {
              target[key] = updateDeeply({}, val);
            }
          } else {
            target[key] = val;
          }
        }
      }
      return target;
    }
    function generateNumber(value) {
      var result, point, temp, exponent, pos;
      if (value !== value) {
        throw new Error("Numeric literal whose value is NaN");
      }
      if (value < 0 || value === 0 && 1 / value < 0) {
        throw new Error("Numeric literal whose value is negative");
      }
      if (value === 1 / 0) {
        return json2 ? "null" : renumber ? "1e400" : "1e+400";
      }
      result = "" + value;
      if (!renumber || result.length < 3) {
        return result;
      }
      point = result.indexOf(".");
      if (!json2 && result.charCodeAt(0) === 48 && point === 1) {
        point = 0;
        result = result.slice(1);
      }
      temp = result;
      result = result.replace("e+", "e");
      exponent = 0;
      if ((pos = temp.indexOf("e")) > 0) {
        exponent = +temp.slice(pos + 1);
        temp = temp.slice(0, pos);
      }
      if (point >= 0) {
        exponent -= temp.length - point - 1;
        temp = +(temp.slice(0, point) + temp.slice(point + 1)) + "";
      }
      pos = 0;
      while (temp.charCodeAt(temp.length + pos - 1) === 48) {
        --pos;
      }
      if (pos !== 0) {
        exponent -= pos;
        temp = temp.slice(0, pos);
      }
      if (exponent !== 0) {
        temp += "e" + exponent;
      }
      if ((temp.length < result.length || hexadecimal && value > 1000000000000 && Math.floor(value) === value && (temp = "0x" + value.toString(16)).length < result.length) && +temp === value) {
        result = temp;
      }
      return result;
    }
    function escapeRegExpCharacter(ch, previousIsBackslash) {
      if ((ch & ~1) === 8232) {
        return (previousIsBackslash ? "u" : "\\u") + (ch === 8232 ? "2028" : "2029");
      } else if (ch === 10 || ch === 13) {
        return (previousIsBackslash ? "" : "\\") + (ch === 10 ? "n" : "r");
      }
      return String.fromCharCode(ch);
    }
    function generateRegExp(reg) {
      var match, result, flags, i2, iz, ch, characterInBrack, previousIsBackslash;
      result = reg.toString();
      if (reg.source) {
        match = result.match(/\/([^/]*)$/);
        if (!match) {
          return result;
        }
        flags = match[1];
        result = "";
        characterInBrack = false;
        previousIsBackslash = false;
        for (i2 = 0, iz = reg.source.length;i2 < iz; ++i2) {
          ch = reg.source.charCodeAt(i2);
          if (!previousIsBackslash) {
            if (characterInBrack) {
              if (ch === 93) {
                characterInBrack = false;
              }
            } else {
              if (ch === 47) {
                result += "\\";
              } else if (ch === 91) {
                characterInBrack = true;
              }
            }
            result += escapeRegExpCharacter(ch, previousIsBackslash);
            previousIsBackslash = ch === 92;
          } else {
            result += escapeRegExpCharacter(ch, previousIsBackslash);
            previousIsBackslash = false;
          }
        }
        return "/" + result + "/" + flags;
      }
      return result;
    }
    function escapeAllowedCharacter(code, next) {
      var hex;
      if (code === 8) {
        return "\\b";
      }
      if (code === 12) {
        return "\\f";
      }
      if (code === 9) {
        return "\\t";
      }
      hex = code.toString(16).toUpperCase();
      if (json2 || code > 255) {
        return "\\u" + "0000".slice(hex.length) + hex;
      } else if (code === 0 && !esutils.code.isDecimalDigit(next)) {
        return "\\0";
      } else if (code === 11) {
        return "\\x0B";
      } else {
        return "\\x" + "00".slice(hex.length) + hex;
      }
    }
    function escapeDisallowedCharacter(code) {
      if (code === 92) {
        return "\\\\";
      }
      if (code === 10) {
        return "\\n";
      }
      if (code === 13) {
        return "\\r";
      }
      if (code === 8232) {
        return "\\u2028";
      }
      if (code === 8233) {
        return "\\u2029";
      }
      throw new Error("Incorrectly classified character");
    }
    function escapeDirective(str) {
      var i2, iz, code, quote;
      quote = quotes === "double" ? '"' : "'";
      for (i2 = 0, iz = str.length;i2 < iz; ++i2) {
        code = str.charCodeAt(i2);
        if (code === 39) {
          quote = '"';
          break;
        } else if (code === 34) {
          quote = "'";
          break;
        } else if (code === 92) {
          ++i2;
        }
      }
      return quote + str + quote;
    }
    function escapeString(str) {
      var result = "", i2, len, code, singleQuotes = 0, doubleQuotes = 0, single, quote;
      for (i2 = 0, len = str.length;i2 < len; ++i2) {
        code = str.charCodeAt(i2);
        if (code === 39) {
          ++singleQuotes;
        } else if (code === 34) {
          ++doubleQuotes;
        } else if (code === 47 && json2) {
          result += "\\";
        } else if (esutils.code.isLineTerminator(code) || code === 92) {
          result += escapeDisallowedCharacter(code);
          continue;
        } else if (!esutils.code.isIdentifierPartES5(code) && (json2 && code < 32 || !json2 && !escapeless && (code < 32 || code > 126))) {
          result += escapeAllowedCharacter(code, str.charCodeAt(i2 + 1));
          continue;
        }
        result += String.fromCharCode(code);
      }
      single = !(quotes === "double" || quotes === "auto" && doubleQuotes < singleQuotes);
      quote = single ? "'" : '"';
      if (!(single ? singleQuotes : doubleQuotes)) {
        return quote + result + quote;
      }
      str = result;
      result = quote;
      for (i2 = 0, len = str.length;i2 < len; ++i2) {
        code = str.charCodeAt(i2);
        if (code === 39 && single || code === 34 && !single) {
          result += "\\";
        }
        result += String.fromCharCode(code);
      }
      return result + quote;
    }
    function flattenToString(arr2) {
      var i2, iz, elem, result = "";
      for (i2 = 0, iz = arr2.length;i2 < iz; ++i2) {
        elem = arr2[i2];
        result += Array.isArray(elem) ? flattenToString(elem) : elem;
      }
      return result;
    }
    function toSourceNodeWhenNeeded(generated, node) {
      if (!sourceMap) {
        if (Array.isArray(generated)) {
          return flattenToString(generated);
        } else {
          return generated;
        }
      }
      if (node == null) {
        if (generated instanceof SourceNode) {
          return generated;
        } else {
          node = {};
        }
      }
      if (node.loc == null) {
        return new SourceNode(null, null, sourceMap, generated, node.name || null);
      }
      return new SourceNode(node.loc.start.line, node.loc.start.column, sourceMap === true ? node.loc.source || null : sourceMap, generated, node.name || null);
    }
    function noEmptySpace() {
      return space ? space : " ";
    }
    function join(left, right) {
      var leftSource, rightSource, leftCharCode, rightCharCode;
      leftSource = toSourceNodeWhenNeeded(left).toString();
      if (leftSource.length === 0) {
        return [right];
      }
      rightSource = toSourceNodeWhenNeeded(right).toString();
      if (rightSource.length === 0) {
        return [left];
      }
      leftCharCode = leftSource.charCodeAt(leftSource.length - 1);
      rightCharCode = rightSource.charCodeAt(0);
      if ((leftCharCode === 43 || leftCharCode === 45) && leftCharCode === rightCharCode || esutils.code.isIdentifierPartES5(leftCharCode) && esutils.code.isIdentifierPartES5(rightCharCode) || leftCharCode === 47 && rightCharCode === 105) {
        return [left, noEmptySpace(), right];
      } else if (esutils.code.isWhiteSpace(leftCharCode) || esutils.code.isLineTerminator(leftCharCode) || esutils.code.isWhiteSpace(rightCharCode) || esutils.code.isLineTerminator(rightCharCode)) {
        return [left, right];
      }
      return [left, space, right];
    }
    function addIndent(stmt) {
      return [base2, stmt];
    }
    function withIndent(fn2) {
      var previousBase;
      previousBase = base2;
      base2 += indent;
      fn2(base2);
      base2 = previousBase;
    }
    function calculateSpaces(str) {
      var i2;
      for (i2 = str.length - 1;i2 >= 0; --i2) {
        if (esutils.code.isLineTerminator(str.charCodeAt(i2))) {
          break;
        }
      }
      return str.length - 1 - i2;
    }
    function adjustMultilineComment(value, specialBase) {
      var array2, i2, len, line, j, spaces, previousBase, sn;
      array2 = value.split(/\r\n|[\r\n]/);
      spaces = Number.MAX_VALUE;
      for (i2 = 1, len = array2.length;i2 < len; ++i2) {
        line = array2[i2];
        j = 0;
        while (j < line.length && esutils.code.isWhiteSpace(line.charCodeAt(j))) {
          ++j;
        }
        if (spaces > j) {
          spaces = j;
        }
      }
      if (typeof specialBase !== "undefined") {
        previousBase = base2;
        if (array2[1][spaces] === "*") {
          specialBase += " ";
        }
        base2 = specialBase;
      } else {
        if (spaces & 1) {
          --spaces;
        }
        previousBase = base2;
      }
      for (i2 = 1, len = array2.length;i2 < len; ++i2) {
        sn = toSourceNodeWhenNeeded(addIndent(array2[i2].slice(spaces)));
        array2[i2] = sourceMap ? sn.join("") : sn;
      }
      base2 = previousBase;
      return array2.join(`
`);
    }
    function generateComment(comment, specialBase) {
      if (comment.type === "Line") {
        if (endsWithLineTerminator(comment.value)) {
          return "//" + comment.value;
        } else {
          var result = "//" + comment.value;
          if (!preserveBlankLines) {
            result += `
`;
          }
          return result;
        }
      }
      if (extra.format.indent.adjustMultilineComment && /[\n\r]/.test(comment.value)) {
        return adjustMultilineComment("/*" + comment.value + "*/", specialBase);
      }
      return "/*" + comment.value + "*/";
    }
    function addComments(stmt, result) {
      var i2, len, comment, save, tailingToStatement, specialBase, fragment, extRange, range2, prevRange, prefix, infix, suffix, count;
      if (stmt.leadingComments && stmt.leadingComments.length > 0) {
        save = result;
        if (preserveBlankLines) {
          comment = stmt.leadingComments[0];
          result = [];
          extRange = comment.extendedRange;
          range2 = comment.range;
          prefix = sourceCode.substring(extRange[0], range2[0]);
          count = (prefix.match(/\n/g) || []).length;
          if (count > 0) {
            result.push(stringRepeat(`
`, count));
            result.push(addIndent(generateComment(comment)));
          } else {
            result.push(prefix);
            result.push(generateComment(comment));
          }
          prevRange = range2;
          for (i2 = 1, len = stmt.leadingComments.length;i2 < len; i2++) {
            comment = stmt.leadingComments[i2];
            range2 = comment.range;
            infix = sourceCode.substring(prevRange[1], range2[0]);
            count = (infix.match(/\n/g) || []).length;
            result.push(stringRepeat(`
`, count));
            result.push(addIndent(generateComment(comment)));
            prevRange = range2;
          }
          suffix = sourceCode.substring(range2[1], extRange[1]);
          count = (suffix.match(/\n/g) || []).length;
          result.push(stringRepeat(`
`, count));
        } else {
          comment = stmt.leadingComments[0];
          result = [];
          if (safeConcatenation && stmt.type === Syntax.Program && stmt.body.length === 0) {
            result.push(`
`);
          }
          result.push(generateComment(comment));
          if (!endsWithLineTerminator(toSourceNodeWhenNeeded(result).toString())) {
            result.push(`
`);
          }
          for (i2 = 1, len = stmt.leadingComments.length;i2 < len; ++i2) {
            comment = stmt.leadingComments[i2];
            fragment = [generateComment(comment)];
            if (!endsWithLineTerminator(toSourceNodeWhenNeeded(fragment).toString())) {
              fragment.push(`
`);
            }
            result.push(addIndent(fragment));
          }
        }
        result.push(addIndent(save));
      }
      if (stmt.trailingComments) {
        if (preserveBlankLines) {
          comment = stmt.trailingComments[0];
          extRange = comment.extendedRange;
          range2 = comment.range;
          prefix = sourceCode.substring(extRange[0], range2[0]);
          count = (prefix.match(/\n/g) || []).length;
          if (count > 0) {
            result.push(stringRepeat(`
`, count));
            result.push(addIndent(generateComment(comment)));
          } else {
            result.push(prefix);
            result.push(generateComment(comment));
          }
        } else {
          tailingToStatement = !endsWithLineTerminator(toSourceNodeWhenNeeded(result).toString());
          specialBase = stringRepeat(" ", calculateSpaces(toSourceNodeWhenNeeded([base2, result, indent]).toString()));
          for (i2 = 0, len = stmt.trailingComments.length;i2 < len; ++i2) {
            comment = stmt.trailingComments[i2];
            if (tailingToStatement) {
              if (i2 === 0) {
                result = [result, indent];
              } else {
                result = [result, specialBase];
              }
              result.push(generateComment(comment, specialBase));
            } else {
              result = [result, addIndent(generateComment(comment))];
            }
            if (i2 !== len - 1 && !endsWithLineTerminator(toSourceNodeWhenNeeded(result).toString())) {
              result = [result, `
`];
            }
          }
        }
      }
      return result;
    }
    function generateBlankLines(start, end, result) {
      var j, newlineCount = 0;
      for (j = start;j < end; j++) {
        if (sourceCode[j] === `
`) {
          newlineCount++;
        }
      }
      for (j = 1;j < newlineCount; j++) {
        result.push(newline);
      }
    }
    function parenthesize(text2, current2, should) {
      if (current2 < should) {
        return ["(", text2, ")"];
      }
      return text2;
    }
    function generateVerbatimString(string4) {
      var i2, iz, result;
      result = string4.split(/\r\n|\n/);
      for (i2 = 1, iz = result.length;i2 < iz; i2++) {
        result[i2] = newline + base2 + result[i2];
      }
      return result;
    }
    function generateVerbatim(expr, precedence) {
      var verbatim, result, prec;
      verbatim = expr[extra.verbatim];
      if (typeof verbatim === "string") {
        result = parenthesize(generateVerbatimString(verbatim), Precedence.Sequence, precedence);
      } else {
        result = generateVerbatimString(verbatim.content);
        prec = verbatim.precedence != null ? verbatim.precedence : Precedence.Sequence;
        result = parenthesize(result, prec, precedence);
      }
      return toSourceNodeWhenNeeded(result, expr);
    }
    function CodeGenerator() {}
    CodeGenerator.prototype.maybeBlock = function(stmt, flags) {
      var result, noLeadingComment, that = this;
      noLeadingComment = !extra.comment || !stmt.leadingComments;
      if (stmt.type === Syntax.BlockStatement && noLeadingComment) {
        return [space, this.generateStatement(stmt, flags)];
      }
      if (stmt.type === Syntax.EmptyStatement && noLeadingComment) {
        return ";";
      }
      withIndent(function() {
        result = [
          newline,
          addIndent(that.generateStatement(stmt, flags))
        ];
      });
      return result;
    };
    CodeGenerator.prototype.maybeBlockSuffix = function(stmt, result) {
      var ends = endsWithLineTerminator(toSourceNodeWhenNeeded(result).toString());
      if (stmt.type === Syntax.BlockStatement && (!extra.comment || !stmt.leadingComments) && !ends) {
        return [result, space];
      }
      if (ends) {
        return [result, base2];
      }
      return [result, newline, base2];
    };
    function generateIdentifier(node) {
      return toSourceNodeWhenNeeded(node.name, node);
    }
    function generateAsyncPrefix(node, spaceRequired) {
      return node.async ? "async" + (spaceRequired ? noEmptySpace() : space) : "";
    }
    function generateStarSuffix(node) {
      var isGenerator = node.generator && !extra.moz.starlessGenerator;
      return isGenerator ? "*" + space : "";
    }
    function generateMethodPrefix(prop) {
      var func = prop.value, prefix = "";
      if (func.async) {
        prefix += generateAsyncPrefix(func, !prop.computed);
      }
      if (func.generator) {
        prefix += generateStarSuffix(func) ? "*" : "";
      }
      return prefix;
    }
    CodeGenerator.prototype.generatePattern = function(node, precedence, flags) {
      if (node.type === Syntax.Identifier) {
        return generateIdentifier(node);
      }
      return this.generateExpression(node, precedence, flags);
    };
    CodeGenerator.prototype.generateFunctionParams = function(node) {
      var i2, iz, result, hasDefault;
      hasDefault = false;
      if (node.type === Syntax.ArrowFunctionExpression && !node.rest && (!node.defaults || node.defaults.length === 0) && node.params.length === 1 && node.params[0].type === Syntax.Identifier) {
        result = [generateAsyncPrefix(node, true), generateIdentifier(node.params[0])];
      } else {
        result = node.type === Syntax.ArrowFunctionExpression ? [generateAsyncPrefix(node, false)] : [];
        result.push("(");
        if (node.defaults) {
          hasDefault = true;
        }
        for (i2 = 0, iz = node.params.length;i2 < iz; ++i2) {
          if (hasDefault && node.defaults[i2]) {
            result.push(this.generateAssignment(node.params[i2], node.defaults[i2], "=", Precedence.Assignment, E_TTT));
          } else {
            result.push(this.generatePattern(node.params[i2], Precedence.Assignment, E_TTT));
          }
          if (i2 + 1 < iz) {
            result.push("," + space);
          }
        }
        if (node.rest) {
          if (node.params.length) {
            result.push("," + space);
          }
          result.push("...");
          result.push(generateIdentifier(node.rest));
        }
        result.push(")");
      }
      return result;
    };
    CodeGenerator.prototype.generateFunctionBody = function(node) {
      var result, expr;
      result = this.generateFunctionParams(node);
      if (node.type === Syntax.ArrowFunctionExpression) {
        result.push(space);
        result.push("=>");
      }
      if (node.expression) {
        result.push(space);
        expr = this.generateExpression(node.body, Precedence.Assignment, E_TTT);
        if (expr.toString().charAt(0) === "{") {
          expr = ["(", expr, ")"];
        }
        result.push(expr);
      } else {
        result.push(this.maybeBlock(node.body, S_TTFF));
      }
      return result;
    };
    CodeGenerator.prototype.generateIterationForStatement = function(operator, stmt, flags) {
      var result = ["for" + (stmt.await ? noEmptySpace() + "await" : "") + space + "("], that = this;
      withIndent(function() {
        if (stmt.left.type === Syntax.VariableDeclaration) {
          withIndent(function() {
            result.push(stmt.left.kind + noEmptySpace());
            result.push(that.generateStatement(stmt.left.declarations[0], S_FFFF));
          });
        } else {
          result.push(that.generateExpression(stmt.left, Precedence.Call, E_TTT));
        }
        result = join(result, operator);
        result = [join(result, that.generateExpression(stmt.right, Precedence.Assignment, E_TTT)), ")"];
      });
      result.push(this.maybeBlock(stmt.body, flags));
      return result;
    };
    CodeGenerator.prototype.generatePropertyKey = function(expr, computed) {
      var result = [];
      if (computed) {
        result.push("[");
      }
      result.push(this.generateExpression(expr, Precedence.Assignment, E_TTT));
      if (computed) {
        result.push("]");
      }
      return result;
    };
    CodeGenerator.prototype.generateAssignment = function(left, right, operator, precedence, flags) {
      if (Precedence.Assignment < precedence) {
        flags |= F_ALLOW_IN;
      }
      return parenthesize([
        this.generateExpression(left, Precedence.Call, flags),
        space + operator + space,
        this.generateExpression(right, Precedence.Assignment, flags)
      ], Precedence.Assignment, precedence);
    };
    CodeGenerator.prototype.semicolon = function(flags) {
      if (!semicolons && flags & F_SEMICOLON_OPT) {
        return "";
      }
      return ";";
    };
    CodeGenerator.Statement = {
      BlockStatement: function(stmt, flags) {
        var range2, content, result = ["{", newline], that = this;
        withIndent(function() {
          if (stmt.body.length === 0 && preserveBlankLines) {
            range2 = stmt.range;
            if (range2[1] - range2[0] > 2) {
              content = sourceCode.substring(range2[0] + 1, range2[1] - 1);
              if (content[0] === `
`) {
                result = ["{"];
              }
              result.push(content);
            }
          }
          var i2, iz, fragment, bodyFlags;
          bodyFlags = S_TFFF;
          if (flags & F_FUNC_BODY) {
            bodyFlags |= F_DIRECTIVE_CTX;
          }
          for (i2 = 0, iz = stmt.body.length;i2 < iz; ++i2) {
            if (preserveBlankLines) {
              if (i2 === 0) {
                if (stmt.body[0].leadingComments) {
                  range2 = stmt.body[0].leadingComments[0].extendedRange;
                  content = sourceCode.substring(range2[0], range2[1]);
                  if (content[0] === `
`) {
                    result = ["{"];
                  }
                }
                if (!stmt.body[0].leadingComments) {
                  generateBlankLines(stmt.range[0], stmt.body[0].range[0], result);
                }
              }
              if (i2 > 0) {
                if (!stmt.body[i2 - 1].trailingComments && !stmt.body[i2].leadingComments) {
                  generateBlankLines(stmt.body[i2 - 1].range[1], stmt.body[i2].range[0], result);
                }
              }
            }
            if (i2 === iz - 1) {
              bodyFlags |= F_SEMICOLON_OPT;
            }
            if (stmt.body[i2].leadingComments && preserveBlankLines) {
              fragment = that.generateStatement(stmt.body[i2], bodyFlags);
            } else {
              fragment = addIndent(that.generateStatement(stmt.body[i2], bodyFlags));
            }
            result.push(fragment);
            if (!endsWithLineTerminator(toSourceNodeWhenNeeded(fragment).toString())) {
              if (preserveBlankLines && i2 < iz - 1) {
                if (!stmt.body[i2 + 1].leadingComments) {
                  result.push(newline);
                }
              } else {
                result.push(newline);
              }
            }
            if (preserveBlankLines) {
              if (i2 === iz - 1) {
                if (!stmt.body[i2].trailingComments) {
                  generateBlankLines(stmt.body[i2].range[1], stmt.range[1], result);
                }
              }
            }
          }
        });
        result.push(addIndent("}"));
        return result;
      },
      BreakStatement: function(stmt, flags) {
        if (stmt.label) {
          return "break " + stmt.label.name + this.semicolon(flags);
        }
        return "break" + this.semicolon(flags);
      },
      ContinueStatement: function(stmt, flags) {
        if (stmt.label) {
          return "continue " + stmt.label.name + this.semicolon(flags);
        }
        return "continue" + this.semicolon(flags);
      },
      ClassBody: function(stmt, flags) {
        var result = ["{", newline], that = this;
        withIndent(function(indent2) {
          var i2, iz;
          for (i2 = 0, iz = stmt.body.length;i2 < iz; ++i2) {
            result.push(indent2);
            result.push(that.generateExpression(stmt.body[i2], Precedence.Sequence, E_TTT));
            if (i2 + 1 < iz) {
              result.push(newline);
            }
          }
        });
        if (!endsWithLineTerminator(toSourceNodeWhenNeeded(result).toString())) {
          result.push(newline);
        }
        result.push(base2);
        result.push("}");
        return result;
      },
      ClassDeclaration: function(stmt, flags) {
        var result, fragment;
        result = ["class"];
        if (stmt.id) {
          result = join(result, this.generateExpression(stmt.id, Precedence.Sequence, E_TTT));
        }
        if (stmt.superClass) {
          fragment = join("extends", this.generateExpression(stmt.superClass, Precedence.Unary, E_TTT));
          result = join(result, fragment);
        }
        result.push(space);
        result.push(this.generateStatement(stmt.body, S_TFFT));
        return result;
      },
      DirectiveStatement: function(stmt, flags) {
        if (extra.raw && stmt.raw) {
          return stmt.raw + this.semicolon(flags);
        }
        return escapeDirective(stmt.directive) + this.semicolon(flags);
      },
      DoWhileStatement: function(stmt, flags) {
        var result = join("do", this.maybeBlock(stmt.body, S_TFFF));
        result = this.maybeBlockSuffix(stmt.body, result);
        return join(result, [
          "while" + space + "(",
          this.generateExpression(stmt.test, Precedence.Sequence, E_TTT),
          ")" + this.semicolon(flags)
        ]);
      },
      CatchClause: function(stmt, flags) {
        var result, that = this;
        withIndent(function() {
          var guard;
          if (stmt.param) {
            result = [
              "catch" + space + "(",
              that.generateExpression(stmt.param, Precedence.Sequence, E_TTT),
              ")"
            ];
            if (stmt.guard) {
              guard = that.generateExpression(stmt.guard, Precedence.Sequence, E_TTT);
              result.splice(2, 0, " if ", guard);
            }
          } else {
            result = ["catch"];
          }
        });
        result.push(this.maybeBlock(stmt.body, S_TFFF));
        return result;
      },
      DebuggerStatement: function(stmt, flags) {
        return "debugger" + this.semicolon(flags);
      },
      EmptyStatement: function(stmt, flags) {
        return ";";
      },
      ExportDefaultDeclaration: function(stmt, flags) {
        var result = ["export"], bodyFlags;
        bodyFlags = flags & F_SEMICOLON_OPT ? S_TFFT : S_TFFF;
        result = join(result, "default");
        if (isStatement(stmt.declaration)) {
          result = join(result, this.generateStatement(stmt.declaration, bodyFlags));
        } else {
          result = join(result, this.generateExpression(stmt.declaration, Precedence.Assignment, E_TTT) + this.semicolon(flags));
        }
        return result;
      },
      ExportNamedDeclaration: function(stmt, flags) {
        var result = ["export"], bodyFlags, that = this;
        bodyFlags = flags & F_SEMICOLON_OPT ? S_TFFT : S_TFFF;
        if (stmt.declaration) {
          return join(result, this.generateStatement(stmt.declaration, bodyFlags));
        }
        if (stmt.specifiers) {
          if (stmt.specifiers.length === 0) {
            result = join(result, "{" + space + "}");
          } else if (stmt.specifiers[0].type === Syntax.ExportBatchSpecifier) {
            result = join(result, this.generateExpression(stmt.specifiers[0], Precedence.Sequence, E_TTT));
          } else {
            result = join(result, "{");
            withIndent(function(indent2) {
              var i2, iz;
              result.push(newline);
              for (i2 = 0, iz = stmt.specifiers.length;i2 < iz; ++i2) {
                result.push(indent2);
                result.push(that.generateExpression(stmt.specifiers[i2], Precedence.Sequence, E_TTT));
                if (i2 + 1 < iz) {
                  result.push("," + newline);
                }
              }
            });
            if (!endsWithLineTerminator(toSourceNodeWhenNeeded(result).toString())) {
              result.push(newline);
            }
            result.push(base2 + "}");
          }
          if (stmt.source) {
            result = join(result, [
              "from" + space,
              this.generateExpression(stmt.source, Precedence.Sequence, E_TTT),
              this.semicolon(flags)
            ]);
          } else {
            result.push(this.semicolon(flags));
          }
        }
        return result;
      },
      ExportAllDeclaration: function(stmt, flags) {
        return [
          "export" + space,
          "*" + space,
          "from" + space,
          this.generateExpression(stmt.source, Precedence.Sequence, E_TTT),
          this.semicolon(flags)
        ];
      },
      ExpressionStatement: function(stmt, flags) {
        var result, fragment;
        function isClassPrefixed(fragment2) {
          var code;
          if (fragment2.slice(0, 5) !== "class") {
            return false;
          }
          code = fragment2.charCodeAt(5);
          return code === 123 || esutils.code.isWhiteSpace(code) || esutils.code.isLineTerminator(code);
        }
        function isFunctionPrefixed(fragment2) {
          var code;
          if (fragment2.slice(0, 8) !== "function") {
            return false;
          }
          code = fragment2.charCodeAt(8);
          return code === 40 || esutils.code.isWhiteSpace(code) || code === 42 || esutils.code.isLineTerminator(code);
        }
        function isAsyncPrefixed(fragment2) {
          var code, i2, iz;
          if (fragment2.slice(0, 5) !== "async") {
            return false;
          }
          if (!esutils.code.isWhiteSpace(fragment2.charCodeAt(5))) {
            return false;
          }
          for (i2 = 6, iz = fragment2.length;i2 < iz; ++i2) {
            if (!esutils.code.isWhiteSpace(fragment2.charCodeAt(i2))) {
              break;
            }
          }
          if (i2 === iz) {
            return false;
          }
          if (fragment2.slice(i2, i2 + 8) !== "function") {
            return false;
          }
          code = fragment2.charCodeAt(i2 + 8);
          return code === 40 || esutils.code.isWhiteSpace(code) || code === 42 || esutils.code.isLineTerminator(code);
        }
        result = [this.generateExpression(stmt.expression, Precedence.Sequence, E_TTT)];
        fragment = toSourceNodeWhenNeeded(result).toString();
        if (fragment.charCodeAt(0) === 123 || isClassPrefixed(fragment) || isFunctionPrefixed(fragment) || isAsyncPrefixed(fragment) || directive && flags & F_DIRECTIVE_CTX && stmt.expression.type === Syntax.Literal && typeof stmt.expression.value === "string") {
          result = ["(", result, ")" + this.semicolon(flags)];
        } else {
          result.push(this.semicolon(flags));
        }
        return result;
      },
      ImportDeclaration: function(stmt, flags) {
        var result, cursor, that = this;
        if (stmt.specifiers.length === 0) {
          return [
            "import",
            space,
            this.generateExpression(stmt.source, Precedence.Sequence, E_TTT),
            this.semicolon(flags)
          ];
        }
        result = [
          "import"
        ];
        cursor = 0;
        if (stmt.specifiers[cursor].type === Syntax.ImportDefaultSpecifier) {
          result = join(result, [
            this.generateExpression(stmt.specifiers[cursor], Precedence.Sequence, E_TTT)
          ]);
          ++cursor;
        }
        if (stmt.specifiers[cursor]) {
          if (cursor !== 0) {
            result.push(",");
          }
          if (stmt.specifiers[cursor].type === Syntax.ImportNamespaceSpecifier) {
            result = join(result, [
              space,
              this.generateExpression(stmt.specifiers[cursor], Precedence.Sequence, E_TTT)
            ]);
          } else {
            result.push(space + "{");
            if (stmt.specifiers.length - cursor === 1) {
              result.push(space);
              result.push(this.generateExpression(stmt.specifiers[cursor], Precedence.Sequence, E_TTT));
              result.push(space + "}" + space);
            } else {
              withIndent(function(indent2) {
                var i2, iz;
                result.push(newline);
                for (i2 = cursor, iz = stmt.specifiers.length;i2 < iz; ++i2) {
                  result.push(indent2);
                  result.push(that.generateExpression(stmt.specifiers[i2], Precedence.Sequence, E_TTT));
                  if (i2 + 1 < iz) {
                    result.push("," + newline);
                  }
                }
              });
              if (!endsWithLineTerminator(toSourceNodeWhenNeeded(result).toString())) {
                result.push(newline);
              }
              result.push(base2 + "}" + space);
            }
          }
        }
        result = join(result, [
          "from" + space,
          this.generateExpression(stmt.source, Precedence.Sequence, E_TTT),
          this.semicolon(flags)
        ]);
        return result;
      },
      VariableDeclarator: function(stmt, flags) {
        var itemFlags = flags & F_ALLOW_IN ? E_TTT : E_FTT;
        if (stmt.init) {
          return [
            this.generateExpression(stmt.id, Precedence.Assignment, itemFlags),
            space,
            "=",
            space,
            this.generateExpression(stmt.init, Precedence.Assignment, itemFlags)
          ];
        }
        return this.generatePattern(stmt.id, Precedence.Assignment, itemFlags);
      },
      VariableDeclaration: function(stmt, flags) {
        var result, i2, iz, node, bodyFlags, that = this;
        result = [stmt.kind];
        bodyFlags = flags & F_ALLOW_IN ? S_TFFF : S_FFFF;
        function block() {
          node = stmt.declarations[0];
          if (extra.comment && node.leadingComments) {
            result.push(`
`);
            result.push(addIndent(that.generateStatement(node, bodyFlags)));
          } else {
            result.push(noEmptySpace());
            result.push(that.generateStatement(node, bodyFlags));
          }
          for (i2 = 1, iz = stmt.declarations.length;i2 < iz; ++i2) {
            node = stmt.declarations[i2];
            if (extra.comment && node.leadingComments) {
              result.push("," + newline);
              result.push(addIndent(that.generateStatement(node, bodyFlags)));
            } else {
              result.push("," + space);
              result.push(that.generateStatement(node, bodyFlags));
            }
          }
        }
        if (stmt.declarations.length > 1) {
          withIndent(block);
        } else {
          block();
        }
        result.push(this.semicolon(flags));
        return result;
      },
      ThrowStatement: function(stmt, flags) {
        return [join("throw", this.generateExpression(stmt.argument, Precedence.Sequence, E_TTT)), this.semicolon(flags)];
      },
      TryStatement: function(stmt, flags) {
        var result, i2, iz, guardedHandlers;
        result = ["try", this.maybeBlock(stmt.block, S_TFFF)];
        result = this.maybeBlockSuffix(stmt.block, result);
        if (stmt.handlers) {
          for (i2 = 0, iz = stmt.handlers.length;i2 < iz; ++i2) {
            result = join(result, this.generateStatement(stmt.handlers[i2], S_TFFF));
            if (stmt.finalizer || i2 + 1 !== iz) {
              result = this.maybeBlockSuffix(stmt.handlers[i2].body, result);
            }
          }
        } else {
          guardedHandlers = stmt.guardedHandlers || [];
          for (i2 = 0, iz = guardedHandlers.length;i2 < iz; ++i2) {
            result = join(result, this.generateStatement(guardedHandlers[i2], S_TFFF));
            if (stmt.finalizer || i2 + 1 !== iz) {
              result = this.maybeBlockSuffix(guardedHandlers[i2].body, result);
            }
          }
          if (stmt.handler) {
            if (Array.isArray(stmt.handler)) {
              for (i2 = 0, iz = stmt.handler.length;i2 < iz; ++i2) {
                result = join(result, this.generateStatement(stmt.handler[i2], S_TFFF));
                if (stmt.finalizer || i2 + 1 !== iz) {
                  result = this.maybeBlockSuffix(stmt.handler[i2].body, result);
                }
              }
            } else {
              result = join(result, this.generateStatement(stmt.handler, S_TFFF));
              if (stmt.finalizer) {
                result = this.maybeBlockSuffix(stmt.handler.body, result);
              }
            }
          }
        }
        if (stmt.finalizer) {
          result = join(result, ["finally", this.maybeBlock(stmt.finalizer, S_TFFF)]);
        }
        return result;
      },
      SwitchStatement: function(stmt, flags) {
        var result, fragment, i2, iz, bodyFlags, that = this;
        withIndent(function() {
          result = [
            "switch" + space + "(",
            that.generateExpression(stmt.discriminant, Precedence.Sequence, E_TTT),
            ")" + space + "{" + newline
          ];
        });
        if (stmt.cases) {
          bodyFlags = S_TFFF;
          for (i2 = 0, iz = stmt.cases.length;i2 < iz; ++i2) {
            if (i2 === iz - 1) {
              bodyFlags |= F_SEMICOLON_OPT;
            }
            fragment = addIndent(this.generateStatement(stmt.cases[i2], bodyFlags));
            result.push(fragment);
            if (!endsWithLineTerminator(toSourceNodeWhenNeeded(fragment).toString())) {
              result.push(newline);
            }
          }
        }
        result.push(addIndent("}"));
        return result;
      },
      SwitchCase: function(stmt, flags) {
        var result, fragment, i2, iz, bodyFlags, that = this;
        withIndent(function() {
          if (stmt.test) {
            result = [
              join("case", that.generateExpression(stmt.test, Precedence.Sequence, E_TTT)),
              ":"
            ];
          } else {
            result = ["default:"];
          }
          i2 = 0;
          iz = stmt.consequent.length;
          if (iz && stmt.consequent[0].type === Syntax.BlockStatement) {
            fragment = that.maybeBlock(stmt.consequent[0], S_TFFF);
            result.push(fragment);
            i2 = 1;
          }
          if (i2 !== iz && !endsWithLineTerminator(toSourceNodeWhenNeeded(result).toString())) {
            result.push(newline);
          }
          bodyFlags = S_TFFF;
          for (;i2 < iz; ++i2) {
            if (i2 === iz - 1 && flags & F_SEMICOLON_OPT) {
              bodyFlags |= F_SEMICOLON_OPT;
            }
            fragment = addIndent(that.generateStatement(stmt.consequent[i2], bodyFlags));
            result.push(fragment);
            if (i2 + 1 !== iz && !endsWithLineTerminator(toSourceNodeWhenNeeded(fragment).toString())) {
              result.push(newline);
            }
          }
        });
        return result;
      },
      IfStatement: function(stmt, flags) {
        var result, bodyFlags, semicolonOptional, that = this;
        withIndent(function() {
          result = [
            "if" + space + "(",
            that.generateExpression(stmt.test, Precedence.Sequence, E_TTT),
            ")"
          ];
        });
        semicolonOptional = flags & F_SEMICOLON_OPT;
        bodyFlags = S_TFFF;
        if (semicolonOptional) {
          bodyFlags |= F_SEMICOLON_OPT;
        }
        if (stmt.alternate) {
          result.push(this.maybeBlock(stmt.consequent, S_TFFF));
          result = this.maybeBlockSuffix(stmt.consequent, result);
          if (stmt.alternate.type === Syntax.IfStatement) {
            result = join(result, ["else ", this.generateStatement(stmt.alternate, bodyFlags)]);
          } else {
            result = join(result, join("else", this.maybeBlock(stmt.alternate, bodyFlags)));
          }
        } else {
          result.push(this.maybeBlock(stmt.consequent, bodyFlags));
        }
        return result;
      },
      ForStatement: function(stmt, flags) {
        var result, that = this;
        withIndent(function() {
          result = ["for" + space + "("];
          if (stmt.init) {
            if (stmt.init.type === Syntax.VariableDeclaration) {
              result.push(that.generateStatement(stmt.init, S_FFFF));
            } else {
              result.push(that.generateExpression(stmt.init, Precedence.Sequence, E_FTT));
              result.push(";");
            }
          } else {
            result.push(";");
          }
          if (stmt.test) {
            result.push(space);
            result.push(that.generateExpression(stmt.test, Precedence.Sequence, E_TTT));
            result.push(";");
          } else {
            result.push(";");
          }
          if (stmt.update) {
            result.push(space);
            result.push(that.generateExpression(stmt.update, Precedence.Sequence, E_TTT));
            result.push(")");
          } else {
            result.push(")");
          }
        });
        result.push(this.maybeBlock(stmt.body, flags & F_SEMICOLON_OPT ? S_TFFT : S_TFFF));
        return result;
      },
      ForInStatement: function(stmt, flags) {
        return this.generateIterationForStatement("in", stmt, flags & F_SEMICOLON_OPT ? S_TFFT : S_TFFF);
      },
      ForOfStatement: function(stmt, flags) {
        return this.generateIterationForStatement("of", stmt, flags & F_SEMICOLON_OPT ? S_TFFT : S_TFFF);
      },
      LabeledStatement: function(stmt, flags) {
        return [stmt.label.name + ":", this.maybeBlock(stmt.body, flags & F_SEMICOLON_OPT ? S_TFFT : S_TFFF)];
      },
      Program: function(stmt, flags) {
        var result, fragment, i2, iz, bodyFlags;
        iz = stmt.body.length;
        result = [safeConcatenation && iz > 0 ? `
` : ""];
        bodyFlags = S_TFTF;
        for (i2 = 0;i2 < iz; ++i2) {
          if (!safeConcatenation && i2 === iz - 1) {
            bodyFlags |= F_SEMICOLON_OPT;
          }
          if (preserveBlankLines) {
            if (i2 === 0) {
              if (!stmt.body[0].leadingComments) {
                generateBlankLines(stmt.range[0], stmt.body[i2].range[0], result);
              }
            }
            if (i2 > 0) {
              if (!stmt.body[i2 - 1].trailingComments && !stmt.body[i2].leadingComments) {
                generateBlankLines(stmt.body[i2 - 1].range[1], stmt.body[i2].range[0], result);
              }
            }
          }
          fragment = addIndent(this.generateStatement(stmt.body[i2], bodyFlags));
          result.push(fragment);
          if (i2 + 1 < iz && !endsWithLineTerminator(toSourceNodeWhenNeeded(fragment).toString())) {
            if (preserveBlankLines) {
              if (!stmt.body[i2 + 1].leadingComments) {
                result.push(newline);
              }
            } else {
              result.push(newline);
            }
          }
          if (preserveBlankLines) {
            if (i2 === iz - 1) {
              if (!stmt.body[i2].trailingComments) {
                generateBlankLines(stmt.body[i2].range[1], stmt.range[1], result);
              }
            }
          }
        }
        return result;
      },
      FunctionDeclaration: function(stmt, flags) {
        return [
          generateAsyncPrefix(stmt, true),
          "function",
          generateStarSuffix(stmt) || noEmptySpace(),
          stmt.id ? generateIdentifier(stmt.id) : "",
          this.generateFunctionBody(stmt)
        ];
      },
      ReturnStatement: function(stmt, flags) {
        if (stmt.argument) {
          return [join("return", this.generateExpression(stmt.argument, Precedence.Sequence, E_TTT)), this.semicolon(flags)];
        }
        return ["return" + this.semicolon(flags)];
      },
      WhileStatement: function(stmt, flags) {
        var result, that = this;
        withIndent(function() {
          result = [
            "while" + space + "(",
            that.generateExpression(stmt.test, Precedence.Sequence, E_TTT),
            ")"
          ];
        });
        result.push(this.maybeBlock(stmt.body, flags & F_SEMICOLON_OPT ? S_TFFT : S_TFFF));
        return result;
      },
      WithStatement: function(stmt, flags) {
        var result, that = this;
        withIndent(function() {
          result = [
            "with" + space + "(",
            that.generateExpression(stmt.object, Precedence.Sequence, E_TTT),
            ")"
          ];
        });
        result.push(this.maybeBlock(stmt.body, flags & F_SEMICOLON_OPT ? S_TFFT : S_TFFF));
        return result;
      }
    };
    merge2(CodeGenerator.prototype, CodeGenerator.Statement);
    CodeGenerator.Expression = {
      SequenceExpression: function(expr, precedence, flags) {
        var result, i2, iz;
        if (Precedence.Sequence < precedence) {
          flags |= F_ALLOW_IN;
        }
        result = [];
        for (i2 = 0, iz = expr.expressions.length;i2 < iz; ++i2) {
          result.push(this.generateExpression(expr.expressions[i2], Precedence.Assignment, flags));
          if (i2 + 1 < iz) {
            result.push("," + space);
          }
        }
        return parenthesize(result, Precedence.Sequence, precedence);
      },
      AssignmentExpression: function(expr, precedence, flags) {
        return this.generateAssignment(expr.left, expr.right, expr.operator, precedence, flags);
      },
      ArrowFunctionExpression: function(expr, precedence, flags) {
        return parenthesize(this.generateFunctionBody(expr), Precedence.ArrowFunction, precedence);
      },
      ConditionalExpression: function(expr, precedence, flags) {
        if (Precedence.Conditional < precedence) {
          flags |= F_ALLOW_IN;
        }
        return parenthesize([
          this.generateExpression(expr.test, Precedence.Coalesce, flags),
          space + "?" + space,
          this.generateExpression(expr.consequent, Precedence.Assignment, flags),
          space + ":" + space,
          this.generateExpression(expr.alternate, Precedence.Assignment, flags)
        ], Precedence.Conditional, precedence);
      },
      LogicalExpression: function(expr, precedence, flags) {
        if (expr.operator === "??") {
          flags |= F_FOUND_COALESCE;
        }
        return this.BinaryExpression(expr, precedence, flags);
      },
      BinaryExpression: function(expr, precedence, flags) {
        var result, leftPrecedence, rightPrecedence, currentPrecedence, fragment, leftSource;
        currentPrecedence = BinaryPrecedence[expr.operator];
        leftPrecedence = expr.operator === "**" ? Precedence.Postfix : currentPrecedence;
        rightPrecedence = expr.operator === "**" ? currentPrecedence : currentPrecedence + 1;
        if (currentPrecedence < precedence) {
          flags |= F_ALLOW_IN;
        }
        fragment = this.generateExpression(expr.left, leftPrecedence, flags);
        leftSource = fragment.toString();
        if (leftSource.charCodeAt(leftSource.length - 1) === 47 && esutils.code.isIdentifierPartES5(expr.operator.charCodeAt(0))) {
          result = [fragment, noEmptySpace(), expr.operator];
        } else {
          result = join(fragment, expr.operator);
        }
        fragment = this.generateExpression(expr.right, rightPrecedence, flags);
        if (expr.operator === "/" && fragment.toString().charAt(0) === "/" || expr.operator.slice(-1) === "<" && fragment.toString().slice(0, 3) === "!--") {
          result.push(noEmptySpace());
          result.push(fragment);
        } else {
          result = join(result, fragment);
        }
        if (expr.operator === "in" && !(flags & F_ALLOW_IN)) {
          return ["(", result, ")"];
        }
        if ((expr.operator === "||" || expr.operator === "&&") && flags & F_FOUND_COALESCE) {
          return ["(", result, ")"];
        }
        return parenthesize(result, currentPrecedence, precedence);
      },
      CallExpression: function(expr, precedence, flags) {
        var result, i2, iz;
        result = [this.generateExpression(expr.callee, Precedence.Call, E_TTF)];
        if (expr.optional) {
          result.push("?.");
        }
        result.push("(");
        for (i2 = 0, iz = expr["arguments"].length;i2 < iz; ++i2) {
          result.push(this.generateExpression(expr["arguments"][i2], Precedence.Assignment, E_TTT));
          if (i2 + 1 < iz) {
            result.push("," + space);
          }
        }
        result.push(")");
        if (!(flags & F_ALLOW_CALL)) {
          return ["(", result, ")"];
        }
        return parenthesize(result, Precedence.Call, precedence);
      },
      ChainExpression: function(expr, precedence, flags) {
        if (Precedence.OptionalChaining < precedence) {
          flags |= F_ALLOW_CALL;
        }
        var result = this.generateExpression(expr.expression, Precedence.OptionalChaining, flags);
        return parenthesize(result, Precedence.OptionalChaining, precedence);
      },
      NewExpression: function(expr, precedence, flags) {
        var result, length, i2, iz, itemFlags;
        length = expr["arguments"].length;
        itemFlags = flags & F_ALLOW_UNPARATH_NEW && !parentheses && length === 0 ? E_TFT : E_TFF;
        result = join("new", this.generateExpression(expr.callee, Precedence.New, itemFlags));
        if (!(flags & F_ALLOW_UNPARATH_NEW) || parentheses || length > 0) {
          result.push("(");
          for (i2 = 0, iz = length;i2 < iz; ++i2) {
            result.push(this.generateExpression(expr["arguments"][i2], Precedence.Assignment, E_TTT));
            if (i2 + 1 < iz) {
              result.push("," + space);
            }
          }
          result.push(")");
        }
        return parenthesize(result, Precedence.New, precedence);
      },
      MemberExpression: function(expr, precedence, flags) {
        var result, fragment;
        result = [this.generateExpression(expr.object, Precedence.Call, flags & F_ALLOW_CALL ? E_TTF : E_TFF)];
        if (expr.computed) {
          if (expr.optional) {
            result.push("?.");
          }
          result.push("[");
          result.push(this.generateExpression(expr.property, Precedence.Sequence, flags & F_ALLOW_CALL ? E_TTT : E_TFT));
          result.push("]");
        } else {
          if (!expr.optional && expr.object.type === Syntax.Literal && typeof expr.object.value === "number") {
            fragment = toSourceNodeWhenNeeded(result).toString();
            if (fragment.indexOf(".") < 0 && !/[eExX]/.test(fragment) && esutils.code.isDecimalDigit(fragment.charCodeAt(fragment.length - 1)) && !(fragment.length >= 2 && fragment.charCodeAt(0) === 48)) {
              result.push(" ");
            }
          }
          result.push(expr.optional ? "?." : ".");
          result.push(generateIdentifier(expr.property));
        }
        return parenthesize(result, Precedence.Member, precedence);
      },
      MetaProperty: function(expr, precedence, flags) {
        var result;
        result = [];
        result.push(typeof expr.meta === "string" ? expr.meta : generateIdentifier(expr.meta));
        result.push(".");
        result.push(typeof expr.property === "string" ? expr.property : generateIdentifier(expr.property));
        return parenthesize(result, Precedence.Member, precedence);
      },
      UnaryExpression: function(expr, precedence, flags) {
        var result, fragment, rightCharCode, leftSource, leftCharCode;
        fragment = this.generateExpression(expr.argument, Precedence.Unary, E_TTT);
        if (space === "") {
          result = join(expr.operator, fragment);
        } else {
          result = [expr.operator];
          if (expr.operator.length > 2) {
            result = join(result, fragment);
          } else {
            leftSource = toSourceNodeWhenNeeded(result).toString();
            leftCharCode = leftSource.charCodeAt(leftSource.length - 1);
            rightCharCode = fragment.toString().charCodeAt(0);
            if ((leftCharCode === 43 || leftCharCode === 45) && leftCharCode === rightCharCode || esutils.code.isIdentifierPartES5(leftCharCode) && esutils.code.isIdentifierPartES5(rightCharCode)) {
              result.push(noEmptySpace());
              result.push(fragment);
            } else {
              result.push(fragment);
            }
          }
        }
        return parenthesize(result, Precedence.Unary, precedence);
      },
      YieldExpression: function(expr, precedence, flags) {
        var result;
        if (expr.delegate) {
          result = "yield*";
        } else {
          result = "yield";
        }
        if (expr.argument) {
          result = join(result, this.generateExpression(expr.argument, Precedence.Yield, E_TTT));
        }
        return parenthesize(result, Precedence.Yield, precedence);
      },
      AwaitExpression: function(expr, precedence, flags) {
        var result = join(expr.all ? "await*" : "await", this.generateExpression(expr.argument, Precedence.Await, E_TTT));
        return parenthesize(result, Precedence.Await, precedence);
      },
      UpdateExpression: function(expr, precedence, flags) {
        if (expr.prefix) {
          return parenthesize([
            expr.operator,
            this.generateExpression(expr.argument, Precedence.Unary, E_TTT)
          ], Precedence.Unary, precedence);
        }
        return parenthesize([
          this.generateExpression(expr.argument, Precedence.Postfix, E_TTT),
          expr.operator
        ], Precedence.Postfix, precedence);
      },
      FunctionExpression: function(expr, precedence, flags) {
        var result = [
          generateAsyncPrefix(expr, true),
          "function"
        ];
        if (expr.id) {
          result.push(generateStarSuffix(expr) || noEmptySpace());
          result.push(generateIdentifier(expr.id));
        } else {
          result.push(generateStarSuffix(expr) || space);
        }
        result.push(this.generateFunctionBody(expr));
        return result;
      },
      ArrayPattern: function(expr, precedence, flags) {
        return this.ArrayExpression(expr, precedence, flags, true);
      },
      ArrayExpression: function(expr, precedence, flags, isPattern) {
        var result, multiline, that = this;
        if (!expr.elements.length) {
          return "[]";
        }
        multiline = isPattern ? false : expr.elements.length > 1;
        result = ["[", multiline ? newline : ""];
        withIndent(function(indent2) {
          var i2, iz;
          for (i2 = 0, iz = expr.elements.length;i2 < iz; ++i2) {
            if (!expr.elements[i2]) {
              if (multiline) {
                result.push(indent2);
              }
              if (i2 + 1 === iz) {
                result.push(",");
              }
            } else {
              result.push(multiline ? indent2 : "");
              result.push(that.generateExpression(expr.elements[i2], Precedence.Assignment, E_TTT));
            }
            if (i2 + 1 < iz) {
              result.push("," + (multiline ? newline : space));
            }
          }
        });
        if (multiline && !endsWithLineTerminator(toSourceNodeWhenNeeded(result).toString())) {
          result.push(newline);
        }
        result.push(multiline ? base2 : "");
        result.push("]");
        return result;
      },
      RestElement: function(expr, precedence, flags) {
        return "..." + this.generatePattern(expr.argument);
      },
      ClassExpression: function(expr, precedence, flags) {
        var result, fragment;
        result = ["class"];
        if (expr.id) {
          result = join(result, this.generateExpression(expr.id, Precedence.Sequence, E_TTT));
        }
        if (expr.superClass) {
          fragment = join("extends", this.generateExpression(expr.superClass, Precedence.Unary, E_TTT));
          result = join(result, fragment);
        }
        result.push(space);
        result.push(this.generateStatement(expr.body, S_TFFT));
        return result;
      },
      MethodDefinition: function(expr, precedence, flags) {
        var result, fragment;
        if (expr["static"]) {
          result = ["static" + space];
        } else {
          result = [];
        }
        if (expr.kind === "get" || expr.kind === "set") {
          fragment = [
            join(expr.kind, this.generatePropertyKey(expr.key, expr.computed)),
            this.generateFunctionBody(expr.value)
          ];
        } else {
          fragment = [
            generateMethodPrefix(expr),
            this.generatePropertyKey(expr.key, expr.computed),
            this.generateFunctionBody(expr.value)
          ];
        }
        return join(result, fragment);
      },
      Property: function(expr, precedence, flags) {
        if (expr.kind === "get" || expr.kind === "set") {
          return [
            expr.kind,
            noEmptySpace(),
            this.generatePropertyKey(expr.key, expr.computed),
            this.generateFunctionBody(expr.value)
          ];
        }
        if (expr.shorthand) {
          if (expr.value.type === "AssignmentPattern") {
            return this.AssignmentPattern(expr.value, Precedence.Sequence, E_TTT);
          }
          return this.generatePropertyKey(expr.key, expr.computed);
        }
        if (expr.method) {
          return [
            generateMethodPrefix(expr),
            this.generatePropertyKey(expr.key, expr.computed),
            this.generateFunctionBody(expr.value)
          ];
        }
        return [
          this.generatePropertyKey(expr.key, expr.computed),
          ":" + space,
          this.generateExpression(expr.value, Precedence.Assignment, E_TTT)
        ];
      },
      ObjectExpression: function(expr, precedence, flags) {
        var multiline, result, fragment, that = this;
        if (!expr.properties.length) {
          return "{}";
        }
        multiline = expr.properties.length > 1;
        withIndent(function() {
          fragment = that.generateExpression(expr.properties[0], Precedence.Sequence, E_TTT);
        });
        if (!multiline) {
          if (!hasLineTerminator(toSourceNodeWhenNeeded(fragment).toString())) {
            return ["{", space, fragment, space, "}"];
          }
        }
        withIndent(function(indent2) {
          var i2, iz;
          result = ["{", newline, indent2, fragment];
          if (multiline) {
            result.push("," + newline);
            for (i2 = 1, iz = expr.properties.length;i2 < iz; ++i2) {
              result.push(indent2);
              result.push(that.generateExpression(expr.properties[i2], Precedence.Sequence, E_TTT));
              if (i2 + 1 < iz) {
                result.push("," + newline);
              }
            }
          }
        });
        if (!endsWithLineTerminator(toSourceNodeWhenNeeded(result).toString())) {
          result.push(newline);
        }
        result.push(base2);
        result.push("}");
        return result;
      },
      AssignmentPattern: function(expr, precedence, flags) {
        return this.generateAssignment(expr.left, expr.right, "=", precedence, flags);
      },
      ObjectPattern: function(expr, precedence, flags) {
        var result, i2, iz, multiline, property, that = this;
        if (!expr.properties.length) {
          return "{}";
        }
        multiline = false;
        if (expr.properties.length === 1) {
          property = expr.properties[0];
          if (property.type === Syntax.Property && property.value.type !== Syntax.Identifier) {
            multiline = true;
          }
        } else {
          for (i2 = 0, iz = expr.properties.length;i2 < iz; ++i2) {
            property = expr.properties[i2];
            if (property.type === Syntax.Property && !property.shorthand) {
              multiline = true;
              break;
            }
          }
        }
        result = ["{", multiline ? newline : ""];
        withIndent(function(indent2) {
          var i3, iz2;
          for (i3 = 0, iz2 = expr.properties.length;i3 < iz2; ++i3) {
            result.push(multiline ? indent2 : "");
            result.push(that.generateExpression(expr.properties[i3], Precedence.Sequence, E_TTT));
            if (i3 + 1 < iz2) {
              result.push("," + (multiline ? newline : space));
            }
          }
        });
        if (multiline && !endsWithLineTerminator(toSourceNodeWhenNeeded(result).toString())) {
          result.push(newline);
        }
        result.push(multiline ? base2 : "");
        result.push("}");
        return result;
      },
      ThisExpression: function(expr, precedence, flags) {
        return "this";
      },
      Super: function(expr, precedence, flags) {
        return "super";
      },
      Identifier: function(expr, precedence, flags) {
        return generateIdentifier(expr);
      },
      ImportDefaultSpecifier: function(expr, precedence, flags) {
        return generateIdentifier(expr.id || expr.local);
      },
      ImportNamespaceSpecifier: function(expr, precedence, flags) {
        var result = ["*"];
        var id = expr.id || expr.local;
        if (id) {
          result.push(space + "as" + noEmptySpace() + generateIdentifier(id));
        }
        return result;
      },
      ImportSpecifier: function(expr, precedence, flags) {
        var imported = expr.imported;
        var result = [imported.name];
        var local = expr.local;
        if (local && local.name !== imported.name) {
          result.push(noEmptySpace() + "as" + noEmptySpace() + generateIdentifier(local));
        }
        return result;
      },
      ExportSpecifier: function(expr, precedence, flags) {
        var local = expr.local;
        var result = [local.name];
        var exported = expr.exported;
        if (exported && exported.name !== local.name) {
          result.push(noEmptySpace() + "as" + noEmptySpace() + generateIdentifier(exported));
        }
        return result;
      },
      Literal: function(expr, precedence, flags) {
        var raw;
        if (expr.hasOwnProperty("raw") && parse10 && extra.raw) {
          try {
            raw = parse10(expr.raw).body[0].expression;
            if (raw.type === Syntax.Literal) {
              if (raw.value === expr.value) {
                return expr.raw;
              }
            }
          } catch (e2) {}
        }
        if (expr.regex) {
          return "/" + expr.regex.pattern + "/" + expr.regex.flags;
        }
        if (typeof expr.value === "bigint") {
          return expr.value.toString() + "n";
        }
        if (expr.bigint) {
          return expr.bigint + "n";
        }
        if (expr.value === null) {
          return "null";
        }
        if (typeof expr.value === "string") {
          return escapeString(expr.value);
        }
        if (typeof expr.value === "number") {
          return generateNumber(expr.value);
        }
        if (typeof expr.value === "boolean") {
          return expr.value ? "true" : "false";
        }
        return generateRegExp(expr.value);
      },
      GeneratorExpression: function(expr, precedence, flags) {
        return this.ComprehensionExpression(expr, precedence, flags);
      },
      ComprehensionExpression: function(expr, precedence, flags) {
        var result, i2, iz, fragment, that = this;
        result = expr.type === Syntax.GeneratorExpression ? ["("] : ["["];
        if (extra.moz.comprehensionExpressionStartsWithAssignment) {
          fragment = this.generateExpression(expr.body, Precedence.Assignment, E_TTT);
          result.push(fragment);
        }
        if (expr.blocks) {
          withIndent(function() {
            for (i2 = 0, iz = expr.blocks.length;i2 < iz; ++i2) {
              fragment = that.generateExpression(expr.blocks[i2], Precedence.Sequence, E_TTT);
              if (i2 > 0 || extra.moz.comprehensionExpressionStartsWithAssignment) {
                result = join(result, fragment);
              } else {
                result.push(fragment);
              }
            }
          });
        }
        if (expr.filter) {
          result = join(result, "if" + space);
          fragment = this.generateExpression(expr.filter, Precedence.Sequence, E_TTT);
          result = join(result, ["(", fragment, ")"]);
        }
        if (!extra.moz.comprehensionExpressionStartsWithAssignment) {
          fragment = this.generateExpression(expr.body, Precedence.Assignment, E_TTT);
          result = join(result, fragment);
        }
        result.push(expr.type === Syntax.GeneratorExpression ? ")" : "]");
        return result;
      },
      ComprehensionBlock: function(expr, precedence, flags) {
        var fragment;
        if (expr.left.type === Syntax.VariableDeclaration) {
          fragment = [
            expr.left.kind,
            noEmptySpace(),
            this.generateStatement(expr.left.declarations[0], S_FFFF)
          ];
        } else {
          fragment = this.generateExpression(expr.left, Precedence.Call, E_TTT);
        }
        fragment = join(fragment, expr.of ? "of" : "in");
        fragment = join(fragment, this.generateExpression(expr.right, Precedence.Sequence, E_TTT));
        return ["for" + space + "(", fragment, ")"];
      },
      SpreadElement: function(expr, precedence, flags) {
        return [
          "...",
          this.generateExpression(expr.argument, Precedence.Assignment, E_TTT)
        ];
      },
      TaggedTemplateExpression: function(expr, precedence, flags) {
        var itemFlags = E_TTF;
        if (!(flags & F_ALLOW_CALL)) {
          itemFlags = E_TFF;
        }
        var result = [
          this.generateExpression(expr.tag, Precedence.Call, itemFlags),
          this.generateExpression(expr.quasi, Precedence.Primary, E_FFT)
        ];
        return parenthesize(result, Precedence.TaggedTemplate, precedence);
      },
      TemplateElement: function(expr, precedence, flags) {
        return expr.value.raw;
      },
      TemplateLiteral: function(expr, precedence, flags) {
        var result, i2, iz;
        result = ["`"];
        for (i2 = 0, iz = expr.quasis.length;i2 < iz; ++i2) {
          result.push(this.generateExpression(expr.quasis[i2], Precedence.Primary, E_TTT));
          if (i2 + 1 < iz) {
            result.push("${" + space);
            result.push(this.generateExpression(expr.expressions[i2], Precedence.Sequence, E_TTT));
            result.push(space + "}");
          }
        }
        result.push("`");
        return result;
      },
      ModuleSpecifier: function(expr, precedence, flags) {
        return this.Literal(expr, precedence, flags);
      },
      ImportExpression: function(expr, precedence, flag) {
        return parenthesize([
          "import(",
          this.generateExpression(expr.source, Precedence.Assignment, E_TTT),
          ")"
        ], Precedence.Call, precedence);
      }
    };
    merge2(CodeGenerator.prototype, CodeGenerator.Expression);
    CodeGenerator.prototype.generateExpression = function(expr, precedence, flags) {
      var result, type2;
      type2 = expr.type || Syntax.Property;
      if (extra.verbatim && expr.hasOwnProperty(extra.verbatim)) {
        return generateVerbatim(expr, precedence);
      }
      result = this[type2](expr, precedence, flags);
      if (extra.comment) {
        result = addComments(expr, result);
      }
      return toSourceNodeWhenNeeded(result, expr);
    };
    CodeGenerator.prototype.generateStatement = function(stmt, flags) {
      var result, fragment;
      result = this[stmt.type](stmt, flags);
      if (extra.comment) {
        result = addComments(stmt, result);
      }
      fragment = toSourceNodeWhenNeeded(result).toString();
      if (stmt.type === Syntax.Program && !safeConcatenation && newline === "" && fragment.charAt(fragment.length - 1) === `
`) {
        result = sourceMap ? toSourceNodeWhenNeeded(result).replaceRight(/\s+$/, "") : fragment.replace(/\s+$/, "");
      }
      return toSourceNodeWhenNeeded(result, stmt);
    };
    function generateInternal(node) {
      var codegen;
      codegen = new CodeGenerator;
      if (isStatement(node)) {
        return codegen.generateStatement(node, S_TFFF);
      }
      if (isExpression(node)) {
        return codegen.generateExpression(node, Precedence.Sequence, E_TTT);
      }
      throw new Error("Unknown node type: " + node.type);
    }
    function generate(node, options2) {
      var defaultOptions2 = getDefaultOptions(), result, pair;
      if (options2 != null) {
        if (typeof options2.indent === "string") {
          defaultOptions2.format.indent.style = options2.indent;
        }
        if (typeof options2.base === "number") {
          defaultOptions2.format.indent.base = options2.base;
        }
        options2 = updateDeeply(defaultOptions2, options2);
        indent = options2.format.indent.style;
        if (typeof options2.base === "string") {
          base2 = options2.base;
        } else {
          base2 = stringRepeat(indent, options2.format.indent.base);
        }
      } else {
        options2 = defaultOptions2;
        indent = options2.format.indent.style;
        base2 = stringRepeat(indent, options2.format.indent.base);
      }
      json2 = options2.format.json;
      renumber = options2.format.renumber;
      hexadecimal = json2 ? false : options2.format.hexadecimal;
      quotes = json2 ? "double" : options2.format.quotes;
      escapeless = options2.format.escapeless;
      newline = options2.format.newline;
      space = options2.format.space;
      if (options2.format.compact) {
        newline = space = indent = base2 = "";
      }
      parentheses = options2.format.parentheses;
      semicolons = options2.format.semicolons;
      safeConcatenation = options2.format.safeConcatenation;
      directive = options2.directive;
      parse10 = json2 ? null : options2.parse;
      sourceMap = options2.sourceMap;
      sourceCode = options2.sourceCode;
      preserveBlankLines = options2.format.preserveBlankLines && sourceCode !== null;
      extra = options2;
      if (sourceMap) {
        if (!exports.browser) {
          SourceNode = require_source_map().SourceNode;
        } else {
          SourceNode = global.sourceMap.SourceNode;
        }
      }
      result = generateInternal(node);
      if (!sourceMap) {
        pair = { code: result.toString(), map: null };
        return options2.sourceMapWithCode ? pair : pair.code;
      }
      pair = result.toStringWithSourceMap({
        file: options2.file,
        sourceRoot: options2.sourceMapRoot
      });
      if (options2.sourceContent) {
        pair.map.setSourceContent(options2.sourceMap, options2.sourceContent);
      }
      if (options2.sourceMapWithCode) {
        return pair;
      }
      return pair.map.toString();
    }
    FORMAT_MINIFY = {
      indent: {
        style: "",
        base: 0
      },
      renumber: true,
      hexadecimal: true,
      quotes: "auto",
      escapeless: true,
      compact: true,
      parentheses: false,
      semicolons: false
    };
    FORMAT_DEFAULTS = getDefaultOptions().format;
    exports.version = require_package().version;
    exports.generate = generate;
    exports.attachComments = estraverse.attachComments;
    exports.Precedence = updateDeeply({}, Precedence);
    exports.browser = false;
    exports.FORMAT_MINIFY = FORMAT_MINIFY;
    exports.FORMAT_DEFAULTS = FORMAT_DEFAULTS;
  })();
});

// node_modules/p5/dist/constants-ClrEsgSR.js
var _PI = Math.PI;
var VERSION = "2.1.1";
var P2D = "p2d";
var P2DHDR = "p2d-hdr";
var WEBGL = "webgl";
var WEBGL2 = "webgl2";
var ARROW = "default";
var SIMPLE = "simple";
var FULL = "full";
var CROSS = "crosshair";
var HAND = "pointer";
var MOVE = "move";
var TEXT = "text";
var WAIT = "wait";
var HALF_PI = _PI / 2;
var PI = _PI;
var QUARTER_PI = _PI / 4;
var TAU = _PI * 2;
var TWO_PI = _PI * 2;
var DEG_TO_RAD = _PI / 180;
var RAD_TO_DEG = 180 / _PI;
var CORNER = "corner";
var CORNERS = "corners";
var RADIUS = "radius";
var RIGHT = "right";
var LEFT = "left";
var CENTER = "center";
var TOP = "top";
var BOTTOM = "bottom";
var BASELINE = "alphabetic";
var POINTS = 0;
var LINES = 1;
var LINE_STRIP = 3;
var LINE_LOOP = 2;
var TRIANGLES = 4;
var TRIANGLE_FAN = 6;
var TRIANGLE_STRIP = 5;
var QUADS = "quads";
var QUAD_STRIP = "quad_strip";
var TESS = "tess";
var EMPTY_PATH = 7;
var PATH = 8;
var CLOSE = "close";
var OPEN = "open";
var CHORD = "chord";
var PIE = "pie";
var PROJECT = "square";
var SQUARE = "butt";
var ROUND = "round";
var BEVEL = "bevel";
var MITER = "miter";
var AUTO = "auto";
var ALT = "Alt";
var BACKSPACE = "Backspace";
var CONTROL = "Control";
var DELETE = "Delete";
var DOWN_ARROW = "ArrowDown";
var ENTER = "Enter";
var ESCAPE = "Escape";
var LEFT_ARROW = "ArrowLeft";
var OPTION = "Alt";
var RETURN = "Enter";
var RIGHT_ARROW = "ArrowRight";
var SHIFT = "Shift";
var TAB = "Tab";
var UP_ARROW = "ArrowUp";
var BLEND = "source-over";
var REMOVE = "destination-out";
var ADD = "lighter";
var DARKEST = "darken";
var LIGHTEST = "lighten";
var DIFFERENCE = "difference";
var SUBTRACT = "subtract";
var EXCLUSION = "exclusion";
var MULTIPLY = "multiply";
var SCREEN = "screen";
var REPLACE = "copy";
var OVERLAY = "overlay";
var HARD_LIGHT = "hard-light";
var SOFT_LIGHT = "soft-light";
var DODGE = "color-dodge";
var BURN = "color-burn";
var THRESHOLD = "threshold";
var GRAY = "gray";
var OPAQUE = "opaque";
var INVERT = "invert";
var POSTERIZE = "posterize";
var DILATE = "dilate";
var ERODE = "erode";
var BLUR = "blur";
var NORMAL = "normal";
var ITALIC = "italic";
var BOLD = "bold";
var BOLDITALIC = "bold italic";
var CHAR = "CHAR";
var WORD = "WORD";
var _DEFAULT_TEXT_FILL = "#000000";
var _DEFAULT_LEADMULT = 1.25;
var _CTX_MIDDLE = "middle";
var LINEAR = "linear";
var QUADRATIC = "quadratic";
var BEZIER = "bezier";
var CURVE = "curve";
var STROKE = "stroke";
var FILL = "fill";
var TEXTURE = "texture";
var IMMEDIATE = "immediate";
var IMAGE = "image";
var NEAREST = "nearest";
var REPEAT = "repeat";
var CLAMP = "clamp";
var MIRROR = "mirror";
var FLAT = "flat";
var SMOOTH = "smooth";
var LANDSCAPE = "landscape";
var PORTRAIT = "portrait";
var _DEFAULT_STROKE = "#000000";
var _DEFAULT_FILL = "#FFFFFF";
var GRID = "grid";
var AXES = "axes";
var LABEL = "label";
var FALLBACK = "fallback";
var CONTAIN = "contain";
var COVER = "cover";
var UNSIGNED_BYTE = "unsigned-byte";
var UNSIGNED_INT = "unsigned-int";
var FLOAT = "float";
var HALF_FLOAT = "half-float";
var INCLUDE = Symbol("include");
var EXCLUDE = Symbol("exclude");
var JOIN = Symbol("join");
var constants = /* @__PURE__ */ Object.freeze({
  __proto__: null,
  ADD,
  ALT,
  ARROW,
  AUTO,
  AXES,
  BACKSPACE,
  BASELINE,
  BEVEL,
  BEZIER,
  BLEND,
  BLUR,
  BOLD,
  BOLDITALIC,
  BOTTOM,
  BURN,
  CENTER,
  CHAR,
  CHORD,
  CLAMP,
  CLOSE,
  CONTAIN,
  CONTROL,
  CORNER,
  CORNERS,
  COVER,
  CROSS,
  CURVE,
  DARKEST,
  DEG_TO_RAD,
  DELETE,
  DIFFERENCE,
  DILATE,
  DODGE,
  DOWN_ARROW,
  EMPTY_PATH,
  ENTER,
  ERODE,
  ESCAPE,
  EXCLUDE,
  EXCLUSION,
  FALLBACK,
  FILL,
  FLAT,
  FLOAT,
  FULL,
  GRAY,
  GRID,
  HALF_FLOAT,
  HALF_PI,
  HAND,
  HARD_LIGHT,
  IMAGE,
  IMMEDIATE,
  INCLUDE,
  INVERT,
  ITALIC,
  JOIN,
  LABEL,
  LANDSCAPE,
  LEFT,
  LEFT_ARROW,
  LIGHTEST,
  LINEAR,
  LINES,
  LINE_LOOP,
  LINE_STRIP,
  MIRROR,
  MITER,
  MOVE,
  MULTIPLY,
  NEAREST,
  NORMAL,
  OPAQUE,
  OPEN,
  OPTION,
  OVERLAY,
  P2D,
  P2DHDR,
  PATH,
  PI,
  PIE,
  POINTS,
  PORTRAIT,
  POSTERIZE,
  PROJECT,
  QUADRATIC,
  QUADS,
  QUAD_STRIP,
  QUARTER_PI,
  RADIUS,
  RAD_TO_DEG,
  REMOVE,
  REPEAT,
  REPLACE,
  RETURN,
  RIGHT,
  RIGHT_ARROW,
  ROUND,
  SCREEN,
  SHIFT,
  SIMPLE,
  SMOOTH,
  SOFT_LIGHT,
  SQUARE,
  STROKE,
  SUBTRACT,
  TAB,
  TAU,
  TESS,
  TEXT,
  TEXTURE,
  THRESHOLD,
  TOP,
  TRIANGLES,
  TRIANGLE_FAN,
  TRIANGLE_STRIP,
  TWO_PI,
  UNSIGNED_BYTE,
  UNSIGNED_INT,
  UP_ARROW,
  VERSION,
  WAIT,
  WEBGL,
  WEBGL2,
  WORD,
  _CTX_MIDDLE,
  _DEFAULT_FILL,
  _DEFAULT_LEADMULT,
  _DEFAULT_STROKE,
  _DEFAULT_TEXT_FILL
});

// node_modules/p5/dist/core/transform.js
function transform(p52, fn2) {
  fn2.applyMatrix = function(...args) {
    let isTypedArray = args[0] instanceof Object.getPrototypeOf(Uint8Array);
    if (Array.isArray(args[0]) || isTypedArray) {
      this._renderer.applyMatrix(...args[0]);
    } else {
      this._renderer.applyMatrix(...args);
    }
    return this;
  };
  fn2.resetMatrix = function() {
    this._renderer.resetMatrix();
    return this;
  };
  fn2.rotate = function(angle, axis) {
    this._renderer.rotate(this._toRadians(angle), axis);
    return this;
  };
  fn2.rotateX = function(angle) {
    this._assert3d("rotateX");
    this._renderer.rotateX(this._toRadians(angle));
    return this;
  };
  fn2.rotateY = function(angle) {
    this._assert3d("rotateY");
    this._renderer.rotateY(this._toRadians(angle));
    return this;
  };
  fn2.rotateZ = function(angle) {
    this._assert3d("rotateZ");
    this._renderer.rotateZ(this._toRadians(angle));
    return this;
  };
  fn2.scale = function(x, y, z) {
    if (x instanceof p52.Vector) {
      const v = x;
      x = v.x;
      y = v.y;
      z = v.z;
    } else if (Array.isArray(x)) {
      const rg = x;
      x = rg[0];
      y = rg[1];
      z = rg[2] || 1;
    }
    if (isNaN(y)) {
      y = z = x;
    } else if (isNaN(z)) {
      z = 1;
    }
    this._renderer.scale(x, y, z);
    return this;
  };
  fn2.shearX = function(angle) {
    const rad = this._toRadians(angle);
    this._renderer.applyMatrix(1, 0, Math.tan(rad), 1, 0, 0);
    return this;
  };
  fn2.shearY = function(angle) {
    const rad = this._toRadians(angle);
    this._renderer.applyMatrix(1, Math.tan(rad), 0, 1, 0, 0);
    return this;
  };
  fn2.translate = function(x, y, z) {
    if (this._renderer.isP3D) {
      this._renderer.translate(x, y, z);
    } else {
      this._renderer.translate(x, y);
    }
    return this;
  };
  fn2.push = function() {
    this._renderer.push();
  };
  fn2.pop = function() {
    this._renderer.pop();
  };
}
if (typeof p5 !== "undefined") {
  transform(p5, p5.prototype);
}

// node_modules/p5/dist/core/structure.js
function structure(p52, fn2) {
  fn2.noLoop = function() {
    this._loop = false;
  };
  fn2.loop = function() {
    if (!this._loop) {
      this._loop = true;
      if (this._setupDone) {
        this._draw();
      }
    }
  };
  fn2.isLooping = function() {
    return this._loop;
  };
  fn2.redraw = async function(n) {
    if (this._inUserDraw || !this._setupDone) {
      return;
    }
    let numberOfRedraws = parseInt(n);
    if (isNaN(numberOfRedraws) || numberOfRedraws < 1) {
      numberOfRedraws = 1;
    }
    const context = this._isGlobal ? window : this;
    if (typeof context.draw === "function") {
      if (typeof context.setup === "undefined") {
        context.scale(context._pixelDensity, context._pixelDensity);
      }
      for (let idxRedraw = 0;idxRedraw < numberOfRedraws; idxRedraw++) {
        context.resetMatrix();
        if (this._accessibleOutputs.grid || this._accessibleOutputs.text) {
          this._updateAccsOutput();
        }
        if (this._renderer.isP3D) {
          this._renderer._update();
        }
        this.frameCount = context.frameCount + 1;
        await this._runLifecycleHook("predraw");
        this._inUserDraw = true;
        try {
          await context.draw();
        } finally {
          this._inUserDraw = false;
        }
        await this._runLifecycleHook("postdraw");
      }
    }
  };
}
if (typeof p5 !== "undefined") {
  structure(p5, p5.prototype);
}

// node_modules/p5/dist/core/environment.js
function environment(p52, fn2, lifecycles) {
  const standardCursors = [ARROW, CROSS, HAND, MOVE, TEXT, WAIT];
  fn2._frameRate = 0;
  fn2._lastFrameTime = window.performance.now();
  fn2._targetFrameRate = 60;
  const _windowPrint = window.print;
  let windowPrintDisabled = false;
  lifecycles.presetup = function() {
    const events = [
      "resize"
    ];
    for (const event of events) {
      window.addEventListener(event, this[`_on${event}`].bind(this), {
        passive: false,
        signal: this._removeSignal
      });
    }
  };
  fn2.print = function(...args) {
    if (!args.length) {
      if (!windowPrintDisabled) {
        _windowPrint();
        if (window.confirm("You just tried to print the webpage. Do you want to prevent this from running again?")) {
          windowPrintDisabled = true;
        }
      }
    } else {
      console.log(...args);
    }
  };
  fn2.frameCount = 0;
  fn2.deltaTime = 0;
  fn2.focused = document.hasFocus();
  fn2.cursor = function(type, x, y) {
    let cursor = "auto";
    const canvas = this._curElement.elt;
    if (standardCursors.includes(type)) {
      cursor = type;
    } else if (typeof type === "string") {
      let coords = "";
      if (x && y && (typeof x === "number" && typeof y === "number")) {
        coords = `${x} ${y}`;
      }
      if (type.substring(0, 7) === "http://" || type.substring(0, 8) === "https://") {
        cursor = `url(${type}) ${coords}, auto`;
      } else if (/\.(cur|jpg|jpeg|gif|png|CUR|JPG|JPEG|GIF|PNG)$/.test(type)) {
        cursor = `url(${type}) ${coords}, auto`;
      } else {
        cursor = type;
      }
    }
    canvas.style.cursor = cursor;
  };
  fn2.frameRate = function(fps) {
    if (typeof fps !== "number" || fps < 0) {
      return this._frameRate;
    } else {
      this._targetFrameRate = fps;
      if (fps === 0) {
        this._frameRate = fps;
      }
      return this;
    }
  };
  fn2.getFrameRate = function() {
    return this.frameRate();
  };
  fn2.setFrameRate = function(fps) {
    return this.frameRate(fps);
  };
  fn2.getTargetFrameRate = function() {
    return this._targetFrameRate;
  };
  fn2.noCursor = function() {
    this._curElement.elt.style.cursor = "none";
  };
  fn2.webglVersion = P2D;
  fn2.displayWidth = screen.width;
  fn2.displayHeight = screen.height;
  fn2.windowWidth = 0;
  fn2.windowHeight = 0;
  fn2._onresize = function(e2) {
    this.windowWidth = getWindowWidth();
    this.windowHeight = getWindowHeight();
    let executeDefault;
    if (typeof this._customActions.windowResized === "function") {
      executeDefault = this._customActions.windowResized(e2);
      if (executeDefault !== undefined && !executeDefault) {
        e2.preventDefault();
      }
    }
  };
  function getWindowWidth() {
    return window.innerWidth || document.documentElement && document.documentElement.clientWidth || document.body && document.body.clientWidth || 0;
  }
  function getWindowHeight() {
    return window.innerHeight || document.documentElement && document.documentElement.clientHeight || document.body && document.body.clientHeight || 0;
  }
  fn2._updateWindowSize = function() {
    this.windowWidth = getWindowWidth();
    this.windowHeight = getWindowHeight();
  };
  Object.defineProperty(fn2, "width", {
    get() {
      return this._renderer.width;
    }
  });
  Object.defineProperty(fn2, "height", {
    get() {
      return this._renderer.height;
    }
  });
  fn2.fullscreen = function(val) {
    if (typeof val === "undefined") {
      return document.fullscreenElement || document.webkitFullscreenElement || document.mozFullScreenElement || document.msFullscreenElement;
    } else {
      if (val) {
        launchFullscreen(document.documentElement);
      } else {
        exitFullscreen();
      }
    }
  };
  fn2.pixelDensity = function(val) {
    let returnValue;
    if (typeof val === "number") {
      if (val !== this._renderer._pixelDensity) {
        this._renderer._pixelDensity = val;
      }
      returnValue = this;
      this.resizeCanvas(this.width, this.height, true);
    } else {
      returnValue = this._renderer._pixelDensity;
    }
    return returnValue;
  };
  fn2.displayDensity = () => window.devicePixelRatio;
  function launchFullscreen(element) {
    const enabled = document.fullscreenEnabled || document.webkitFullscreenEnabled || document.mozFullScreenEnabled || document.msFullscreenEnabled;
    if (!enabled) {
      throw new Error("Fullscreen not enabled in this browser.");
    }
    if (element.requestFullscreen) {
      element.requestFullscreen();
    } else if (element.mozRequestFullScreen) {
      element.mozRequestFullScreen();
    } else if (element.webkitRequestFullscreen) {
      element.webkitRequestFullscreen();
    } else if (element.msRequestFullscreen) {
      element.msRequestFullscreen();
    }
  }
  function exitFullscreen() {
    if (document.exitFullscreen) {
      document.exitFullscreen();
    } else if (document.mozCancelFullScreen) {
      document.mozCancelFullScreen();
    } else if (document.webkitExitFullscreen) {
      document.webkitExitFullscreen();
    } else if (document.msExitFullscreen) {
      document.msExitFullscreen();
    }
  }
  fn2.getURL = () => location.href;
  fn2.getURLPath = () => location.pathname.split("/").filter((v) => v !== "");
  fn2.getURLParams = function() {
    const re = /[?&]([^&=]+)(?:[&=])([^&=]+)/gim;
    let m;
    const v = {};
    while ((m = re.exec(location.search)) != null) {
      if (m.index === re.lastIndex) {
        re.lastIndex++;
      }
      v[m[1]] = m[2];
    }
    return v;
  };
  fn2.worldToScreen = function(worldPosition) {
    if (typeof worldPosition === "number") {
      worldPosition = this.createVector(...arguments);
    }
    const matrix = this._renderer.getWorldToScreenMatrix();
    const screenPosition = matrix.multiplyAndNormalizePoint(worldPosition);
    return screenPosition;
  };
  fn2.screenToWorld = function(screenPosition) {
    if (typeof screenPosition === "number") {
      screenPosition = this.createVector(...arguments);
    }
    const matrix = this._renderer.getWorldToScreenMatrix();
    if (screenPosition.dimensions === 2) {
      let z = matrix.mat4[14] / matrix.mat4[15];
      screenPosition = this.createVector(screenPosition.x, screenPosition.y, z);
    }
    const matrixInverse = matrix.invert(matrix);
    const worldPosition = matrixInverse.multiplyAndNormalizePoint(screenPosition);
    return worldPosition;
  };
}
if (typeof p5 !== "undefined") {
  environment(p5, p5.prototype);
}

// node_modules/colorjs.io/src/multiply-matrices.js
function multiplyMatrices(A, B) {
  let m = A.length;
  if (!Array.isArray(A[0])) {
    A = [A];
  }
  if (!Array.isArray(B[0])) {
    B = B.map((x) => [x]);
  }
  let p = B[0].length;
  let B_cols = B[0].map((_, i) => B.map((x) => x[i]));
  let product = A.map((row) => B_cols.map((col) => {
    let ret = 0;
    if (!Array.isArray(row)) {
      for (let c of col) {
        ret += row * c;
      }
      return ret;
    }
    for (let i = 0;i < row.length; i++) {
      ret += row[i] * (col[i] || 0);
    }
    return ret;
  }));
  if (m === 1) {
    product = product[0];
  }
  if (p === 1) {
    return product.map((x) => x[0]);
  }
  return product;
}

// node_modules/colorjs.io/src/util.js
function isString(str) {
  return type(str) === "string";
}
function type(o) {
  let str = Object.prototype.toString.call(o);
  return (str.match(/^\[object\s+(.*?)\]$/)[1] || "").toLowerCase();
}
function serializeNumber(n, { precision, unit }) {
  if (isNone(n)) {
    return "none";
  }
  return toPrecision(n, precision) + (unit ?? "");
}
function isNone(n) {
  return Number.isNaN(n) || n instanceof Number && n?.none;
}
function toPrecision(n, precision) {
  if (n === 0) {
    return 0;
  }
  let integer = ~~n;
  let digits = 0;
  if (integer && precision) {
    digits = ~~Math.log10(Math.abs(integer)) + 1;
  }
  const multiplier = 10 ** (precision - digits);
  return Math.floor(n * multiplier + 0.5) / multiplier;
}
var angleFactor = {
  deg: 1,
  grad: 0.9,
  rad: 180 / Math.PI,
  turn: 360
};
function parseFunction(str) {
  if (!str) {
    return;
  }
  str = str.trim();
  const isFunctionRegex = /^([a-z]+)\((.+?)\)$/i;
  const isNumberRegex = /^-?[\d.]+$/;
  const unitValueRegex = /%|deg|g?rad|turn$/;
  const singleArgument = /\/?\s*(none|[-\w.]+(?:%|deg|g?rad|turn)?)/g;
  let parts = str.match(isFunctionRegex);
  if (parts) {
    let args = [];
    parts[2].replace(singleArgument, ($0, rawArg) => {
      let match = rawArg.match(unitValueRegex);
      let arg = rawArg;
      if (match) {
        let unit = match[0];
        let unitlessArg = arg.slice(0, -unit.length);
        if (unit === "%") {
          arg = new Number(unitlessArg / 100);
          arg.type = "<percentage>";
        } else {
          arg = new Number(unitlessArg * angleFactor[unit]);
          arg.type = "<angle>";
          arg.unit = unit;
        }
      } else if (isNumberRegex.test(arg)) {
        arg = new Number(arg);
        arg.type = "<number>";
      } else if (arg === "none") {
        arg = new Number(NaN);
        arg.none = true;
      }
      if ($0.startsWith("/")) {
        arg = arg instanceof Number ? arg : new Number(arg);
        arg.alpha = true;
      }
      if (typeof arg === "object" && arg instanceof Number) {
        arg.raw = rawArg;
      }
      args.push(arg);
    });
    return {
      name: parts[1].toLowerCase(),
      rawName: parts[1],
      rawArgs: parts[2],
      args
    };
  }
}
function last(arr) {
  return arr[arr.length - 1];
}
function interpolate(start, end, p) {
  if (isNaN(start)) {
    return end;
  }
  if (isNaN(end)) {
    return start;
  }
  return start + (end - start) * p;
}
function interpolateInv(start, end, value) {
  return (value - start) / (end - start);
}
function mapRange(from, to, value) {
  return interpolate(to[0], to[1], interpolateInv(from[0], from[1], value));
}
function parseCoordGrammar(coordGrammars) {
  return coordGrammars.map((coordGrammar) => {
    return coordGrammar.split("|").map((type2) => {
      type2 = type2.trim();
      let range = type2.match(/^(<[a-z]+>)\[(-?[.\d]+),\s*(-?[.\d]+)\]?$/);
      if (range) {
        let ret = new String(range[1]);
        ret.range = [+range[2], +range[3]];
        return ret;
      }
      return type2;
    });
  });
}
function clamp(min, val, max) {
  return Math.max(Math.min(max, val), min);
}
function copySign(to, from) {
  return Math.sign(to) === Math.sign(from) ? to : -to;
}
function spow(base, exp) {
  return copySign(Math.abs(base) ** exp, base);
}
function zdiv(n, d) {
  return d === 0 ? 0 : n / d;
}
function bisectLeft(arr, value, lo = 0, hi = arr.length) {
  while (lo < hi) {
    const mid = lo + hi >> 1;
    if (arr[mid] < value) {
      lo = mid + 1;
    } else {
      hi = mid;
    }
  }
  return lo;
}

// node_modules/colorjs.io/src/hooks.js
class Hooks {
  add(name, callback, first) {
    if (typeof arguments[0] != "string") {
      for (var name in arguments[0]) {
        this.add(name, arguments[0][name], arguments[1]);
      }
      return;
    }
    (Array.isArray(name) ? name : [name]).forEach(function(name2) {
      this[name2] = this[name2] || [];
      if (callback) {
        this[name2][first ? "unshift" : "push"](callback);
      }
    }, this);
  }
  run(name, env) {
    this[name] = this[name] || [];
    this[name].forEach(function(callback) {
      callback.call(env && env.context ? env.context : env, env);
    });
  }
}
var hooks = new Hooks;
var hooks_default = hooks;

// node_modules/colorjs.io/src/adapt.js
var WHITES = {
  D50: [0.3457 / 0.3585, 1, (1 - 0.3457 - 0.3585) / 0.3585],
  D65: [0.3127 / 0.329, 1, (1 - 0.3127 - 0.329) / 0.329]
};
function getWhite(name) {
  if (Array.isArray(name)) {
    return name;
  }
  return WHITES[name];
}
function adapt(W1, W2, XYZ, options2 = {}) {
  W1 = getWhite(W1);
  W2 = getWhite(W2);
  if (!W1 || !W2) {
    throw new TypeError(`Missing white point to convert ${!W1 ? "from" : ""}${!W1 && !W2 ? "/" : ""}${!W2 ? "to" : ""}`);
  }
  if (W1 === W2) {
    return XYZ;
  }
  let env = { W1, W2, XYZ, options: options2 };
  hooks_default.run("chromatic-adaptation-start", env);
  if (!env.M) {
    if (env.W1 === WHITES.D65 && env.W2 === WHITES.D50) {
      env.M = [
        [1.0479297925449969, 0.022946870601609652, -0.05019226628920524],
        [0.02962780877005599, 0.9904344267538799, -0.017073799063418826],
        [-0.009243040646204504, 0.015055191490298152, 0.7518742814281371]
      ];
    } else if (env.W1 === WHITES.D50 && env.W2 === WHITES.D65) {
      env.M = [
        [0.955473421488075, -0.02309845494876471, 0.06325924320057072],
        [-0.0283697093338637, 1.0099953980813041, 0.021041441191917323],
        [0.012314014864481998, -0.020507649298898964, 1.330365926242124]
      ];
    }
  }
  hooks_default.run("chromatic-adaptation-end", env);
  if (env.M) {
    return multiplyMatrices(env.M, env.XYZ);
  } else {
    throw new TypeError("Only Bradford CAT with white points D50 and D65 supported for now.");
  }
}

// node_modules/colorjs.io/src/defaults.js
var defaults_default = {
  gamut_mapping: "css",
  precision: 5,
  deltaE: "76",
  verbose: globalThis?.process?.env?.NODE_ENV?.toLowerCase() !== "test",
  warn: function warn(msg) {
    if (this.verbose) {
      globalThis?.console?.warn?.(msg);
    }
  }
};

// node_modules/colorjs.io/src/parse.js
var noneTypes = new Set(["<number>", "<percentage>", "<angle>"]);
function coerceCoords(space, format, name, coords) {
  let types = Object.entries(space.coords).map(([id, coordMeta], i) => {
    let coordGrammar = format.coordGrammar[i];
    let arg = coords[i];
    let providedType = arg?.type;
    let type2;
    if (arg.none) {
      type2 = coordGrammar.find((c) => noneTypes.has(c));
    } else {
      type2 = coordGrammar.find((c) => c == providedType);
    }
    if (!type2) {
      let coordName = coordMeta.name || id;
      throw new TypeError(`${providedType ?? arg.raw} not allowed for ${coordName} in ${name}()`);
    }
    let fromRange = type2.range;
    if (providedType === "<percentage>") {
      fromRange ||= [0, 1];
    }
    let toRange = coordMeta.range || coordMeta.refRange;
    if (fromRange && toRange) {
      coords[i] = mapRange(fromRange, toRange, coords[i]);
    }
    return type2;
  });
  return types;
}
function parse(str, { meta } = {}) {
  let env = { str: String(str)?.trim() };
  hooks_default.run("parse-start", env);
  if (env.color) {
    return env.color;
  }
  env.parsed = parseFunction(env.str);
  if (env.parsed) {
    let name = env.parsed.name;
    if (name === "color") {
      let id = env.parsed.args.shift();
      let alternateId = id.startsWith("--") ? id.substring(2) : `--${id}`;
      let ids = [id, alternateId];
      let alpha = env.parsed.rawArgs.indexOf("/") > 0 ? env.parsed.args.pop() : 1;
      for (let space of ColorSpace.all) {
        let colorSpec = space.getFormat("color");
        if (colorSpec) {
          if (ids.includes(colorSpec.id) || colorSpec.ids?.filter((specId) => ids.includes(specId)).length) {
            const coords = Object.keys(space.coords).map((_, i) => env.parsed.args[i] || 0);
            let types;
            if (colorSpec.coordGrammar) {
              types = coerceCoords(space, colorSpec, "color", coords);
            }
            if (meta) {
              Object.assign(meta, { formatId: "color", types });
            }
            if (colorSpec.id.startsWith("--") && !id.startsWith("--")) {
              defaults_default.warn(`${space.name} is a non-standard space and not currently supported in the CSS spec. ` + `Use prefixed color(${colorSpec.id}) instead of color(${id}).`);
            }
            if (id.startsWith("--") && !colorSpec.id.startsWith("--")) {
              defaults_default.warn(`${space.name} is a standard space and supported in the CSS spec. ` + `Use color(${colorSpec.id}) instead of prefixed color(${id}).`);
            }
            return { spaceId: space.id, coords, alpha };
          }
        }
      }
      let didYouMean = "";
      let registryId = id in ColorSpace.registry ? id : alternateId;
      if (registryId in ColorSpace.registry) {
        let cssId = ColorSpace.registry[registryId].formats?.color?.id;
        if (cssId) {
          didYouMean = `Did you mean color(${cssId})?`;
        }
      }
      throw new TypeError(`Cannot parse color(${id}). ` + (didYouMean || "Missing a plugin?"));
    } else {
      for (let space of ColorSpace.all) {
        let format = space.getFormat(name);
        if (format && format.type === "function") {
          let alpha = 1;
          if (format.lastAlpha || last(env.parsed.args).alpha) {
            alpha = env.parsed.args.pop();
          }
          let coords = env.parsed.args;
          let types;
          if (format.coordGrammar) {
            types = coerceCoords(space, format, name, coords);
          }
          if (meta) {
            Object.assign(meta, { formatId: format.name, types });
          }
          return {
            spaceId: space.id,
            coords,
            alpha
          };
        }
      }
    }
  } else {
    for (let space of ColorSpace.all) {
      for (let formatId in space.formats) {
        let format = space.formats[formatId];
        if (format.type !== "custom") {
          continue;
        }
        if (format.test && !format.test(env.str)) {
          continue;
        }
        let color = format.parse(env.str);
        if (color) {
          color.alpha ??= 1;
          if (meta) {
            meta.formatId = formatId;
          }
          return color;
        }
      }
    }
  }
  throw new TypeError(`Could not parse ${str} as a color. Missing a plugin?`);
}

// node_modules/colorjs.io/src/getColor.js
function getColor(color) {
  if (Array.isArray(color)) {
    return color.map(getColor);
  }
  if (!color) {
    throw new TypeError("Empty color reference");
  }
  if (isString(color)) {
    color = parse(color);
  }
  let space = color.space || color.spaceId;
  if (!(space instanceof ColorSpace)) {
    color.space = ColorSpace.get(space);
  }
  if (color.alpha === undefined) {
    color.alpha = 1;
  }
  return color;
}

// node_modules/colorjs.io/src/space.js
var  = 0.000075;

class ColorSpace {
  constructor(options2) {
    this.id = options2.id;
    this.name = options2.name;
    this.base = options2.base ? ColorSpace.get(options2.base) : null;
    this.aliases = options2.aliases;
    if (this.base) {
      this.fromBase = options2.fromBase;
      this.toBase = options2.toBase;
    }
    let coords = options2.coords ?? this.base.coords;
    for (let name in coords) {
      if (!("name" in coords[name])) {
        coords[name].name = name;
      }
    }
    this.coords = coords;
    let white = options2.white ?? this.base.white ?? "D65";
    this.white = getWhite(white);
    this.formats = options2.formats ?? {};
    for (let name in this.formats) {
      let format = this.formats[name];
      format.type ||= "function";
      format.name ||= name;
    }
    if (!this.formats.color?.id) {
      this.formats.color = {
        ...this.formats.color ?? {},
        id: options2.cssId || this.id
      };
    }
    if (options2.gamutSpace) {
      this.gamutSpace = options2.gamutSpace === "self" ? this : ColorSpace.get(options2.gamutSpace);
    } else {
      if (this.isPolar) {
        this.gamutSpace = this.base;
      } else {
        this.gamutSpace = this;
      }
    }
    if (this.gamutSpace.isUnbounded) {
      this.inGamut = (coords2, options3) => {
        return true;
      };
    }
    this.referred = options2.referred;
    Object.defineProperty(this, "path", {
      value: getPath(this).reverse(),
      writable: false,
      enumerable: true,
      configurable: true
    });
    hooks_default.run("colorspace-init-end", this);
  }
  inGamut(coords, { epsilon =  } = {}) {
    if (!this.equals(this.gamutSpace)) {
      coords = this.to(this.gamutSpace, coords);
      return this.gamutSpace.inGamut(coords, { epsilon });
    }
    let coordMeta = Object.values(this.coords);
    return coords.every((c, i) => {
      let meta = coordMeta[i];
      if (meta.type !== "angle" && meta.range) {
        if (Number.isNaN(c)) {
          return true;
        }
        let [min, max] = meta.range;
        return (min === undefined || c >= min - epsilon) && (max === undefined || c <= max + epsilon);
      }
      return true;
    });
  }
  get isUnbounded() {
    return Object.values(this.coords).every((coord) => !("range" in coord));
  }
  get cssId() {
    return this.formats?.color?.id || this.id;
  }
  get isPolar() {
    for (let id in this.coords) {
      if (this.coords[id].type === "angle") {
        return true;
      }
    }
    return false;
  }
  getFormat(format) {
    if (typeof format === "object") {
      format = processFormat(format, this);
      return format;
    }
    let ret;
    if (format === "default") {
      ret = Object.values(this.formats)[0];
    } else {
      ret = this.formats[format];
    }
    if (ret) {
      ret = processFormat(ret, this);
      return ret;
    }
    return null;
  }
  equals(space) {
    if (!space) {
      return false;
    }
    return this === space || this.id === space || this.id === space.id;
  }
  to(space, coords) {
    if (arguments.length === 1) {
      const color = getColor(space);
      [space, coords] = [color.space, color.coords];
    }
    space = ColorSpace.get(space);
    if (this.equals(space)) {
      return coords;
    }
    coords = coords.map((c) => Number.isNaN(c) ? 0 : c);
    let myPath = this.path;
    let otherPath = space.path;
    let connectionSpace, connectionSpaceIndex;
    for (let i = 0;i < myPath.length; i++) {
      if (myPath[i].equals(otherPath[i])) {
        connectionSpace = myPath[i];
        connectionSpaceIndex = i;
      } else {
        break;
      }
    }
    if (!connectionSpace) {
      throw new Error(`Cannot convert between color spaces ${this} and ${space}: no connection space was found`);
    }
    for (let i = myPath.length - 1;i > connectionSpaceIndex; i--) {
      coords = myPath[i].toBase(coords);
    }
    for (let i = connectionSpaceIndex + 1;i < otherPath.length; i++) {
      coords = otherPath[i].fromBase(coords);
    }
    return coords;
  }
  from(space, coords) {
    if (arguments.length === 1) {
      const color = getColor(space);
      [space, coords] = [color.space, color.coords];
    }
    space = ColorSpace.get(space);
    return space.to(this, coords);
  }
  toString() {
    return `${this.name} (${this.id})`;
  }
  getMinCoords() {
    let ret = [];
    for (let id in this.coords) {
      let meta = this.coords[id];
      let range = meta.range || meta.refRange;
      ret.push(range?.min ?? 0);
    }
    return ret;
  }
  static registry = {};
  static get all() {
    return [...new Set(Object.values(ColorSpace.registry))];
  }
  static register(id, space) {
    if (arguments.length === 1) {
      space = arguments[0];
      id = space.id;
    }
    space = this.get(space);
    if (this.registry[id] && this.registry[id] !== space) {
      throw new Error(`Duplicate color space registration: '${id}'`);
    }
    this.registry[id] = space;
    if (arguments.length === 1 && space.aliases) {
      for (let alias of space.aliases) {
        this.register(alias, space);
      }
    }
    return space;
  }
  static get(space, ...alternatives) {
    if (!space || space instanceof ColorSpace) {
      return space;
    }
    let argType = type(space);
    if (argType === "string") {
      let ret = ColorSpace.registry[space.toLowerCase()];
      if (!ret) {
        throw new TypeError(`No color space found with id = "${space}"`);
      }
      return ret;
    }
    if (alternatives.length) {
      return ColorSpace.get(...alternatives);
    }
    throw new TypeError(`${space} is not a valid color space`);
  }
  static resolveCoord(ref, workingSpace) {
    let coordType = type(ref);
    let space, coord;
    if (coordType === "string") {
      if (ref.includes(".")) {
        [space, coord] = ref.split(".");
      } else {
        [space, coord] = [, ref];
      }
    } else if (Array.isArray(ref)) {
      [space, coord] = ref;
    } else {
      space = ref.space;
      coord = ref.coordId;
    }
    space = ColorSpace.get(space);
    if (!space) {
      space = workingSpace;
    }
    if (!space) {
      throw new TypeError(`Cannot resolve coordinate reference ${ref}: No color space specified and relative references are not allowed here`);
    }
    coordType = type(coord);
    if (coordType === "number" || coordType === "string" && coord >= 0) {
      let meta = Object.entries(space.coords)[coord];
      if (meta) {
        return { space, id: meta[0], index: coord, ...meta[1] };
      }
    }
    space = ColorSpace.get(space);
    let normalizedCoord = coord.toLowerCase();
    let i = 0;
    for (let id in space.coords) {
      let meta = space.coords[id];
      if (id.toLowerCase() === normalizedCoord || meta.name?.toLowerCase() === normalizedCoord) {
        return { space, id, index: i, ...meta };
      }
      i++;
    }
    throw new TypeError(`No "${coord}" coordinate found in ${space.name}. Its coordinates are: ${Object.keys(space.coords).join(", ")}`);
  }
  static DEFAULT_FORMAT = {
    type: "functions",
    name: "color"
  };
}
function getPath(space) {
  let ret = [space];
  for (let s = space;s = s.base; ) {
    ret.push(s);
  }
  return ret;
}
function processFormat(format, { coords } = {}) {
  if (format.coords && !format.coordGrammar) {
    format.type ||= "function";
    format.name ||= "color";
    format.coordGrammar = parseCoordGrammar(format.coords);
    let coordFormats = Object.entries(coords).map(([id, coordMeta], i) => {
      let outputType = format.coordGrammar[i][0];
      let fromRange = coordMeta.range || coordMeta.refRange;
      let toRange = outputType.range, suffix = "";
      if (outputType == "<percentage>") {
        toRange = [0, 100];
        suffix = "%";
      } else if (outputType == "<angle>") {
        suffix = "deg";
      }
      return { fromRange, toRange, suffix };
    });
    format.serializeCoords = (coords2, precision) => {
      return coords2.map((c, i) => {
        let { fromRange, toRange, suffix } = coordFormats[i];
        if (fromRange && toRange) {
          c = mapRange(fromRange, toRange, c);
        }
        c = serializeNumber(c, { precision, unit: suffix });
        return c;
      });
    };
  }
  return format;
}
// node_modules/colorjs.io/src/spaces/xyz-d65.js
var xyz_d65_default = new ColorSpace({
  id: "xyz-d65",
  name: "XYZ D65",
  coords: {
    x: { name: "X" },
    y: { name: "Y" },
    z: { name: "Z" }
  },
  white: "D65",
  formats: {
    color: {
      ids: ["xyz-d65", "xyz"]
    }
  },
  aliases: ["xyz"]
});

// node_modules/colorjs.io/src/rgbspace.js
class RGBColorSpace extends ColorSpace {
  constructor(options2) {
    if (!options2.coords) {
      options2.coords = {
        r: {
          range: [0, 1],
          name: "Red"
        },
        g: {
          range: [0, 1],
          name: "Green"
        },
        b: {
          range: [0, 1],
          name: "Blue"
        }
      };
    }
    if (!options2.base) {
      options2.base = xyz_d65_default;
    }
    if (options2.toXYZ_M && options2.fromXYZ_M) {
      options2.toBase ??= (rgb) => {
        let xyz = multiplyMatrices(options2.toXYZ_M, rgb);
        if (this.white !== this.base.white) {
          xyz = adapt(this.white, this.base.white, xyz);
        }
        return xyz;
      };
      options2.fromBase ??= (xyz) => {
        xyz = adapt(this.base.white, this.white, xyz);
        return multiplyMatrices(options2.fromXYZ_M, xyz);
      };
    }
    options2.referred ??= "display";
    super(options2);
  }
}

// node_modules/colorjs.io/src/getAll.js
function getAll(color, space) {
  color = getColor(color);
  if (!space || color.space.equals(space)) {
    return color.coords.slice();
  }
  space = ColorSpace.get(space);
  return space.from(color);
}

// node_modules/colorjs.io/src/get.js
function get(color, prop) {
  color = getColor(color);
  let { space, index } = ColorSpace.resolveCoord(prop, color.space);
  let coords = getAll(color, space);
  return coords[index];
}

// node_modules/colorjs.io/src/setAll.js
function setAll(color, space, coords) {
  color = getColor(color);
  space = ColorSpace.get(space);
  color.coords = space.to(color.space, coords);
  return color;
}
setAll.returns = "color";

// node_modules/colorjs.io/src/set.js
function set(color, prop, value) {
  color = getColor(color);
  if (arguments.length === 2 && type(arguments[1]) === "object") {
    let object = arguments[1];
    for (let p in object) {
      set(color, p, object[p]);
    }
  } else {
    if (typeof value === "function") {
      value = value(get(color, prop));
    }
    let { space, index } = ColorSpace.resolveCoord(prop, color.space);
    let coords = getAll(color, space);
    coords[index] = value;
    setAll(color, space, coords);
  }
  return color;
}
set.returns = "color";
// node_modules/colorjs.io/src/spaces/xyz-d50.js
var xyz_d50_default = new ColorSpace({
  id: "xyz-d50",
  name: "XYZ D50",
  white: "D50",
  base: xyz_d65_default,
  fromBase: (coords) => adapt(xyz_d65_default.white, "D50", coords),
  toBase: (coords) => adapt("D50", xyz_d65_default.white, coords)
});

// node_modules/colorjs.io/src/spaces/lab.js
var 2 = 216 / 24389;
var 3 = 24 / 116;
var  = 24389 / 27;
var white = WHITES.D50;
var lab_default = new ColorSpace({
  id: "lab",
  name: "Lab",
  coords: {
    l: {
      refRange: [0, 100],
      name: "Lightness"
    },
    a: {
      refRange: [-125, 125]
    },
    b: {
      refRange: [-125, 125]
    }
  },
  white,
  base: xyz_d50_default,
  fromBase(XYZ) {
    let xyz = XYZ.map((value, i) => value / white[i]);
    let f = xyz.map((value) => value > 2 ? Math.cbrt(value) : ( * value + 16) / 116);
    return [
      116 * f[1] - 16,
      500 * (f[0] - f[1]),
      200 * (f[1] - f[2])
    ];
  },
  toBase(Lab) {
    let f = [];
    f[1] = (Lab[0] + 16) / 116;
    f[0] = Lab[1] / 500 + f[1];
    f[2] = f[1] - Lab[2] / 200;
    let xyz = [
      f[0] > 3 ? Math.pow(f[0], 3) : (116 * f[0] - 16) / ,
      Lab[0] > 8 ? Math.pow((Lab[0] + 16) / 116, 3) : Lab[0] / ,
      f[2] > 3 ? Math.pow(f[2], 3) : (116 * f[2] - 16) / 
    ];
    return xyz.map((value, i) => value * white[i]);
  },
  formats: {
    lab: {
      coords: ["<number> | <percentage>", "<number> | <percentage>[-1,1]", "<number> | <percentage>[-1,1]"]
    }
  }
});

// node_modules/colorjs.io/src/angles.js
function constrain(angle) {
  return (angle % 360 + 360) % 360;
}
function adjust(arc, angles) {
  if (arc === "raw") {
    return angles;
  }
  let [a1, a2] = angles.map(constrain);
  let angleDiff = a2 - a1;
  if (arc === "increasing") {
    if (angleDiff < 0) {
      a2 += 360;
    }
  } else if (arc === "decreasing") {
    if (angleDiff > 0) {
      a1 += 360;
    }
  } else if (arc === "longer") {
    if (-180 < angleDiff && angleDiff < 180) {
      if (angleDiff > 0) {
        a1 += 360;
      } else {
        a2 += 360;
      }
    }
  } else if (arc === "shorter") {
    if (angleDiff > 180) {
      a1 += 360;
    } else if (angleDiff < -180) {
      a2 += 360;
    }
  }
  return [a1, a2];
}

// node_modules/colorjs.io/src/spaces/lch.js
var lch_default = new ColorSpace({
  id: "lch",
  name: "LCH",
  coords: {
    l: {
      refRange: [0, 100],
      name: "Lightness"
    },
    c: {
      refRange: [0, 150],
      name: "Chroma"
    },
    h: {
      refRange: [0, 360],
      type: "angle",
      name: "Hue"
    }
  },
  base: lab_default,
  fromBase(Lab) {
    let [L, a, b] = Lab;
    let hue;
    const 4 = 0.02;
    if (Math.abs(a) < 4 && Math.abs(b) < 4) {
      hue = NaN;
    } else {
      hue = Math.atan2(b, a) * 180 / Math.PI;
    }
    return [
      L,
      Math.sqrt(a ** 2 + b ** 2),
      constrain(hue)
    ];
  },
  toBase(LCH) {
    let [Lightness, Chroma, Hue] = LCH;
    if (Chroma < 0) {
      Chroma = 0;
    }
    if (isNaN(Hue)) {
      Hue = 0;
    }
    return [
      Lightness,
      Chroma * Math.cos(Hue * Math.PI / 180),
      Chroma * Math.sin(Hue * Math.PI / 180)
    ];
  },
  formats: {
    lch: {
      coords: ["<number> | <percentage>", "<number> | <percentage>", "<number> | <angle>"]
    }
  }
});

// node_modules/colorjs.io/src/deltaE/deltaE2000.js
var Gfactor = 25 ** 7;
var  = Math.PI;
var r2d = 180 / ;
var d2r =  / 180;
function pow7(x) {
  const x2 = x * x;
  const x7 = x2 * x2 * x2 * x;
  return x7;
}
function deltaE2000_default(color, sample, { kL = 1, kC = 1, kH = 1 } = {}) {
  [color, sample] = getColor([color, sample]);
  let [L1, a1, b1] = lab_default.from(color);
  let C1 = lch_default.from(lab_default, [L1, a1, b1])[1];
  let [L2, a2, b2] = lab_default.from(sample);
  let C2 = lch_default.from(lab_default, [L2, a2, b2])[1];
  if (C1 < 0) {
    C1 = 0;
  }
  if (C2 < 0) {
    C2 = 0;
  }
  let Cbar = (C1 + C2) / 2;
  let C7 = pow7(Cbar);
  let G = 0.5 * (1 - Math.sqrt(C7 / (C7 + Gfactor)));
  let adash1 = (1 + G) * a1;
  let adash2 = (1 + G) * a2;
  let Cdash1 = Math.sqrt(adash1 ** 2 + b1 ** 2);
  let Cdash2 = Math.sqrt(adash2 ** 2 + b2 ** 2);
  let h1 = adash1 === 0 && b1 === 0 ? 0 : Math.atan2(b1, adash1);
  let h2 = adash2 === 0 && b2 === 0 ? 0 : Math.atan2(b2, adash2);
  if (h1 < 0) {
    h1 += 2 * ;
  }
  if (h2 < 0) {
    h2 += 2 * ;
  }
  h1 *= r2d;
  h2 *= r2d;
  let L = L2 - L1;
  let C = Cdash2 - Cdash1;
  let hdiff = h2 - h1;
  let hsum = h1 + h2;
  let habs = Math.abs(hdiff);
  let h;
  if (Cdash1 * Cdash2 === 0) {
    h = 0;
  } else if (habs <= 180) {
    h = hdiff;
  } else if (hdiff > 180) {
    h = hdiff - 360;
  } else if (hdiff < -180) {
    h = hdiff + 360;
  } else {
    defaults_default.warn("the unthinkable has happened");
  }
  let H = 2 * Math.sqrt(Cdash2 * Cdash1) * Math.sin(h * d2r / 2);
  let Ldash = (L1 + L2) / 2;
  let Cdash = (Cdash1 + Cdash2) / 2;
  let Cdash7 = pow7(Cdash);
  let hdash;
  if (Cdash1 * Cdash2 === 0) {
    hdash = hsum;
  } else if (habs <= 180) {
    hdash = hsum / 2;
  } else if (hsum < 360) {
    hdash = (hsum + 360) / 2;
  } else {
    hdash = (hsum - 360) / 2;
  }
  let lsq = (Ldash - 50) ** 2;
  let SL = 1 + 0.015 * lsq / Math.sqrt(20 + lsq);
  let SC = 1 + 0.045 * Cdash;
  let T = 1;
  T -= 0.17 * Math.cos((hdash - 30) * d2r);
  T += 0.24 * Math.cos(2 * hdash * d2r);
  T += 0.32 * Math.cos((3 * hdash + 6) * d2r);
  T -= 0.2 * Math.cos((4 * hdash - 63) * d2r);
  let SH = 1 + 0.015 * Cdash * T;
  let _ = 30 * Math.exp(-1 * ((hdash - 275) / 25) ** 2);
  let RC = 2 * Math.sqrt(Cdash7 / (Cdash7 + Gfactor));
  let RT = -1 * Math.sin(2 * _ * d2r) * RC;
  let dE = (L / (kL * SL)) ** 2;
  dE += (C / (kC * SC)) ** 2;
  dE += (H / (kH * SH)) ** 2;
  dE += RT * (C / (kC * SC)) * (H / (kH * SH));
  return Math.sqrt(dE);
}

// node_modules/colorjs.io/src/spaces/oklab.js
var XYZtoLMS_M = [
  [0.819022437996703, 0.3619062600528904, -0.1288737815209879],
  [0.0329836539323885, 0.9292868615863434, 0.0361446663506424],
  [0.0481771893596242, 0.2642395317527308, 0.6335478284694309]
];
var LMStoXYZ_M = [
  [1.2268798758459243, -0.5578149944602171, 0.2813910456659647],
  [-0.0405757452148008, 1.112286803280317, -0.0717110580655164],
  [-0.0763729366746601, -0.4214933324022432, 1.5869240198367816]
];
var LMStoLab_M = [
  [0.210454268309314, 0.7936177747023054, -0.0040720430116193],
  [1.9779985324311684, -2.42859224204858, 0.450593709617411],
  [0.0259040424655478, 0.7827717124575296, -0.8086757549230774]
];
var LabtoLMS_M = [
  [1, 0.3963377773761749, 0.2158037573099136],
  [1, -0.1055613458156586, -0.0638541728258133],
  [1, -0.0894841775298119, -1.2914855480194092]
];
var oklab_default = new ColorSpace({
  id: "oklab",
  name: "Oklab",
  coords: {
    l: {
      refRange: [0, 1],
      name: "Lightness"
    },
    a: {
      refRange: [-0.4, 0.4]
    },
    b: {
      refRange: [-0.4, 0.4]
    }
  },
  white: "D65",
  base: xyz_d65_default,
  fromBase(XYZ) {
    let LMS = multiplyMatrices(XYZtoLMS_M, XYZ);
    let LMSg = LMS.map((val) => Math.cbrt(val));
    return multiplyMatrices(LMStoLab_M, LMSg);
  },
  toBase(OKLab) {
    let LMSg = multiplyMatrices(LabtoLMS_M, OKLab);
    let LMS = LMSg.map((val) => val ** 3);
    return multiplyMatrices(LMStoXYZ_M, LMS);
  },
  formats: {
    oklab: {
      coords: ["<percentage> | <number>", "<number> | <percentage>[-1,1]", "<number> | <percentage>[-1,1]"]
    }
  }
});

// node_modules/colorjs.io/src/deltaE/deltaEOK.js
function deltaEOK_default(color, sample) {
  [color, sample] = getColor([color, sample]);
  let [L1, a1, b1] = oklab_default.from(color);
  let [L2, a2, b2] = oklab_default.from(sample);
  let L = L1 - L2;
  let a = a1 - a2;
  let b = b1 - b2;
  return Math.sqrt(L ** 2 + a ** 2 + b ** 2);
}

// node_modules/colorjs.io/src/inGamut.js
var 4 = 0.000075;
function inGamut(color, space, { epsilon = 4 } = {}) {
  color = getColor(color);
  if (!space) {
    space = color.space;
  }
  space = ColorSpace.get(space);
  let coords = color.coords;
  if (space !== color.space) {
    coords = space.from(color);
  }
  return space.inGamut(coords, { epsilon });
}

// node_modules/colorjs.io/src/clone.js
function clone(color) {
  return {
    space: color.space,
    coords: color.coords.slice(),
    alpha: color.alpha
  };
}

// node_modules/colorjs.io/src/distance.js
function distance(color1, color2, space = "lab") {
  space = ColorSpace.get(space);
  let coords1 = space.from(color1);
  let coords2 = space.from(color2);
  return Math.sqrt(coords1.reduce((acc, c1, i) => {
    let c2 = coords2[i];
    if (isNaN(c1) || isNaN(c2)) {
      return acc;
    }
    return acc + (c2 - c1) ** 2;
  }, 0));
}

// node_modules/colorjs.io/src/deltaE/deltaE76.js
function deltaE76(color, sample) {
  return distance(color, sample, "lab");
}

// node_modules/colorjs.io/src/deltaE/deltaECMC.js
var 2 = Math.PI;
var d2r2 = 2 / 180;
function deltaECMC_default(color, sample, { l = 2, c = 1 } = {}) {
  [color, sample] = getColor([color, sample]);
  let [L1, a1, b1] = lab_default.from(color);
  let [, C1, H1] = lch_default.from(lab_default, [L1, a1, b1]);
  let [L2, a2, b2] = lab_default.from(sample);
  let C2 = lch_default.from(lab_default, [L2, a2, b2])[1];
  if (C1 < 0) {
    C1 = 0;
  }
  if (C2 < 0) {
    C2 = 0;
  }
  let L = L1 - L2;
  let C = C1 - C2;
  let a = a1 - a2;
  let b = b1 - b2;
  let H2 = a ** 2 + b ** 2 - C ** 2;
  let SL = 0.511;
  if (L1 >= 16) {
    SL = 0.040975 * L1 / (1 + 0.01765 * L1);
  }
  let SC = 0.0638 * C1 / (1 + 0.0131 * C1) + 0.638;
  let T;
  if (Number.isNaN(H1)) {
    H1 = 0;
  }
  if (H1 >= 164 && H1 <= 345) {
    T = 0.56 + Math.abs(0.2 * Math.cos((H1 + 168) * d2r2));
  } else {
    T = 0.36 + Math.abs(0.4 * Math.cos((H1 + 35) * d2r2));
  }
  let C4 = Math.pow(C1, 4);
  let F = Math.sqrt(C4 / (C4 + 1900));
  let SH = SC * (F * T + 1 - F);
  let dE = (L / (l * SL)) ** 2;
  dE += (C / (c * SC)) ** 2;
  dE += H2 / SH ** 2;
  return Math.sqrt(dE);
}

// node_modules/colorjs.io/src/spaces/xyz-abs-d65.js
var Yw = 203;
var xyz_abs_d65_default = new ColorSpace({
  id: "xyz-abs-d65",
  cssId: "--xyz-abs-d65",
  name: "Absolute XYZ D65",
  coords: {
    x: {
      refRange: [0, 9504.7],
      name: "Xa"
    },
    y: {
      refRange: [0, 1e4],
      name: "Ya"
    },
    z: {
      refRange: [0, 10888.3],
      name: "Za"
    }
  },
  base: xyz_d65_default,
  fromBase(XYZ) {
    return XYZ.map((v) => Math.max(v * Yw, 0));
  },
  toBase(AbsXYZ) {
    return AbsXYZ.map((v) => Math.max(v / Yw, 0));
  }
});

// node_modules/colorjs.io/src/spaces/jzazbz.js
var b = 1.15;
var g = 0.66;
var n = 2610 / 2 ** 14;
var ninv = 2 ** 14 / 2610;
var c1 = 3424 / 2 ** 12;
var c2 = 2413 / 2 ** 7;
var c3 = 2392 / 2 ** 7;
var p = 1.7 * 2523 / 2 ** 5;
var pinv = 2 ** 5 / (1.7 * 2523);
var d = -0.56;
var d0 = 0.000000000016295499532821565;
var XYZtoCone_M = [
  [0.41478972, 0.579999, 0.014648],
  [-0.20151, 1.120649, 0.0531008],
  [-0.0166008, 0.2648, 0.6684799]
];
var ConetoXYZ_M = [
  [1.9242264357876067, -1.0047923125953657, 0.037651404030618],
  [0.35031676209499907, 0.7264811939316552, -0.06538442294808501],
  [-0.09098281098284752, -0.3127282905230739, 1.5227665613052603]
];
var ConetoIab_M = [
  [0.5, 0.5, 0],
  [3.524, -4.066708, 0.542708],
  [0.199076, 1.096799, -1.295875]
];
var IabtoCone_M = [
  [1, 0.1386050432715393, 0.05804731615611886],
  [0.9999999999999999, -0.1386050432715393, -0.05804731615611886],
  [0.9999999999999998, -0.09601924202631895, -0.8118918960560388]
];
var jzazbz_default = new ColorSpace({
  id: "jzazbz",
  name: "Jzazbz",
  coords: {
    jz: {
      refRange: [0, 1],
      name: "Jz"
    },
    az: {
      refRange: [-0.5, 0.5]
    },
    bz: {
      refRange: [-0.5, 0.5]
    }
  },
  base: xyz_abs_d65_default,
  fromBase(XYZ) {
    let [Xa, Ya, Za] = XYZ;
    let Xm = b * Xa - (b - 1) * Za;
    let Ym = g * Ya - (g - 1) * Xa;
    let LMS = multiplyMatrices(XYZtoCone_M, [Xm, Ym, Za]);
    let PQLMS = LMS.map(function(val) {
      let num = c1 + c2 * (val / 1e4) ** n;
      let denom = 1 + c3 * (val / 1e4) ** n;
      return (num / denom) ** p;
    });
    let [Iz, az, bz] = multiplyMatrices(ConetoIab_M, PQLMS);
    let Jz = (1 + d) * Iz / (1 + d * Iz) - d0;
    return [Jz, az, bz];
  },
  toBase(Jzazbz) {
    let [Jz, az, bz] = Jzazbz;
    let Iz = (Jz + d0) / (1 + d - d * (Jz + d0));
    let PQLMS = multiplyMatrices(IabtoCone_M, [Iz, az, bz]);
    let LMS = PQLMS.map(function(val) {
      let num = c1 - val ** pinv;
      let denom = c3 * val ** pinv - c2;
      let x = 1e4 * (num / denom) ** ninv;
      return x;
    });
    let [Xm, Ym, Za] = multiplyMatrices(ConetoXYZ_M, LMS);
    let Xa = (Xm + (b - 1) * Za) / b;
    let Ya = (Ym + (g - 1) * Xa) / g;
    return [Xa, Ya, Za];
  },
  formats: {
    color: {
      coords: ["<number> | <percentage>", "<number> | <percentage>[-1,1]", "<number> | <percentage>[-1,1]"]
    }
  }
});

// node_modules/colorjs.io/src/spaces/jzczhz.js
var jzczhz_default = new ColorSpace({
  id: "jzczhz",
  name: "JzCzHz",
  coords: {
    jz: {
      refRange: [0, 1],
      name: "Jz"
    },
    cz: {
      refRange: [0, 1],
      name: "Chroma"
    },
    hz: {
      refRange: [0, 360],
      type: "angle",
      name: "Hue"
    }
  },
  base: jzazbz_default,
  fromBase(jzazbz) {
    let [Jz, az, bz] = jzazbz;
    let hue;
    const 5 = 0.0002;
    if (Math.abs(az) < 5 && Math.abs(bz) < 5) {
      hue = NaN;
    } else {
      hue = Math.atan2(bz, az) * 180 / Math.PI;
    }
    return [
      Jz,
      Math.sqrt(az ** 2 + bz ** 2),
      constrain(hue)
    ];
  },
  toBase(jzczhz) {
    return [
      jzczhz[0],
      jzczhz[1] * Math.cos(jzczhz[2] * Math.PI / 180),
      jzczhz[1] * Math.sin(jzczhz[2] * Math.PI / 180)
    ];
  }
});

// node_modules/colorjs.io/src/deltaE/deltaEJz.js
function deltaEJz_default(color, sample) {
  [color, sample] = getColor([color, sample]);
  let [Jz1, Cz1, Hz1] = jzczhz_default.from(color);
  let [Jz2, Cz2, Hz2] = jzczhz_default.from(sample);
  let J = Jz1 - Jz2;
  let C = Cz1 - Cz2;
  if (Number.isNaN(Hz1) && Number.isNaN(Hz2)) {
    Hz1 = 0;
    Hz2 = 0;
  } else if (Number.isNaN(Hz1)) {
    Hz1 = Hz2;
  } else if (Number.isNaN(Hz2)) {
    Hz2 = Hz1;
  }
  let h = Hz1 - Hz2;
  let H = 2 * Math.sqrt(Cz1 * Cz2) * Math.sin(h / 2 * (Math.PI / 180));
  return Math.sqrt(J ** 2 + C ** 2 + H ** 2);
}

// node_modules/colorjs.io/src/spaces/ictcp.js
var c12 = 3424 / 4096;
var c22 = 2413 / 128;
var c32 = 2392 / 128;
var m1 = 2610 / 16384;
var m2 = 2523 / 32;
var im1 = 16384 / 2610;
var im2 = 32 / 2523;
var XYZtoLMS_M2 = [
  [0.3592832590121217, 0.6976051147779502, -0.035891593232029],
  [-0.1920808463704993, 1.100476797037432, 0.0753748658519118],
  [0.0070797844607479, 0.0748396662186362, 0.8433265453898765]
];
var LMStoIPT_M = [
  [2048 / 4096, 2048 / 4096, 0],
  [6610 / 4096, -13613 / 4096, 7003 / 4096],
  [17933 / 4096, -17390 / 4096, -543 / 4096]
];
var IPTtoLMS_M = [
  [0.9999999999999998, 0.0086090370379328, 0.111029625003026],
  [0.9999999999999998, -0.0086090370379328, -0.1110296250030259],
  [0.9999999999999998, 0.5600313357106791, -0.3206271749873188]
];
var LMStoXYZ_M2 = [
  [2.0701522183894223, -1.3263473389671563, 0.2066510476294053],
  [0.3647385209748072, 0.6805660249472273, -0.0453045459220347],
  [-0.0497472075358123, -0.0492609666966131, 1.1880659249923042]
];
var ictcp_default = new ColorSpace({
  id: "ictcp",
  name: "ICTCP",
  coords: {
    i: {
      refRange: [0, 1],
      name: "I"
    },
    ct: {
      refRange: [-0.5, 0.5],
      name: "CT"
    },
    cp: {
      refRange: [-0.5, 0.5],
      name: "CP"
    }
  },
  base: xyz_abs_d65_default,
  fromBase(XYZ) {
    let LMS = multiplyMatrices(XYZtoLMS_M2, XYZ);
    return LMStoICtCp(LMS);
  },
  toBase(ICtCp) {
    let LMS = ICtCptoLMS(ICtCp);
    return multiplyMatrices(LMStoXYZ_M2, LMS);
  }
});
function LMStoICtCp(LMS) {
  let PQLMS = LMS.map(function(val) {
    let num = c12 + c22 * (val / 1e4) ** m1;
    let denom = 1 + c32 * (val / 1e4) ** m1;
    return (num / denom) ** m2;
  });
  return multiplyMatrices(LMStoIPT_M, PQLMS);
}
function ICtCptoLMS(ICtCp) {
  let PQLMS = multiplyMatrices(IPTtoLMS_M, ICtCp);
  let LMS = PQLMS.map(function(val) {
    let num = Math.max(val ** im2 - c12, 0);
    let denom = c22 - c32 * val ** im2;
    return 1e4 * (num / denom) ** im1;
  });
  return LMS;
}

// node_modules/colorjs.io/src/deltaE/deltaEITP.js
function deltaEITP_default(color, sample) {
  [color, sample] = getColor([color, sample]);
  let [I1, T1, P1] = ictcp_default.from(color);
  let [I2, T2, P2] = ictcp_default.from(sample);
  return 720 * Math.sqrt((I1 - I2) ** 2 + 0.25 * (T1 - T2) ** 2 + (P1 - P2) ** 2);
}

// node_modules/colorjs.io/src/spaces/cam16.js
var white2 = WHITES.D65;
var adaptedCoef = 0.42;
var adaptedCoefInv = 1 / adaptedCoef;
var tau = 2 * Math.PI;
var cat16 = [
  [0.401288, 0.650173, -0.051461],
  [-0.250268, 1.204414, 0.045854],
  [-0.002079, 0.048952, 0.953127]
];
var cat16Inv = [
  [1.8620678550872327, -1.0112546305316843, 0.14918677544445175],
  [0.38752654323613717, 0.6214474419314753, -0.008973985167612518],
  [-0.015841498849333856, -0.03412293802851557, 1.0499644368778496]
];
var m12 = [
  [460, 451, 288],
  [460, -891, -261],
  [460, -220, -6300]
];
var surroundMap = {
  dark: [0.8, 0.525, 0.8],
  dim: [0.9, 0.59, 0.9],
  average: [1, 0.69, 1]
};
var hueQuadMap = {
  h: [20.14, 90, 164.25, 237.53, 380.14],
  e: [0.8, 0.7, 1, 1.2, 0.8],
  H: [0, 100, 200, 300, 400]
};
var rad2deg = 180 / Math.PI;
var deg2rad = Math.PI / 180;
function adapt2(coords, fl) {
  const temp = coords.map((c) => {
    const x = spow(fl * Math.abs(c) * 0.01, adaptedCoef);
    return 400 * copySign(x, c) / (x + 27.13);
  });
  return temp;
}
function unadapt(adapted, fl) {
  const constant = 100 / fl * 27.13 ** adaptedCoefInv;
  return adapted.map((c) => {
    const cabs = Math.abs(c);
    return copySign(constant * spow(cabs / (400 - cabs), adaptedCoefInv), c);
  });
}
function hueQuadrature(h) {
  let hp = constrain(h);
  if (hp <= hueQuadMap.h[0]) {
    hp += 360;
  }
  const i = bisectLeft(hueQuadMap.h, hp) - 1;
  const [hi, hii] = hueQuadMap.h.slice(i, i + 2);
  const [ei, eii] = hueQuadMap.e.slice(i, i + 2);
  const Hi = hueQuadMap.H[i];
  const t = (hp - hi) / ei;
  return Hi + 100 * t / (t + (hii - hp) / eii);
}
function invHueQuadrature(H) {
  let Hp = (H % 400 + 400) % 400;
  const i = Math.floor(0.01 * Hp);
  Hp = Hp % 100;
  const [hi, hii] = hueQuadMap.h.slice(i, i + 2);
  const [ei, eii] = hueQuadMap.e.slice(i, i + 2);
  return constrain((Hp * (eii * hi - ei * hii) - 100 * hi * eii) / (Hp * (eii - ei) - 100 * eii));
}
function environment2(refWhite, adaptingLuminance, backgroundLuminance, surround, discounting) {
  const env = {};
  env.discounting = discounting;
  env.refWhite = refWhite;
  env.surround = surround;
  const xyzW = refWhite.map((c) => {
    return c * 100;
  });
  env.la = adaptingLuminance;
  env.yb = backgroundLuminance;
  const yw = xyzW[1];
  const rgbW = multiplyMatrices(cat16, xyzW);
  surround = surroundMap[env.surround];
  const f = surround[0];
  env.c = surround[1];
  env.nc = surround[2];
  const k = 1 / (5 * env.la + 1);
  const k4 = k ** 4;
  env.fl = k4 * env.la + 0.1 * (1 - k4) * (1 - k4) * Math.cbrt(5 * env.la);
  env.flRoot = env.fl ** 0.25;
  env.n = env.yb / yw;
  env.z = 1.48 + Math.sqrt(env.n);
  env.nbb = 0.725 * env.n ** -0.2;
  env.ncb = env.nbb;
  const d2 = discounting ? 1 : Math.max(Math.min(f * (1 - 1 / 3.6 * Math.exp((-env.la - 42) / 92)), 1), 0);
  env.dRgb = rgbW.map((c) => {
    return interpolate(1, yw / c, d2);
  });
  env.dRgbInv = env.dRgb.map((c) => {
    return 1 / c;
  });
  const rgbCW = rgbW.map((c, i) => {
    return c * env.dRgb[i];
  });
  const rgbAW = adapt2(rgbCW, env.fl);
  env.aW = env.nbb * (2 * rgbAW[0] + rgbAW[1] + 0.05 * rgbAW[2]);
  return env;
}
var viewingConditions = environment2(white2, 64 / Math.PI * 0.2, 20, "average", false);
function fromCam16(cam16, env) {
  if (!(cam16.J !== undefined ^ cam16.Q !== undefined)) {
    throw new Error("Conversion requires one and only one: 'J' or 'Q'");
  }
  if (!(cam16.C !== undefined ^ cam16.M !== undefined ^ cam16.s !== undefined)) {
    throw new Error("Conversion requires one and only one: 'C', 'M' or 's'");
  }
  if (!(cam16.h !== undefined ^ cam16.H !== undefined)) {
    throw new Error("Conversion requires one and only one: 'h' or 'H'");
  }
  if (cam16.J === 0 || cam16.Q === 0) {
    return [0, 0, 0];
  }
  let hRad = 0;
  if (cam16.h !== undefined) {
    hRad = constrain(cam16.h) * deg2rad;
  } else {
    hRad = invHueQuadrature(cam16.H) * deg2rad;
  }
  const cosh = Math.cos(hRad);
  const sinh = Math.sin(hRad);
  let Jroot = 0;
  if (cam16.J !== undefined) {
    Jroot = spow(cam16.J, 1 / 2) * 0.1;
  } else if (cam16.Q !== undefined) {
    Jroot = 0.25 * env.c * cam16.Q / ((env.aW + 4) * env.flRoot);
  }
  let alpha = 0;
  if (cam16.C !== undefined) {
    alpha = cam16.C / Jroot;
  } else if (cam16.M !== undefined) {
    alpha = cam16.M / env.flRoot / Jroot;
  } else if (cam16.s !== undefined) {
    alpha = 0.0004 * cam16.s ** 2 * (env.aW + 4) / env.c;
  }
  const t = spow(alpha * Math.pow(1.64 - Math.pow(0.29, env.n), -0.73), 10 / 9);
  const et = 0.25 * (Math.cos(hRad + 2) + 3.8);
  const A = env.aW * spow(Jroot, 2 / env.c / env.z);
  const p1 = 50000 / 13 * env.nc * env.ncb * et;
  const p2 = A / env.nbb;
  const r = 23 * (p2 + 0.305) * zdiv(t, 23 * p1 + t * (11 * cosh + 108 * sinh));
  const a = r * cosh;
  const b2 = r * sinh;
  const rgb_c = unadapt(multiplyMatrices(m12, [p2, a, b2]).map((c) => {
    return c * 1 / 1403;
  }), env.fl);
  return multiplyMatrices(cat16Inv, rgb_c.map((c, i) => {
    return c * env.dRgbInv[i];
  })).map((c) => {
    return c / 100;
  });
}
function toCam16(xyzd65, env) {
  const xyz100 = xyzd65.map((c) => {
    return c * 100;
  });
  const rgbA = adapt2(multiplyMatrices(cat16, xyz100).map((c, i) => {
    return c * env.dRgb[i];
  }), env.fl);
  const a = rgbA[0] + (-12 * rgbA[1] + rgbA[2]) / 11;
  const b2 = (rgbA[0] + rgbA[1] - 2 * rgbA[2]) / 9;
  const hRad = (Math.atan2(b2, a) % tau + tau) % tau;
  const et = 0.25 * (Math.cos(hRad + 2) + 3.8);
  const t = 50000 / 13 * env.nc * env.ncb * zdiv(et * Math.sqrt(a ** 2 + b2 ** 2), rgbA[0] + rgbA[1] + 1.05 * rgbA[2] + 0.305);
  const alpha = spow(t, 0.9) * Math.pow(1.64 - Math.pow(0.29, env.n), 0.73);
  const A = env.nbb * (2 * rgbA[0] + rgbA[1] + 0.05 * rgbA[2]);
  const Jroot = spow(A / env.aW, 0.5 * env.c * env.z);
  const J = 100 * spow(Jroot, 2);
  const Q = 4 / env.c * Jroot * (env.aW + 4) * env.flRoot;
  const C = alpha * Jroot;
  const M = C * env.flRoot;
  const h = constrain(hRad * rad2deg);
  const H = hueQuadrature(h);
  const s = 50 * spow(env.c * alpha / (env.aW + 4), 1 / 2);
  return { J, C, h, s, Q, M, H };
}
var cam16_default = new ColorSpace({
  id: "cam16-jmh",
  cssId: "--cam16-jmh",
  name: "CAM16-JMh",
  coords: {
    j: {
      refRange: [0, 100],
      name: "J"
    },
    m: {
      refRange: [0, 105],
      name: "Colorfulness"
    },
    h: {
      refRange: [0, 360],
      type: "angle",
      name: "Hue"
    }
  },
  base: xyz_d65_default,
  fromBase(xyz) {
    const cam16 = toCam16(xyz, viewingConditions);
    return [cam16.J, cam16.M, cam16.h];
  },
  toBase(cam16) {
    return fromCam16({ J: cam16[0], M: cam16[1], h: cam16[2] }, viewingConditions);
  }
});

// node_modules/colorjs.io/src/spaces/hct.js
var white3 = WHITES.D65;
var 6 = 216 / 24389;
var 2 = 24389 / 27;
function toLstar(y) {
  const fy = y > 6 ? Math.cbrt(y) : (2 * y + 16) / 116;
  return 116 * fy - 16;
}
function fromLstar(lstar) {
  return lstar > 8 ? Math.pow((lstar + 16) / 116, 3) : lstar / 2;
}
function fromHct(coords, env) {
  let [h, c, t] = coords;
  let xyz = [];
  let j = 0;
  if (t === 0) {
    return [0, 0, 0];
  }
  let y = fromLstar(t);
  if (t > 0) {
    j = 0.00379058511492914 * t ** 2 + 0.608983189401032 * t + 0.9155088574762233;
  } else {
    j = 0.000009514440756550361 * t ** 2 + 0.08693057439788597 * t - 21.928975842194614;
  }
  const threshold = 0.000000000002;
  const max_attempts = 15;
  let attempt = 0;
  let last2 = Infinity;
  let best = j;
  while (attempt <= max_attempts) {
    xyz = fromCam16({ J: j, C: c, h }, env);
    const delta = Math.abs(xyz[1] - y);
    if (delta < last2) {
      if (delta <= threshold) {
        return xyz;
      }
      best = j;
      last2 = delta;
    }
    j = j - (xyz[1] - y) * j / (2 * xyz[1]);
    attempt += 1;
  }
  return fromCam16({ J: j, C: c, h }, env);
}
function toHct(xyz, env) {
  const t = toLstar(xyz[1]);
  if (t === 0) {
    return [0, 0, 0];
  }
  const cam16 = toCam16(xyz, viewingConditions2);
  return [constrain(cam16.h), cam16.C, t];
}
var viewingConditions2 = environment2(white3, 200 / Math.PI * fromLstar(50), fromLstar(50) * 100, "average", false);
var hct_default = new ColorSpace({
  id: "hct",
  name: "HCT",
  coords: {
    h: {
      refRange: [0, 360],
      type: "angle",
      name: "Hue"
    },
    c: {
      refRange: [0, 145],
      name: "Colorfulness"
    },
    t: {
      refRange: [0, 100],
      name: "Tone"
    }
  },
  base: xyz_d65_default,
  fromBase(xyz) {
    return toHct(xyz, viewingConditions2);
  },
  toBase(hct) {
    return fromHct(hct, viewingConditions2);
  },
  formats: {
    color: {
      id: "--hct",
      coords: ["<number> | <angle>", "<percentage> | <number>", "<percentage> | <number>"]
    }
  }
});

// node_modules/colorjs.io/src/deltaE/deltaEHCT.js
var rad2deg2 = 180 / Math.PI;
var deg2rad2 = Math.PI / 180;
var ucsCoeff = [1, 0.007, 0.0228];
function convertUcsAb(coords) {
  if (coords[1] < 0) {
    coords = hct_default.fromBase(hct_default.toBase(coords));
  }
  const M = Math.log(Math.max(1 + ucsCoeff[2] * coords[1] * viewingConditions2.flRoot, 1)) / ucsCoeff[2];
  const hrad = coords[0] * deg2rad2;
  const a = M * Math.cos(hrad);
  const b2 = M * Math.sin(hrad);
  return [coords[2], a, b2];
}
function deltaEHCT_default(color, sample) {
  [color, sample] = getColor([color, sample]);
  let [t1, a1, b1] = convertUcsAb(hct_default.from(color));
  let [t2, a2, b2] = convertUcsAb(hct_default.from(sample));
  return Math.sqrt((t1 - t2) ** 2 + (a1 - a2) ** 2 + (b1 - b2) ** 2);
}

// node_modules/colorjs.io/src/deltaE/index.js
var deltaE_default = {
  deltaE76,
  deltaECMC: deltaECMC_default,
  deltaE2000: deltaE2000_default,
  deltaEJz: deltaEJz_default,
  deltaEITP: deltaEITP_default,
  deltaEOK: deltaEOK_default,
  deltaEHCT: deltaEHCT_default
};

// node_modules/colorjs.io/src/toGamut.js
function calcEpsilon(jnd) {
  const order = !jnd ? 0 : Math.floor(Math.log10(Math.abs(jnd)));
  return Math.max(parseFloat(`1e${order - 2}`), 0.000001);
}
var GMAPPRESET = {
  hct: {
    method: "hct.c",
    jnd: 2,
    deltaEMethod: "hct",
    blackWhiteClamp: {}
  },
  "hct-tonal": {
    method: "hct.c",
    jnd: 0,
    deltaEMethod: "hct",
    blackWhiteClamp: { channel: "hct.t", min: 0, max: 100 }
  }
};
function toGamut(color, {
  method = defaults_default.gamut_mapping,
  space = undefined,
  deltaEMethod = "",
  jnd = 2,
  blackWhiteClamp = {}
} = {}) {
  color = getColor(color);
  if (isString(arguments[1])) {
    space = arguments[1];
  } else if (!space) {
    space = color.space;
  }
  space = ColorSpace.get(space);
  if (inGamut(color, space, { epsilon: 0 })) {
    return color;
  }
  let spaceColor;
  if (method === "css") {
    spaceColor = toGamutCSS(color, { space });
  } else {
    if (method !== "clip" && !inGamut(color, space)) {
      if (Object.prototype.hasOwnProperty.call(GMAPPRESET, method)) {
        ({ method, jnd, deltaEMethod, blackWhiteClamp } = GMAPPRESET[method]);
      }
      let de = deltaE2000_default;
      if (deltaEMethod !== "") {
        for (let m in deltaE_default) {
          if ("deltae" + deltaEMethod.toLowerCase() === m.toLowerCase()) {
            de = deltaE_default[m];
            break;
          }
        }
      }
      let clipped = toGamut(to(color, space), { method: "clip", space });
      if (de(color, clipped) > jnd) {
        if (Object.keys(blackWhiteClamp).length === 3) {
          let channelMeta = ColorSpace.resolveCoord(blackWhiteClamp.channel);
          let channel = get(to(color, channelMeta.space), channelMeta.id);
          if (isNone(channel)) {
            channel = 0;
          }
          if (channel >= blackWhiteClamp.max) {
            return to({ space: "xyz-d65", coords: WHITES["D65"] }, color.space);
          } else if (channel <= blackWhiteClamp.min) {
            return to({ space: "xyz-d65", coords: [0, 0, 0] }, color.space);
          }
        }
        let coordMeta = ColorSpace.resolveCoord(method);
        let mapSpace = coordMeta.space;
        let coordId = coordMeta.id;
        let mappedColor = to(color, mapSpace);
        mappedColor.coords.forEach((c, i) => {
          if (isNone(c)) {
            mappedColor.coords[i] = 0;
          }
        });
        let bounds = coordMeta.range || coordMeta.refRange;
        let min = bounds[0];
        let 5 = calcEpsilon(jnd);
        let low = min;
        let high = get(mappedColor, coordId);
        while (high - low > 5) {
          let clipped2 = clone(mappedColor);
          clipped2 = toGamut(clipped2, { space, method: "clip" });
          let deltaE = de(mappedColor, clipped2);
          if (deltaE - jnd < 5) {
            low = get(mappedColor, coordId);
          } else {
            high = get(mappedColor, coordId);
          }
          set(mappedColor, coordId, (low + high) / 2);
        }
        spaceColor = to(mappedColor, space);
      } else {
        spaceColor = clipped;
      }
    } else {
      spaceColor = to(color, space);
    }
    if (method === "clip" || !inGamut(spaceColor, space, { epsilon: 0 })) {
      let bounds = Object.values(space.coords).map((c) => c.range || []);
      spaceColor.coords = spaceColor.coords.map((c, i) => {
        let [min, max] = bounds[i];
        if (min !== undefined) {
          c = Math.max(min, c);
        }
        if (max !== undefined) {
          c = Math.min(c, max);
        }
        return c;
      });
    }
  }
  if (space !== color.space) {
    spaceColor = to(spaceColor, color.space);
  }
  color.coords = spaceColor.coords;
  return color;
}
toGamut.returns = "color";
var COLORS = {
  WHITE: { space: oklab_default, coords: [1, 0, 0] },
  BLACK: { space: oklab_default, coords: [0, 0, 0] }
};
function toGamutCSS(origin, { space } = {}) {
  const JND = 0.02;
  const 5 = 0.0001;
  origin = getColor(origin);
  if (!space) {
    space = origin.space;
  }
  space = ColorSpace.get(space);
  const oklchSpace = ColorSpace.get("oklch");
  if (space.isUnbounded) {
    return to(origin, space);
  }
  const origin_OKLCH = to(origin, oklchSpace);
  let L = origin_OKLCH.coords[0];
  if (L >= 1) {
    const white4 = to(COLORS.WHITE, space);
    white4.alpha = origin.alpha;
    return to(white4, space);
  }
  if (L <= 0) {
    const black = to(COLORS.BLACK, space);
    black.alpha = origin.alpha;
    return to(black, space);
  }
  if (inGamut(origin_OKLCH, space, { epsilon: 0 })) {
    return to(origin_OKLCH, space);
  }
  function clip(_color) {
    const destColor = to(_color, space);
    const spaceCoords = Object.values(space.coords);
    destColor.coords = destColor.coords.map((coord, index) => {
      if ("range" in spaceCoords[index]) {
        const [min2, max2] = spaceCoords[index].range;
        return clamp(min2, coord, max2);
      }
      return coord;
    });
    return destColor;
  }
  let min = 0;
  let max = origin_OKLCH.coords[1];
  let min_inGamut = true;
  let current = clone(origin_OKLCH);
  let clipped = clip(current);
  let E = deltaEOK_default(clipped, current);
  if (E < JND) {
    return clipped;
  }
  while (max - min > 5) {
    const chroma = (min + max) / 2;
    current.coords[1] = chroma;
    if (min_inGamut && inGamut(current, space, { epsilon: 0 })) {
      min = chroma;
    } else {
      clipped = clip(current);
      E = deltaEOK_default(clipped, current);
      if (E < JND) {
        if (JND - E < 5) {
          break;
        } else {
          min_inGamut = false;
          min = chroma;
        }
      } else {
        max = chroma;
      }
    }
  }
  return clipped;
}

// node_modules/colorjs.io/src/to.js
function to(color, space, { inGamut: inGamut2 } = {}) {
  color = getColor(color);
  space = ColorSpace.get(space);
  let coords = space.from(color);
  let ret = { space, coords, alpha: color.alpha };
  if (inGamut2) {
    ret = toGamut(ret, inGamut2 === true ? undefined : inGamut2);
  }
  return ret;
}
to.returns = "color";
// node_modules/colorjs.io/src/serialize.js
function serialize(color, {
  precision = defaults_default.precision,
  format = "default",
  inGamut: inGamut2 = true,
  ...customOptions
} = {}) {
  let ret;
  color = getColor(color);
  let formatId = format;
  format = color.space.getFormat(format) ?? color.space.getFormat("default") ?? ColorSpace.DEFAULT_FORMAT;
  let coords = color.coords.slice();
  inGamut2 ||= format.toGamut;
  if (inGamut2 && !inGamut(color)) {
    coords = toGamut(clone(color), inGamut2 === true ? undefined : inGamut2).coords;
  }
  if (format.type === "custom") {
    customOptions.precision = precision;
    if (format.serialize) {
      ret = format.serialize(coords, color.alpha, customOptions);
    } else {
      throw new TypeError(`format ${formatId} can only be used to parse colors, not for serialization`);
    }
  } else {
    let name = format.name || "color";
    if (format.serializeCoords) {
      coords = format.serializeCoords(coords, precision);
    } else {
      if (precision !== null) {
        coords = coords.map((c) => {
          return serializeNumber(c, { precision });
        });
      }
    }
    let args = [...coords];
    if (name === "color") {
      let cssId = format.id || format.ids?.[0] || color.space.id;
      args.unshift(cssId);
    }
    let alpha = color.alpha;
    if (precision !== null) {
      alpha = serializeNumber(alpha, { precision });
    }
    let strAlpha = color.alpha >= 1 || format.noAlpha ? "" : `${format.commas ? "," : " /"} ${alpha}`;
    ret = `${name}(${args.join(format.commas ? ", " : " ")}${strAlpha})`;
  }
  return ret;
}
// node_modules/colorjs.io/src/spaces/p3-linear.js
var toXYZ_M = [
  [0.4865709486482162, 0.26566769316909306, 0.1982172852343625],
  [0.2289745640697488, 0.6917385218365064, 0.079286914093745],
  [0, 0.04511338185890264, 1.043944368900976]
];
var fromXYZ_M = [
  [2.493496911941425, -0.9313836179191239, -0.40271078445071684],
  [-0.8294889695615747, 1.7626640603183463, 0.023624685841943577],
  [0.03584583024378447, -0.07617238926804182, 0.9568845240076872]
];
var p3_linear_default = new RGBColorSpace({
  id: "p3-linear",
  cssId: "--display-p3-linear",
  name: "Linear P3",
  white: "D65",
  toXYZ_M,
  fromXYZ_M
});

// node_modules/colorjs.io/src/spaces/srgb-linear.js
var toXYZ_M2 = [
  [0.41239079926595934, 0.357584339383878, 0.1804807884018343],
  [0.21263900587151027, 0.715168678767756, 0.07219231536073371],
  [0.01933081871559182, 0.11919477979462598, 0.9505321522496607]
];
var fromXYZ_M2 = [
  [3.2409699419045226, -1.537383177570094, -0.4986107602930034],
  [-0.9692436362808796, 1.8759675015077202, 0.04155505740717559],
  [0.05563007969699366, -0.20397695888897652, 1.0569715142428786]
];
var srgb_linear_default = new RGBColorSpace({
  id: "srgb-linear",
  name: "Linear sRGB",
  white: "D65",
  toXYZ_M: toXYZ_M2,
  fromXYZ_M: fromXYZ_M2
});

// node_modules/colorjs.io/src/keywords.js
var keywords_default = {
  aliceblue: [240 / 255, 248 / 255, 1],
  antiquewhite: [250 / 255, 235 / 255, 215 / 255],
  aqua: [0, 1, 1],
  aquamarine: [127 / 255, 1, 212 / 255],
  azure: [240 / 255, 1, 1],
  beige: [245 / 255, 245 / 255, 220 / 255],
  bisque: [1, 228 / 255, 196 / 255],
  black: [0, 0, 0],
  blanchedalmond: [1, 235 / 255, 205 / 255],
  blue: [0, 0, 1],
  blueviolet: [138 / 255, 43 / 255, 226 / 255],
  brown: [165 / 255, 42 / 255, 42 / 255],
  burlywood: [222 / 255, 184 / 255, 135 / 255],
  cadetblue: [95 / 255, 158 / 255, 160 / 255],
  chartreuse: [127 / 255, 1, 0],
  chocolate: [210 / 255, 105 / 255, 30 / 255],
  coral: [1, 127 / 255, 80 / 255],
  cornflowerblue: [100 / 255, 149 / 255, 237 / 255],
  cornsilk: [1, 248 / 255, 220 / 255],
  crimson: [220 / 255, 20 / 255, 60 / 255],
  cyan: [0, 1, 1],
  darkblue: [0, 0, 139 / 255],
  darkcyan: [0, 139 / 255, 139 / 255],
  darkgoldenrod: [184 / 255, 134 / 255, 11 / 255],
  darkgray: [169 / 255, 169 / 255, 169 / 255],
  darkgreen: [0, 100 / 255, 0],
  darkgrey: [169 / 255, 169 / 255, 169 / 255],
  darkkhaki: [189 / 255, 183 / 255, 107 / 255],
  darkmagenta: [139 / 255, 0, 139 / 255],
  darkolivegreen: [85 / 255, 107 / 255, 47 / 255],
  darkorange: [1, 140 / 255, 0],
  darkorchid: [153 / 255, 50 / 255, 204 / 255],
  darkred: [139 / 255, 0, 0],
  darksalmon: [233 / 255, 150 / 255, 122 / 255],
  darkseagreen: [143 / 255, 188 / 255, 143 / 255],
  darkslateblue: [72 / 255, 61 / 255, 139 / 255],
  darkslategray: [47 / 255, 79 / 255, 79 / 255],
  darkslategrey: [47 / 255, 79 / 255, 79 / 255],
  darkturquoise: [0, 206 / 255, 209 / 255],
  darkviolet: [148 / 255, 0, 211 / 255],
  deeppink: [1, 20 / 255, 147 / 255],
  deepskyblue: [0, 191 / 255, 1],
  dimgray: [105 / 255, 105 / 255, 105 / 255],
  dimgrey: [105 / 255, 105 / 255, 105 / 255],
  dodgerblue: [30 / 255, 144 / 255, 1],
  firebrick: [178 / 255, 34 / 255, 34 / 255],
  floralwhite: [1, 250 / 255, 240 / 255],
  forestgreen: [34 / 255, 139 / 255, 34 / 255],
  fuchsia: [1, 0, 1],
  gainsboro: [220 / 255, 220 / 255, 220 / 255],
  ghostwhite: [248 / 255, 248 / 255, 1],
  gold: [1, 215 / 255, 0],
  goldenrod: [218 / 255, 165 / 255, 32 / 255],
  gray: [128 / 255, 128 / 255, 128 / 255],
  green: [0, 128 / 255, 0],
  greenyellow: [173 / 255, 1, 47 / 255],
  grey: [128 / 255, 128 / 255, 128 / 255],
  honeydew: [240 / 255, 1, 240 / 255],
  hotpink: [1, 105 / 255, 180 / 255],
  indianred: [205 / 255, 92 / 255, 92 / 255],
  indigo: [75 / 255, 0, 130 / 255],
  ivory: [1, 1, 240 / 255],
  khaki: [240 / 255, 230 / 255, 140 / 255],
  lavender: [230 / 255, 230 / 255, 250 / 255],
  lavenderblush: [1, 240 / 255, 245 / 255],
  lawngreen: [124 / 255, 252 / 255, 0],
  lemonchiffon: [1, 250 / 255, 205 / 255],
  lightblue: [173 / 255, 216 / 255, 230 / 255],
  lightcoral: [240 / 255, 128 / 255, 128 / 255],
  lightcyan: [224 / 255, 1, 1],
  lightgoldenrodyellow: [250 / 255, 250 / 255, 210 / 255],
  lightgray: [211 / 255, 211 / 255, 211 / 255],
  lightgreen: [144 / 255, 238 / 255, 144 / 255],
  lightgrey: [211 / 255, 211 / 255, 211 / 255],
  lightpink: [1, 182 / 255, 193 / 255],
  lightsalmon: [1, 160 / 255, 122 / 255],
  lightseagreen: [32 / 255, 178 / 255, 170 / 255],
  lightskyblue: [135 / 255, 206 / 255, 250 / 255],
  lightslategray: [119 / 255, 136 / 255, 153 / 255],
  lightslategrey: [119 / 255, 136 / 255, 153 / 255],
  lightsteelblue: [176 / 255, 196 / 255, 222 / 255],
  lightyellow: [1, 1, 224 / 255],
  lime: [0, 1, 0],
  limegreen: [50 / 255, 205 / 255, 50 / 255],
  linen: [250 / 255, 240 / 255, 230 / 255],
  magenta: [1, 0, 1],
  maroon: [128 / 255, 0, 0],
  mediumaquamarine: [102 / 255, 205 / 255, 170 / 255],
  mediumblue: [0, 0, 205 / 255],
  mediumorchid: [186 / 255, 85 / 255, 211 / 255],
  mediumpurple: [147 / 255, 112 / 255, 219 / 255],
  mediumseagreen: [60 / 255, 179 / 255, 113 / 255],
  mediumslateblue: [123 / 255, 104 / 255, 238 / 255],
  mediumspringgreen: [0, 250 / 255, 154 / 255],
  mediumturquoise: [72 / 255, 209 / 255, 204 / 255],
  mediumvioletred: [199 / 255, 21 / 255, 133 / 255],
  midnightblue: [25 / 255, 25 / 255, 112 / 255],
  mintcream: [245 / 255, 1, 250 / 255],
  mistyrose: [1, 228 / 255, 225 / 255],
  moccasin: [1, 228 / 255, 181 / 255],
  navajowhite: [1, 222 / 255, 173 / 255],
  navy: [0, 0, 128 / 255],
  oldlace: [253 / 255, 245 / 255, 230 / 255],
  olive: [128 / 255, 128 / 255, 0],
  olivedrab: [107 / 255, 142 / 255, 35 / 255],
  orange: [1, 165 / 255, 0],
  orangered: [1, 69 / 255, 0],
  orchid: [218 / 255, 112 / 255, 214 / 255],
  palegoldenrod: [238 / 255, 232 / 255, 170 / 255],
  palegreen: [152 / 255, 251 / 255, 152 / 255],
  paleturquoise: [175 / 255, 238 / 255, 238 / 255],
  palevioletred: [219 / 255, 112 / 255, 147 / 255],
  papayawhip: [1, 239 / 255, 213 / 255],
  peachpuff: [1, 218 / 255, 185 / 255],
  peru: [205 / 255, 133 / 255, 63 / 255],
  pink: [1, 192 / 255, 203 / 255],
  plum: [221 / 255, 160 / 255, 221 / 255],
  powderblue: [176 / 255, 224 / 255, 230 / 255],
  purple: [128 / 255, 0, 128 / 255],
  rebeccapurple: [102 / 255, 51 / 255, 153 / 255],
  red: [1, 0, 0],
  rosybrown: [188 / 255, 143 / 255, 143 / 255],
  royalblue: [65 / 255, 105 / 255, 225 / 255],
  saddlebrown: [139 / 255, 69 / 255, 19 / 255],
  salmon: [250 / 255, 128 / 255, 114 / 255],
  sandybrown: [244 / 255, 164 / 255, 96 / 255],
  seagreen: [46 / 255, 139 / 255, 87 / 255],
  seashell: [1, 245 / 255, 238 / 255],
  sienna: [160 / 255, 82 / 255, 45 / 255],
  silver: [192 / 255, 192 / 255, 192 / 255],
  skyblue: [135 / 255, 206 / 255, 235 / 255],
  slateblue: [106 / 255, 90 / 255, 205 / 255],
  slategray: [112 / 255, 128 / 255, 144 / 255],
  slategrey: [112 / 255, 128 / 255, 144 / 255],
  snow: [1, 250 / 255, 250 / 255],
  springgreen: [0, 1, 127 / 255],
  steelblue: [70 / 255, 130 / 255, 180 / 255],
  tan: [210 / 255, 180 / 255, 140 / 255],
  teal: [0, 128 / 255, 128 / 255],
  thistle: [216 / 255, 191 / 255, 216 / 255],
  tomato: [1, 99 / 255, 71 / 255],
  turquoise: [64 / 255, 224 / 255, 208 / 255],
  violet: [238 / 255, 130 / 255, 238 / 255],
  wheat: [245 / 255, 222 / 255, 179 / 255],
  white: [1, 1, 1],
  whitesmoke: [245 / 255, 245 / 255, 245 / 255],
  yellow: [1, 1, 0],
  yellowgreen: [154 / 255, 205 / 255, 50 / 255]
};

// node_modules/colorjs.io/src/spaces/srgb.js
var coordGrammar = Array(3).fill("<percentage> | <number>[0, 255]");
var coordGrammarNumber = Array(3).fill("<number>[0, 255]");
var srgb_default = new RGBColorSpace({
  id: "srgb",
  name: "sRGB",
  base: srgb_linear_default,
  fromBase: (rgb) => {
    return rgb.map((val) => {
      let sign = val < 0 ? -1 : 1;
      let abs = val * sign;
      if (abs > 0.0031308) {
        return sign * (1.055 * abs ** (1 / 2.4) - 0.055);
      }
      return 12.92 * val;
    });
  },
  toBase: (rgb) => {
    return rgb.map((val) => {
      let sign = val < 0 ? -1 : 1;
      let abs = val * sign;
      if (abs <= 0.04045) {
        return val / 12.92;
      }
      return sign * ((abs + 0.055) / 1.055) ** 2.4;
    });
  },
  formats: {
    rgb: {
      coords: coordGrammar
    },
    rgb_number: {
      name: "rgb",
      commas: true,
      coords: coordGrammarNumber,
      noAlpha: true
    },
    color: {},
    rgba: {
      coords: coordGrammar,
      commas: true,
      lastAlpha: true
    },
    rgba_number: {
      name: "rgba",
      commas: true,
      coords: coordGrammarNumber
    },
    hex: {
      type: "custom",
      toGamut: true,
      test: (str) => /^#([a-f0-9]{3,4}){1,2}$/i.test(str),
      parse(str) {
        if (str.length <= 5) {
          str = str.replace(/[a-f0-9]/gi, "$&$&");
        }
        let rgba = [];
        str.replace(/[a-f0-9]{2}/gi, (component) => {
          rgba.push(parseInt(component, 16) / 255);
        });
        return {
          spaceId: "srgb",
          coords: rgba.slice(0, 3),
          alpha: rgba.slice(3)[0]
        };
      },
      serialize: (coords, alpha, {
        collapse = true
      } = {}) => {
        if (alpha < 1) {
          coords.push(alpha);
        }
        coords = coords.map((c) => Math.round(c * 255));
        let collapsible = collapse && coords.every((c) => c % 17 === 0);
        let hex = coords.map((c) => {
          if (collapsible) {
            return (c / 17).toString(16);
          }
          return c.toString(16).padStart(2, "0");
        }).join("");
        return "#" + hex;
      }
    },
    keyword: {
      type: "custom",
      test: (str) => /^[a-z]+$/i.test(str),
      parse(str) {
        str = str.toLowerCase();
        let ret = { spaceId: "srgb", coords: null, alpha: 1 };
        if (str === "transparent") {
          ret.coords = keywords_default.black;
          ret.alpha = 0;
        } else {
          ret.coords = keywords_default[str];
        }
        if (ret.coords) {
          return ret;
        }
      }
    }
  }
});

// node_modules/colorjs.io/src/spaces/p3.js
var p3_default = new RGBColorSpace({
  id: "p3",
  cssId: "display-p3",
  name: "P3",
  base: p3_linear_default,
  fromBase: srgb_default.fromBase,
  toBase: srgb_default.toBase
});

// node_modules/colorjs.io/src/luminance.js
function getLuminance(color) {
  return get(color, [xyz_d65_default, "y"]);
}

// node_modules/colorjs.io/src/contrast/WCAG21.js
function contrastWCAG21(color1, color2) {
  color1 = getColor(color1);
  color2 = getColor(color2);
  let Y1 = Math.max(getLuminance(color1), 0);
  let Y2 = Math.max(getLuminance(color2), 0);
  if (Y2 > Y1) {
    [Y1, Y2] = [Y2, Y1];
  }
  return (Y1 + 0.05) / (Y2 + 0.05);
}
// node_modules/colorjs.io/src/contrast/APCA.js
var normBG = 0.56;
var normTXT = 0.57;
var revTXT = 0.62;
var revBG = 0.65;
var blkThrs = 0.022;
var blkClmp = 1.414;
var loClip = 0.1;
var deltaYmin = 0.0005;
var scaleBoW = 1.14;
var loBoWoffset = 0.027;
var scaleWoB = 1.14;
function fclamp(Y) {
  if (Y >= blkThrs) {
    return Y;
  }
  return Y + (blkThrs - Y) ** blkClmp;
}
function linearize(val) {
  let sign = val < 0 ? -1 : 1;
  let abs = Math.abs(val);
  return sign * Math.pow(abs, 2.4);
}
function contrastAPCA(background, foreground) {
  foreground = getColor(foreground);
  background = getColor(background);
  let S;
  let C;
  let Sapc;
  let R, G, B;
  foreground = to(foreground, "srgb");
  [R, G, B] = foreground.coords;
  let lumTxt = linearize(R) * 0.2126729 + linearize(G) * 0.7151522 + linearize(B) * 0.072175;
  background = to(background, "srgb");
  [R, G, B] = background.coords;
  let lumBg = linearize(R) * 0.2126729 + linearize(G) * 0.7151522 + linearize(B) * 0.072175;
  let Ytxt = fclamp(lumTxt);
  let Ybg = fclamp(lumBg);
  let BoW = Ybg > Ytxt;
  if (Math.abs(Ybg - Ytxt) < deltaYmin) {
    C = 0;
  } else {
    if (BoW) {
      S = Ybg ** normBG - Ytxt ** normTXT;
      C = S * scaleBoW;
    } else {
      S = Ybg ** revBG - Ytxt ** revTXT;
      C = S * scaleWoB;
    }
  }
  if (Math.abs(C) < loClip) {
    Sapc = 0;
  } else if (C > 0) {
    Sapc = C - loBoWoffset;
  } else {
    Sapc = C + loBoWoffset;
  }
  return Sapc * 100;
}
// node_modules/colorjs.io/src/interpolation.js
function range(color1, color2, options2 = {}) {
  if (isRange(color1)) {
    let [r, options3] = [color1, color2];
    return range(...r.rangeArgs.colors, { ...r.rangeArgs.options, ...options3 });
  }
  let { space, outputSpace, progression, premultiplied } = options2;
  color1 = getColor(color1);
  color2 = getColor(color2);
  color1 = clone(color1);
  color2 = clone(color2);
  let rangeArgs = { colors: [color1, color2], options: options2 };
  if (space) {
    space = ColorSpace.get(space);
  } else {
    space = ColorSpace.registry[defaults_default.interpolationSpace] || color1.space;
  }
  outputSpace = outputSpace ? ColorSpace.get(outputSpace) : space;
  color1 = to(color1, space);
  color2 = to(color2, space);
  color1 = toGamut(color1);
  color2 = toGamut(color2);
  if (space.coords.h && space.coords.h.type === "angle") {
    let arc = options2.hue = options2.hue || "shorter";
    let hue = [space, "h"];
    let [1, 2] = [get(color1, hue), get(color2, hue)];
    if (isNaN(1) && !isNaN(2)) {
      1 = 2;
    } else if (isNaN(2) && !isNaN(1)) {
      2 = 1;
    }
    [1, 2] = adjust(arc, [1, 2]);
    set(color1, hue, 1);
    set(color2, hue, 2);
  }
  if (premultiplied) {
    color1.coords = color1.coords.map((c) => c * color1.alpha);
    color2.coords = color2.coords.map((c) => c * color2.alpha);
  }
  return Object.assign((p2) => {
    p2 = progression ? progression(p2) : p2;
    let coords = color1.coords.map((start, i) => {
      let end = color2.coords[i];
      return interpolate(start, end, p2);
    });
    let alpha = interpolate(color1.alpha, color2.alpha, p2);
    let ret = { space, coords, alpha };
    if (premultiplied) {
      ret.coords = ret.coords.map((c) => c / alpha);
    }
    if (outputSpace !== space) {
      ret = to(ret, outputSpace);
    }
    return ret;
  }, {
    rangeArgs
  });
}
function isRange(val) {
  return type(val) === "function" && !!val.rangeArgs;
}
defaults_default.interpolationSpace = "lab";
// node_modules/colorjs.io/src/spaces/hsl.js
var hsl_default = new ColorSpace({
  id: "hsl",
  name: "HSL",
  coords: {
    h: {
      refRange: [0, 360],
      type: "angle",
      name: "Hue"
    },
    s: {
      range: [0, 100],
      name: "Saturation"
    },
    l: {
      range: [0, 100],
      name: "Lightness"
    }
  },
  base: srgb_default,
  fromBase: (rgb) => {
    let max = Math.max(...rgb);
    let min = Math.min(...rgb);
    let [r, g2, b2] = rgb;
    let [h, s, l] = [NaN, 0, (min + max) / 2];
    let d2 = max - min;
    if (d2 !== 0) {
      s = l === 0 || l === 1 ? 0 : (max - l) / Math.min(l, 1 - l);
      switch (max) {
        case r:
          h = (g2 - b2) / d2 + (g2 < b2 ? 6 : 0);
          break;
        case g2:
          h = (b2 - r) / d2 + 2;
          break;
        case b2:
          h = (r - g2) / d2 + 4;
      }
      h = h * 60;
    }
    if (s < 0) {
      h += 180;
      s = Math.abs(s);
    }
    if (h >= 360) {
      h -= 360;
    }
    return [h, s * 100, l * 100];
  },
  toBase: (hsl) => {
    let [h, s, l] = hsl;
    h = h % 360;
    if (h < 0) {
      h += 360;
    }
    s /= 100;
    l /= 100;
    function f(n2) {
      let k = (n2 + h / 30) % 12;
      let a = s * Math.min(l, 1 - l);
      return l - a * Math.max(-1, Math.min(k - 3, 9 - k, 1));
    }
    return [f(0), f(8), f(4)];
  },
  formats: {
    hsl: {
      coords: ["<number> | <angle>", "<percentage>", "<percentage>"]
    },
    hsla: {
      coords: ["<number> | <angle>", "<percentage>", "<percentage>"],
      commas: true,
      lastAlpha: true
    }
  }
});
// node_modules/colorjs.io/src/spaces/hsv.js
var hsv_default = new ColorSpace({
  id: "hsv",
  name: "HSV",
  coords: {
    h: {
      refRange: [0, 360],
      type: "angle",
      name: "Hue"
    },
    s: {
      range: [0, 100],
      name: "Saturation"
    },
    v: {
      range: [0, 100],
      name: "Value"
    }
  },
  base: hsl_default,
  fromBase(hsl) {
    let [h, s, l] = hsl;
    s /= 100;
    l /= 100;
    let v = l + s * Math.min(l, 1 - l);
    return [
      h,
      v === 0 ? 0 : 200 * (1 - l / v),
      100 * v
    ];
  },
  toBase(hsv) {
    let [h, s, v] = hsv;
    s /= 100;
    v /= 100;
    let l = v * (1 - s / 2);
    return [
      h,
      l === 0 || l === 1 ? 0 : (v - l) / Math.min(l, 1 - l) * 100,
      l * 100
    ];
  },
  formats: {
    color: {
      id: "--hsv",
      coords: ["<number> | <angle>", "<percentage> | <number>", "<percentage> | <number>"]
    }
  }
});

// node_modules/colorjs.io/src/spaces/hwb.js
var hwb_default = new ColorSpace({
  id: "hwb",
  name: "HWB",
  coords: {
    h: {
      refRange: [0, 360],
      type: "angle",
      name: "Hue"
    },
    w: {
      range: [0, 100],
      name: "Whiteness"
    },
    b: {
      range: [0, 100],
      name: "Blackness"
    }
  },
  base: hsv_default,
  fromBase(hsv) {
    let [h, s, v] = hsv;
    return [h, v * (100 - s) / 100, 100 - v];
  },
  toBase(hwb) {
    let [h, w, b2] = hwb;
    w /= 100;
    b2 /= 100;
    let sum = w + b2;
    if (sum >= 1) {
      let gray = w / sum;
      return [h, 0, gray * 100];
    }
    let v = 1 - b2;
    let s = v === 0 ? 0 : 1 - w / v;
    return [h, s * 100, v * 100];
  },
  formats: {
    hwb: {
      coords: ["<number> | <angle>", "<percentage> | <number>", "<percentage> | <number>"]
    }
  }
});
// node_modules/colorjs.io/src/spaces/oklch.js
var oklch_default = new ColorSpace({
  id: "oklch",
  name: "Oklch",
  coords: {
    l: {
      refRange: [0, 1],
      name: "Lightness"
    },
    c: {
      refRange: [0, 0.4],
      name: "Chroma"
    },
    h: {
      refRange: [0, 360],
      type: "angle",
      name: "Hue"
    }
  },
  white: "D65",
  base: oklab_default,
  fromBase(oklab) {
    let [L, a, b2] = oklab;
    let h;
    const 5 = 0.0002;
    if (Math.abs(a) < 5 && Math.abs(b2) < 5) {
      h = NaN;
    } else {
      h = Math.atan2(b2, a) * 180 / Math.PI;
    }
    return [
      L,
      Math.sqrt(a ** 2 + b2 ** 2),
      constrain(h)
    ];
  },
  toBase(oklch) {
    let [L, C, h] = oklch;
    let a, b2;
    if (isNaN(h)) {
      a = 0;
      b2 = 0;
    } else {
      a = C * Math.cos(h * Math.PI / 180);
      b2 = C * Math.sin(h * Math.PI / 180);
    }
    return [L, a, b2];
  },
  formats: {
    oklch: {
      coords: ["<percentage> | <number>", "<number> | <percentage>[0,1]", "<number> | <angle>"]
    }
  }
});
// node_modules/p5/dist/color/color_spaces/hsb.js
var HSBSpace = new ColorSpace({
  id: "hsb",
  name: "HSB",
  coords: {
    h: {
      refRange: [0, 360],
      type: "angle",
      name: "Hue"
    },
    s: {
      range: [0, 100],
      name: "Saturation"
    },
    b: {
      range: [0, 100],
      name: "Brightness"
    }
  },
  base: srgb_default,
  fromBase: (rgb) => {
    const val = Math.max(...rgb);
    const chroma = val - Math.min(...rgb);
    let [red, green, blue] = rgb;
    let hue, sat;
    if (chroma === 0) {
      hue = 0;
      sat = 0;
    } else {
      sat = chroma / val;
      if (red === val) {
        hue = (green - blue) / chroma;
      } else if (green === val) {
        hue = 2 + (blue - red) / chroma;
      } else if (blue === val) {
        hue = 4 + (red - green) / chroma;
      }
      if (hue < 0) {
        hue += 6;
      } else if (hue >= 6) {
        hue -= 6;
      }
    }
    return [hue / 6 * 360, sat * 100, val * 100];
  },
  toBase,
  formats: {
    default: {
      type: "custom",
      serialize: (coords, alpha) => {
        const rgb = toBase(coords);
        let ret = `rgb(${Math.round(rgb[0] * 100 * 100) / 100}% ${Math.round(rgb[1] * 100 * 100) / 100}% ${Math.round(rgb[2] * 100 * 100) / 100}%`;
        if (alpha < 1) {
          ret += ` / ${alpha}`;
        }
        ret += ")";
        return ret;
      }
    },
    hsb: {
      coords: ["<number> | <angle>", "<percentage>", "<percentage>"]
    },
    hsba: {
      coords: ["<number> | <angle>", "<percentage>", "<percentage>"],
      commans: true,
      lastAlpha: true
    }
  }
});
function toBase(hsb) {
  const hue = hsb[0] / 360 * 6;
  const sat = hsb[1] / 100;
  const val = hsb[2] / 100;
  let RGB = [];
  if (sat === 0) {
    RGB = [val, val, val];
  } else {
    const sector = Math.floor(hue);
    const tint1 = val * (1 - sat);
    const tint2 = val * (1 - sat * (hue - sector));
    const tint3 = val * (1 - sat * (1 + sector - hue));
    let red, green, blue;
    if (sector === 1) {
      red = tint2;
      green = val;
      blue = tint1;
    } else if (sector === 2) {
      red = tint1;
      green = val;
      blue = tint3;
    } else if (sector === 3) {
      red = tint1;
      green = tint2;
      blue = val;
    } else if (sector === 4) {
      red = tint3;
      green = tint1;
      blue = val;
    } else if (sector === 5) {
      red = val;
      green = tint1;
      blue = tint2;
    } else {
      red = val;
      green = tint3;
      blue = tint1;
    }
    RGB = [red, green, blue];
  }
  return RGB;
}

// node_modules/p5/dist/creating_reading-p2iQtNm5.js
var map = (n2, start1, stop1, start2, stop2, clamp2) => {
  let result = (n2 - start1) / (stop1 - start1) * (stop2 - start2) + start2;
  if (clamp2) {
    result = Math.max(result, Math.min(start2, stop2));
    result = Math.min(result, Math.max(start2, stop2));
  }
  return result;
};
var serializationMap = {};

class Color {
  _color;
  mode;
  static colorMap = {};
  static #colorjsMaxes = {};
  static #grayscaleMap = {};
  static addColorMode(mode, definition) {
    ColorSpace.register(definition);
    Color.colorMap[mode] = definition.id;
    Color.#colorjsMaxes[mode] = Object.values(definition.coords).reduce((acc, v) => {
      acc.push(v.refRange || v.range);
      return acc;
    }, []);
    Color.#colorjsMaxes[mode].push([0, 1]);
    Color.#grayscaleMap[mode] = definition.fromGray;
  }
  constructor(vals, colorMode, colorMaxes, { clamp: clamp2 = false } = {}) {
    this.mode = colorMode || RGB;
    if (vals instanceof Color) {
      const mode = colorMode ? Color.colorMap[colorMode] : Color.colorMap[vals.mode];
      this._color = to(vals._color, mode);
      this.mode = mode;
    } else if (typeof vals === "object" && !Array.isArray(vals) && vals !== null) {
      const mode = colorMode ? Color.colorMap[colorMode] : vals.spaceId;
      this._color = to(vals, mode);
      this.mode = colorMode || Object.entries(Color.colorMap).find(([key, val]) => {
        return val === this._color.spaceId;
      });
    } else if (typeof vals[0] === "string") {
      try {
        this._color = parse(vals[0]);
        const [mode] = Object.entries(Color.colorMap).find(([key, val]) => {
          return val === this._color.spaceId;
        });
        this.mode = mode;
        this._color = to(this._color, this._color.spaceId);
      } catch (err) {
        throw new Error("Invalid color string");
      }
    } else {
      let mappedVals;
      if (colorMaxes) {
        if (vals.length === 4) {
          mappedVals = Color.mapColorRange(vals, this.mode, colorMaxes, clamp2);
        } else if (vals.length === 3) {
          mappedVals = Color.mapColorRange([vals[0], vals[1], vals[2]], this.mode, colorMaxes, clamp2);
          mappedVals.push(1);
        } else if (vals.length === 2) {
          if (Color.#grayscaleMap[this.mode]) {
            mappedVals = Color.#grayscaleMap[this.mode](vals[0], colorMaxes, clamp2);
          } else {
            mappedVals = Color.mapColorRange([vals[0], vals[0], vals[0]], this.mode, colorMaxes, clamp2);
          }
          const alphaMaxes = Array.isArray(colorMaxes[colorMaxes.length - 1]) ? colorMaxes[colorMaxes.length - 1] : [0, colorMaxes[colorMaxes.length - 1]];
          mappedVals.push(map(vals[1], alphaMaxes[0], alphaMaxes[1], 0, 1, clamp2));
        } else if (vals.length === 1) {
          if (Color.#grayscaleMap[this.mode]) {
            mappedVals = Color.#grayscaleMap[this.mode](vals[0], colorMaxes, clamp2);
          } else {
            mappedVals = Color.mapColorRange([vals[0], vals[0], vals[0]], this.mode, colorMaxes, clamp2);
          }
          mappedVals.push(1);
        } else {
          throw new Error("Invalid color");
        }
      } else {
        mappedVals = vals;
      }
      const space = Color.colorMap[this.mode] || console.error("Invalid color mode");
      const coords = mappedVals.slice(0, 3);
      const color = {
        space,
        coords,
        alpha: mappedVals[3]
      };
      this._color = to(color, space);
    }
  }
  static mapColorRange(origin, mode, maxes, clamp2) {
    const p5Maxes = maxes.map((max) => {
      if (!Array.isArray(max)) {
        return [0, max];
      } else {
        return max;
      }
    });
    const colorjsMaxes = Color.#colorjsMaxes[mode];
    return origin.map((channel, i) => {
      const newval = map(channel, p5Maxes[i][0], p5Maxes[i][1], colorjsMaxes[i][0], colorjsMaxes[i][1], clamp2);
      return newval;
    });
  }
  static unmapColorRange(origin, mode, maxes) {
    const p5Maxes = maxes.map((max) => {
      if (!Array.isArray(max)) {
        return [0, max];
      } else {
        return max;
      }
    });
    const colorjsMaxes = Color.#colorjsMaxes[mode];
    return origin.map((channel, i) => {
      const newval = map(channel, colorjsMaxes[i][0], colorjsMaxes[i][1], p5Maxes[i][0], p5Maxes[i][1]);
      return newval;
    });
  }
  #toColorMode(mode) {
    return new Color(this._color, mode);
  }
  get _array() {
    return this._getRGBA();
  }
  array() {
    return this._array;
  }
  lerp(color, amt, mode) {
    let spaceIndex = -1;
    while ((spaceIndex + 1 < this._color.space.path.length || spaceIndex + 1 < color._color.space.path.length) && this._color.space.path[spaceIndex + 1] === color._color.space.path[spaceIndex + 1]) {
      spaceIndex += 1;
    }
    if (spaceIndex === -1) {
      throw new Error("Cannot lerp colors. No common color space found");
    }
    const obj = range(this._color, color._color, {
      space: this._color.space.path[spaceIndex].id
    })(amt);
    return new Color(obj, mode || this.mode);
  }
  toString(format) {
    const key = `${this._color.space.id}-${this._color.coords.join(",")}-${this._color.alpha}-${format}`;
    let colorString = serializationMap[key];
    if (!colorString) {
      colorString = serialize(this._color, {
        format
      });
      serializationMap[key] = colorString;
    }
    return colorString;
  }
  contrast(other_color, options2 = "WCAG21") {
    if (options2 !== "all") {
      let contrastVal, minimum;
      switch (options2) {
        case "WCAG21":
          contrastVal = contrastWCAG21(this._color, other_color._color);
          minimum = 4.5;
          break;
        case "APCA":
          contrastVal = Math.abs(contrastAPCA(this._color, other_color._color));
          minimum = 75;
          break;
        default:
          return null;
      }
      return contrastVal >= minimum;
    } else {
      const wcag21Value = contrastWCAG21(this._color, other_color._color);
      const apcaValue = contrastAPCA(this._color, other_color._color);
      return {
        WCAG21: {
          value: wcag21Value,
          passedMinimum: wcag21Value >= 4.5,
          passedAAA: wcag21Value >= 7
        },
        APCA: {
          value: apcaValue,
          passedMinimum: Math.abs(apcaValue) >= 75
        }
      };
    }
  }
  setRed(new_red, max = [0, 1]) {
    if (!Array.isArray(max)) {
      max = [0, max];
    }
    const colorjsMax = Color.#colorjsMaxes[RGB][0];
    const newval = map(new_red, max[0], max[1], colorjsMax[0], colorjsMax[1]);
    if (this.mode === RGB || this.mode === RGBHDR) {
      this._color.coords[0] = newval;
    } else {
      const space = this._color.space.id;
      const representation = to(this._color, "srgb");
      representation.coords[0] = newval;
      this._color = to(representation, space);
    }
  }
  setGreen(new_green, max = [0, 1]) {
    if (!Array.isArray(max)) {
      max = [0, max];
    }
    const colorjsMax = Color.#colorjsMaxes[RGB][1];
    const newval = map(new_green, max[0], max[1], colorjsMax[0], colorjsMax[1]);
    if (this.mode === RGB || this.mode === RGBHDR) {
      this._color.coords[1] = newval;
    } else {
      const space = this._color.space.id;
      const representation = to(this._color, "srgb");
      representation.coords[1] = newval;
      this._color = to(representation, space);
    }
  }
  setBlue(new_blue, max = [0, 1]) {
    if (!Array.isArray(max)) {
      max = [0, max];
    }
    const colorjsMax = Color.#colorjsMaxes[RGB][2];
    const newval = map(new_blue, max[0], max[1], colorjsMax[0], colorjsMax[1]);
    if (this.mode === RGB || this.mode === RGBHDR) {
      this._color.coords[2] = newval;
    } else {
      const space = this._color.space.id;
      const representation = to(this._color, "srgb");
      representation.coords[2] = newval;
      this._color = to(representation, space);
    }
  }
  setAlpha(new_alpha, max = [0, 1]) {
    if (!Array.isArray(max)) {
      max = [0, max];
    }
    const colorjsMax = Color.#colorjsMaxes[this.mode][3];
    const newval = map(new_alpha, max[0], max[1], colorjsMax[0], colorjsMax[1]);
    this._color.alpha = newval;
  }
  _getRGBA(maxes = [1, 1, 1, 1]) {
    const colorjsMaxes = Color.#colorjsMaxes[RGB];
    let coords = structuredClone(to(this._color, "srgb").coords);
    coords.push(this._color.alpha);
    const rangeMaxes = maxes.map((v) => {
      if (!Array.isArray(v)) {
        return [0, v];
      } else {
        return v;
      }
    });
    coords = coords.map((coord, i) => {
      return map(coord, colorjsMaxes[i][0], colorjsMaxes[i][1], rangeMaxes[i][0], rangeMaxes[i][1]);
    });
    return coords;
  }
  _getMode() {
    return this.mode;
  }
  _getRed(max = [0, 1]) {
    if (!Array.isArray(max)) {
      max = [0, max];
    }
    if (this.mode === RGB || this.mode === RGBHDR) {
      const colorjsMax = Color.#colorjsMaxes[this.mode][0];
      return map(this._color.coords[0], colorjsMax[0], colorjsMax[1], max[0], max[1]);
    } else {
      const colorjsMax = Color.#colorjsMaxes[RGB][0];
      return map(to(this._color, "srgb").coords[0], colorjsMax[0], colorjsMax[1], max[0], max[1]);
    }
  }
  _getGreen(max = [0, 1]) {
    if (!Array.isArray(max)) {
      max = [0, max];
    }
    if (this.mode === RGB || this.mode === RGBHDR) {
      const colorjsMax = Color.#colorjsMaxes[this.mode][1];
      return map(this._color.coords[1], colorjsMax[0], colorjsMax[1], max[0], max[1]);
    } else {
      const colorjsMax = Color.#colorjsMaxes[RGB][1];
      return map(to(this._color, "srgb").coords[1], colorjsMax[0], colorjsMax[1], max[0], max[1]);
    }
  }
  _getBlue(max = [0, 1]) {
    if (!Array.isArray(max)) {
      max = [0, max];
    }
    if (this.mode === RGB || this.mode === RGBHDR) {
      const colorjsMax = Color.#colorjsMaxes[this.mode][2];
      return map(this._color.coords[2], colorjsMax[0], colorjsMax[1], max[0], max[1]);
    } else {
      const colorjsMax = Color.#colorjsMaxes[RGB][2];
      return map(to(this._color, "srgb").coords[2], colorjsMax[0], colorjsMax[1], max[0], max[1]);
    }
  }
  _getAlpha(max = [0, 1]) {
    if (!Array.isArray(max)) {
      max = [0, max];
    }
    const colorjsMax = Color.#colorjsMaxes[this.mode][3];
    return map(this._color.alpha, colorjsMax[0], colorjsMax[1], max[0], max[1]);
  }
  _getHue(max = [0, 360]) {
    if (!Array.isArray(max)) {
      max = [0, max];
    }
    if (this.mode === HSB || this.mode === HSL) {
      const colorjsMax = Color.#colorjsMaxes[this.mode][0];
      return map(this._color.coords[0], colorjsMax[0], colorjsMax[1], max[0], max[1]);
    } else {
      const colorjsMax = Color.#colorjsMaxes[HSL][0];
      return map(to(this._color, "hsl").coords[0], colorjsMax[0], colorjsMax[1], max[0], max[1]);
    }
  }
  _getSaturation(max = [0, 100]) {
    if (!Array.isArray(max)) {
      max = [0, max];
    }
    if (this.mode === HSB || this.mode === HSL) {
      const colorjsMax = Color.#colorjsMaxes[this.mode][1];
      return map(this._color.coords[1], colorjsMax[0], colorjsMax[1], max[0], max[1]);
    } else {
      const colorjsMax = Color.#colorjsMaxes[HSL][1];
      return map(to(this._color, "hsl").coords[1], colorjsMax[0], colorjsMax[1], max[0], max[1]);
    }
  }
  _getBrightness(max = [0, 100]) {
    if (!Array.isArray(max)) {
      max = [0, max];
    }
    if (this.mode === HSB) {
      const colorjsMax = Color.#colorjsMaxes[this.mode][2];
      return map(this._color.coords[2], colorjsMax[0], colorjsMax[1], max[0], max[1]);
    } else {
      const colorjsMax = Color.#colorjsMaxes[HSB][2];
      return map(to(this._color, "hsb").coords[2], colorjsMax[0], colorjsMax[1], max[0], max[1]);
    }
  }
  _getLightness(max = [0, 100]) {
    if (!Array.isArray(max)) {
      max = [0, max];
    }
    if (this.mode === HSL) {
      const colorjsMax = Color.#colorjsMaxes[this.mode][2];
      return map(this._color.coords[2], colorjsMax[0], colorjsMax[1], max[0], max[1]);
    } else {
      const colorjsMax = Color.#colorjsMaxes[HSL][2];
      return map(to(this._color, "hsl").coords[2], colorjsMax[0], colorjsMax[1], max[0], max[1]);
    }
  }
}
function color(p52, fn2, lifecycles) {
  p52.Color = Color;
  srgb_default.fromGray = p3_default.fromGray = function(val, maxes, clamp2) {
    const p5Maxes = maxes.map((max) => {
      if (!Array.isArray(max)) {
        return [0, max];
      } else {
        return max;
      }
    });
    const v = map(val, p5Maxes[2][0], p5Maxes[2][1], 0, 1, clamp2);
    return [v, v, v];
  };
  HSBSpace.fromGray = hsl_default.fromGray = function(val, maxes, clamp2) {
    const p5Maxes = maxes.map((max) => {
      if (!Array.isArray(max)) {
        return [0, max];
      } else {
        return max;
      }
    });
    const v = map(val, p5Maxes[2][0], p5Maxes[2][1], 0, 100, clamp2);
    return [0, 0, v];
  };
  hwb_default.fromGray = function(val, maxes, clamp2) {
    const p5Maxes = maxes.map((max) => {
      if (!Array.isArray(max)) {
        return [0, max];
      } else {
        return max;
      }
    });
    const wbMax = Math.abs(p5Maxes[1][0] - p5Maxes[1][1]) / 2 + Math.abs(p5Maxes[2][0] - p5Maxes[2][1]) / 2;
    const nVal = map(val, 0, wbMax, 0, 100);
    let white4, black;
    if (nVal < 50) {
      black = nVal;
      white4 = 100 - nVal;
    } else if (nVal >= 50) {
      white4 = nVal;
      black = 100 - nVal;
    }
    return [0, white4, black];
  };
  lab_default.fromGray = lch_default.fromGray = oklab_default.fromGray = oklch_default.fromGray = function(val, maxes, clamp2) {
    const p5Maxes = maxes.map((max) => {
      if (!Array.isArray(max)) {
        return [0, max];
      } else {
        return max;
      }
    });
    const v = map(val, p5Maxes[0][0], p5Maxes[0][1], 0, 100, clamp2);
    return [v, 0, 0];
  };
  p52.Color.addColorMode(RGB, srgb_default);
  p52.Color.addColorMode(RGBHDR, p3_default);
  p52.Color.addColorMode(HSB, HSBSpace);
  p52.Color.addColorMode(HSL, hsl_default);
  p52.Color.addColorMode(HWB, hwb_default);
  p52.Color.addColorMode(LAB, lab_default);
  p52.Color.addColorMode(LCH, lch_default);
  p52.Color.addColorMode(OKLAB, oklab_default);
  p52.Color.addColorMode(OKLCH, oklch_default);
  lifecycles.presetup = function() {
    const pInst = this;
    const setMethods = ["Red", "Green", "Blue", "Alpha"];
    for (let i in setMethods) {
      const method = setMethods[i];
      const setCopy = p52.Color.prototype["set" + method];
      p52.Color.prototype["set" + method] = function(newval, max) {
        max = max || pInst?._renderer?.states?.colorMaxes?.[RGB][i];
        return setCopy.call(this, newval, max);
      };
    }
    function decorateGet(channel, modes) {
      const getCopy = p52.Color.prototype["_get" + channel];
      p52.Color.prototype["_get" + channel] = function(max) {
        if (Object.keys(modes).includes(this.mode)) {
          max = max || pInst?._renderer?.states?.colorMaxes?.[this.mode][modes[this.mode]];
        } else {
          const defaultMode = Object.keys(modes)[0];
          max = max || pInst?._renderer?.states?.colorMaxes?.[defaultMode][modes[defaultMode]];
        }
        return getCopy.call(this, max);
      };
    }
    decorateGet("Red", {
      [RGB]: 0,
      [RGBHDR]: 0
    });
    decorateGet("Green", {
      [RGB]: 1,
      [RGBHDR]: 1
    });
    decorateGet("Blue", {
      [RGB]: 2,
      [RGBHDR]: 2
    });
    decorateGet("Alpha", {
      [RGB]: 3,
      [RGBHDR]: 3,
      [HSB]: 3,
      [HSL]: 3,
      [HWB]: 3,
      [LAB]: 3,
      [LCH]: 3,
      [OKLAB]: 3,
      [OKLCH]: 3
    });
    decorateGet("Hue", {
      [HSL]: 0,
      [HSB]: 0,
      [HWB]: 0,
      [LCH]: 2,
      [OKLCH]: 2
    });
    decorateGet("Saturation", {
      [HSL]: 1,
      [HSB]: 1
    });
    decorateGet("Brightness", {
      [HSB]: 2
    });
    decorateGet("Lightness", {
      [HSL]: 2
    });
  };
}
if (typeof p5 !== "undefined") {
  color(p5, p5.prototype);
}
var RGB = "rgb";
var RGBHDR = "rgbhdr";
var HSB = "hsb";
var HSL = "hsl";
var HWB = "hwb";
var LAB = "lab";
var LCH = "lch";
var OKLAB = "oklab";
var OKLCH = "oklch";
var RGBA = "rgba";
function creatingReading(p52, fn2) {
  fn2.RGB = RGB;
  fn2.RGBHDR = RGBHDR;
  fn2.HSB = HSB;
  fn2.HSL = HSL;
  fn2.HWB = HWB;
  fn2.LAB = LAB;
  fn2.LCH = LCH;
  fn2.OKLAB = OKLAB;
  fn2.OKLCH = OKLCH;
  fn2.RGBA = RGBA;
  p52.Renderer.states.colorMode = RGB;
  p52.Renderer.states.colorMaxes = {
    [RGB]: [255, 255, 255, 255],
    [RGBHDR]: [255, 255, 255, 255],
    [HSB]: [360, 100, 100, 1],
    [HSL]: [360, 100, 100, 1],
    [HWB]: [360, 100, 100, 1],
    [LAB]: [100, [-125, 125], [-125, 125], 1],
    [LCH]: [100, 150, 360, 1],
    [OKLAB]: [100, [-125, 125], [-125, 125], 1],
    [OKLCH]: [100, 150, 360, 1],
    clone: function() {
      const cloned = { ...this };
      for (const key in cloned) {
        if (cloned[key] instanceof Array) {
          cloned[key] = [...cloned[key]];
        }
      }
      return cloned;
    }
  };
  fn2.color = function(...args) {
    if (args[0] instanceof Color) {
      return args[0];
    }
    const arg = Array.isArray(args[0]) ? args[0] : args;
    return new Color(arg, this._renderer.states.colorMode, this._renderer.states.colorMaxes[this._renderer.states.colorMode], { clamp: true });
  };
  fn2.red = function(c) {
    return this.color(c)._getRed();
  };
  fn2.green = function(c) {
    return this.color(c)._getGreen();
  };
  fn2.blue = function(c) {
    return this.color(c)._getBlue();
  };
  fn2.alpha = function(c) {
    return this.color(c)._getAlpha();
  };
  fn2.hue = function(c) {
    let colorMode = HSL;
    let i = 0;
    if (this._renderer.states.colorMode === HSB || this._renderer.states.colorMode === HSL) {
      colorMode = this._renderer.states.colorMode;
    } else if (this._renderer.states.colorMode === LCH || this._renderer.states.colorMode === OKLCH) {
      colorMode = this._renderer.states.colorMode;
      i = 2;
    }
    return this.color(c)._getHue(this._renderer.states.colorMaxes[colorMode][i]);
  };
  fn2.saturation = function(c) {
    const colorMode = this._renderer.states.colorMode === HSB ? HSB : HSL;
    return this.color(c)._getSaturation(this._renderer.states.colorMaxes[colorMode][1]);
  };
  fn2.brightness = function(c) {
    return this.color(c)._getBrightness(this._renderer.states.colorMaxes.hsb[2]);
  };
  fn2.lightness = function(c) {
    return this.color(c)._getLightness(this._renderer.states.colorMaxes.hsl[2]);
  };
  fn2.lerpColor = function(c13, c23, amt) {
    return c13.lerp(c23, amt, this._renderer.states.colorMode);
  };
  fn2.paletteLerp = function(color_stops, amt) {
    const first_color_stop = color_stops[0];
    if (amt < first_color_stop[1])
      return this.color(first_color_stop[0]);
    for (let i = 1;i < color_stops.length; i++) {
      const color_stop = color_stops[i];
      if (amt < color_stop[1]) {
        const prev_color_stop = color_stops[i - 1];
        return this.lerpColor(this.color(prev_color_stop[0]), this.color(color_stop[0]), (amt - prev_color_stop[1]) / (color_stop[1] - prev_color_stop[1]));
      }
    }
    return this.color(color_stops[color_stops.length - 1][0]);
  };
}
if (typeof p5 !== "undefined") {
  creatingReading(p5, p5.prototype);
}

// node_modules/p5/dist/io/p5.XML.js
class XML {
  constructor(DOM) {
    if (!DOM) {
      const xmlDoc = document.implementation.createDocument(null, "doc");
      this.DOM = xmlDoc.createElement("root");
    } else {
      this.DOM = DOM;
    }
  }
  getParent() {
    return new XML(this.DOM.parentElement);
  }
  getName() {
    return this.DOM.tagName;
  }
  setName(name) {
    const content = this.DOM.innerHTML;
    const attributes = this.DOM.attributes;
    const xmlDoc = document.implementation.createDocument(null, "default");
    const newDOM = xmlDoc.createElement(name);
    newDOM.innerHTML = content;
    for (let i = 0;i < attributes.length; i++) {
      newDOM.setAttribute(attributes[i].nodeName, attributes[i].nodeValue);
    }
    this.DOM = newDOM;
  }
  hasChildren() {
    return this.DOM.children.length > 0;
  }
  listChildren() {
    const arr = [];
    for (let i = 0;i < this.DOM.childNodes.length; i++) {
      arr.push(this.DOM.childNodes[i].nodeName);
    }
    return arr;
  }
  getChildren(param) {
    if (param) {
      return elementsToP5XML(this.DOM.getElementsByTagName(param));
    } else {
      return elementsToP5XML(this.DOM.children);
    }
  }
  getChild(param) {
    if (typeof param === "string") {
      for (const child of this.DOM.children) {
        if (child.tagName === param)
          return new XML(child);
      }
    } else {
      return new XML(this.DOM.children[param]);
    }
  }
  addChild(node) {
    if (node instanceof XML) {
      this.DOM.appendChild(node.DOM);
    }
  }
  removeChild(param) {
    let ind = -1;
    if (typeof param === "string") {
      for (let i = 0;i < this.DOM.children.length; i++) {
        if (this.DOM.children[i].tagName === param) {
          ind = i;
          break;
        }
      }
    } else {
      ind = param;
    }
    if (ind !== -1) {
      this.DOM.removeChild(this.DOM.children[ind]);
    }
  }
  getAttributeCount() {
    return this.DOM.attributes.length;
  }
  listAttributes() {
    const arr = [];
    for (const attribute of this.DOM.attributes) {
      arr.push(attribute.nodeName);
    }
    return arr;
  }
  hasAttribute(name) {
    const obj = {};
    for (const attribute of this.DOM.attributes) {
      obj[attribute.nodeName] = attribute.nodeValue;
    }
    return obj[name] ? true : false;
  }
  getNum(name, defaultValue) {
    const obj = {};
    for (const attribute of this.DOM.attributes) {
      obj[attribute.nodeName] = attribute.nodeValue;
    }
    return Number(obj[name]) || defaultValue || 0;
  }
  getString(name, defaultValue) {
    const obj = {};
    for (const attribute of this.DOM.attributes) {
      obj[attribute.nodeName] = attribute.nodeValue;
    }
    return obj[name] ? String(obj[name]) : defaultValue || null;
  }
  setAttribute(name, value) {
    this.DOM.setAttribute(name, value);
  }
  getContent(defaultValue) {
    let str;
    str = this.DOM.textContent;
    str = str.replace(/\s\s+/g, ",");
    return str || defaultValue || null;
  }
  setContent(content) {
    if (!this.DOM.children.length) {
      this.DOM.textContent = content;
    }
  }
  serialize() {
    const xmlSerializer = new XMLSerializer;
    return xmlSerializer.serializeToString(this.DOM);
  }
}
function elementsToP5XML(elements) {
  const arr = [];
  for (let i = 0;i < elements.length; i++) {
    arr.push(new XML(elements[i]));
  }
  return arr;
}
function xml(p52, fn2) {
  p52.XML = XML;
}
if (typeof p5 !== "undefined") {
  xml(p5, p5.prototype);
}

// node_modules/p5/dist/dom/p5.File.js
class File2 {
  constructor(file, pInst) {
    this.file = file;
    this._pInst = pInst;
    const typeList = file.type.split("/");
    this.type = typeList[0];
    this.subtype = typeList[1];
    this.name = file.name;
    this.size = file.size;
    this.data = undefined;
  }
  static _createLoader(theFile, callback) {
    const reader = new FileReader;
    reader.onload = function(e2) {
      const p5file = new File2(theFile);
      if (p5file.file.type === "application/json") {
        p5file.data = JSON.parse(e2.target.result);
      } else if (p5file.file.type === "text/xml") {
        const parser = new DOMParser;
        const xml2 = parser.parseFromString(e2.target.result, "text/xml");
        p5file.data = new XML(xml2.documentElement);
      } else {
        p5file.data = e2.target.result;
      }
      callback(p5file);
    };
    return reader;
  }
  static _load(f, callback) {
    if (/^text\//.test(f.type) || f.type === "application/json") {
      File2._createLoader(f, callback).readAsText(f);
    } else if (!/^(video|audio)\//.test(f.type)) {
      File2._createLoader(f, callback).readAsDataURL(f);
    } else {
      const file = new File2(f);
      file.data = URL.createObjectURL(f);
      callback(file);
    }
  }
}
function file(p52, fn2) {
  p52.File = File2;
}
if (typeof p5 !== "undefined") {
  file(p5, p5.prototype);
}

// node_modules/p5/dist/dom/p5.Element.js
class Element {
  width;
  height;
  elt;
  constructor(elt, pInst) {
    this.elt = elt;
    this._pInst = this._pixelsState = pInst;
    this._events = {};
    this.width = this.elt.offsetWidth;
    this.height = this.elt.offsetHeight;
  }
  remove() {
    if (this.stop) {
      this.stop();
      const sources = this.elt.srcObject;
      if (sources !== null) {
        const tracks = sources.getTracks();
        tracks.forEach((track) => {
          track.stop();
        });
      }
    }
    let sketch = this._pInst;
    if (sketch && !sketch._elements && sketch._pInst) {
      sketch = sketch._pInst;
    }
    if (sketch && sketch._elements) {
      const i = sketch._elements.indexOf(this);
      if (i !== -1)
        sketch._elements.splice(i, 1);
    }
    for (let ev in this._events) {
      this.elt.removeEventListener(ev, this._events[ev]);
    }
    if (this.elt && this.elt.parentNode) {
      this.elt.parentNode.removeChild(this.elt);
    }
  }
  parent(p2) {
    if (typeof p2 === "undefined") {
      return this.elt.parentNode;
    }
    if (typeof p2 === "string") {
      if (p2[0] === "#") {
        p2 = p2.substring(1);
      }
      p2 = document.getElementById(p2);
    } else if (p2 instanceof Element) {
      p2 = p2.elt;
    }
    p2.appendChild(this.elt);
    return this;
  }
  child(childNode) {
    if (typeof childNode === "undefined") {
      return this.elt.childNodes;
    }
    if (typeof childNode === "string") {
      if (childNode[0] === "#") {
        childNode = childNode.substring(1);
      }
      childNode = document.getElementById(childNode);
    } else if (childNode instanceof Element) {
      childNode = childNode.elt;
    }
    if (childNode instanceof HTMLElement) {
      this.elt.appendChild(childNode);
    }
    return this;
  }
  html(...args) {
    if (args.length === 0) {
      return this.elt.innerHTML;
    } else if (args[1]) {
      this.elt.insertAdjacentHTML("beforeend", args[0]);
      return this;
    } else {
      this.elt.innerHTML = args[0];
      return this;
    }
  }
  id(id) {
    if (typeof id === "undefined") {
      return this.elt.id;
    }
    this.elt.id = id;
    this.width = this.elt.offsetWidth;
    this.height = this.elt.offsetHeight;
    return this;
  }
  class(c) {
    if (typeof c === "undefined") {
      return this.elt.className;
    }
    this.elt.className = c;
    return this;
  }
  addClass(c) {
    if (this.elt.className) {
      if (!this.hasClass(c)) {
        this.elt.className = this.elt.className + " " + c;
      }
    } else {
      this.elt.className = c;
    }
    return this;
  }
  removeClass(c) {
    this.elt.classList.remove(c);
    return this;
  }
  hasClass(c) {
    return this.elt.classList.contains(c);
  }
  toggleClass(c) {
    if (this.elt.classList.contains(c)) {
      this.elt.classList.remove(c);
    } else {
      this.elt.classList.add(c);
    }
    return this;
  }
  center(align) {
    const style = this.elt.style.display;
    const hidden = this.elt.style.display === "none";
    const parentHidden = this.parent().style.display === "none";
    const pos = { x: this.elt.offsetLeft, y: this.elt.offsetTop };
    if (hidden)
      this.show();
    if (parentHidden)
      this.parent().show();
    this.elt.style.display = "block";
    this.position(0, 0);
    const wOffset = Math.abs(this.parent().offsetWidth - this.elt.offsetWidth);
    const hOffset = Math.abs(this.parent().offsetHeight - this.elt.offsetHeight);
    if (align === "both" || align === undefined) {
      this.position(wOffset / 2 + this.parent().offsetLeft, hOffset / 2 + this.parent().offsetTop);
    } else if (align === "horizontal") {
      this.position(wOffset / 2 + this.parent().offsetLeft, pos.y);
    } else if (align === "vertical") {
      this.position(pos.x, hOffset / 2 + this.parent().offsetTop);
    }
    this.style("display", style);
    if (hidden)
      this.hide();
    if (parentHidden)
      this.parent().hide();
    return this;
  }
  position(...args) {
    if (args.length === 0) {
      return { x: this.elt.offsetLeft, y: this.elt.offsetTop };
    } else {
      let positionType = "absolute";
      if (args[2] === "static" || args[2] === "fixed" || args[2] === "relative" || args[2] === "sticky" || args[2] === "initial" || args[2] === "inherit") {
        positionType = args[2];
      }
      this.elt.style.position = positionType;
      this.elt.style.left = args[0] + "px";
      this.elt.style.top = args[1] + "px";
      this.x = args[0];
      this.y = args[1];
      return this;
    }
  }
  show() {
    this.elt.style.display = "block";
    return this;
  }
  hide() {
    this.elt.style.display = "none";
    return this;
  }
  size(w, h) {
    if (arguments.length === 0) {
      return { width: this.elt.offsetWidth, height: this.elt.offsetHeight };
    } else {
      let aW = w;
      let aH = h;
      const AUTO$1 = AUTO;
      if (aW !== AUTO$1 || aH !== AUTO$1) {
        if (aW === AUTO$1) {
          aW = h * this.width / this.height;
        } else if (aH === AUTO$1) {
          aH = w * this.height / this.width;
        }
        if (this.elt instanceof HTMLCanvasElement) {
          const j = {};
          const k = this.elt.getContext("2d");
          let prop;
          for (prop in k) {
            j[prop] = k[prop];
          }
          this.elt.setAttribute("width", aW * this._pInst._pixelDensity);
          this.elt.setAttribute("height", aH * this._pInst._pixelDensity);
          this.elt.style.width = aW + "px";
          this.elt.style.height = aH + "px";
          this._pInst.scale(this._pInst._pixelDensity, this._pInst._pixelDensity);
          for (prop in j) {
            this.elt.getContext("2d")[prop] = j[prop];
          }
        } else {
          this.elt.style.width = aW + "px";
          this.elt.style.height = aH + "px";
          this.elt.width = aW;
          this.elt.height = aH;
        }
        this.width = aW;
        this.height = aH;
        if (this._pInst && this._pInst._curElement) {
          if (this._pInst._curElement.elt === this.elt) {
            this._pInst.width = aW;
            this._pInst.height = aH;
          }
        }
      }
      return this;
    }
  }
  style(prop, val) {
    const self2 = this;
    if (val instanceof Color) {
      val = val.toString();
    }
    if (typeof val === "undefined") {
      if (prop.indexOf(":") === -1) {
        let styles = window.getComputedStyle(self2.elt);
        let style = styles.getPropertyValue(prop);
        return style;
      } else {
        const attrs = prop.split(";");
        for (let i = 0;i < attrs.length; i++) {
          const parts = attrs[i].split(":");
          if (parts[0] && parts[1]) {
            this.elt.style[parts[0].trim()] = parts[1].trim();
          }
        }
      }
    } else {
      this.elt.style[prop] = val;
      if (prop === "width" || prop === "height" || prop === "left" || prop === "top") {
        let styles = window.getComputedStyle(self2.elt);
        let styleVal = styles.getPropertyValue(prop);
        let numVal = styleVal.replace(/[^\d.]/g, "");
        this[prop] = Math.round(parseFloat(numVal, 10));
      }
    }
    return this;
  }
  _translate(...args) {
    this.elt.style.position = "absolute";
    let transform2 = "";
    if (this.elt.style.transform) {
      transform2 = this.elt.style.transform.replace(/translate3d\(.*\)/g, "");
      transform2 = transform2.replace(/translate[X-Z]?\(.*\)/g, "");
    }
    if (args.length === 2) {
      this.elt.style.transform = "translate(" + args[0] + "px, " + args[1] + "px)";
    } else if (args.length > 2) {
      this.elt.style.transform = "translate3d(" + args[0] + "px," + args[1] + "px," + args[2] + "px)";
      if (args.length === 3) {
        this.elt.parentElement.style.perspective = "1000px";
      } else {
        this.elt.parentElement.style.perspective = args[3] + "px";
      }
    }
    this.elt.style.transform += transform2;
    return this;
  }
  _rotate(...args) {
    let transform2 = "";
    if (this.elt.style.transform) {
      transform2 = this.elt.style.transform.replace(/rotate3d\(.*\)/g, "");
      transform2 = transform2.replace(/rotate[X-Z]?\(.*\)/g, "");
    }
    if (args.length === 1) {
      this.elt.style.transform = "rotate(" + args[0] + "deg)";
    } else if (args.length === 2) {
      this.elt.style.transform = "rotate(" + args[0] + "deg, " + args[1] + "deg)";
    } else if (args.length === 3) {
      this.elt.style.transform = "rotateX(" + args[0] + "deg)";
      this.elt.style.transform += "rotateY(" + args[1] + "deg)";
      this.elt.style.transform += "rotateZ(" + args[2] + "deg)";
    }
    this.elt.style.transform += transform2;
    return this;
  }
  attribute(attr, value) {
    if (this.elt.firstChild != null && (this.elt.firstChild.type === "checkbox" || this.elt.firstChild.type === "radio")) {
      if (typeof value === "undefined") {
        return this.elt.firstChild.getAttribute(attr);
      } else {
        for (let i = 0;i < this.elt.childNodes.length; i++) {
          this.elt.childNodes[i].setAttribute(attr, value);
        }
      }
    } else if (typeof value === "undefined") {
      return this.elt.getAttribute(attr);
    } else {
      this.elt.setAttribute(attr, value);
      return this;
    }
  }
  removeAttribute(attr) {
    if (this.elt.firstChild != null && (this.elt.firstChild.type === "checkbox" || this.elt.firstChild.type === "radio")) {
      for (let i = 0;i < this.elt.childNodes.length; i++) {
        this.elt.childNodes[i].removeAttribute(attr);
      }
    }
    this.elt.removeAttribute(attr);
    return this;
  }
  value(...args) {
    if (args.length > 0) {
      this.elt.value = args[0];
      return this;
    } else {
      if (this.elt.type === "range") {
        return parseFloat(this.elt.value);
      } else
        return this.elt.value;
    }
  }
  mousePressed(fxn) {
    const eventPrependedFxn = function(event) {
      this._pInst.mouseIsPressed = true;
      this._pInst._activePointers.set(event.pointerId, event);
      this._pInst._setMouseButton(event);
      this._pInst._updatePointerCoords(event);
      return fxn.call(this, event);
    };
    Element._adjustListener("pointerdown", eventPrependedFxn, this);
    return this;
  }
  doubleClicked(fxn) {
    Element._adjustListener("dblclick", fxn, this);
    return this;
  }
  mouseWheel(fxn) {
    Element._adjustListener("wheel", fxn, this);
    return this;
  }
  mouseReleased(fxn) {
    Element._adjustListener("pointerup", fxn, this);
    return this;
  }
  mouseClicked(fxn) {
    Element._adjustListener("click", fxn, this);
    return this;
  }
  mouseMoved(fxn) {
    Element._adjustListener("pointermove", fxn, this);
    return this;
  }
  mouseOver(fxn) {
    Element._adjustListener("pointerover", fxn, this);
    return this;
  }
  mouseOut(fxn) {
    Element._adjustListener("pointerout", fxn, this);
    return this;
  }
  dragOver(fxn) {
    Element._adjustListener("dragover", fxn, this);
    return this;
  }
  dragLeave(fxn) {
    Element._adjustListener("dragleave", fxn, this);
    return this;
  }
  changed(fxn) {
    Element._adjustListener("change", fxn, this);
    return this;
  }
  input(fxn) {
    Element._adjustListener("input", fxn, this);
    return this;
  }
  drop(callback, fxn) {
    if (window.File && window.FileReader && window.FileList && window.Blob) {
      if (!this._dragDisabled) {
        this._dragDisabled = true;
        const preventDefault = function(evt) {
          evt.preventDefault();
        };
        this.elt.addEventListener("dragover", preventDefault);
        this.elt.addEventListener("dragleave", preventDefault);
      }
      Element._attachListener("drop", function(evt) {
        evt.preventDefault();
        if (typeof fxn === "function") {
          fxn.call(this, evt);
        }
        const files = evt.dataTransfer.files;
        for (const f of files) {
          File2._load(f, callback);
        }
      }, this);
    } else {
      console.log("The File APIs are not fully supported in this browser.");
    }
    return this;
  }
  draggable(elmMove) {
    let isTouch = "ontouchstart" in window;
    let x = 0, y = 0, px = 0, py = 0, elmDrag, dragMouseDownEvt = isTouch ? "touchstart" : "mousedown", closeDragElementEvt = isTouch ? "touchend" : "mouseup", elementDragEvt = isTouch ? "touchmove" : "mousemove";
    if (elmMove === undefined) {
      elmMove = this.elt;
      elmDrag = elmMove;
    } else if (elmMove !== this.elt && elmMove.elt !== this.elt) {
      elmMove = elmMove.elt;
      elmDrag = this.elt;
    }
    elmDrag.addEventListener(dragMouseDownEvt, dragMouseDown, false);
    elmDrag.style.cursor = "move";
    function dragMouseDown(e2) {
      e2 = e2 || window.event;
      if (isTouch) {
        const touches = e2.changedTouches;
        px = parseInt(touches[0].clientX);
        py = parseInt(touches[0].clientY);
      } else {
        px = parseInt(e2.clientX);
        py = parseInt(e2.clientY);
      }
      document.addEventListener(closeDragElementEvt, closeDragElement, false);
      document.addEventListener(elementDragEvt, elementDrag, false);
      return false;
    }
    function elementDrag(e2) {
      e2 = e2 || window.event;
      if (isTouch) {
        const touches = e2.changedTouches;
        x = px - parseInt(touches[0].clientX);
        y = py - parseInt(touches[0].clientY);
        px = parseInt(touches[0].clientX);
        py = parseInt(touches[0].clientY);
      } else {
        x = px - parseInt(e2.clientX);
        y = py - parseInt(e2.clientY);
        px = parseInt(e2.clientX);
        py = parseInt(e2.clientY);
      }
      elmMove.style.left = elmMove.offsetLeft - x + "px";
      elmMove.style.top = elmMove.offsetTop - y + "px";
    }
    function closeDragElement() {
      document.removeEventListener(closeDragElementEvt, closeDragElement, false);
      document.removeEventListener(elementDragEvt, elementDrag, false);
    }
    return this;
  }
  static _adjustListener(ev, fxn, ctx) {
    if (fxn === false) {
      Element._detachListener(ev, ctx);
    } else {
      Element._attachListener(ev, fxn, ctx);
    }
    return this;
  }
  static _attachListener(ev, fxn, ctx) {
    if (ctx._events[ev]) {
      Element._detachListener(ev, ctx);
    }
    const f = fxn.bind(ctx);
    ctx.elt.addEventListener(ev, f, {
      capture: false,
      signal: ctx._pInst._removeSignal
    });
    ctx._events[ev] = f;
  }
  static _detachListener(ev, ctx) {
    const f = ctx._events[ev];
    ctx.elt.removeEventListener(ev, f, false);
    ctx._events[ev] = null;
  }
}
function element(p52, fn2) {
  p52.Element = Element;
}
if (typeof p5 !== "undefined") {
  element(p5, p5.prototype);
}

// node_modules/p5/dist/image/filters.js
var Filters = {
  _toPixels(canvas) {
    if (canvas instanceof ImageData) {
      return canvas.data;
    } else {
      if (canvas.getContext("2d")) {
        return canvas.getContext("2d").getImageData(0, 0, canvas.width, canvas.height).data;
      } else if (canvas.getContext("webgl")) {
        const gl = canvas.getContext("webgl");
        const len = gl.drawingBufferWidth * gl.drawingBufferHeight * 4;
        const data = new Uint8Array(len);
        gl.readPixels(0, 0, canvas.width, canvas.height, gl.RGBA, gl.UNSIGNED_BYTE, data);
        return data;
      }
    }
  },
  _getARGB(data, i) {
    const offset = i * 4;
    return data[offset + 3] << 24 & 4278190080 | data[offset] << 16 & 16711680 | data[offset + 1] << 8 & 65280 | data[offset + 2] & 255;
  },
  _setPixels(pixels, data) {
    let offset = 0;
    for (let i = 0, al = pixels.length;i < al; i++) {
      offset = i * 4;
      pixels[offset + 0] = (data[i] & 16711680) >>> 16;
      pixels[offset + 1] = (data[i] & 65280) >>> 8;
      pixels[offset + 2] = data[i] & 255;
      pixels[offset + 3] = (data[i] & 4278190080) >>> 24;
    }
  },
  _toImageData(canvas) {
    if (canvas instanceof ImageData) {
      return canvas;
    } else {
      return canvas.getContext("2d").getImageData(0, 0, canvas.width, canvas.height);
    }
  },
  _createImageData(width, height) {
    Filters._tmpCanvas = document.createElement("canvas");
    Filters._tmpCtx = Filters._tmpCanvas.getContext("2d");
    return this._tmpCtx.createImageData(width, height);
  },
  apply(canvas, func, filterParam) {
    const pixelsState = canvas.getContext("2d");
    const imageData = pixelsState.getImageData(0, 0, canvas.width, canvas.height);
    const newImageData = func(imageData, filterParam);
    if (newImageData instanceof ImageData) {
      pixelsState.putImageData(newImageData, 0, 0, 0, 0, canvas.width, canvas.height);
    } else {
      pixelsState.putImageData(imageData, 0, 0, 0, 0, canvas.width, canvas.height);
    }
  },
  threshold(canvas, level = 0.5) {
    const pixels = Filters._toPixels(canvas);
    const thresh = Math.floor(level * 255);
    for (let i = 0;i < pixels.length; i += 4) {
      const r = pixels[i];
      const g2 = pixels[i + 1];
      const b2 = pixels[i + 2];
      const gray = 0.2126 * r + 0.7152 * g2 + 0.0722 * b2;
      let val;
      if (gray >= thresh) {
        val = 255;
      } else {
        val = 0;
      }
      pixels[i] = pixels[i + 1] = pixels[i + 2] = val;
    }
  },
  gray(canvas) {
    const pixels = Filters._toPixels(canvas);
    for (let i = 0;i < pixels.length; i += 4) {
      const r = pixels[i];
      const g2 = pixels[i + 1];
      const b2 = pixels[i + 2];
      const gray = 0.2126 * r + 0.7152 * g2 + 0.0722 * b2;
      pixels[i] = pixels[i + 1] = pixels[i + 2] = gray;
    }
  },
  opaque(canvas) {
    const pixels = Filters._toPixels(canvas);
    for (let i = 0;i < pixels.length; i += 4) {
      pixels[i + 3] = 255;
    }
    return pixels;
  },
  invert(canvas) {
    const pixels = Filters._toPixels(canvas);
    for (let i = 0;i < pixels.length; i += 4) {
      pixels[i] = 255 - pixels[i];
      pixels[i + 1] = 255 - pixels[i + 1];
      pixels[i + 2] = 255 - pixels[i + 2];
    }
  },
  posterize(canvas, level = 4) {
    const pixels = Filters._toPixels(canvas);
    if (level < 2 || level > 255) {
      throw new Error("Level must be greater than 2 and less than 255 for posterize");
    }
    const levels1 = level - 1;
    for (let i = 0;i < pixels.length; i += 4) {
      const rlevel = pixels[i];
      const glevel = pixels[i + 1];
      const blevel = pixels[i + 2];
      pixels[i] = (rlevel * level >> 8) * 255 / levels1;
      pixels[i + 1] = (glevel * level >> 8) * 255 / levels1;
      pixels[i + 2] = (blevel * level >> 8) * 255 / levels1;
    }
  },
  dilate(canvas) {
    const pixels = Filters._toPixels(canvas);
    let currIdx = 0;
    const maxIdx = pixels.length ? pixels.length / 4 : 0;
    const out = new Int32Array(maxIdx);
    let currRowIdx, maxRowIdx, colOrig, colOut, currLum;
    let idxRight, idxLeft, idxUp, idxDown;
    let colRight, colLeft, colUp, colDown;
    let lumRight, lumLeft, lumUp, lumDown;
    while (currIdx < maxIdx) {
      currRowIdx = currIdx;
      maxRowIdx = currIdx + canvas.width;
      while (currIdx < maxRowIdx) {
        colOrig = colOut = Filters._getARGB(pixels, currIdx);
        idxLeft = currIdx - 1;
        idxRight = currIdx + 1;
        idxUp = currIdx - canvas.width;
        idxDown = currIdx + canvas.width;
        if (idxLeft < currRowIdx) {
          idxLeft = currIdx;
        }
        if (idxRight >= maxRowIdx) {
          idxRight = currIdx;
        }
        if (idxUp < 0) {
          idxUp = 0;
        }
        if (idxDown >= maxIdx) {
          idxDown = currIdx;
        }
        colUp = Filters._getARGB(pixels, idxUp);
        colLeft = Filters._getARGB(pixels, idxLeft);
        colDown = Filters._getARGB(pixels, idxDown);
        colRight = Filters._getARGB(pixels, idxRight);
        currLum = 77 * (colOrig >> 16 & 255) + 151 * (colOrig >> 8 & 255) + 28 * (colOrig & 255);
        lumLeft = 77 * (colLeft >> 16 & 255) + 151 * (colLeft >> 8 & 255) + 28 * (colLeft & 255);
        lumRight = 77 * (colRight >> 16 & 255) + 151 * (colRight >> 8 & 255) + 28 * (colRight & 255);
        lumUp = 77 * (colUp >> 16 & 255) + 151 * (colUp >> 8 & 255) + 28 * (colUp & 255);
        lumDown = 77 * (colDown >> 16 & 255) + 151 * (colDown >> 8 & 255) + 28 * (colDown & 255);
        if (lumLeft > currLum) {
          colOut = colLeft;
          currLum = lumLeft;
        }
        if (lumRight > currLum) {
          colOut = colRight;
          currLum = lumRight;
        }
        if (lumUp > currLum) {
          colOut = colUp;
          currLum = lumUp;
        }
        if (lumDown > currLum) {
          colOut = colDown;
          currLum = lumDown;
        }
        out[currIdx++] = colOut;
      }
    }
    Filters._setPixels(pixels, out);
  },
  erode(canvas) {
    const pixels = Filters._toPixels(canvas);
    let currIdx = 0;
    const maxIdx = pixels.length ? pixels.length / 4 : 0;
    const out = new Int32Array(maxIdx);
    let currRowIdx, maxRowIdx, colOrig, colOut, currLum;
    let idxRight, idxLeft, idxUp, idxDown;
    let colRight, colLeft, colUp, colDown;
    let lumRight, lumLeft, lumUp, lumDown;
    while (currIdx < maxIdx) {
      currRowIdx = currIdx;
      maxRowIdx = currIdx + canvas.width;
      while (currIdx < maxRowIdx) {
        colOrig = colOut = Filters._getARGB(pixels, currIdx);
        idxLeft = currIdx - 1;
        idxRight = currIdx + 1;
        idxUp = currIdx - canvas.width;
        idxDown = currIdx + canvas.width;
        if (idxLeft < currRowIdx) {
          idxLeft = currIdx;
        }
        if (idxRight >= maxRowIdx) {
          idxRight = currIdx;
        }
        if (idxUp < 0) {
          idxUp = 0;
        }
        if (idxDown >= maxIdx) {
          idxDown = currIdx;
        }
        colUp = Filters._getARGB(pixels, idxUp);
        colLeft = Filters._getARGB(pixels, idxLeft);
        colDown = Filters._getARGB(pixels, idxDown);
        colRight = Filters._getARGB(pixels, idxRight);
        currLum = 77 * (colOrig >> 16 & 255) + 151 * (colOrig >> 8 & 255) + 28 * (colOrig & 255);
        lumLeft = 77 * (colLeft >> 16 & 255) + 151 * (colLeft >> 8 & 255) + 28 * (colLeft & 255);
        lumRight = 77 * (colRight >> 16 & 255) + 151 * (colRight >> 8 & 255) + 28 * (colRight & 255);
        lumUp = 77 * (colUp >> 16 & 255) + 151 * (colUp >> 8 & 255) + 28 * (colUp & 255);
        lumDown = 77 * (colDown >> 16 & 255) + 151 * (colDown >> 8 & 255) + 28 * (colDown & 255);
        if (lumLeft < currLum) {
          colOut = colLeft;
          currLum = lumLeft;
        }
        if (lumRight < currLum) {
          colOut = colRight;
          currLum = lumRight;
        }
        if (lumUp < currLum) {
          colOut = colUp;
          currLum = lumUp;
        }
        if (lumDown < currLum) {
          colOut = colDown;
          currLum = lumDown;
        }
        out[currIdx++] = colOut;
      }
    }
    Filters._setPixels(pixels, out);
  },
  blur(canvas, radius) {
    blurARGB(canvas, radius);
  }
};
var blurRadius;
var blurKernelSize;
var blurKernel;
var blurMult;
function buildBlurKernel(r) {
  let radius = r * 3.5 | 0;
  radius = radius < 1 ? 1 : radius < 248 ? radius : 248;
  if (blurRadius !== radius) {
    blurRadius = radius;
    blurKernelSize = 1 + blurRadius << 1;
    blurKernel = new Int32Array(blurKernelSize);
    blurMult = new Array(blurKernelSize);
    for (let l = 0;l < blurKernelSize; l++) {
      blurMult[l] = new Int32Array(256);
    }
    let bk, bki;
    let bm, bmi;
    for (let i = 1, radiusi = radius - 1;i < radius; i++) {
      blurKernel[radius + i] = blurKernel[radiusi] = bki = radiusi * radiusi;
      bm = blurMult[radius + i];
      bmi = blurMult[radiusi--];
      for (let j = 0;j < 256; j++) {
        bm[j] = bmi[j] = bki * j;
      }
    }
    bk = blurKernel[radius] = radius * radius;
    bm = blurMult[radius];
    for (let k = 0;k < 256; k++) {
      bm[k] = bk * k;
    }
  }
}
function blurARGB(canvas, radius) {
  const pixels = Filters._toPixels(canvas);
  const width = canvas.width;
  const height = canvas.height;
  const numPackedPixels = width * height;
  const argb = new Int32Array(numPackedPixels);
  for (let j = 0;j < numPackedPixels; j++) {
    argb[j] = Filters._getARGB(pixels, j);
  }
  let sum, cr, cg, cb, ca;
  let read, ri, ym, ymi, bk0;
  const a2 = new Int32Array(numPackedPixels);
  const r2 = new Int32Array(numPackedPixels);
  const g2 = new Int32Array(numPackedPixels);
  const b2 = new Int32Array(numPackedPixels);
  let yi = 0;
  buildBlurKernel(radius);
  let x, y, i;
  let bm;
  for (y = 0;y < height; y++) {
    for (x = 0;x < width; x++) {
      cb = cg = cr = ca = sum = 0;
      read = x - blurRadius;
      if (read < 0) {
        bk0 = -read;
        read = 0;
      } else {
        if (read >= width) {
          break;
        }
        bk0 = 0;
      }
      for (i = bk0;i < blurKernelSize; i++) {
        if (read >= width) {
          break;
        }
        const c = argb[read + yi];
        bm = blurMult[i];
        ca += bm[(c & -16777216) >>> 24];
        cr += bm[(c & 16711680) >> 16];
        cg += bm[(c & 65280) >> 8];
        cb += bm[c & 255];
        sum += blurKernel[i];
        read++;
      }
      ri = yi + x;
      a2[ri] = ca / sum;
      r2[ri] = cr / sum;
      g2[ri] = cg / sum;
      b2[ri] = cb / sum;
    }
    yi += width;
  }
  yi = 0;
  ym = -blurRadius;
  ymi = ym * width;
  for (y = 0;y < height; y++) {
    for (x = 0;x < width; x++) {
      cb = cg = cr = ca = sum = 0;
      if (ym < 0) {
        bk0 = ri = -ym;
        read = x;
      } else {
        if (ym >= height) {
          break;
        }
        bk0 = 0;
        ri = ym;
        read = x + ymi;
      }
      for (i = bk0;i < blurKernelSize; i++) {
        if (ri >= height) {
          break;
        }
        bm = blurMult[i];
        ca += bm[a2[read]];
        cr += bm[r2[read]];
        cg += bm[g2[read]];
        cb += bm[b2[read]];
        sum += blurKernel[i];
        ri++;
        read += width;
      }
      argb[x + yi] = ca / sum << 24 | cr / sum << 16 | cg / sum << 8 | cb / sum;
    }
    yi += width;
    ymi += width;
    ym++;
  }
  Filters._setPixels(pixels, argb);
}

// node_modules/p5/dist/math/p5.Vector.js
var calculateRemainder2D = function(xComponent, yComponent) {
  if (xComponent !== 0) {
    this.x = this.x % xComponent;
  }
  if (yComponent !== 0) {
    this.y = this.y % yComponent;
  }
  return this;
};
var calculateRemainder3D = function(xComponent, yComponent, zComponent) {
  if (xComponent !== 0) {
    this.x = this.x % xComponent;
  }
  if (yComponent !== 0) {
    this.y = this.y % yComponent;
  }
  if (zComponent !== 0) {
    this.z = this.z % zComponent;
  }
  return this;
};

class Vector {
  constructor(...args) {
    let values = args;
    if (typeof args[0] === "function") {
      this.isPInst = true;
      this._fromRadians = args[0];
      this._toRadians = args[1];
      values = args.slice(2);
    }
    let dimensions = values.length;
    if (dimensions === 0) {
      this.dimensions = 2;
      this._values = [0, 0, 0];
    } else {
      this.dimensions = dimensions;
      this._values = values;
    }
  }
  get values() {
    return this._values;
  }
  set values(newValues) {
    let dimensions = newValues.length;
    if (dimensions === 0) {
      this.dimensions = 2;
      this._values = [0, 0, 0];
    } else {
      this.dimensions = dimensions;
      this._values = newValues.slice();
    }
  }
  get x() {
    return this._values[0] || 0;
  }
  getValue(index) {
    if (index < this._values.length) {
      return this._values[index];
    } else {
      p5._friendlyError("The index parameter is trying to set a value outside the bounds of the vector", "p5.Vector.setValue");
    }
  }
  setValue(index, value) {
    if (index < this._values.length) {
      this._values[index] = value;
    } else {
      p5._friendlyError("The index parameter is trying to set a value outside the bounds of the vector", "p5.Vector.setValue");
    }
  }
  get y() {
    return this._values[1] || 0;
  }
  get z() {
    return this._values[2] || 0;
  }
  get w() {
    return this._values[3] || 0;
  }
  set x(xVal) {
    if (this._values.length > 1) {
      this._values[0] = xVal;
    }
  }
  set y(yVal) {
    if (this._values.length > 1) {
      this._values[1] = yVal;
    }
  }
  set z(zVal) {
    if (this._values.length > 2) {
      this._values[2] = zVal;
    }
  }
  set w(wVal) {
    if (this._values.length > 3) {
      this._values[3] = wVal;
    }
  }
  toString() {
    return `vector[${this._values.join(", ")}]`;
  }
  set(...args) {
    if (args[0] instanceof Vector) {
      this._values = args[0].values.slice();
    } else if (Array.isArray(args[0])) {
      this._values = args[0].map((arg) => arg || 0);
    } else {
      this._values = args.map((arg) => arg || 0);
    }
    this.dimensions = this._values.length;
    return this;
  }
  copy() {
    if (this.isPInst) {
      return new Vector(this._fromRadians, this._toRadians, ...this._values);
    } else {
      return new Vector(...this._values);
    }
  }
  add(...args) {
    if (args[0] instanceof Vector) {
      args = args[0].values;
    } else if (Array.isArray(args[0])) {
      args = args[0];
    }
    args.forEach((value, index) => {
      this._values[index] = (this._values[index] || 0) + (value || 0);
    });
    return this;
  }
  rem(x, y, z) {
    if (x instanceof Vector) {
      if ([x.x, x.y, x.z].every(Number.isFinite)) {
        const xComponent = parseFloat(x.x);
        const yComponent = parseFloat(x.y);
        const zComponent = parseFloat(x.z);
        return calculateRemainder3D.call(this, xComponent, yComponent, zComponent);
      }
    } else if (Array.isArray(x)) {
      if (x.every((element2) => Number.isFinite(element2))) {
        if (x.length === 2) {
          return calculateRemainder2D.call(this, x[0], x[1]);
        }
        if (x.length === 3) {
          return calculateRemainder3D.call(this, x[0], x[1], x[2]);
        }
      }
    } else if (arguments.length === 1) {
      if (Number.isFinite(arguments[0]) && arguments[0] !== 0) {
        this.x = this.x % arguments[0];
        this.y = this.y % arguments[0];
        this.z = this.z % arguments[0];
        return this;
      }
    } else if (arguments.length === 2) {
      const vectorComponents = [...arguments];
      if (vectorComponents.every((element2) => Number.isFinite(element2))) {
        if (vectorComponents.length === 2) {
          return calculateRemainder2D.call(this, vectorComponents[0], vectorComponents[1]);
        }
      }
    } else if (arguments.length === 3) {
      const vectorComponents = [...arguments];
      if (vectorComponents.every((element2) => Number.isFinite(element2))) {
        if (vectorComponents.length === 3) {
          return calculateRemainder3D.call(this, vectorComponents[0], vectorComponents[1], vectorComponents[2]);
        }
      }
    }
  }
  sub(...args) {
    if (args[0] instanceof Vector) {
      args[0].values.forEach((value, index) => {
        this._values[index] -= value || 0;
      });
    } else if (Array.isArray(args[0])) {
      args[0].forEach((value, index) => {
        this._values[index] -= value || 0;
      });
    } else {
      args.forEach((value, index) => {
        this._values[index] -= value || 0;
      });
    }
    return this;
  }
  mult(...args) {
    if (args.length === 1 && args[0] instanceof Vector) {
      const v = args[0];
      const maxLen = Math.min(this._values.length, v.values.length);
      for (let i = 0;i < maxLen; i++) {
        if (Number.isFinite(v.values[i]) && typeof v.values[i] === "number") {
          this._values[i] *= v.values[i];
        } else {
          console.warn("p5.Vector.prototype.mult:", "v contains components that are either undefined or not finite numbers");
          return this;
        }
      }
    } else if (args.length === 1 && Array.isArray(args[0])) {
      const arr = args[0];
      const maxLen = Math.min(this._values.length, arr.length);
      for (let i = 0;i < maxLen; i++) {
        if (Number.isFinite(arr[i]) && typeof arr[i] === "number") {
          this._values[i] *= arr[i];
        } else {
          console.warn("p5.Vector.prototype.mult:", "arr contains elements that are either undefined or not finite numbers");
          return this;
        }
      }
    } else if (args.length === 1 && typeof args[0] === "number" && Number.isFinite(args[0])) {
      for (let i = 0;i < this._values.length; i++) {
        this._values[i] *= args[0];
      }
    }
    return this;
  }
  div(...args) {
    if (args.length === 0)
      return this;
    if (args.length === 1 && args[0] instanceof Vector) {
      const v = args[0];
      if (v._values.every((val) => Number.isFinite(val) && typeof val === "number")) {
        if (v._values.some((val) => val === 0)) {
          console.warn("p5.Vector.prototype.div:", "divide by 0");
          return this;
        }
        this._values = this._values.map((val, i) => val / v._values[i]);
      } else {
        console.warn("p5.Vector.prototype.div:", "vector contains components that are either undefined or not finite numbers");
      }
      return this;
    }
    if (args.length === 1 && Array.isArray(args[0])) {
      const arr = args[0];
      if (arr.every((val) => Number.isFinite(val) && typeof val === "number")) {
        if (arr.some((val) => val === 0)) {
          console.warn("p5.Vector.prototype.div:", "divide by 0");
          return this;
        }
        this._values = this._values.map((val, i) => val / arr[i]);
      } else {
        console.warn("p5.Vector.prototype.div:", "array contains components that are either undefined or not finite numbers");
      }
      return this;
    }
    if (args.every((val) => Number.isFinite(val) && typeof val === "number")) {
      if (args.some((val) => val === 0)) {
        console.warn("p5.Vector.prototype.div:", "divide by 0");
        return this;
      }
      this._values = this._values.map((val, i) => val / args[0]);
    } else {
      console.warn("p5.Vector.prototype.div:", "arguments contain components that are either undefined or not finite numbers");
    }
    return this;
  }
  mag() {
    return Math.sqrt(this.magSq());
  }
  magSq() {
    return this._values.reduce((sum, component) => sum + component * component, 0);
  }
  dot(...args) {
    if (args[0] instanceof Vector) {
      return this.dot(...args[0]._values);
    }
    return this._values.reduce((sum, component, index) => {
      return sum + component * (args[index] || 0);
    }, 0);
  }
  cross(v) {
    const x = this.y * v.z - this.z * v.y;
    const y = this.z * v.x - this.x * v.z;
    const z = this.x * v.y - this.y * v.x;
    if (this.isPInst) {
      return new Vector(this._fromRadians, this._toRadians, x, y, z);
    } else {
      return new Vector(x, y, z);
    }
  }
  dist(v) {
    return v.copy().sub(this).mag();
  }
  normalize() {
    const len = this.mag();
    if (len !== 0)
      this.mult(1 / len);
    return this;
  }
  limit(max) {
    const mSq = this.magSq();
    if (mSq > max * max) {
      this.div(Math.sqrt(mSq)).mult(max);
    }
    return this;
  }
  setMag(n2) {
    return this.normalize().mult(n2);
  }
  heading() {
    const h = Math.atan2(this.y, this.x);
    if (this.isPInst)
      return this._fromRadians(h);
    return h;
  }
  setHeading(a) {
    if (this.isPInst)
      a = this._toRadians(a);
    let m = this.mag();
    this.x = m * Math.cos(a);
    this.y = m * Math.sin(a);
    return this;
  }
  rotate(a) {
    let newHeading = this.heading() + a;
    if (this.isPInst)
      newHeading = this._toRadians(newHeading);
    const mag = this.mag();
    this.x = Math.cos(newHeading) * mag;
    this.y = Math.sin(newHeading) * mag;
    return this;
  }
  angleBetween(v) {
    const magSqMult = this.magSq() * v.magSq();
    if (magSqMult === 0) {
      return NaN;
    }
    const u = this.cross(v);
    let angle = Math.atan2(u.mag(), this.dot(v)) * Math.sign(u.z || 1);
    if (this.isPInst) {
      angle = this._fromRadians(angle);
    }
    return angle;
  }
  lerp(x, y, z, amt) {
    if (x instanceof Vector) {
      return this.lerp(x.x, x.y, x.z, y);
    }
    this.x += (x - this.x) * amt || 0;
    this.y += (y - this.y) * amt || 0;
    this.z += (z - this.z) * amt || 0;
    return this;
  }
  slerp(v, amt) {
    if (amt === 0) {
      return this;
    }
    if (amt === 1) {
      return this.set(v);
    }
    const selfMag = this.mag();
    const vMag = v.mag();
    const magmag = selfMag * vMag;
    if (magmag === 0) {
      this.mult(1 - amt).add(v.x * amt, v.y * amt, v.z * amt);
      return this;
    }
    const axis = this.cross(v);
    const axisMag = axis.mag();
    const theta = Math.atan2(axisMag, this.dot(v));
    if (axisMag > 0) {
      axis.x /= axisMag;
      axis.y /= axisMag;
      axis.z /= axisMag;
    } else if (theta < Math.PI * 0.5) {
      this.mult(1 - amt).add(v.x * amt, v.y * amt, v.z * amt);
      return this;
    } else {
      if (this.z === 0 && v.z === 0) {
        axis.set(0, 0, 1);
      } else if (this.x !== 0) {
        axis.set(this.y, -this.x, 0).normalize();
      } else {
        axis.set(1, 0, 0);
      }
    }
    const ey = axis.cross(this);
    const lerpedMagFactor = 1 - amt + amt * vMag / selfMag;
    const cosMultiplier = lerpedMagFactor * Math.cos(amt * theta);
    const sinMultiplier = lerpedMagFactor * Math.sin(amt * theta);
    this.x = this.x * cosMultiplier + ey.x * sinMultiplier;
    this.y = this.y * cosMultiplier + ey.y * sinMultiplier;
    this.z = this.z * cosMultiplier + ey.z * sinMultiplier;
    return this;
  }
  reflect(surfaceNormal) {
    const surfaceNormalCopy = Vector.normalize(surfaceNormal);
    return this.sub(surfaceNormalCopy.mult(2 * this.dot(surfaceNormalCopy)));
  }
  array() {
    return [this.x || 0, this.y || 0, this.z || 0];
  }
  equals(...args) {
    let values;
    if (args[0] instanceof Vector) {
      values = args[0]._values;
    } else if (Array.isArray(args[0])) {
      values = args[0];
    } else {
      values = args;
    }
    for (let i = 0;i < this._values.length; i++) {
      if (this._values[i] !== (values[i] || 0)) {
        return false;
      }
    }
    return true;
  }
  clampToZero() {
    for (let i = 0;i < this._values.length; i++) {
      this._values[i] = this._clampToZero(this._values[i]);
    }
    return this;
  }
  _clampToZero(val) {
    return Math.abs((val || 0) - 0) <= Number.EPSILON ? 0 : val;
  }
  static fromAngle(angle, length) {
    if (typeof length === "undefined") {
      length = 1;
    }
    return new Vector(length * Math.cos(angle), length * Math.sin(angle));
  }
  static fromAngles(theta, phi, length) {
    if (typeof length === "undefined") {
      length = 1;
    }
    const cosPhi = Math.cos(phi);
    const sinPhi = Math.sin(phi);
    const cosTheta = Math.cos(theta);
    const sinTheta = Math.sin(theta);
    return new Vector(length * sinTheta * sinPhi, -length * cosTheta, length * sinTheta * cosPhi);
  }
  static random2D() {
    return this.fromAngle(Math.random() * TWO_PI);
  }
  static random3D() {
    const angle = Math.random() * TWO_PI;
    const vz = Math.random() * 2 - 1;
    const vzBase = Math.sqrt(1 - vz * vz);
    const vx = vzBase * Math.cos(angle);
    const vy = vzBase * Math.sin(angle);
    return new Vector(vx, vy, vz);
  }
  static copy(v) {
    return v.copy(v);
  }
  static add(v1, v2, target) {
    if (!target) {
      target = v1.copy();
      if (arguments.length === 3) {
        p5._friendlyError("The target parameter is undefined, it should be of type p5.Vector", "p5.Vector.add");
      }
    } else {
      target.set(v1);
    }
    target.add(v2);
    return target;
  }
  static rem(v1, v2) {
    if (v1 instanceof Vector && v2 instanceof Vector) {
      let target = v1.copy();
      target.rem(v2);
      return target;
    }
  }
  static sub(v1, v2, target) {
    if (!target) {
      target = v1.copy();
      if (arguments.length === 3) {
        p5._friendlyError("The target parameter is undefined, it should be of type p5.Vector", "p5.Vector.sub");
      }
    } else {
      target.set(v1);
    }
    target.sub(v2);
    return target;
  }
  static mult(v, n2, target) {
    if (!target) {
      target = v.copy();
      if (arguments.length === 3) {
        p5._friendlyError("The target parameter is undefined, it should be of type p5.Vector", "p5.Vector.mult");
      }
    } else {
      target.set(v);
    }
    target.mult(n2);
    return target;
  }
  static rotate(v, a, target) {
    if (arguments.length === 2) {
      target = v.copy();
    } else {
      if (!(target instanceof Vector)) {
        p5._friendlyError("The target parameter should be of type p5.Vector", "p5.Vector.rotate");
      }
      target.set(v);
    }
    target.rotate(a);
    return target;
  }
  static div(v, n2, target) {
    if (!target) {
      target = v.copy();
      if (arguments.length === 3) {
        p5._friendlyError("The target parameter is undefined, it should be of type p5.Vector", "p5.Vector.div");
      }
    } else {
      target.set(v);
    }
    target.div(n2);
    return target;
  }
  static dot(v1, v2) {
    return v1.dot(v2);
  }
  static cross(v1, v2) {
    return v1.cross(v2);
  }
  static dist(v1, v2) {
    return v1.dist(v2);
  }
  static lerp(v1, v2, amt, target) {
    if (!target) {
      target = v1.copy();
      if (arguments.length === 4) {
        p5._friendlyError("The target parameter is undefined, it should be of type p5.Vector", "p5.Vector.lerp");
      }
    } else {
      target.set(v1);
    }
    target.lerp(v2, amt);
    return target;
  }
  static slerp(v1, v2, amt, target) {
    if (!target) {
      target = v1.copy();
      if (arguments.length === 4) {
        p5._friendlyError("The target parameter is undefined, it should be of type p5.Vector", "p5.Vector.slerp");
      }
    } else {
      target.set(v1);
    }
    target.slerp(v2, amt);
    return target;
  }
  static mag(vecT) {
    return vecT.mag();
  }
  static magSq(vecT) {
    return vecT.magSq();
  }
  static normalize(v, target) {
    if (arguments.length < 2) {
      target = v.copy();
    } else {
      if (!(target instanceof Vector)) {
        p5._friendlyError("The target parameter should be of type p5.Vector", "p5.Vector.normalize");
      }
      target.set(v);
    }
    return target.normalize();
  }
  static limit(v, max, target) {
    if (arguments.length < 3) {
      target = v.copy();
    } else {
      if (!(target instanceof Vector)) {
        p5._friendlyError("The target parameter should be of type p5.Vector", "p5.Vector.limit");
      }
      target.set(v);
    }
    return target.limit(max);
  }
  static setMag(v, len, target) {
    if (arguments.length < 3) {
      target = v.copy();
    } else {
      if (!(target instanceof Vector)) {
        p5._friendlyError("The target parameter should be of type p5.Vector", "p5.Vector.setMag");
      }
      target.set(v);
    }
    return target.setMag(len);
  }
  static heading(v) {
    return v.heading();
  }
  static angleBetween(v1, v2) {
    return v1.angleBetween(v2);
  }
  static reflect(incidentVector, surfaceNormal, target) {
    if (arguments.length < 3) {
      target = incidentVector.copy();
    } else {
      if (!(target instanceof Vector)) {
        p5._friendlyError("The target parameter should be of type p5.Vector", "p5.Vector.reflect");
      }
      target.set(incidentVector);
    }
    return target.reflect(surfaceNormal);
  }
  static array(v) {
    return v.array();
  }
  static equals(v1, v2) {
    let v;
    if (v1 instanceof Vector) {
      v = v1;
    } else if (v1 instanceof Array) {
      v = new Vector().set(v1);
    } else {
      p5._friendlyError("The v1 parameter should be of type Array or p5.Vector", "p5.Vector.equals");
    }
    return v.equals(v2);
  }
}
function vector(p52, fn2) {
  p52.Vector = Vector;
}
if (typeof p5 !== "undefined") {
  vector(p5, p5.prototype);
}

// node_modules/p5/dist/shape/custom_shapes.js
function polylineLength(vertices) {
  let length = 0;
  for (let i = 1;i < vertices.length; i++) {
    length += vertices[i - 1].position.dist(vertices[i].position);
  }
  return length;
}

class Vertex {
  constructor(properties) {
    for (const [key, value] of Object.entries(properties)) {
      this[key] = value;
    }
  }
}

class ShapePrimitive {
  vertices;
  _shape = null;
  _primitivesIndex = null;
  _contoursIndex = null;
  isClosing = false;
  constructor(...vertices) {
    if (this.constructor === ShapePrimitive) {
      throw new Error("ShapePrimitive is an abstract class: it cannot be instantiated.");
    }
    if (vertices.length > 0) {
      this.vertices = vertices;
    } else {
      throw new Error("At least one vertex must be passed to the constructor.");
    }
  }
  get vertexCount() {
    return this.vertices.length;
  }
  get vertexCapacity() {
    throw new Error("Getter vertexCapacity must be implemented.");
  }
  get _firstInterpolatedVertex() {
    return this.startVertex();
  }
  get canOverrideAnchor() {
    return false;
  }
  accept(visitor) {
    throw new Error("Method accept() must be implemented.");
  }
  addToShape(shape) {
    let lastContour = shape.at(-1);
    if (lastContour.primitives.length === 0) {
      lastContour.primitives.push(this);
    } else {
      let lastPrimitive = shape.at(-1, -1);
      let hasSameType = lastPrimitive instanceof this.constructor;
      let spareCapacity = lastPrimitive.vertexCapacity - lastPrimitive.vertexCount;
      let pushableVertices;
      let remainingVertices;
      if (hasSameType && spareCapacity > 0) {
        pushableVertices = this.vertices.splice(0, spareCapacity);
        remainingVertices = this.vertices;
        lastPrimitive.vertices.push(...pushableVertices);
        if (remainingVertices.length > 0) {
          lastContour.primitives.push(this);
        }
      } else {
        lastContour.primitives.push(this);
      }
    }
    let addedToShape = this.vertices.length > 0;
    if (addedToShape) {
      let lastContour2 = shape.at(-1);
      this._primitivesIndex = lastContour2.primitives.length - 1;
      this._contoursIndex = shape.contours.length - 1;
      this._shape = shape;
    }
    return shape.at(-1, -1);
  }
  get _nextPrimitive() {
    return this._belongsToShape ? this._shape.at(this._contoursIndex, this._primitivesIndex + 1) : null;
  }
  get _belongsToShape() {
    return this._shape !== null;
  }
  handlesClose() {
    return false;
  }
  close(vertex) {
    throw new Error("Unimplemented!");
  }
}

class Contour {
  #kind;
  primitives;
  constructor(kind = PATH) {
    this.#kind = kind;
    this.primitives = [];
  }
  get kind() {
    const isEmpty = this.primitives.length === 0;
    const isPath = this.#kind === PATH;
    return isEmpty && isPath ? EMPTY_PATH : this.#kind;
  }
  accept(visitor) {
    for (const primitive of this.primitives) {
      primitive.accept(visitor);
    }
  }
}

class Anchor extends ShapePrimitive {
  #vertexCapacity = 1;
  get vertexCapacity() {
    return this.#vertexCapacity;
  }
  accept(visitor) {
    visitor.visitAnchor(this);
  }
  getEndVertex() {
    return this.vertices[0];
  }
}

class Segment extends ShapePrimitive {
  constructor(...vertices) {
    super(...vertices);
    if (this.constructor === Segment) {
      throw new Error("Segment is an abstract class: it cannot be instantiated.");
    }
  }
  get _previousPrimitive() {
    return this._belongsToShape ? this._shape.at(this._contoursIndex, this._primitivesIndex - 1) : null;
  }
  getStartVertex() {
    return this._previousPrimitive.getEndVertex();
  }
  getEndVertex() {
    return this.vertices.at(-1);
  }
}

class LineSegment extends Segment {
  #vertexCapacity = 1;
  get vertexCapacity() {
    return this.#vertexCapacity;
  }
  accept(visitor) {
    visitor.visitLineSegment(this);
  }
}

class BezierSegment extends Segment {
  #order;
  #vertexCapacity;
  constructor(order, ...vertices) {
    super(...vertices);
    let numericalOrder = Array.isArray(order) ? order[0] : order;
    this.#order = numericalOrder;
    this.#vertexCapacity = numericalOrder;
  }
  get order() {
    return this.#order;
  }
  get vertexCapacity() {
    return this.#vertexCapacity;
  }
  #_hullLength;
  hullLength() {
    if (this.#_hullLength === undefined) {
      this.#_hullLength = polylineLength([
        this.getStartVertex(),
        ...this.vertices
      ]);
    }
    return this.#_hullLength;
  }
  accept(visitor) {
    visitor.visitBezierSegment(this);
  }
}

class SplineSegment extends Segment {
  #vertexCapacity = Infinity;
  _splineProperties = {
    ends: INCLUDE,
    tightness: 0
  };
  get vertexCapacity() {
    return this.#vertexCapacity;
  }
  accept(visitor) {
    visitor.visitSplineSegment(this);
  }
  get _comesAfterSegment() {
    return this._previousPrimitive instanceof Segment;
  }
  get canOverrideAnchor() {
    return this._splineProperties.ends === EXCLUDE;
  }
  get _firstInterpolatedVertex() {
    if (this._splineProperties.ends === EXCLUDE) {
      return this._comesAfterSegment ? this.vertices[1] : this.vertices[0];
    } else {
      return this.getStartVertex();
    }
  }
  get _chainedToSegment() {
    if (this._belongsToShape && this._comesAfterSegment) {
      let interpolatedStartPosition = this._firstInterpolatedVertex.position;
      let predecessorEndPosition = this.getStartVertex().position;
      return predecessorEndPosition.equals(interpolatedStartPosition);
    } else {
      return false;
    }
  }
  addToShape(shape) {
    const added = super.addToShape(shape);
    this._splineProperties.ends = shape._splineProperties.ends;
    this._splineProperties.tightness = shape._splineProperties.tightness;
    if (this._splineProperties.ends !== EXCLUDE)
      return added;
    let verticesPushed = !this._belongsToShape;
    let lastPrimitive = shape.at(-1, -1);
    let message = (array1, array2) => `Spline does not start where previous path segment ends:
      second spline vertex at (${array1})
      expected to be at (${array2}).`;
    if (verticesPushed && lastPrimitive.vertices.length === 2 && lastPrimitive._comesAfterSegment && !lastPrimitive._chainedToSegment) {
      let interpolatedStart = lastPrimitive._firstInterpolatedVertex.position;
      let predecessorEnd = lastPrimitive.getStartVertex().position;
      console.warn(message(interpolatedStart.array(), predecessorEnd.array()));
    }
    return added;
  }
  getEndVertex() {
    if (this._splineProperties.ends === INCLUDE) {
      return super.getEndVertex();
    } else if (this._splineProperties.ends === EXCLUDE) {
      return this.vertices.at(-2);
    } else {
      return this.getStartVertex();
    }
  }
  getControlPoints() {
    let points = [];
    if (this._comesAfterSegment) {
      points.push(this.getStartVertex());
    }
    points.push(this.getStartVertex());
    for (const vertex of this.vertices) {
      points.push(vertex);
    }
    const prevVertex = this.getStartVertex();
    if (this._splineProperties.ends === INCLUDE) {
      points.unshift(prevVertex);
      points.push(this.vertices.at(-1));
    } else if (this._splineProperties.ends === JOIN) {
      points.unshift(this.vertices.at(-1));
      points.push(prevVertex, this.vertices.at(0));
    }
    return points;
  }
  handlesClose() {
    if (!this._belongsToShape)
      return false;
    const contour = this._shape.at(this._contoursIndex);
    return contour.primitives.length === 2 && this._primitivesIndex === 1;
  }
  close() {
    this._splineProperties.ends = JOIN;
  }
}

class Point extends ShapePrimitive {
  #vertexCapacity = 1;
  get vertexCapacity() {
    return this.#vertexCapacity;
  }
  accept(visitor) {
    visitor.visitPoint(this);
  }
}

class Line extends ShapePrimitive {
  #vertexCapacity = 2;
  get vertexCapacity() {
    return this.#vertexCapacity;
  }
  accept(visitor) {
    visitor.visitLine(this);
  }
}

class Triangle extends ShapePrimitive {
  #vertexCapacity = 3;
  get vertexCapacity() {
    return this.#vertexCapacity;
  }
  accept(visitor) {
    visitor.visitTriangle(this);
  }
}

class Quad extends ShapePrimitive {
  #vertexCapacity = 4;
  get vertexCapacity() {
    return this.#vertexCapacity;
  }
  accept(visitor) {
    visitor.visitQuad(this);
  }
}

class TriangleFan extends ShapePrimitive {
  #vertexCapacity = Infinity;
  get vertexCapacity() {
    return this.#vertexCapacity;
  }
  accept(visitor) {
    visitor.visitTriangleFan(this);
  }
}

class TriangleStrip extends ShapePrimitive {
  #vertexCapacity = Infinity;
  get vertexCapacity() {
    return this.#vertexCapacity;
  }
  accept(visitor) {
    visitor.visitTriangleStrip(this);
  }
}

class QuadStrip extends ShapePrimitive {
  #vertexCapacity = Infinity;
  get vertexCapacity() {
    return this.#vertexCapacity;
  }
  accept(visitor) {
    visitor.visitQuadStrip(this);
  }
}

class PrimitiveShapeCreators {
  creators;
  constructor() {
    let creators = new Map;
    creators.set(`vertex-${EMPTY_PATH}`, (...vertices) => new Anchor(...vertices));
    creators.set(`vertex-${PATH}`, (...vertices) => new LineSegment(...vertices));
    creators.set(`vertex-${POINTS}`, (...vertices) => new Point(...vertices));
    creators.set(`vertex-${LINES}`, (...vertices) => new Line(...vertices));
    creators.set(`vertex-${TRIANGLES}`, (...vertices) => new Triangle(...vertices));
    creators.set(`vertex-${QUADS}`, (...vertices) => new Quad(...vertices));
    creators.set(`vertex-${TRIANGLE_FAN}`, (...vertices) => new TriangleFan(...vertices));
    creators.set(`vertex-${TRIANGLE_STRIP}`, (...vertices) => new TriangleStrip(...vertices));
    creators.set(`vertex-${QUAD_STRIP}`, (...vertices) => new QuadStrip(...vertices));
    creators.set(`bezierVertex-${EMPTY_PATH}`, (order, ...vertices) => new Anchor(...vertices));
    creators.set(`bezierVertex-${PATH}`, (order, ...vertices) => new BezierSegment(order, ...vertices));
    creators.set(`splineVertex-${EMPTY_PATH}`, (...vertices) => new Anchor(...vertices));
    creators.set(`splineVertex-${PATH}`, (...vertices) => new SplineSegment(...vertices));
    this.creators = creators;
  }
  get(vertexKind, shapeKind) {
    const key = `${vertexKind}-${shapeKind}`;
    return this.creators.get(key);
  }
  set(vertexKind, shapeKind, creator) {
    const key = `${vertexKind}-${shapeKind}`;
    this.creators.set(key, creator);
  }
  clear() {
    this.creators.clear();
  }
}

class Shape {
  #vertexProperties;
  #initialVertexProperties;
  #primitiveShapeCreators;
  #bezierOrder = 3;
  kind = null;
  contours = [];
  _splineProperties = {
    tightness: 0,
    ends: INCLUDE
  };
  userVertexProperties = null;
  constructor(vertexProperties, primitiveShapeCreators = new PrimitiveShapeCreators) {
    this.#initialVertexProperties = vertexProperties;
    this.#vertexProperties = vertexProperties;
    this.#primitiveShapeCreators = primitiveShapeCreators;
    for (const key in this.#vertexProperties) {
      if (key !== "position" && key !== "textureCoordinates") {
        this[key] = function(value) {
          this.#vertexProperties[key] = value;
        };
      }
    }
  }
  serializeToArray(val) {
    if (val === null || val === undefined) {
      return [];
    }
    if (val instanceof Number) {
      return [val];
    } else if (val instanceof Array) {
      return val;
    } else if (val.array instanceof Function) {
      return val.array();
    } else {
      throw new Error(`Can't convert ${val} to array!`);
    }
  }
  vertexToArray(vertex) {
    const array = [];
    for (const key in this.#vertexProperties) {
      if (this.userVertexProperties && key in this.userVertexProperties)
        continue;
      const val = vertex[key];
      array.push(...this.serializeToArray(val));
    }
    for (const key in this.userVertexProperties) {
      if (key in vertex) {
        array.push(...this.serializeToArray(vertex[key]));
      } else {
        array.push(...new Array(this.userVertexProperties[key]).fill(0));
      }
    }
    return array;
  }
  hydrateValue(queue, original) {
    if (original === null) {
      return null;
    } else if (original instanceof Number) {
      return queue.shift();
    } else if (original instanceof Array) {
      const array = [];
      for (let i = 0;i < original.length; i++) {
        array.push(queue.shift());
      }
      return array;
    } else if (original instanceof Vector) {
      return new Vector(queue.shift(), queue.shift(), queue.shift());
    } else if (original instanceof Color) {
      const array = [
        queue.shift(),
        queue.shift(),
        queue.shift(),
        queue.shift()
      ];
      return new Color(array);
    }
  }
  arrayToVertex(array) {
    const vertex = {};
    const queue = [...array];
    for (const key in this.#vertexProperties) {
      if (this.userVertexProperties && key in this.userVertexProperties)
        continue;
      const original = this.#vertexProperties[key];
      vertex[key] = this.hydrateValue(queue, original);
    }
    for (const key in this.userVertexProperties) {
      const original = this.#vertexProperties[key];
      vertex[key] = this.hydrateValue(queue, original);
    }
    return vertex;
  }
  arrayScale(array, scale) {
    return array.map((v) => v * scale);
  }
  arraySum(first, ...rest) {
    return first.map((v, i) => {
      let result = v;
      for (let j = 0;j < rest.length; j++) {
        result += rest[j][i];
      }
      return result;
    });
  }
  arrayMinus(a, b2) {
    return a.map((v, i) => v - b2[i]);
  }
  evaluateCubicBezier([a, b2, c, d2], t) {
    return this.arraySum(this.arrayScale(a, Math.pow(1 - t, 3)), this.arrayScale(b2, 3 * Math.pow(1 - t, 2) * t), this.arrayScale(c, 3 * (1 - t) * Math.pow(t, 2)), this.arrayScale(d2, Math.pow(t, 3)));
  }
  evaluateQuadraticBezier([a, b2, c], t) {
    return this.arraySum(this.arrayScale(a, Math.pow(1 - t, 2)), this.arrayScale(b2, 2 * (1 - t) * t), this.arrayScale(c, t * t));
  }
  catmullRomToBezier(vertices, tightness) {
    let s = 1 - tightness;
    let bezArrays = [];
    for (let i = 0;i + 3 < vertices.length; i++) {
      const [a, b2, c, d2] = vertices.slice(i, i + 4);
      const bezB = this.arraySum(b2, this.arrayScale(this.arrayMinus(c, a), s / 6));
      const bezC = this.arraySum(c, this.arrayScale(this.arrayMinus(b2, d2), s / 6));
      const bezD = c;
      bezArrays.push([bezB, bezC, bezD]);
    }
    return bezArrays;
  }
  at(contoursIndex, primitivesIndex, verticesIndex) {
    let contour;
    let primitive;
    contour = this.contours.at(contoursIndex);
    switch (arguments.length) {
      case 1:
        return contour;
      case 2:
        return contour.primitives.at(primitivesIndex);
      case 3:
        primitive = contour.primitives.at(primitivesIndex);
        return primitive.vertices.at(verticesIndex);
    }
  }
  reset() {
    this.#vertexProperties = { ...this.#initialVertexProperties };
    this.kind = null;
    this.contours = [];
    this.userVertexProperties = null;
  }
  vertexProperty(name, data) {
    this.userVertexProperties = this.userVertexProperties || {};
    const key = this.vertexPropertyKey(name);
    const dataArray = Array.isArray(data) ? data : [data];
    if (!this.userVertexProperties[key]) {
      this.userVertexProperties[key] = dataArray.length;
    }
    this.#vertexProperties[key] = dataArray;
  }
  vertexPropertyName(key) {
    return key.replace(/Src$/, "");
  }
  vertexPropertyKey(name) {
    return name + "Src";
  }
  bezierOrder(...order) {
    this.#bezierOrder = order;
  }
  splineProperty(key, value) {
    this._splineProperties[key] = value;
  }
  splineProperties(values) {
    if (values) {
      for (const key in values) {
        this.splineProperty(key, values[key]);
      }
    } else {
      return this._splineProperties;
    }
  }
  #createVertex(position, textureCoordinates) {
    this.#vertexProperties.position = position;
    if (textureCoordinates !== undefined) {
      this.#vertexProperties.textureCoordinates = textureCoordinates;
    }
    return new Vertex(this.#vertexProperties);
  }
  #createPrimitiveShape(vertexKind, shapeKind, ...vertices) {
    let primitiveShapeCreator = this.#primitiveShapeCreators.get(vertexKind, shapeKind);
    return vertexKind === "bezierVertex" ? primitiveShapeCreator(this.#bezierOrder, ...vertices) : primitiveShapeCreator(...vertices);
  }
  #generalVertex(kind, position, textureCoordinates) {
    let vertexKind = kind;
    let lastContourKind = this.at(-1).kind;
    let vertex = this.#createVertex(position, textureCoordinates);
    let primitiveShape = this.#createPrimitiveShape(vertexKind, lastContourKind, vertex);
    return primitiveShape.addToShape(this);
  }
  vertex(position, textureCoordinates, { isClosing = false } = {}) {
    const added = this.#generalVertex("vertex", position, textureCoordinates);
    added.isClosing = isClosing;
  }
  bezierVertex(position, textureCoordinates) {
    this.#generalVertex("bezierVertex", position, textureCoordinates);
  }
  splineVertex(position, textureCoordinates) {
    this.#generalVertex("splineVertex", position, textureCoordinates);
  }
  arcVertex(position, textureCoordinates) {
    this.#generalVertex("arcVertex", position, textureCoordinates);
  }
  beginContour(shapeKind = PATH) {
    if (this.at(-1)?.kind === EMPTY_PATH) {
      this.contours.pop();
    }
    this.contours.push(new Contour(shapeKind));
  }
  endContour(closeMode = OPEN, _index = this.contours.length - 1) {
    const contour = this.at(_index);
    if (closeMode === CLOSE) {
      const isPath = contour.kind === PATH;
      const anchorVertex = this.at(_index, 0, 0);
      const anchorHasPosition = Object.hasOwn(anchorVertex, "position");
      const lastSegment = this.at(_index, -1);
      if (isPath && anchorHasPosition) {
        if (lastSegment.handlesClose()) {
          lastSegment.close(anchorVertex);
        } else {
          const rest = this.contours.splice(_index + 1, this.contours.length - _index - 1);
          const prevVertexProperties = this.#vertexProperties;
          this.#vertexProperties = { ...prevVertexProperties };
          for (const key in anchorVertex) {
            if (["position", "textureCoordinates"].includes(key))
              continue;
            this.#vertexProperties[key] = anchorVertex[key];
          }
          this.vertex(anchorVertex.position, anchorVertex.textureCoordinates, { isClosing: true });
          this.#vertexProperties = prevVertexProperties;
          this.contours.push(...rest);
        }
      }
    }
  }
  beginShape(shapeKind = PATH) {
    this.kind = shapeKind;
    this.beginContour(shapeKind);
  }
  endShape(closeMode = OPEN) {
    if (closeMode === CLOSE) {
      this.endContour(closeMode, 0);
    }
  }
  accept(visitor) {
    for (const contour of this.contours) {
      contour.accept(visitor);
    }
  }
}

class PrimitiveVisitor {
  constructor() {
    if (this.constructor === PrimitiveVisitor) {
      throw new Error("PrimitiveVisitor is an abstract class: it cannot be instantiated.");
    }
  }
  visitAnchor(anchor) {
    throw new Error("Method visitAnchor() has not been implemented.");
  }
  visitLineSegment(lineSegment) {
    throw new Error("Method visitLineSegment() has not been implemented.");
  }
  visitBezierSegment(bezierSegment) {
    throw new Error("Method visitBezierSegment() has not been implemented.");
  }
  visitSplineSegment(curveSegment) {
    throw new Error("Method visitSplineSegment() has not been implemented.");
  }
  visitArcSegment(arcSegment) {
    throw new Error("Method visitArcSegment() has not been implemented.");
  }
  visitPoint(point) {
    throw new Error("Method visitPoint() has not been implemented.");
  }
  visitLine(line) {
    throw new Error("Method visitLine() has not been implemented.");
  }
  visitTriangle(triangle) {
    throw new Error("Method visitTriangle() has not been implemented.");
  }
  visitQuad(quad) {
    throw new Error("Method visitQuad() has not been implemented.");
  }
  visitTriangleFan(triangleFan) {
    throw new Error("Method visitTriangleFan() has not been implemented.");
  }
  visitTriangleStrip(triangleStrip) {
    throw new Error("Method visitTriangleStrip() has not been implemented.");
  }
  visitQuadStrip(quadStrip) {
    throw new Error("Method visitQuadStrip() has not been implemented.");
  }
}

class PrimitiveToPath2DConverter extends PrimitiveVisitor {
  path = new Path2D;
  strokeWeight;
  constructor({ strokeWeight }) {
    super();
    this.strokeWeight = strokeWeight;
  }
  visitAnchor(anchor) {
    let vertex = anchor.getEndVertex();
    this.path.moveTo(vertex.position.x, vertex.position.y);
  }
  visitLineSegment(lineSegment) {
    if (lineSegment.isClosing) {
      this.path.closePath();
    } else {
      let vertex = lineSegment.getEndVertex();
      this.path.lineTo(vertex.position.x, vertex.position.y);
    }
  }
  visitBezierSegment(bezierSegment) {
    let [v1, v2, v3] = bezierSegment.vertices;
    switch (bezierSegment.order) {
      case 2:
        this.path.quadraticCurveTo(v1.position.x, v1.position.y, v2.position.x, v2.position.y);
        break;
      case 3:
        this.path.bezierCurveTo(v1.position.x, v1.position.y, v2.position.x, v2.position.y, v3.position.x, v3.position.y);
        break;
    }
  }
  visitSplineSegment(splineSegment) {
    const shape = splineSegment._shape;
    if (splineSegment._splineProperties.ends === EXCLUDE && !splineSegment._comesAfterSegment) {
      let startVertex = splineSegment._firstInterpolatedVertex;
      this.path.moveTo(startVertex.position.x, startVertex.position.y);
    }
    const arrayVertices = splineSegment.getControlPoints().map((v) => shape.vertexToArray(v));
    let bezierArrays = shape.catmullRomToBezier(arrayVertices, splineSegment._splineProperties.tightness).map((arr) => arr.map((vertArr) => shape.arrayToVertex(vertArr)));
    for (const array of bezierArrays) {
      const points = array.flatMap((vert) => [vert.position.x, vert.position.y]);
      this.path.bezierCurveTo(...points);
    }
  }
  visitPoint(point) {
    const { x, y } = point.vertices[0].position;
    this.path.moveTo(x, y);
    this.path.lineTo(x + 0.00001, y);
  }
  visitLine(line) {
    const { x: x0, y: y0 } = line.vertices[0].position;
    const { x: x1, y: y1 } = line.vertices[1].position;
    this.path.moveTo(x0, y0);
    this.path.lineTo(x1, y1);
  }
  visitTriangle(triangle) {
    const [v0, v1, v2] = triangle.vertices;
    this.path.moveTo(v0.position.x, v0.position.y);
    this.path.lineTo(v1.position.x, v1.position.y);
    this.path.lineTo(v2.position.x, v2.position.y);
    this.path.closePath();
  }
  visitQuad(quad) {
    const [v0, v1, v2, v3] = quad.vertices;
    this.path.moveTo(v0.position.x, v0.position.y);
    this.path.lineTo(v1.position.x, v1.position.y);
    this.path.lineTo(v2.position.x, v2.position.y);
    this.path.lineTo(v3.position.x, v3.position.y);
    this.path.closePath();
  }
  visitTriangleFan(triangleFan) {
    const [v0, ...rest] = triangleFan.vertices;
    for (let i = 0;i < rest.length - 1; i++) {
      const v1 = rest[i];
      const v2 = rest[i + 1];
      this.path.moveTo(v0.position.x, v0.position.y);
      this.path.lineTo(v1.position.x, v1.position.y);
      this.path.lineTo(v2.position.x, v2.position.y);
      this.path.closePath();
    }
  }
  visitTriangleStrip(triangleStrip) {
    for (let i = 0;i < triangleStrip.vertices.length - 2; i++) {
      const v0 = triangleStrip.vertices[i];
      const v1 = triangleStrip.vertices[i + 1];
      const v2 = triangleStrip.vertices[i + 2];
      this.path.moveTo(v0.position.x, v0.position.y);
      this.path.lineTo(v1.position.x, v1.position.y);
      this.path.lineTo(v2.position.x, v2.position.y);
      this.path.closePath();
    }
  }
  visitQuadStrip(quadStrip) {
    for (let i = 0;i < quadStrip.vertices.length - 3; i += 2) {
      const v0 = quadStrip.vertices[i];
      const v1 = quadStrip.vertices[i + 1];
      const v2 = quadStrip.vertices[i + 2];
      const v3 = quadStrip.vertices[i + 3];
      this.path.moveTo(v0.position.x, v0.position.y);
      this.path.lineTo(v1.position.x, v1.position.y);
      this.path.lineTo(v3.position.x, v3.position.y);
      this.path.lineTo(v2.position.x, v2.position.y);
      this.path.closePath();
    }
  }
}

class PrimitiveToVerticesConverter extends PrimitiveVisitor {
  contours = [];
  curveDetail;
  constructor({ curveDetail = 1 } = {}) {
    super();
    this.curveDetail = curveDetail;
  }
  lastContour() {
    return this.contours[this.contours.length - 1];
  }
  visitAnchor(anchor) {
    this.contours.push([]);
    const next = anchor._nextPrimitive;
    if (next?.canOverrideAnchor) {
      this.lastContour().push(next._firstInterpolatedVertex);
    } else {
      this.lastContour().push(anchor.getEndVertex());
    }
  }
  visitLineSegment(lineSegment) {
    this.lastContour().push(lineSegment.getEndVertex());
  }
  visitBezierSegment(bezierSegment) {
    const contour = this.lastContour();
    const numPoints = Math.max(1, Math.ceil(bezierSegment.hullLength() * this.curveDetail));
    const vertexArrays = [
      bezierSegment.getStartVertex(),
      ...bezierSegment.vertices
    ].map((v) => bezierSegment._shape.vertexToArray(v));
    for (let i = 0;i < numPoints; i++) {
      const t = (i + 1) / numPoints;
      contour.push(bezierSegment._shape.arrayToVertex(bezierSegment.order === 3 ? bezierSegment._shape.evaluateCubicBezier(vertexArrays, t) : bezierSegment._shape.evaluateQuadraticBezier(vertexArrays, t)));
    }
  }
  visitSplineSegment(splineSegment) {
    const shape = splineSegment._shape;
    const contour = this.lastContour();
    const arrayVertices = splineSegment.getControlPoints().map((v) => shape.vertexToArray(v));
    let bezierArrays = shape.catmullRomToBezier(arrayVertices, splineSegment._splineProperties.tightness);
    let startVertex = shape.vertexToArray(splineSegment._firstInterpolatedVertex);
    for (const array of bezierArrays) {
      const bezierControls = [startVertex, ...array];
      const numPoints = Math.max(1, Math.ceil(polylineLength(bezierControls.map((v) => shape.arrayToVertex(v))) * this.curveDetail));
      for (let i = 0;i < numPoints; i++) {
        const t = (i + 1) / numPoints;
        contour.push(shape.arrayToVertex(shape.evaluateCubicBezier(bezierControls, t)));
      }
      startVertex = array[2];
    }
  }
  visitPoint(point) {
    this.contours.push(point.vertices.slice());
  }
  visitLine(line) {
    this.contours.push(line.vertices.slice());
  }
  visitTriangle(triangle) {
    this.contours.push(triangle.vertices.slice());
  }
  visitQuad(quad) {
    this.contours.push(quad.vertices.slice());
  }
  visitTriangleFan(triangleFan) {
    this.contours.push(triangleFan.vertices.slice());
  }
  visitTriangleStrip(triangleStrip) {
    this.contours.push(triangleStrip.vertices.slice());
  }
  visitQuadStrip(quadStrip) {
    this.contours.push(quadStrip.vertices.slice());
  }
}

class PointAtLengthGetter extends PrimitiveVisitor {
  constructor() {
    super();
  }
}
function customShapes(p52, fn2) {
  p52.Shape = Shape;
  p52.Contour = Contour;
  p52.ShapePrimitive = ShapePrimitive;
  p52.Vertex = Vertex;
  p52.Anchor = Anchor;
  p52.Segment = Segment;
  p52.LineSegment = LineSegment;
  p52.BezierSegment = BezierSegment;
  p52.SplineSegment = SplineSegment;
  p52.Point = Point;
  p52.Line = Line;
  p52.Triangle = Triangle;
  p52.Quad = Quad;
  p52.TriangleFan = TriangleFan;
  p52.TriangleStrip = TriangleStrip;
  p52.QuadStrip = QuadStrip;
  p52.PrimitiveVisitor = PrimitiveVisitor;
  p52.PrimitiveToPath2DConverter = PrimitiveToPath2DConverter;
  p52.PrimitiveToVerticesConverter = PrimitiveToVerticesConverter;
  p52.PointAtLengthGetter = PointAtLengthGetter;
  fn2.bezierOrder = function(order) {
    return this._renderer.bezierOrder(order);
  };
  fn2.splineVertex = function(...args) {
    let x = 0, y = 0, z = 0, u = 0, v = 0;
    if (args.length === 2) {
      [x, y] = args;
    } else if (args.length === 4) {
      [x, y, u, v] = args;
    } else if (args.length === 3) {
      [x, y, z] = args;
    } else if (args.length === 5) {
      [x, y, z, u, v] = args;
    }
    this._renderer.splineVertex(x, y, z, u, v);
  };
  fn2.splineProperty = function(property, value) {
    return this._renderer.splineProperty(property, value);
  };
  fn2.splineProperties = function(values) {
    return this._renderer.splineProperties(values);
  };
  fn2.vertex = function(x, y) {
    let z, u, v;
    z = u = v = 0;
    if (arguments.length === 3) {
      z = arguments[2];
    } else if (arguments.length === 4) {
      u = arguments[2];
      v = arguments[3];
    } else if (arguments.length === 5) {
      z = arguments[2];
      u = arguments[3];
      v = arguments[4];
    }
    this._renderer.vertex(x, y, z, u, v);
    return;
  };
  fn2.beginContour = function(kind) {
    this._renderer.beginContour(kind);
  };
  fn2.endContour = function(mode = OPEN) {
    this._renderer.endContour(mode);
  };
}
if (typeof p5 !== "undefined") {
  customShapes(p5, p5.prototype);
}

// node_modules/p5/dist/core/States.js
class States {
  #modified = {};
  constructor(initialState) {
    for (const key in initialState) {
      this[key] = initialState[key];
    }
  }
  setValue(key, value) {
    if (!(key in this.#modified)) {
      this.#modified[key] = this[key];
    }
    this[key] = value;
  }
  getDiff() {
    const diff = this.#modified;
    this.#modified = {};
    return diff;
  }
  getModified() {
    return this.#modified;
  }
  applyDiff(prevModified) {
    for (const key in this.#modified) {
      this[key] = this.#modified[key];
    }
    this.#modified = prevModified;
  }
}

// node_modules/p5/dist/io/utilities.js
var fileSaver = __toESM(require_FileSaver(), 1);
function downloadFile(data, fName, extension) {
  const fx = _checkFileExtension(fName, extension);
  const filename = fx[0];
  let saveData = data;
  if (!(saveData instanceof Blob)) {
    saveData = new Blob([data]);
  }
  fileSaver.saveAs(saveData, filename);
}
function _checkFileExtension(filename, extension) {
  if (!extension || extension === true || extension === "true") {
    extension = "";
  }
  if (!filename) {
    filename = "untitled";
  }
  let ext = "";
  if (filename && filename.includes(".")) {
    ext = filename.split(".").pop();
  }
  if (extension) {
    if (ext !== extension) {
      ext = extension;
      filename = `${filename}.${ext}`;
    }
  }
  return [filename, ext];
}

// node_modules/p5/dist/p5.Renderer-DBmMi2eT.js
class Image {
  constructor(width, height) {
    this.width = width;
    this.height = height;
    this.canvas = document.createElement("canvas");
    this.canvas.width = this.width;
    this.canvas.height = this.height;
    this.drawingContext = this.canvas.getContext("2d");
    this._pixelsState = this;
    this._pixelDensity = 1;
    this.gifProperties = null;
    this._modified = false;
    this.pixels = [];
  }
  pixelDensity(density) {
    if (typeof density !== "undefined") {
      if (density <= 0) {
        density = 1;
      }
      this._pixelDensity = density;
      this.width /= density;
      this.height /= density;
      return this;
    } else {
      return this._pixelDensity;
    }
  }
  _animateGif(pInst) {
    const props = this.gifProperties;
    const curTime = pInst._lastRealFrameTime || window.performance.now();
    if (props.lastChangeTime === 0) {
      props.lastChangeTime = curTime;
    }
    if (props.playing) {
      props.timeDisplayed = curTime - props.lastChangeTime;
      const curDelay = props.frames[props.displayIndex].delay;
      if (props.timeDisplayed >= curDelay) {
        const skips = Math.floor(props.timeDisplayed / curDelay);
        props.timeDisplayed = 0;
        props.lastChangeTime = curTime;
        props.displayIndex += skips;
        props.loopCount = Math.floor(props.displayIndex / props.numFrames);
        if (props.loopLimit !== null && props.loopCount >= props.loopLimit) {
          props.playing = false;
        } else {
          const ind = props.displayIndex % props.numFrames;
          this.drawingContext.putImageData(props.frames[ind].image, 0, 0);
          props.displayIndex = ind;
          this.setModified(true);
        }
      }
    }
  }
  loadPixels() {
    const pixelsState = this._pixelsState;
    const pd = this._pixelDensity;
    const w = this.width * pd;
    const h = this.height * pd;
    const imageData = this.drawingContext.getImageData(0, 0, w, h);
    pixelsState.imageData = imageData;
    this.pixels = pixelsState.pixels = imageData.data;
    this.setModified(true);
  }
  updatePixels(x, y, w, h) {
    const pixelsState = this._pixelsState;
    const pd = this._pixelDensity;
    if (x === undefined && y === undefined && w === undefined && h === undefined) {
      x = 0;
      y = 0;
      w = this.width;
      h = this.height;
    }
    x *= pd;
    y *= pd;
    w *= pd;
    h *= pd;
    if (this.gifProperties) {
      this.gifProperties.frames[this.gifProperties.displayIndex].image = pixelsState.imageData;
    }
    this.drawingContext.putImageData(pixelsState.imageData, x, y, 0, 0, w, h);
    this.setModified(true);
  }
  get(x, y, w, h) {
    const pixelsState = this._pixelsState;
    const pd = this._pixelDensity;
    const canvas = this.canvas;
    if (typeof x === "undefined" && typeof y === "undefined") {
      x = y = 0;
      w = pixelsState.width;
      h = pixelsState.height;
    } else {
      x *= pd;
      y *= pd;
      if (typeof w === "undefined" && typeof h === "undefined") {
        if (x < 0 || y < 0 || x >= canvas.width || y >= canvas.height) {
          return [0, 0, 0, 0];
        }
        return this._getPixel(x, y);
      }
    }
    const region = new Image(w * pd, h * pd);
    region.pixelDensity(pd);
    region.canvas.getContext("2d").drawImage(canvas, x, y, w * pd, h * pd, 0, 0, w * pd, h * pd);
    return region;
  }
  _getPixel(x, y) {
    let imageData, index;
    imageData = this.drawingContext.getImageData(x, y, 1, 1).data;
    index = 0;
    return [
      imageData[index + 0],
      imageData[index + 1],
      imageData[index + 2],
      imageData[index + 3]
    ];
  }
  set(x, y, imgOrCol) {
    x = Math.floor(x);
    y = Math.floor(y);
    const pixelsState = this._pixelsState;
    if (imgOrCol instanceof Image) {
      this.drawingContext.save();
      this.drawingContext.setTransform(1, 0, 0, 1, 0, 0);
      this.drawingContext.scale(this._pixelDensity, this._pixelDensity);
      this.drawingContext.clearRect(x, y, imgOrCol.width, imgOrCol.height);
      this.drawingContext.drawImage(imgOrCol.canvas, x, y);
      this.drawingContext.restore();
    } else {
      let r = 0, g2 = 0, b2 = 0, a = 0;
      let idx = 4 * (y * this._pixelDensity * (this.width * this._pixelDensity) + x * this._pixelDensity);
      if (!pixelsState.imageData) {
        pixelsState.loadPixels();
      }
      if (typeof imgOrCol === "number") {
        if (idx < pixelsState.pixels.length) {
          r = imgOrCol;
          g2 = imgOrCol;
          b2 = imgOrCol;
          a = 255;
        }
      } else if (Array.isArray(imgOrCol)) {
        if (imgOrCol.length < 4) {
          throw new Error("pixel array must be of the form [R, G, B, A]");
        }
        if (idx < pixelsState.pixels.length) {
          r = imgOrCol[0];
          g2 = imgOrCol[1];
          b2 = imgOrCol[2];
          a = imgOrCol[3];
        }
      } else if (imgOrCol instanceof p5.Color) {
        if (idx < pixelsState.pixels.length) {
          [r, g2, b2, a] = imgOrCol._getRGBA([255, 255, 255, 255]);
        }
      }
      for (let i = 0;i < this._pixelDensity; i++) {
        for (let j = 0;j < this._pixelDensity; j++) {
          idx = 4 * ((y * this._pixelDensity + j) * this.width * this._pixelDensity + (x * this._pixelDensity + i));
          pixelsState.pixels[idx] = r;
          pixelsState.pixels[idx + 1] = g2;
          pixelsState.pixels[idx + 2] = b2;
          pixelsState.pixels[idx + 3] = a;
        }
      }
    }
    this.setModified(true);
  }
  resize(width, height) {
    if (width === 0 && height === 0) {
      width = this.canvas.width;
      height = this.canvas.height;
    } else if (width === 0) {
      width = this.canvas.width * height / this.canvas.height;
    } else if (height === 0) {
      height = this.canvas.height * width / this.canvas.width;
    }
    width = Math.floor(width);
    height = Math.floor(height);
    const tempCanvas = document.createElement("canvas");
    tempCanvas.width = width;
    tempCanvas.height = height;
    if (this.gifProperties) {
      const props = this.gifProperties;
      const nearestNeighbor = (src, dst) => {
        let pos = 0;
        for (let y = 0;y < dst.height; y++) {
          for (let x = 0;x < dst.width; x++) {
            const srcX = Math.floor(x * src.width / dst.width);
            const srcY = Math.floor(y * src.height / dst.height);
            let srcPos = (srcY * src.width + srcX) * 4;
            dst.data[pos++] = src.data[srcPos++];
            dst.data[pos++] = src.data[srcPos++];
            dst.data[pos++] = src.data[srcPos++];
            dst.data[pos++] = src.data[srcPos++];
          }
        }
      };
      for (let i = 0;i < props.numFrames; i++) {
        const resizedImageData = this.drawingContext.createImageData(width, height);
        nearestNeighbor(props.frames[i].image, resizedImageData);
        props.frames[i].image = resizedImageData;
      }
    }
    tempCanvas.getContext("2d").drawImage(this.canvas, 0, 0, this.canvas.width, this.canvas.height, 0, 0, tempCanvas.width, tempCanvas.height);
    this.canvas.width = this.width = width;
    this.canvas.height = this.height = height;
    this.drawingContext.drawImage(tempCanvas, 0, 0, width, height, 0, 0, width, height);
    if (this.pixels.length > 0) {
      this.loadPixels();
    }
    this.setModified(true);
  }
  copy(...args) {
    let srcImage, sx, sy, sw, sh, dx, dy, dw, dh;
    if (args.length === 9) {
      srcImage = args[0];
      sx = args[1];
      sy = args[2];
      sw = args[3];
      sh = args[4];
      dx = args[5];
      dy = args[6];
      dw = args[7];
      dh = args[8];
    } else if (args.length === 8) {
      srcImage = this;
      sx = args[0];
      sy = args[1];
      sw = args[2];
      sh = args[3];
      dx = args[4];
      dy = args[5];
      dw = args[6];
      dh = args[7];
    } else {
      throw new Error("Signature not supported");
    }
    this._copyHelper(this, srcImage, sx, sy, sw, sh, dx, dy, dw, dh);
  }
  _copyHelper(dstImage, srcImage, sx, sy, sw, sh, dx, dy, dw, dh) {
    const s = srcImage.canvas.width / srcImage.width;
    let sxMod = 0;
    let syMod = 0;
    if (srcImage._renderer && srcImage._renderer.isP3D) {
      sxMod = srcImage.width / 2;
      syMod = srcImage.height / 2;
    }
    if (dstImage._renderer && dstImage._renderer.isP3D) {
      dstImage.push();
      dstImage.resetMatrix();
      dstImage.noLights();
      dstImage.blendMode(dstImage.BLEND);
      dstImage.imageMode(dstImage.CORNER);
      dstImage._renderer.image(srcImage, sx + sxMod, sy + syMod, sw, sh, dx, dy, dw, dh);
      dstImage.pop();
    } else {
      dstImage.drawingContext.drawImage(srcImage.canvas, s * (sx + sxMod), s * (sy + syMod), s * sw, s * sh, dx, dy, dw, dh);
    }
  }
  mask(p5Image) {
    if (p5Image === undefined) {
      p5Image = this;
    }
    const currBlend = this.drawingContext.globalCompositeOperation;
    let imgScaleFactor = this._pixelDensity;
    let maskScaleFactor = 1;
    if (p5Image instanceof Renderer) {
      maskScaleFactor = p5Image._pInst._renderer._pixelDensity;
    }
    const copyArgs = [
      p5Image,
      0,
      0,
      maskScaleFactor * p5Image.width,
      maskScaleFactor * p5Image.height,
      0,
      0,
      imgScaleFactor * this.width,
      imgScaleFactor * this.height
    ];
    this.drawingContext.globalCompositeOperation = "destination-in";
    if (this.gifProperties) {
      for (let i = 0;i < this.gifProperties.frames.length; i++) {
        this.drawingContext.putImageData(this.gifProperties.frames[i].image, 0, 0);
        this.copy(...copyArgs);
        this.gifProperties.frames[i].image = this.drawingContext.getImageData(0, 0, imgScaleFactor * this.width, imgScaleFactor * this.height);
      }
      this.drawingContext.putImageData(this.gifProperties.frames[this.gifProperties.displayIndex].image, 0, 0);
    } else {
      this.copy(...copyArgs);
    }
    this.drawingContext.globalCompositeOperation = currBlend;
    this.setModified(true);
  }
  filter(operation, value) {
    Filters.apply(this.canvas, Filters[operation], value);
    this.setModified(true);
  }
  blend(...args) {
    const currBlend = this.drawingContext.globalCompositeOperation;
    const blendMode = args[args.length - 1];
    const copyArgs = Array.prototype.slice.call(args, 0, args.length - 1);
    this.drawingContext.globalCompositeOperation = blendMode;
    this.copy(...copyArgs);
    this.drawingContext.globalCompositeOperation = currBlend;
    this.setModified(true);
  }
  setModified(val) {
    this._modified = val;
  }
  isModified() {
    return this._modified;
  }
  save(filename, extension) {
    if (this.gifProperties) {
      encodeAndDownloadGif(this, filename);
    } else {
      let htmlCanvas = this.canvas;
      extension = extension || _checkFileExtension(filename, extension)[1] || "png";
      let mimeType;
      switch (extension) {
        default:
          mimeType = "image/png";
          break;
        case "webp":
          mimeType = "image/webp";
          break;
        case "jpeg":
        case "jpg":
          mimeType = "image/jpeg";
          break;
      }
      htmlCanvas.toBlob((blob) => {
        downloadFile(blob, filename, extension);
      }, mimeType);
    }
  }
  async toBlob() {
    return new Promise((resolve) => {
      this.canvas.toBlob(resolve);
    });
  }
  reset() {
    if (this.gifProperties) {
      const props = this.gifProperties;
      props.playing = true;
      props.timeSinceStart = 0;
      props.timeDisplayed = 0;
      props.lastChangeTime = 0;
      props.loopCount = 0;
      props.displayIndex = 0;
      this.drawingContext.putImageData(props.frames[0].image, 0, 0);
    }
  }
  getCurrentFrame() {
    if (this.gifProperties) {
      const props = this.gifProperties;
      return props.displayIndex % props.numFrames;
    }
  }
  setFrame(index) {
    if (this.gifProperties) {
      const props = this.gifProperties;
      if (index < props.numFrames && index >= 0) {
        props.timeDisplayed = 0;
        props.lastChangeTime = 0;
        props.displayIndex = index;
        this.drawingContext.putImageData(props.frames[index].image, 0, 0);
      } else {
        console.log("Cannot set GIF to a frame number that is higher than total number of frames or below zero.");
      }
    }
  }
  numFrames() {
    if (this.gifProperties) {
      return this.gifProperties.numFrames;
    }
  }
  play() {
    if (this.gifProperties) {
      this.gifProperties.playing = true;
    }
  }
  pause() {
    if (this.gifProperties) {
      this.gifProperties.playing = false;
    }
  }
  delay(d2, index) {
    if (this.gifProperties) {
      const props = this.gifProperties;
      if (index < props.numFrames && index >= 0) {
        props.frames[index].delay = d2;
      } else {
        for (const frame of props.frames) {
          frame.delay = d2;
        }
      }
    }
  }
}
function encodeAndDownloadGif(pImg, filename) {
  const props = pImg.gifProperties;
  let loopLimit = props.loopLimit;
  if (loopLimit === 1) {
    loopLimit = null;
  } else if (loopLimit === null) {
    loopLimit = 0;
  }
  const buffer = new Uint8Array(pImg.width * pImg.height * props.numFrames);
  const allFramesPixelColors = [];
  const paletteFreqsAndFrames = {};
  for (let i = 0;i < props.numFrames; i++) {
    const paletteSet = new Set;
    const data = props.frames[i].image.data;
    const dataLength = data.length;
    const pixelColors = new Uint32Array(pImg.width * pImg.height);
    for (let j = 0, k = 0;j < dataLength; j += 4, k++) {
      const r = data[j + 0];
      const g2 = data[j + 1];
      const b2 = data[j + 2];
      const color2 = r << 16 | g2 << 8 | b2 << 0;
      paletteSet.add(color2);
      pixelColors[k] = color2;
    }
    const paletteStr = [...paletteSet].sort().toString();
    if (paletteFreqsAndFrames[paletteStr] === undefined) {
      paletteFreqsAndFrames[paletteStr] = { freq: 1, frames: [i] };
    } else {
      paletteFreqsAndFrames[paletteStr].freq += 1;
      paletteFreqsAndFrames[paletteStr].frames.push(i);
    }
    allFramesPixelColors.push(pixelColors);
  }
  let framesUsingGlobalPalette = [];
  const palettesSortedByFreq = Object.keys(paletteFreqsAndFrames).sort(function(a, b2) {
    return paletteFreqsAndFrames[b2].freq - paletteFreqsAndFrames[a].freq;
  });
  const globalPalette = palettesSortedByFreq[0].split(",").map((a) => parseInt(a));
  framesUsingGlobalPalette = framesUsingGlobalPalette.concat(paletteFreqsAndFrames[globalPalette].frames);
  const globalPaletteSet = new Set(globalPalette);
  for (let i = 1;i < palettesSortedByFreq.length; i++) {
    const palette = palettesSortedByFreq[i].split(",").map((a) => parseInt(a));
    const difference = palette.filter((x) => !globalPaletteSet.has(x));
    if (globalPalette.length + difference.length <= 256) {
      for (let j = 0;j < difference.length; j++) {
        globalPalette.push(difference[j]);
        globalPaletteSet.add(difference[j]);
      }
      framesUsingGlobalPalette = framesUsingGlobalPalette.concat(paletteFreqsAndFrames[palettesSortedByFreq[i]].frames);
    }
  }
  framesUsingGlobalPalette = new Set(framesUsingGlobalPalette);
  const globalIndicesLookup = {};
  for (let i = 0;i < globalPalette.length; i++) {
    if (!globalIndicesLookup[globalPalette[i]]) {
      globalIndicesLookup[globalPalette[i]] = i;
    }
  }
  let powof2 = 1;
  while (powof2 < globalPalette.length) {
    powof2 <<= 1;
  }
  globalPalette.length = powof2;
  const opts = {
    loop: loopLimit,
    palette: new Uint32Array(globalPalette)
  };
  const gifWriter = new omggif.GifWriter(buffer, pImg.width, pImg.height, opts);
  let previousFrame = {};
  for (let i = 0;i < props.numFrames; i++) {
    const localPaletteRequired = !framesUsingGlobalPalette.has(i);
    const palette = localPaletteRequired ? [] : globalPalette;
    const pixelPaletteIndex = new Uint8Array(pImg.width * pImg.height);
    const colorIndicesLookup = {};
    const cannotBeTransparent = new Set;
    allFramesPixelColors[i].forEach((color2, k) => {
      if (localPaletteRequired) {
        if (colorIndicesLookup[color2] === undefined) {
          colorIndicesLookup[color2] = palette.length;
          palette.push(color2);
        }
        pixelPaletteIndex[k] = colorIndicesLookup[color2];
      } else {
        pixelPaletteIndex[k] = globalIndicesLookup[color2];
      }
      if (i > 0) {
        if (allFramesPixelColors[i - 1][k] !== color2) {
          cannotBeTransparent.add(color2);
        }
      }
    });
    const frameOpts = {};
    const canBeTransparent = palette.filter((a) => !cannotBeTransparent.has(a));
    if (canBeTransparent.length > 0) {
      const transparent = canBeTransparent[0];
      const transparentIndex = localPaletteRequired ? colorIndicesLookup[transparent] : globalIndicesLookup[transparent];
      if (i > 0) {
        for (let k = 0;k < allFramesPixelColors[i].length; k++) {
          if (allFramesPixelColors[i - 1][k] === allFramesPixelColors[i][k]) {
            pixelPaletteIndex[k] = transparentIndex;
          }
        }
        frameOpts.transparent = transparentIndex;
        previousFrame.frameOpts.disposal = 1;
      }
    }
    frameOpts.delay = props.frames[i].delay / 10;
    if (localPaletteRequired) {
      let powof22 = 1;
      while (powof22 < palette.length) {
        powof22 <<= 1;
      }
      palette.length = powof22;
      frameOpts.palette = new Uint32Array(palette);
    }
    if (i > 0) {
      gifWriter.addFrame(0, 0, pImg.width, pImg.height, previousFrame.pixelPaletteIndex, previousFrame.frameOpts);
    }
    previousFrame = {
      pixelPaletteIndex,
      frameOpts
    };
  }
  previousFrame.frameOpts.disposal = 1;
  gifWriter.addFrame(0, 0, pImg.width, pImg.height, previousFrame.pixelPaletteIndex, previousFrame.frameOpts);
  const extension = "gif";
  const blob = new Blob([buffer.slice(0, gifWriter.end())], {
    type: "image/gif"
  });
  downloadFile(blob, filename, extension);
}
function image(p52, fn2) {
  p52.Image = Image;
}
if (typeof p5 !== "undefined") {
  image(p5, p5.prototype);
}

class ClonableObject {
  constructor(obj = {}) {
    for (const key in obj) {
      this[key] = obj[key];
    }
  }
  clone() {
    return new ClonableObject(this);
  }
}

class Renderer {
  static states = {
    strokeColor: null,
    strokeSet: false,
    fillColor: null,
    fillSet: false,
    tint: null,
    imageMode: CORNER,
    rectMode: CORNER,
    ellipseMode: CENTER,
    strokeWeight: 1,
    textFont: { family: "sans-serif" },
    textLeading: 15,
    leadingSet: false,
    textSize: 12,
    textAlign: LEFT,
    textBaseline: BASELINE,
    bezierOrder: 3,
    splineProperties: new ClonableObject({
      ends: INCLUDE,
      tightness: 0
    }),
    textWrap: WORD,
    fontStyle: NORMAL,
    fontStretch: NORMAL,
    fontWeight: NORMAL,
    lineHeight: NORMAL,
    fontVariant: NORMAL,
    direction: "inherit"
  };
  constructor(pInst, w, h, isMainCanvas) {
    this._pInst = pInst;
    this._isMainCanvas = isMainCanvas;
    this.pixels = [];
    this._pixelDensity = Math.ceil(window.devicePixelRatio) || 1;
    this.width = w;
    this.height = h;
    this._events = {};
    if (isMainCanvas) {
      this._isMainCanvas = true;
    }
    this.states = new States(Renderer.states);
    this.states.strokeColor = new Color([0, 0, 0]);
    this.states.fillColor = new Color([1, 1, 1]);
    this._pushPopStack = [];
    this._pushPopDepth = 0;
    this._clipping = false;
    this._clipInvert = false;
    this._currentShape = undefined;
  }
  get currentShape() {
    if (!this._currentShape) {
      this._currentShape = new Shape(this.getCommonVertexProperties());
    }
    return this._currentShape;
  }
  remove() {}
  pixelDensity(val) {
    let returnValue;
    if (typeof val === "number") {
      if (val !== this._pixelDensity) {
        this._pixelDensity = val;
      }
      returnValue = this;
      this.resize(this.width, this.height);
    } else {
      returnValue = this._pixelDensity;
    }
    return returnValue;
  }
  push() {
    this._pushPopDepth++;
    this._pushPopStack.push(this.states.getDiff());
  }
  pop() {
    this._pushPopDepth--;
    const diff = this._pushPopStack.pop() || {};
    const modified = this.states.getModified();
    this.states.applyDiff(diff);
    this.updateShapeVertexProperties(modified);
    this.updateShapeProperties(modified);
  }
  bezierOrder(order) {
    if (order === undefined) {
      return this.states.bezierOrder;
    } else {
      this.states.setValue("bezierOrder", order);
      this.updateShapeProperties();
    }
  }
  bezierVertex(x, y, z = 0, u = 0, v = 0) {
    const position = new Vector(x, y, z);
    const textureCoordinates = this.getSupportedIndividualVertexProperties().textureCoordinates ? new Vector(u, v) : undefined;
    this.currentShape.bezierVertex(position, textureCoordinates);
  }
  splineProperty(key, value) {
    if (value === undefined) {
      return this.states.splineProperties[key];
    } else {
      this.states.setValue("splineProperties", this.states.splineProperties.clone());
      this.states.splineProperties[key] = value;
    }
    this.updateShapeProperties();
  }
  splineProperties(values) {
    if (values) {
      for (const key in values) {
        this.splineProperty(key, values[key]);
      }
    } else {
      return { ...this.states.splineProperties };
    }
  }
  splineVertex(x, y, z = 0, u = 0, v = 0) {
    const position = new Vector(x, y, z);
    const textureCoordinates = this.getSupportedIndividualVertexProperties().textureCoordinates ? new Vector(u, v) : undefined;
    this.currentShape.splineVertex(position, textureCoordinates);
  }
  curveDetail(d2) {
    if (d2 === undefined) {
      return this.states.curveDetail;
    } else {
      this.states.setValue("curveDetail", d2);
    }
  }
  beginShape(...args) {
    this.currentShape.reset();
    this.updateShapeVertexProperties();
    this.currentShape.beginShape(...args);
  }
  endShape(...args) {
    this.currentShape.endShape(...args);
    this.drawShape(this.currentShape);
  }
  beginContour(shapeKind) {
    this.currentShape.beginContour(shapeKind);
  }
  endContour(mode) {
    this.currentShape.endContour(mode);
  }
  drawShape(shape, count) {
    throw new Error("Unimplemented");
  }
  vertex(x, y, z = 0, u = 0, v = 0) {
    const position = new Vector(x, y, z);
    const textureCoordinates = this.getSupportedIndividualVertexProperties().textureCoordinates ? new Vector(u, v) : undefined;
    this.currentShape.vertex(position, textureCoordinates);
  }
  bezier(x1, y1, x2, y2, x3, y3, x4, y4) {
    const oldOrder = this._pInst.bezierOrder();
    this._pInst.bezierOrder(oldOrder);
    this._pInst.beginShape();
    this._pInst.bezierVertex(x1, y1);
    this._pInst.bezierVertex(x2, y2);
    this._pInst.bezierVertex(x3, y3);
    this._pInst.bezierVertex(x4, y4);
    this._pInst.endShape();
    return this;
  }
  spline(...args) {
    if (args.length === 2 * 4) {
      const [x1, y1, x2, y2, x3, y3, x4, y4] = args;
      this._pInst.beginShape();
      this._pInst.splineVertex(x1, y1);
      this._pInst.splineVertex(x2, y2);
      this._pInst.splineVertex(x3, y3);
      this._pInst.splineVertex(x4, y4);
      this._pInst.endShape();
    } else if (args.length === 3 * 4) {
      const [x1, y1, z1, x2, y2, z2, x3, y3, z3, x4, y4, z4] = args;
      this._pInst.beginShape();
      this._pInst.splineVertex(x1, y1, z1);
      this._pInst.splineVertex(x2, y2, z2);
      this._pInst.splineVertex(x3, y3, z3);
      this._pInst.splineVertex(x4, y4, z4);
      this._pInst.endShape();
    }
    return this;
  }
  beginClip(options2 = {}) {
    if (this._clipping) {
      throw new Error("It looks like you're trying to clip while already in the middle of clipping. Did you forget to endClip()?");
    }
    this._clipping = true;
    this._clipInvert = options2.invert;
  }
  endClip() {
    if (!this._clipping) {
      throw new Error("It looks like you've called endClip() without beginClip(). Did you forget to call beginClip() first?");
    }
    this._clipping = false;
  }
  resize(w, h) {
    this.width = w;
    this.height = h;
  }
  get(x, y, w, h) {
    const pd = this._pixelDensity;
    const canvas = this.canvas;
    if (typeof x === "undefined" && typeof y === "undefined") {
      x = y = 0;
      w = this.width;
      h = this.height;
    } else {
      x *= pd;
      y *= pd;
      if (typeof w === "undefined" && typeof h === "undefined") {
        if (x < 0 || y < 0 || x >= canvas.width || y >= canvas.height) {
          return [0, 0, 0, 0];
        }
        return this._getPixel(x, y);
      }
    }
    const region = new Image(w * pd, h * pd);
    region.pixelDensity(pd);
    region.canvas.getContext("2d").drawImage(canvas, x, y, w * pd, h * pd, 0, 0, w * pd, h * pd);
    return region;
  }
  scale(x, y) {}
  fill(...args) {
    this.states.setValue("fillSet", true);
    this.states.setValue("fillColor", this._pInst.color(...args));
    this.updateShapeVertexProperties();
  }
  noFill() {
    this.states.setValue("fillColor", null);
  }
  strokeWeight(w) {
    if (w === undefined) {
      return this.states.strokeWeight;
    } else {
      this.states.setValue("strokeWeight", w);
    }
  }
  stroke(...args) {
    this.states.setValue("strokeSet", true);
    this.states.setValue("strokeColor", this._pInst.color(...args));
    this.updateShapeVertexProperties();
  }
  noStroke() {
    this.states.setValue("strokeColor", null);
  }
  getCommonVertexProperties() {
    return {};
  }
  getSupportedIndividualVertexProperties() {
    return {
      textureCoordinates: false
    };
  }
  updateShapeProperties(modified) {
    if (!modified || modified.bezierOrder || modified.splineProperties) {
      const shape = this.currentShape;
      shape.bezierOrder(this.states.bezierOrder);
      shape.splineProperty("ends", this.states.splineProperties.ends);
      shape.splineProperty("tightness", this.states.splineProperties.tightness);
    }
  }
  updateShapeVertexProperties(modified) {
    const props = this.getCommonVertexProperties();
    if (!modified || Object.keys(modified).some((k) => (k in props))) {
      const shape = this.currentShape;
      for (const key in props) {
        shape[key](props[key]);
      }
    }
  }
  _applyDefaults() {
    return this;
  }
}
function renderer(p52, fn2) {
  p52.Renderer = Renderer;
}

// node_modules/p5/dist/dom/p5.MediaElement.js
var VIDEO = "video";
var AUDIO = "audio";

class Cue {
  constructor(callback, time, id, val) {
    this.callback = callback;
    this.time = time;
    this.id = id;
    this.val = val;
  }
}

class MediaElement extends Element {
  constructor(elt, pInst) {
    super(elt, pInst);
    const self2 = this;
    this.elt.crossOrigin = "anonymous";
    this._prevTime = 0;
    this._cueIDCounter = 0;
    this._cues = [];
    this.pixels = [];
    this._pixelsState = this;
    this._pixelDensity = 1;
    this._modified = false;
    this._frameOnCanvas = -1;
    Object.defineProperty(self2, "src", {
      get() {
        const firstChildSrc = self2.elt.children[0].src;
        const srcVal = self2.elt.src === window.location.href ? "" : self2.elt.src;
        const ret = firstChildSrc === window.location.href ? srcVal : firstChildSrc;
        return ret;
      },
      set(newValue) {
        for (let i = 0;i < self2.elt.children.length; i++) {
          self2.elt.removeChild(self2.elt.children[i]);
        }
        const source = document.createElement("source");
        source.src = newValue;
        elt.appendChild(source);
        self2.elt.src = newValue;
        self2.modified = true;
      }
    });
    self2._onended = function() {};
    self2.elt.onended = function() {
      self2._onended(self2);
    };
  }
  play() {
    if (this.elt.currentTime === this.elt.duration) {
      this.elt.currentTime = 0;
    }
    let promise;
    if (this.elt.readyState > 1) {
      promise = this.elt.play();
    } else {
      this.elt.load();
      promise = this.elt.play();
    }
    if (promise && promise.catch) {
      promise.catch((e2) => {
        if (e2.name === "NotAllowedError") {
          if (typeof IS_MINIFIED === "undefined") {
            p5._friendlyAutoplayError(this.src);
          } else {
            console.error(e2);
          }
        } else {
          console.error("Media play method encountered an unexpected error", e2);
        }
      });
    }
    return this;
  }
  stop() {
    this.elt.pause();
    this.elt.currentTime = 0;
    return this;
  }
  pause() {
    this.elt.pause();
    return this;
  }
  loop() {
    this.elt.setAttribute("loop", true);
    this.play();
    return this;
  }
  noLoop() {
    this.elt.removeAttribute("loop");
    return this;
  }
  _setupAutoplayFailDetection() {
    const timeout = setTimeout(() => {
      if (typeof IS_MINIFIED === "undefined") {
        p5._friendlyAutoplayError(this.src);
      } else {
        console.error(e);
      }
    }, 500);
    this.elt.addEventListener("play", () => clearTimeout(timeout), {
      passive: true,
      once: true
    });
  }
  autoplay(val) {
    const oldVal = this.elt.getAttribute("autoplay");
    this.elt.setAttribute("autoplay", val);
    if (val && !oldVal) {
      const setupAutoplayFailDetection = () => this._setupAutoplayFailDetection();
      if (this.elt.readyState === 4) {
        setupAutoplayFailDetection();
      } else {
        this.elt.addEventListener("canplay", setupAutoplayFailDetection, {
          passive: true,
          once: true
        });
      }
    }
    return this;
  }
  volume(val) {
    if (typeof val === "undefined") {
      return this.elt.volume;
    } else {
      this.elt.volume = val;
    }
  }
  speed(val) {
    if (typeof val === "undefined") {
      return this.presetPlaybackRate || this.elt.playbackRate;
    } else {
      if (this.loadedmetadata) {
        this.elt.playbackRate = val;
      } else {
        this.presetPlaybackRate = val;
      }
    }
  }
  time(val) {
    if (typeof val !== "undefined") {
      this.elt.currentTime = val;
    }
    return this.elt.currentTime;
  }
  duration() {
    return this.elt.duration;
  }
  _ensureCanvas() {
    if (!this.canvas) {
      this.canvas = document.createElement("canvas");
      this.drawingContext = this.canvas.getContext("2d");
      this.setModified(true);
    }
    const needsRedraw = this._frameOnCanvas !== this._pInst.frameCount;
    if (this.loadedmetadata && needsRedraw) {
      if (this.canvas.width !== this.elt.width) {
        this.canvas.width = this.elt.width;
        this.canvas.height = this.elt.height;
        this.width = this.canvas.width;
        this.height = this.canvas.height;
      }
      this.drawingContext.clearRect(0, 0, this.canvas.width, this.canvas.height);
      if (this.flipped === true) {
        this.drawingContext.save();
        this.drawingContext.scale(-1, 1);
        this.drawingContext.translate(-this.canvas.width, 0);
      }
      this.drawingContext.drawImage(this.elt, 0, 0, this.canvas.width, this.canvas.height);
      if (this.flipped === true) {
        this.drawingContext.restore();
      }
      this.setModified(true);
      this._frameOnCanvas = this._pInst.frameCount;
    }
  }
  loadPixels(...args) {
    this._ensureCanvas();
    return p5.Renderer2D.prototype.loadPixels.apply(this, args);
  }
  updatePixels(x, y, w, h) {
    if (this.loadedmetadata) {
      this._ensureCanvas();
      p5.Renderer2D.prototype.updatePixels.call(this, x, y, w, h);
    }
    this.setModified(true);
    return this;
  }
  get(...args) {
    this._ensureCanvas();
    return p5.Renderer2D.prototype.get.apply(this, args);
  }
  _getPixel(...args) {
    this.loadPixels();
    return p5.Renderer2D.prototype._getPixel.apply(this, args);
  }
  set(x, y, imgOrCol) {
    if (this.loadedmetadata) {
      this._ensureCanvas();
      p5.Renderer2D.prototype.set.call(this, x, y, imgOrCol);
      this.setModified(true);
    }
  }
  copy(...args) {
    this._ensureCanvas();
    p5.prototype.copy.apply(this, args);
  }
  mask(...args) {
    this.loadPixels();
    this.setModified(true);
    p5.Image.prototype.mask.apply(this, args);
  }
  isModified() {
    return this._modified;
  }
  setModified(value) {
    this._modified = value;
  }
  onended(callback) {
    this._onended = callback;
    return this;
  }
  _getAudioContext() {
    return;
  }
  _getSoundOut() {
    return;
  }
  connect(obj) {
    let audioContext, mainOutput;
    if (this._getAudioContext() && this._getSoundOut()) {
      audioContext = this._getAudioContext();
      mainOutput = this._getSoundOut().input;
    } else {
      try {
        audioContext = obj.context;
        mainOutput = audioContext.destination;
      } catch (e2) {
        throw "connect() is meant to be used with Web Audio API or p5.sound.js";
      }
    }
    if (!this.audioSourceNode) {
      this.audioSourceNode = audioContext.createMediaElementSource(this.elt);
      this.audioSourceNode.connect(mainOutput);
    }
    if (obj) {
      if (obj.input) {
        this.audioSourceNode.connect(obj.input);
      } else {
        this.audioSourceNode.connect(obj);
      }
    } else {
      this.audioSourceNode.connect(mainOutput);
    }
  }
  disconnect() {
    if (this.audioSourceNode) {
      this.audioSourceNode.disconnect();
    } else {
      throw "nothing to disconnect";
    }
  }
  showControls() {
    this.elt.style["text-align"] = "inherit";
    this.elt.controls = true;
  }
  hideControls() {
    this.elt.controls = false;
  }
  addCue(time, callback, val) {
    const id = this._cueIDCounter++;
    const cue = new Cue(callback, time, id, val);
    this._cues.push(cue);
    if (!this.elt.ontimeupdate) {
      this.elt.ontimeupdate = this._onTimeUpdate.bind(this);
    }
    return id;
  }
  removeCue(id) {
    for (let i = 0;i < this._cues.length; i++) {
      if (this._cues[i].id === id) {
        console.log(id);
        this._cues.splice(i, 1);
      }
    }
    if (this._cues.length === 0) {
      this.elt.ontimeupdate = null;
    }
  }
  clearCues() {
    this._cues = [];
    this.elt.ontimeupdate = null;
  }
  _onTimeUpdate() {
    const playbackTime = this.time();
    for (let i = 0;i < this._cues.length; i++) {
      const callbackTime = this._cues[i].time;
      const val = this._cues[i].val;
      if (this._prevTime < callbackTime && callbackTime <= playbackTime) {
        this._cues[i].callback(val);
      }
    }
    this._prevTime = playbackTime;
  }
}
function media(p52, fn2) {
  function addElement(elt, pInst, media2) {
    const node = pInst._userNode ? pInst._userNode : document.body;
    node.appendChild(elt);
    const c = media2 ? new MediaElement(elt, pInst) : new Element(elt, pInst);
    pInst._elements.push(c);
    return c;
  }
  function createMedia(pInst, type2, src, callback) {
    const elt = document.createElement(type2);
    src = src || "";
    if (typeof src === "string") {
      src = [src];
    }
    for (const mediaSource of src) {
      const sourceEl = document.createElement("source");
      sourceEl.setAttribute("src", mediaSource);
      elt.appendChild(sourceEl);
    }
    const mediaEl = addElement(elt, pInst, true);
    mediaEl.loadedmetadata = false;
    elt.addEventListener("loadedmetadata", () => {
      mediaEl.width = elt.videoWidth;
      mediaEl.height = elt.videoHeight;
      if (mediaEl.elt.width === 0)
        mediaEl.elt.width = elt.videoWidth;
      if (mediaEl.elt.height === 0)
        mediaEl.elt.height = elt.videoHeight;
      if (mediaEl.presetPlaybackRate) {
        mediaEl.elt.playbackRate = mediaEl.presetPlaybackRate;
        delete mediaEl.presetPlaybackRate;
      }
      mediaEl.loadedmetadata = true;
    });
    if (typeof callback === "function") {
      const callbackHandler = () => {
        callback(mediaEl);
        elt.removeEventListener("canplaythrough", callbackHandler);
      };
      elt.addEventListener("canplaythrough", callbackHandler);
    }
    return mediaEl;
  }
  fn2.createVideo = function(src, callback) {
    return createMedia(this, VIDEO, src, callback);
  };
  fn2.createAudio = function(src, callback) {
    return createMedia(this, AUDIO, src, callback);
  };
  fn2.VIDEO = VIDEO;
  fn2.AUDIO = AUDIO;
  if (navigator.mediaDevices === undefined) {
    navigator.mediaDevices = {};
  }
  if (navigator.mediaDevices.getUserMedia === undefined) {
    navigator.mediaDevices.getUserMedia = function(constraints) {
      const getUserMedia = navigator.webkitGetUserMedia || navigator.mozGetUserMedia;
      if (!getUserMedia) {
        return Promise.reject(new Error("getUserMedia is not implemented in this browser"));
      }
      return new Promise(function(resolve, reject) {
        getUserMedia.call(navigator, constraints, resolve, reject);
      });
    };
  }
  fn2.createCapture = function(...args) {
    if (!(navigator.mediaDevices && navigator.mediaDevices.getUserMedia)) {
      throw new DOMException("getUserMedia not supported in this browser");
    }
    let useVideo = true;
    let useAudio = true;
    let constraints;
    let callback;
    let flipped = false;
    for (const arg of args) {
      if (arg === fn2.VIDEO)
        useAudio = false;
      else if (arg === fn2.AUDIO)
        useVideo = false;
      else if (typeof arg === "object") {
        if (arg.flipped !== undefined) {
          flipped = arg.flipped;
          delete arg.flipped;
        }
        constraints = Object.assign({}, constraints, arg);
      } else if (typeof arg === "function") {
        callback = arg;
      }
    }
    const videoConstraints = { video: useVideo, audio: useAudio };
    constraints = Object.assign({}, videoConstraints, constraints);
    const domElement = document.createElement(VIDEO);
    domElement.setAttribute("playsinline", "");
    navigator.mediaDevices.getUserMedia(constraints).then(function(stream) {
      try {
        if ("srcObject" in domElement) {
          domElement.srcObject = stream;
        } else {
          domElement.src = window.URL.createObjectURL(stream);
        }
      } catch (err) {
        domElement.src = stream;
      }
    }).catch((e2) => {
      if (e2.name === "NotFoundError")
        p52._friendlyError("No webcam found on this device", "createCapture");
      if (e2.name === "NotAllowedError")
        p52._friendlyError("Access to the camera was denied", "createCapture");
      console.error(e2);
    });
    const videoEl = addElement(domElement, this, true);
    videoEl.loadedmetadata = false;
    domElement.addEventListener("loadedmetadata", function() {
      domElement.play();
      if (domElement.width) {
        videoEl.width = domElement.width;
        videoEl.height = domElement.height;
        if (flipped) {
          videoEl.elt.style.transform = "scaleX(-1)";
        }
      } else {
        videoEl.width = videoEl.elt.width = domElement.videoWidth;
        videoEl.height = videoEl.elt.height = domElement.videoHeight;
      }
      videoEl.loadedmetadata = true;
      if (callback)
        callback(domElement.srcObject);
    });
    videoEl.flipped = flipped;
    return videoEl;
  };
  p52.MediaElement = MediaElement;
  MediaElement.prototype._getSoundOut = function() {
    return p52.soundOut;
  };
  MediaElement.prototype._getAudioContext = function() {
    if (typeof fn2.getAudioContext === "function") {
      return fn2.getAudioContext();
    } else {
      return;
    }
  };
}
if (typeof p5 !== "undefined") {
  media(p5, p5.prototype);
}

// node_modules/p5/dist/core/helpers.js
function modeAdjust(a, b2, c, d2, mode) {
  let bbox;
  if (mode === CORNER) {
    bbox = {
      x: a,
      y: b2,
      w: Math.abs(c),
      h: Math.abs(d2)
    };
  } else if (mode === CORNERS) {
    bbox = {
      x: Math.min(a, c),
      y: Math.min(b2, d2),
      w: Math.abs(c - a),
      h: Math.abs(d2 - b2)
    };
  } else if (mode === RADIUS) {
    c = Math.abs(c);
    d2 = Math.abs(d2);
    bbox = {
      x: a - c,
      y: b2 - d2,
      w: 2 * c,
      h: 2 * d2
    };
  } else if (mode === CENTER) {
    c = Math.abs(c);
    d2 = Math.abs(d2);
    bbox = {
      x: a - c * 0.5,
      y: b2 - d2 * 0.5,
      w: c,
      h: d2
    };
  }
  return bbox;
}
var canvas = { modeAdjust };

// node_modules/p5/dist/shape/2d_primitives.js
function primitives(p52, fn2) {
  fn2._normalizeArcAngles = (start, stop, width, height, correctForScaling) => {
    const epsilon = 0.00001;
    let separation;
    start = start - TWO_PI * Math.floor(start / TWO_PI);
    stop = stop - TWO_PI * Math.floor(stop / TWO_PI);
    separation = Math.min(Math.abs(start - stop), TWO_PI - Math.abs(start - stop));
    if (correctForScaling) {
      if (start <= HALF_PI) {
        start = Math.atan(width / height * Math.tan(start));
      } else if (start > HALF_PI && start <= 3 * HALF_PI) {
        start = Math.atan(width / height * Math.tan(start)) + PI;
      } else {
        start = Math.atan(width / height * Math.tan(start)) + TWO_PI;
      }
      if (stop <= HALF_PI) {
        stop = Math.atan(width / height * Math.tan(stop));
      } else if (stop > HALF_PI && stop <= 3 * HALF_PI) {
        stop = Math.atan(width / height * Math.tan(stop)) + PI;
      } else {
        stop = Math.atan(width / height * Math.tan(stop)) + TWO_PI;
      }
    }
    if (start > stop) {
      stop += TWO_PI;
    }
    return {
      start,
      stop,
      correspondToSamePoint: separation < epsilon
    };
  };
  fn2.arc = function(x, y, w, h, start, stop, mode, detail) {
    if (!this._renderer.states.strokeColor && !this._renderer.states.fillColor) {
      return this;
    }
    if (start === stop) {
      return this;
    }
    start = this._toRadians(start);
    stop = this._toRadians(stop);
    const vals = canvas.modeAdjust(x, y, w, h, this._renderer.states.ellipseMode);
    const angles = this._normalizeArcAngles(start, stop, vals.w, vals.h, true);
    if (angles.correspondToSamePoint) {
      this._renderer.ellipse([vals.x, vals.y, vals.w, vals.h, detail]);
    } else {
      this._renderer.arc(vals.x, vals.y, vals.w, vals.h, angles.start, angles.stop, mode, detail);
      if (this._accessibleOutputs.grid || this._accessibleOutputs.text) {
        this._accsOutput("arc", [
          vals.x,
          vals.y,
          vals.w,
          vals.h,
          angles.start,
          angles.stop,
          mode
        ]);
      }
    }
    return this;
  };
  fn2.ellipse = function(x, y, w, h, detailX) {
    return this._renderEllipse(...arguments);
  };
  fn2.circle = function(...args) {
    const argss = args.slice(0, 2);
    argss.push(args[2], args[2]);
    return this._renderEllipse(...argss);
  };
  fn2._renderEllipse = function(x, y, w, h, detailX) {
    if (!this._renderer.states.strokeColor && !this._renderer.states.fillColor) {
      return this;
    }
    if (typeof h === "undefined") {
      h = w;
    }
    const vals = canvas.modeAdjust(x, y, w, h, this._renderer.states.ellipseMode);
    this._renderer.ellipse([vals.x, vals.y, vals.w, vals.h, detailX]);
    if (this._accessibleOutputs.grid || this._accessibleOutputs.text) {
      this._accsOutput("ellipse", [vals.x, vals.y, vals.w, vals.h]);
    }
    return this;
  };
  fn2.line = function(...args) {
    if (this._renderer.states.strokeColor) {
      this._renderer.line(...args);
    }
    if (this._accessibleOutputs.grid || this._accessibleOutputs.text) {
      this._accsOutput("line", args);
    }
    return this;
  };
  fn2.point = function(...args) {
    if (this._renderer.states.strokeColor) {
      if (args.length === 1 && args[0] instanceof p52.Vector) {
        this._renderer.point.call(this._renderer, args[0].x, args[0].y, args[0].z);
      } else {
        this._renderer.point(...args);
        if (this._accessibleOutputs.grid || this._accessibleOutputs.text) {
          this._accsOutput("point", args);
        }
      }
    }
    return this;
  };
  fn2.quad = function(...args) {
    if (this._renderer.states.strokeColor || this._renderer.states.fillColor) {
      if (this._renderer.isP3D && args.length < 12) {
        this._renderer.quad.call(this._renderer, args[0], args[1], 0, args[2], args[3], 0, args[4], args[5], 0, args[6], args[7], 0, args[8], args[9]);
      } else {
        this._renderer.quad(...args);
        if (this._accessibleOutputs.grid || this._accessibleOutputs.text) {
          this._accsOutput("quadrilateral", args);
        }
      }
    }
    return this;
  };
  fn2.rect = function(...args) {
    return this._renderRect(...args);
  };
  fn2.square = function(x, y, s, tl, tr, br, bl) {
    return this._renderRect.call(this, x, y, s, s, tl, tr, br, bl);
  };
  fn2._renderRect = function() {
    if (this._renderer.states.strokeColor || this._renderer.states.fillColor) {
      if (arguments.length === 3) {
        arguments[3] = arguments[2];
      }
      const vals = canvas.modeAdjust(arguments[0], arguments[1], arguments[2], arguments[3], this._renderer.states.rectMode);
      if (this._renderer.states.rectMode === CORNER) {
        vals.w = arguments[2];
        vals.h = arguments[3];
      }
      const args = [vals.x, vals.y, vals.w, vals.h];
      for (let i = 4;i < arguments.length; i++) {
        args[i] = arguments[i];
      }
      this._renderer.rect(args);
      if (this._accessibleOutputs.grid || this._accessibleOutputs.text) {
        this._accsOutput("rectangle", [vals.x, vals.y, vals.w, vals.h]);
      }
    }
    return this;
  };
  fn2.triangle = function(...args) {
    if (this._renderer.states.strokeColor || this._renderer.states.fillColor) {
      this._renderer.triangle(args);
    }
    if (this._accessibleOutputs.grid || this._accessibleOutputs.text) {
      this._accsOutput("triangle", args);
    }
    return this;
  };
}
if (typeof p5 !== "undefined") {
  primitives(p5, p5.prototype);
}

// node_modules/p5/dist/shape/attributes.js
function attributes(p52, fn2) {
  fn2.ellipseMode = function(m) {
    if (m === CORNER || m === CORNERS || m === RADIUS || m === CENTER) {
      this._renderer.states.setValue("ellipseMode", m);
    }
    return this;
  };
  fn2.noSmooth = function() {
    if (!this._renderer.isP3D) {
      if ("imageSmoothingEnabled" in this.drawingContext) {
        this.drawingContext.imageSmoothingEnabled = false;
      }
    } else {
      this.setAttributes("antialias", false);
    }
    return this;
  };
  fn2.rectMode = function(m) {
    if (m === CORNER || m === CORNERS || m === RADIUS || m === CENTER) {
      this._renderer.states.setValue("rectMode", m);
    }
    return this;
  };
  fn2.smooth = function() {
    if (!this._renderer.isP3D) {
      if ("imageSmoothingEnabled" in this.drawingContext) {
        this.drawingContext.imageSmoothingEnabled = true;
      }
    } else {
      this.setAttributes("antialias", true);
    }
    return this;
  };
  fn2.strokeCap = function(cap) {
    if (cap === ROUND || cap === SQUARE || cap === PROJECT) {
      this._renderer.strokeCap(cap);
    }
    return this;
  };
  fn2.strokeJoin = function(join) {
    if (join === ROUND || join === BEVEL || join === MITER) {
      this._renderer.strokeJoin(join);
    }
    return this;
  };
  fn2.strokeWeight = function(w) {
    this._renderer.strokeWeight(w);
    return this;
  };
}
if (typeof p5 !== "undefined") {
  attributes(p5, p5.prototype);
}

// node_modules/p5/dist/shape/curves.js
function curves(p52, fn2) {
  fn2.bezier = function(...args) {
    if (!this._renderer.states.strokeColor && !this._renderer.states.fillColor) {
      return this;
    }
    this._renderer.bezier(...args);
    return this;
  };
  fn2.bezierPoint = function(a, b2, c, d2, t) {
    const adjustedT = 1 - t;
    return Math.pow(adjustedT, 3) * a + 3 * Math.pow(adjustedT, 2) * t * b2 + 3 * adjustedT * Math.pow(t, 2) * c + Math.pow(t, 3) * d2;
  };
  fn2.bezierTangent = function(a, b2, c, d2, t) {
    const adjustedT = 1 - t;
    return 3 * d2 * Math.pow(t, 2) - 3 * c * Math.pow(t, 2) + 6 * c * adjustedT * t - 6 * b2 * adjustedT * t + 3 * b2 * Math.pow(adjustedT, 2) - 3 * a * Math.pow(adjustedT, 2);
  };
  fn2.spline = function(...args) {
    if (!this._renderer.states.strokeColor && !this._renderer.states.fillColor) {
      return this;
    }
    this._renderer.spline(...args);
    return this;
  };
  fn2.splinePoint = function(a, b2, c, d2, t) {
    const s = this._renderer.states.splineProperties.tightness, t3 = t * t * t, t2 = t * t, f1 = (s - 1) / 2 * t3 + (1 - s) * t2 + (s - 1) / 2 * t, f2 = (s + 3) / 2 * t3 + (-5 - s) / 2 * t2 + 1, f3 = (-3 - s) / 2 * t3 + (s + 2) * t2 + (1 - s) / 2 * t, f4 = (1 - s) / 2 * t3 + (s - 1) / 2 * t2;
    return a * f1 + b2 * f2 + c * f3 + d2 * f4;
  };
  fn2.splineTangent = function(a, b2, c, d2, t) {
    const s = this._renderer.states.splineProperties.tightness, tt3 = t * t * 3, t2 = t * 2, f1 = (s - 1) / 2 * tt3 + (1 - s) * t2 + (s - 1) / 2, f2 = (s + 3) / 2 * tt3 + (-5 - s) / 2 * t2, f3 = (-3 - s) / 2 * tt3 + (s + 2) * t2 + (1 - s) / 2, f4 = (1 - s) / 2 * tt3 + (s - 1) / 2 * t2;
    return a * f1 + b2 * f2 + c * f3 + d2 * f4;
  };
}
if (typeof p5 !== "undefined") {
  curves(p5, p5.prototype);
}

// node_modules/p5/dist/shape/vertex.js
function vertex(p52, fn2) {
  fn2.beginShape = function(kind) {
    this._renderer.beginShape(...arguments);
  };
  fn2.bezierVertex = function(...args) {
    this._renderer.bezierVertex(...args);
  };
  fn2.endShape = function(mode, count = 1) {
    if (count < 1) {
      console.log("\uD83C\uDF38 p5.js says: You can not have less than one instance");
      count = 1;
    }
    this._renderer.endShape(mode, count);
  };
  fn2.normal = function(x, y, z) {
    this._assert3d("normal");
    this._renderer.normal(...arguments);
    return this;
  };
  fn2.vertexProperty = function(attributeName, data) {
    this._renderer.vertexProperty(attributeName, data);
  };
}
if (typeof p5 !== "undefined") {
  vertex(p5, p5.prototype);
}

// node_modules/p5/dist/color/setting.js
function setting(p52, fn2) {
  fn2.beginClip = function(options2 = {}) {
    this._renderer.beginClip(options2);
  };
  fn2.endClip = function() {
    this._renderer.endClip();
  };
  fn2.clip = function(callback, options2) {
    this._renderer.beginClip(options2);
    callback();
    this._renderer.endClip(options2);
  };
  fn2.background = function(...args) {
    this._renderer.background(...args);
    return this;
  };
  fn2.clear = function(...args) {
    const _r = args[0] || 0;
    const _g = args[1] || 0;
    const _b = args[2] || 0;
    const _a = args[3] || 0;
    this._renderer.clear(_r, _g, _b, _a);
    return this;
  };
  fn2.colorMode = function(mode, max1, max2, max3, maxA) {
    if ([
      RGB,
      RGBHDR,
      HSB,
      HSL,
      HWB,
      LAB,
      LCH,
      OKLAB,
      OKLCH
    ].includes(mode)) {
      this._renderer.states.setValue("colorMode", mode);
      this._renderer.states.setValue("colorMaxes", this._renderer.states.colorMaxes.clone());
      const maxes = this._renderer.states.colorMaxes[mode];
      if (arguments.length === 2) {
        maxes[0] = max1;
        maxes[1] = max1;
        maxes[2] = max1;
        maxes[3] = max1;
      } else if (arguments.length === 4) {
        maxes[0] = max1;
        maxes[1] = max2;
        maxes[2] = max3;
      } else if (arguments.length === 5) {
        maxes[0] = max1;
        maxes[1] = max2;
        maxes[2] = max3;
        maxes[3] = maxA;
      }
    }
    return this._renderer.states.colorMode;
  };
  fn2.fill = function(...args) {
    this._renderer.fill(...args);
    return this;
  };
  fn2.noFill = function() {
    this._renderer.noFill();
    return this;
  };
  fn2.noStroke = function() {
    this._renderer.states.setValue("strokeColor", null);
    return this;
  };
  fn2.stroke = function(...args) {
    this._renderer.stroke(...args);
    return this;
  };
  fn2.erase = function(opacityFill = 255, opacityStroke = 255) {
    this._renderer.erase(opacityFill, opacityStroke);
    return this;
  };
  fn2.noErase = function() {
    this._renderer.noErase();
    return this;
  };
  fn2.blendMode = function(mode) {
    if (mode === NORMAL) {
      console.warn("NORMAL has been deprecated for use in blendMode. defaulting to BLEND instead.");
      mode = BLEND;
    }
    this._renderer.blendMode(mode);
  };
}
if (typeof p5 !== "undefined") {
  setting(p5, p5.prototype);
}

// node_modules/p5/dist/rendering-CEHgvKUS.js
var omggif2 = __toESM(require_omggif(), 1);

// node_modules/p5/dist/io/csv.js
function parse2(csv, options2, reviver = (v) => v) {
  const ctx = Object.create(null);
  ctx.options = options2 || {};
  ctx.reviver = reviver;
  ctx.value = "";
  ctx.entry = [];
  ctx.output = [];
  ctx.col = 1;
  ctx.row = 1;
  ctx.options.delimiter = ctx.options.delimiter === undefined ? '"' : options2.delimiter;
  if (ctx.options.delimiter.length > 1 || ctx.options.delimiter.length === 0)
    throw Error(`CSVError: delimiter must be one character [${ctx.options.separator}]`);
  ctx.options.separator = ctx.options.separator === undefined ? "," : options2.separator;
  if (ctx.options.separator.length > 1 || ctx.options.separator.length === 0)
    throw Error(`CSVError: separator must be one character [${ctx.options.separator}]`);
  const lexer = new RegExp(`${escapeRegExp(ctx.options.delimiter)}|${escapeRegExp(ctx.options.separator)}|\r
|
|\r|[^${escapeRegExp(ctx.options.delimiter)}${escapeRegExp(ctx.options.separator)}\r
]+`, "y");
  const isNewline = /^(\r\n|\n|\r)$/;
  let matches = [];
  let match = "";
  let state = 0;
  while ((matches = lexer.exec(csv)) !== null) {
    match = matches[0];
    switch (state) {
      case 0:
        switch (true) {
          case match === ctx.options.delimiter:
            state = 3;
            break;
          case match === ctx.options.separator:
            state = 0;
            valueEnd(ctx);
            break;
          case isNewline.test(match):
            state = 0;
            valueEnd(ctx);
            entryEnd(ctx);
            break;
          default:
            ctx.value += match;
            state = 2;
            break;
        }
        break;
      case 2:
        switch (true) {
          case match === ctx.options.separator:
            state = 0;
            valueEnd(ctx);
            break;
          case isNewline.test(match):
            state = 0;
            valueEnd(ctx);
            entryEnd(ctx);
            break;
          default:
            state = 4;
            throw Error(`CSVError: Illegal state [row:${ctx.row}, col:${ctx.col}]`);
        }
        break;
      case 3:
        switch (true) {
          case match === ctx.options.delimiter:
            state = 4;
            break;
          default:
            state = 3;
            ctx.value += match;
            break;
        }
        break;
      case 4:
        switch (true) {
          case match === ctx.options.delimiter:
            state = 3;
            ctx.value += match;
            break;
          case match === ctx.options.separator:
            state = 0;
            valueEnd(ctx);
            break;
          case isNewline.test(match):
            state = 0;
            valueEnd(ctx);
            entryEnd(ctx);
            break;
          default:
            throw Error(`CSVError: Illegal state [row:${ctx.row}, col:${ctx.col}]`);
        }
        break;
    }
  }
  if (ctx.entry.length !== 0) {
    valueEnd(ctx);
    entryEnd(ctx);
  }
  return ctx.output;
}
function stringify(array, options2 = {}, replacer = (v) => v) {
  const ctx = Object.create(null);
  ctx.options = options2;
  ctx.options.eof = ctx.options.eof !== undefined ? ctx.options.eof : true;
  ctx.row = 1;
  ctx.col = 1;
  ctx.output = "";
  ctx.options.delimiter = ctx.options.delimiter === undefined ? '"' : options2.delimiter;
  if (ctx.options.delimiter.length > 1 || ctx.options.delimiter.length === 0)
    throw Error(`CSVError: delimiter must be one character [${ctx.options.separator}]`);
  ctx.options.separator = ctx.options.separator === undefined ? "," : options2.separator;
  if (ctx.options.separator.length > 1 || ctx.options.separator.length === 0)
    throw Error(`CSVError: separator must be one character [${ctx.options.separator}]`);
  const needsDelimiters = new RegExp(`${escapeRegExp(ctx.options.delimiter)}|${escapeRegExp(ctx.options.separator)}|\r
|
|\r`);
  array.forEach((row, rIdx) => {
    let entry = "";
    ctx.col = 1;
    row.forEach((col, cIdx) => {
      if (typeof col === "string") {
        col = col.replace(new RegExp(ctx.options.delimiter, "g"), `${ctx.options.delimiter}${ctx.options.delimiter}`);
        col = needsDelimiters.test(col) ? `${ctx.options.delimiter}${col}${ctx.options.delimiter}` : col;
      }
      entry += replacer(col, ctx.row, ctx.col);
      if (cIdx !== row.length - 1) {
        entry += ctx.options.separator;
      }
      ctx.col++;
    });
    switch (true) {
      case ctx.options.eof:
      case (!ctx.options.eof && rIdx !== array.length - 1):
        ctx.output += `${entry}
`;
        break;
      default:
        ctx.output += `${entry}`;
        break;
    }
    ctx.row++;
  });
  return ctx.output;
}
function valueEnd(ctx) {
  const value = ctx.options.typed ? inferType(ctx.value) : ctx.value;
  ctx.entry.push(ctx.reviver(value, ctx.row, ctx.col));
  ctx.value = "";
  ctx.col++;
}
function entryEnd(ctx) {
  ctx.output.push(ctx.entry);
  ctx.entry = [];
  ctx.row++;
  ctx.col = 1;
}
function inferType(value) {
  const isNumber = /.\./;
  switch (true) {
    case value === "true":
    case value === "false":
      return value === "true";
    case isNumber.test(value):
      return parseFloat(value);
    case isFinite(value):
      return parseInt(value);
    default:
      return value;
  }
}
function escapeRegExp(str) {
  return str.replace(/[\-\[\]\/\{\}\(\)\*\+\?\.\\\^\$\|]/g, "\\$&");
}

// node_modules/p5/dist/rendering-CEHgvKUS.js
var import_gifenc = __toESM(require_gifenc(), 1);

// node_modules/p5/dist/image/pixels.js
function pixels(p52, fn2) {
  fn2.blend = function(...args) {
    if (this._renderer) {
      this._renderer.blend(...args);
    } else {
      p52.Renderer2D.prototype.blend.apply(this, args);
    }
  };
  fn2.copy = function(...args) {
    let srcImage, sx, sy, sw, sh, dx, dy, dw, dh;
    if (args.length === 9) {
      srcImage = args[0];
      sx = args[1];
      sy = args[2];
      sw = args[3];
      sh = args[4];
      dx = args[5];
      dy = args[6];
      dw = args[7];
      dh = args[8];
    } else if (args.length === 8) {
      srcImage = this;
      sx = args[0];
      sy = args[1];
      sw = args[2];
      sh = args[3];
      dx = args[4];
      dy = args[5];
      dw = args[6];
      dh = args[7];
    } else {
      throw new Error("Signature not supported");
    }
    fn2._copyHelper(this, srcImage, sx, sy, sw, sh, dx, dy, dw, dh);
  };
  fn2._copyHelper = (dstImage, srcImage, sx, sy, sw, sh, dx, dy, dw, dh) => {
    const s = srcImage.canvas.width / srcImage.width;
    let sxMod = 0;
    let syMod = 0;
    if (srcImage._renderer && srcImage._renderer.isP3D) {
      sxMod = srcImage.width / 2;
      syMod = srcImage.height / 2;
    }
    if (dstImage._renderer && dstImage._renderer.isP3D) {
      dstImage.push();
      dstImage.resetMatrix();
      dstImage.noLights();
      dstImage.blendMode(dstImage.BLEND);
      dstImage.imageMode(dstImage.CORNER);
      dstImage._renderer.image(srcImage, sx + sxMod, sy + syMod, sw, sh, dx, dy, dw, dh);
      dstImage.pop();
    } else {
      dstImage.drawingContext.drawImage(srcImage.canvas, s * (sx + sxMod), s * (sy + syMod), s * sw, s * sh, dx, dy, dw, dh);
    }
  };
  fn2.getFilterGraphicsLayer = function() {
    return this._renderer.getFilterGraphicsLayer();
  };
  fn2.filter = function(...args) {
    let { shader, operation, value, useWebGL } = parseFilterArgs(...args);
    if (this._renderer.isP3D && shader) {
      this._renderer.filter(shader);
      return;
    }
    if (!useWebGL && !this._renderer.isP3D) {
      if (this.canvas !== undefined) {
        Filters.apply(this.canvas, Filters[operation], value);
      } else {
        Filters.apply(this.elt, Filters[operation], value);
      }
      return;
    }
    if (!useWebGL && this._renderer.isP3D) {
      console.warn("filter() with useWebGL=false is not supported in WEBGL");
    }
    if (this._renderer.isP3D) {
      this._renderer.filter(operation, value);
    } else {
      if (shader) {
        this._renderer.filterRenderer.setOperation(operation, value, shader);
      } else {
        this._renderer.filterRenderer.setOperation(operation, value);
      }
      this._renderer.filterRenderer.applyFilter();
    }
  };
  function parseFilterArgs(...args) {
    let result = {
      shader: undefined,
      operation: undefined,
      value: undefined,
      useWebGL: true
    };
    if (args[0] instanceof p52.Shader) {
      result.shader = args[0];
      return result;
    } else {
      result.operation = args[0];
    }
    if (args.length > 1 && typeof args[1] === "number") {
      result.value = args[1];
    }
    if (args[args.length - 1] === false) {
      result.useWebGL = false;
    }
    return result;
  }
  fn2.get = function(x, y, w, h) {
    return this._renderer.get(...arguments);
  };
  fn2.loadPixels = function(...args) {
    this._renderer.loadPixels();
  };
  fn2.set = function(x, y, imgOrCol) {
    this._renderer.set(x, y, imgOrCol);
  };
  fn2.updatePixels = function(x, y, w, h) {
    if (this.pixels.length === 0) {
      return;
    }
    this._renderer.updatePixels(x, y, w, h);
  };
}
if (typeof p5 !== "undefined") {
  pixels(p5, p5.prototype);
}

// node_modules/p5/dist/math/Matrices/MatrixInterface.js
var GLMAT_ARRAY_TYPE = Array;
var isMatrixArray = (x) => Array.isArray(x);
if (typeof Float32Array !== "undefined") {
  GLMAT_ARRAY_TYPE = Float32Array;
  isMatrixArray = (x) => Array.isArray(x) || x instanceof Float32Array;
}

class MatrixInterface {
  #matrix = null;
  constructor(...args) {
    if (this.constructor === MatrixInterface) {
      throw new Error("Class is of abstract type and can't be instantiated");
    }
  }
}

// node_modules/p5/dist/math/Matrices/Matrix.js
var isPerfectSquare = (arr) => {
  const sqDimention = Math.sqrt(arr.length);
  if (sqDimention % 1 !== 0) {
    throw new Error("Array length must be a perfect square.");
  }
  return true;
};
var GLMAT_ARRAY_TYPE2 = Array;
var isMatrixArray2 = (x) => Array.isArray(x);
if (typeof Float32Array !== "undefined") {
  GLMAT_ARRAY_TYPE2 = Float32Array;
  isMatrixArray2 = (x) => Array.isArray(x) || x instanceof Float32Array;
}

class Matrix extends MatrixInterface {
  matrix;
  #sqDimention;
  constructor(...args) {
    super(...args);
    if (isMatrixArray2(args[0]) && isPerfectSquare(args[0])) {
      const sqDimention = Math.sqrt(args[0].length);
      this.#sqDimention = sqDimention;
      this.matrix = GLMAT_ARRAY_TYPE2.from(args[0]);
    } else if (typeof args[0] === "number") {
      this.#sqDimention = Number(args[0]);
      this.matrix = this.#createIdentityMatrix(args[0]);
    }
    return this;
  }
  get mat3() {
    if (this.#sqDimention === 3) {
      return this.matrix;
    } else {
      return;
    }
  }
  get mat4() {
    if (this.#sqDimention === 4) {
      return this.matrix;
    } else {
      return;
    }
  }
  add(matrix) {
    if (this.matrix.length !== matrix.matrix.length) {
      throw new Error("Matrices must be of the same dimension to add.");
    }
    for (let i = 0;i < this.matrix.length; i++) {
      this.matrix[i] += matrix.matrix[i];
    }
    return this;
  }
  setElement(index, value) {
    if (index >= 0 && index < this.matrix.length) {
      this.matrix[index] = value;
    }
    return this;
  }
  reset() {
    this.matrix = this.#createIdentityMatrix(this.#sqDimention);
    return this;
  }
  set(inMatrix) {
    let refArray = GLMAT_ARRAY_TYPE2.from([...arguments]);
    if (inMatrix instanceof Matrix) {
      refArray = GLMAT_ARRAY_TYPE2.from(inMatrix.matrix);
    } else if (isMatrixArray2(inMatrix)) {
      refArray = GLMAT_ARRAY_TYPE2.from(inMatrix);
    }
    if (refArray.length !== this.matrix.length) {
      p5._friendlyError(`Expected same dimensions values but received different ${refArray.length}.`, "p5.Matrix.set");
      return this;
    }
    this.matrix = refArray;
    return this;
  }
  get() {
    return new Matrix(this.matrix);
  }
  copy() {
    return new Matrix(this.matrix);
  }
  clone() {
    return this.copy();
  }
  diagonal() {
    const diagonal = [];
    for (let i = 0;i < this.#sqDimention; i++) {
      diagonal.push(this.matrix[i * (this.#sqDimention + 1)]);
    }
    return diagonal;
  }
  row(columnIndex) {
    const columnVector = [];
    for (let i = 0;i < this.#sqDimention; i++) {
      columnVector.push(this.matrix[i * this.#sqDimention + columnIndex]);
    }
    return new Vector(...columnVector);
  }
  column(rowIndex) {
    const rowVector = [];
    for (let i = 0;i < this.#sqDimention; i++) {
      rowVector.push(this.matrix[rowIndex * this.#sqDimention + i]);
    }
    return new Vector(...rowVector);
  }
  transpose(a) {
    if (this.#sqDimention === 4) {
      return this.#transpose4x4(a);
    } else if (this.#sqDimention === 3) {
      return this.#transpose3x3(a);
    } else {
      return this.#transposeNxN(a);
    }
  }
  mult(multMatrix) {
    let _src;
    if (multMatrix === this || multMatrix === this.matrix) {
      _src = this.copy().matrix;
    } else if (multMatrix instanceof Matrix) {
      _src = multMatrix.matrix;
    } else if (isMatrixArray2(multMatrix) && isPerfectSquare(multMatrix)) {
      _src = multMatrix;
    } else if (isPerfectSquare(Array.from(arguments))) {
      _src = Array.from(arguments);
    } else
      ;
    if (this.#sqDimention === 4 && _src.length === 16) {
      return this.#mult4x4(_src);
    } else if (this.#sqDimention === 3 && _src.length === 9) {
      return this.#mult3x3(_src);
    } else {
      return this.#multNxN(_src);
    }
  }
  multiplyVec(multVector, target) {
    if (target === undefined) {
      target = multVector.copy();
    }
    for (let i = 0;i < this.#sqDimention; i++) {
      target.values[i] = this.row(i).dot(multVector);
    }
    return target;
  }
  invert(a) {
    if (this.#sqDimention === 4) {
      return this.#invert4x4(a);
    } else if (this.#sqDimention === 3) {
      return this.#invert3x3(a);
    } else {
      throw new Error("Invert is not implemented for N>4 at the moment, we are working on it");
    }
  }
  createSubMatrix3x3() {
    if (this.#sqDimention === 4) {
      const result = new Matrix(3);
      result.mat3[0] = this.matrix[0];
      result.mat3[1] = this.matrix[1];
      result.mat3[2] = this.matrix[2];
      result.mat3[3] = this.matrix[4];
      result.mat3[4] = this.matrix[5];
      result.mat3[5] = this.matrix[6];
      result.mat3[6] = this.matrix[8];
      result.mat3[7] = this.matrix[9];
      result.mat3[8] = this.matrix[10];
      return result;
    } else {
      throw new Error("Matrix dimension must be 4 to create a 3x3 submatrix.");
    }
  }
  inverseTranspose4x4({ mat4 }) {
    if (this.#sqDimention !== 3) {
      throw new Error("This function only works with 33 matrices.");
    } else {
      this.matrix[0] = mat4[0];
      this.matrix[1] = mat4[1];
      this.matrix[2] = mat4[2];
      this.matrix[3] = mat4[4];
      this.matrix[4] = mat4[5];
      this.matrix[5] = mat4[6];
      this.matrix[6] = mat4[8];
      this.matrix[7] = mat4[9];
      this.matrix[8] = mat4[10];
    }
    const inverse = this.invert();
    if (inverse) {
      inverse.transpose(this.matrix);
    } else {
      for (let i = 0;i < 9; i++) {
        this.matrix[i] = 0;
      }
    }
    return this;
  }
  apply(multMatrix) {
    let _src;
    if (multMatrix === this || multMatrix === this.matrix) {
      _src = this.copy().matrix;
    } else if (multMatrix instanceof Matrix) {
      _src = multMatrix.matrix;
    } else if (isMatrixArray2(multMatrix)) {
      _src = multMatrix;
    } else if (arguments.length === 16) {
      _src = arguments;
    } else {
      return;
    }
    const mat4 = this.matrix;
    const m0 = mat4[0];
    const m4 = mat4[4];
    const m8 = mat4[8];
    const m122 = mat4[12];
    mat4[0] = _src[0] * m0 + _src[1] * m4 + _src[2] * m8 + _src[3] * m122;
    mat4[4] = _src[4] * m0 + _src[5] * m4 + _src[6] * m8 + _src[7] * m122;
    mat4[8] = _src[8] * m0 + _src[9] * m4 + _src[10] * m8 + _src[11] * m122;
    mat4[12] = _src[12] * m0 + _src[13] * m4 + _src[14] * m8 + _src[15] * m122;
    const m13 = mat4[1];
    const m5 = mat4[5];
    const m9 = mat4[9];
    const m132 = mat4[13];
    mat4[1] = _src[0] * m13 + _src[1] * m5 + _src[2] * m9 + _src[3] * m132;
    mat4[5] = _src[4] * m13 + _src[5] * m5 + _src[6] * m9 + _src[7] * m132;
    mat4[9] = _src[8] * m13 + _src[9] * m5 + _src[10] * m9 + _src[11] * m132;
    mat4[13] = _src[12] * m13 + _src[13] * m5 + _src[14] * m9 + _src[15] * m132;
    const m22 = mat4[2];
    const m6 = mat4[6];
    const m10 = mat4[10];
    const m14 = mat4[14];
    mat4[2] = _src[0] * m22 + _src[1] * m6 + _src[2] * m10 + _src[3] * m14;
    mat4[6] = _src[4] * m22 + _src[5] * m6 + _src[6] * m10 + _src[7] * m14;
    mat4[10] = _src[8] * m22 + _src[9] * m6 + _src[10] * m10 + _src[11] * m14;
    mat4[14] = _src[12] * m22 + _src[13] * m6 + _src[14] * m10 + _src[15] * m14;
    const m3 = mat4[3];
    const m7 = mat4[7];
    const m11 = mat4[11];
    const m15 = mat4[15];
    mat4[3] = _src[0] * m3 + _src[1] * m7 + _src[2] * m11 + _src[3] * m15;
    mat4[7] = _src[4] * m3 + _src[5] * m7 + _src[6] * m11 + _src[7] * m15;
    mat4[11] = _src[8] * m3 + _src[9] * m7 + _src[10] * m11 + _src[11] * m15;
    mat4[15] = _src[12] * m3 + _src[13] * m7 + _src[14] * m11 + _src[15] * m15;
    return this;
  }
  scale(x, y, z) {
    if (x instanceof Vector) {
      y = x.y;
      z = x.z;
      x = x.x;
    } else if (x instanceof Array) {
      y = x[1];
      z = x[2];
      x = x[0];
    }
    this.matrix[0] *= x;
    this.matrix[1] *= x;
    this.matrix[2] *= x;
    this.matrix[3] *= x;
    this.matrix[4] *= y;
    this.matrix[5] *= y;
    this.matrix[6] *= y;
    this.matrix[7] *= y;
    this.matrix[8] *= z;
    this.matrix[9] *= z;
    this.matrix[10] *= z;
    this.matrix[11] *= z;
    return this;
  }
  rotate4x4(a, x, y, z) {
    if (x instanceof Vector) {
      y = x.y;
      z = x.z;
      x = x.x;
    } else if (x instanceof Array) {
      y = x[1];
      z = x[2];
      x = x[0];
    }
    const len = Math.sqrt(x * x + y * y + z * z);
    x *= 1 / len;
    y *= 1 / len;
    z *= 1 / len;
    const a00 = this.matrix[0];
    const a01 = this.matrix[1];
    const a02 = this.matrix[2];
    const a03 = this.matrix[3];
    const a10 = this.matrix[4];
    const a11 = this.matrix[5];
    const a12 = this.matrix[6];
    const a13 = this.matrix[7];
    const a20 = this.matrix[8];
    const a21 = this.matrix[9];
    const a22 = this.matrix[10];
    const a23 = this.matrix[11];
    const sA = Math.sin(a);
    const cA = Math.cos(a);
    const tA = 1 - cA;
    const b00 = x * x * tA + cA;
    const b01 = y * x * tA + z * sA;
    const b02 = z * x * tA - y * sA;
    const b10 = x * y * tA - z * sA;
    const b11 = y * y * tA + cA;
    const b12 = z * y * tA + x * sA;
    const b20 = x * z * tA + y * sA;
    const b21 = y * z * tA - x * sA;
    const b22 = z * z * tA + cA;
    this.matrix[0] = a00 * b00 + a10 * b01 + a20 * b02;
    this.matrix[1] = a01 * b00 + a11 * b01 + a21 * b02;
    this.matrix[2] = a02 * b00 + a12 * b01 + a22 * b02;
    this.matrix[3] = a03 * b00 + a13 * b01 + a23 * b02;
    this.matrix[4] = a00 * b10 + a10 * b11 + a20 * b12;
    this.matrix[5] = a01 * b10 + a11 * b11 + a21 * b12;
    this.matrix[6] = a02 * b10 + a12 * b11 + a22 * b12;
    this.matrix[7] = a03 * b10 + a13 * b11 + a23 * b12;
    this.matrix[8] = a00 * b20 + a10 * b21 + a20 * b22;
    this.matrix[9] = a01 * b20 + a11 * b21 + a21 * b22;
    this.matrix[10] = a02 * b20 + a12 * b21 + a22 * b22;
    this.matrix[11] = a03 * b20 + a13 * b21 + a23 * b22;
    return this;
  }
  translate(v) {
    const x = v[0], y = v[1], z = v[2] || 0;
    this.matrix[12] += this.matrix[0] * x + this.matrix[4] * y + this.matrix[8] * z;
    this.matrix[13] += this.matrix[1] * x + this.matrix[5] * y + this.matrix[9] * z;
    this.matrix[14] += this.matrix[2] * x + this.matrix[6] * y + this.matrix[10] * z;
    this.matrix[15] += this.matrix[3] * x + this.matrix[7] * y + this.matrix[11] * z;
    return this;
  }
  rotateX(a) {
    this.rotate4x4(a, 1, 0, 0);
  }
  rotateY(a) {
    this.rotate4x4(a, 0, 1, 0);
  }
  rotateZ(a) {
    this.rotate4x4(a, 0, 0, 1);
  }
  perspective(fovy, aspect, near, far) {
    const f = 1 / Math.tan(fovy / 2), nf = 1 / (near - far);
    this.matrix[0] = f / aspect;
    this.matrix[1] = 0;
    this.matrix[2] = 0;
    this.matrix[3] = 0;
    this.matrix[4] = 0;
    this.matrix[5] = f;
    this.matrix[6] = 0;
    this.matrix[7] = 0;
    this.matrix[8] = 0;
    this.matrix[9] = 0;
    this.matrix[10] = (far + near) * nf;
    this.matrix[11] = -1;
    this.matrix[12] = 0;
    this.matrix[13] = 0;
    this.matrix[14] = 2 * far * near * nf;
    this.matrix[15] = 0;
    return this;
  }
  ortho(left, right, bottom, top, near, far) {
    const lr = 1 / (left - right), bt = 1 / (bottom - top), nf = 1 / (near - far);
    this.matrix[0] = -2 * lr;
    this.matrix[1] = 0;
    this.matrix[2] = 0;
    this.matrix[3] = 0;
    this.matrix[4] = 0;
    this.matrix[5] = -2 * bt;
    this.matrix[6] = 0;
    this.matrix[7] = 0;
    this.matrix[8] = 0;
    this.matrix[9] = 0;
    this.matrix[10] = 2 * nf;
    this.matrix[11] = 0;
    this.matrix[12] = (left + right) * lr;
    this.matrix[13] = (top + bottom) * bt;
    this.matrix[14] = (far + near) * nf;
    this.matrix[15] = 1;
    return this;
  }
  multiplyVec4(x, y, z, w) {
    const result = new Array(4);
    const m = this.matrix;
    result[0] = m[0] * x + m[4] * y + m[8] * z + m[12] * w;
    result[1] = m[1] * x + m[5] * y + m[9] * z + m[13] * w;
    result[2] = m[2] * x + m[6] * y + m[10] * z + m[14] * w;
    result[3] = m[3] * x + m[7] * y + m[11] * z + m[15] * w;
    return result;
  }
  multiplyPoint({ x, y, z }) {
    const array = this.multiplyVec4(x, y, z, 1);
    return new Vector(array[0], array[1], array[2]);
  }
  multiplyAndNormalizePoint({ x, y, z }) {
    const array = this.multiplyVec4(x, y, z, 1);
    array[0] /= array[3];
    array[1] /= array[3];
    array[2] /= array[3];
    return new Vector(array[0], array[1], array[2]);
  }
  multiplyDirection({ x, y, z }) {
    const array = this.multiplyVec4(x, y, z, 0);
    return new Vector(array[0], array[1], array[2]);
  }
  multiplyVec3(multVector, target) {
    if (target === undefined) {
      target = multVector.copy();
    }
    target.x = this.row(0).dot(multVector);
    target.y = this.row(1).dot(multVector);
    target.z = this.row(2).dot(multVector);
    return target;
  }
  #createIdentityMatrix(dimension) {
    if (dimension === 3)
      return new GLMAT_ARRAY_TYPE2([1, 0, 0, 0, 1, 0, 0, 0, 1]);
    if (dimension === 4)
      return new GLMAT_ARRAY_TYPE2([
        1,
        0,
        0,
        0,
        0,
        1,
        0,
        0,
        0,
        0,
        1,
        0,
        0,
        0,
        0,
        1
      ]);
    const identityMatrix = new GLMAT_ARRAY_TYPE2(dimension * dimension).fill(0);
    for (let i = 0;i < dimension; i++) {
      identityMatrix[i * dimension + i] = 1;
    }
    return identityMatrix;
  }
  #mult4x4(_src) {
    let b0 = this.matrix[0], b1 = this.matrix[1], b2 = this.matrix[2], b3 = this.matrix[3];
    this.matrix[0] = b0 * _src[0] + b1 * _src[4] + b2 * _src[8] + b3 * _src[12];
    this.matrix[1] = b0 * _src[1] + b1 * _src[5] + b2 * _src[9] + b3 * _src[13];
    this.matrix[2] = b0 * _src[2] + b1 * _src[6] + b2 * _src[10] + b3 * _src[14];
    this.matrix[3] = b0 * _src[3] + b1 * _src[7] + b2 * _src[11] + b3 * _src[15];
    b0 = this.matrix[4];
    b1 = this.matrix[5];
    b2 = this.matrix[6];
    b3 = this.matrix[7];
    this.matrix[4] = b0 * _src[0] + b1 * _src[4] + b2 * _src[8] + b3 * _src[12];
    this.matrix[5] = b0 * _src[1] + b1 * _src[5] + b2 * _src[9] + b3 * _src[13];
    this.matrix[6] = b0 * _src[2] + b1 * _src[6] + b2 * _src[10] + b3 * _src[14];
    this.matrix[7] = b0 * _src[3] + b1 * _src[7] + b2 * _src[11] + b3 * _src[15];
    b0 = this.matrix[8];
    b1 = this.matrix[9];
    b2 = this.matrix[10];
    b3 = this.matrix[11];
    this.matrix[8] = b0 * _src[0] + b1 * _src[4] + b2 * _src[8] + b3 * _src[12];
    this.matrix[9] = b0 * _src[1] + b1 * _src[5] + b2 * _src[9] + b3 * _src[13];
    this.matrix[10] = b0 * _src[2] + b1 * _src[6] + b2 * _src[10] + b3 * _src[14];
    this.matrix[11] = b0 * _src[3] + b1 * _src[7] + b2 * _src[11] + b3 * _src[15];
    b0 = this.matrix[12];
    b1 = this.matrix[13];
    b2 = this.matrix[14];
    b3 = this.matrix[15];
    this.matrix[12] = b0 * _src[0] + b1 * _src[4] + b2 * _src[8] + b3 * _src[12];
    this.matrix[13] = b0 * _src[1] + b1 * _src[5] + b2 * _src[9] + b3 * _src[13];
    this.matrix[14] = b0 * _src[2] + b1 * _src[6] + b2 * _src[10] + b3 * _src[14];
    this.matrix[15] = b0 * _src[3] + b1 * _src[7] + b2 * _src[11] + b3 * _src[15];
    return this;
  }
  #multNxN(multMatrix) {
    if (multMatrix.length !== this.matrix.length) {
      throw new Error("Matrices must be of the same dimension to multiply.");
    }
    const result = new GLMAT_ARRAY_TYPE2(this.matrix.length).fill(0);
    for (let i = 0;i < this.#sqDimention; i++) {
      for (let j = 0;j < this.#sqDimention; j++) {
        for (let k = 0;k < this.#sqDimention; k++) {
          result[i * this.#sqDimention + j] += this.matrix[i * this.#sqDimention + k] * multMatrix[k * this.#sqDimention + j];
        }
      }
    }
    this.matrix = result;
    return this;
  }
  #mult3x3(_src) {
    let b0 = this.mat3[0];
    let b1 = this.mat3[1];
    let b2 = this.mat3[2];
    this.mat3[0] = b0 * _src[0] + b1 * _src[3] + b2 * _src[6];
    this.mat3[1] = b0 * _src[1] + b1 * _src[4] + b2 * _src[7];
    this.mat3[2] = b0 * _src[2] + b1 * _src[5] + b2 * _src[8];
    b0 = this.mat3[3];
    b1 = this.mat3[4];
    b2 = this.mat3[5];
    this.mat3[3] = b0 * _src[0] + b1 * _src[3] + b2 * _src[6];
    this.mat3[4] = b0 * _src[1] + b1 * _src[4] + b2 * _src[7];
    this.mat3[5] = b0 * _src[2] + b1 * _src[5] + b2 * _src[8];
    b0 = this.mat3[6];
    b1 = this.mat3[7];
    b2 = this.mat3[8];
    this.mat3[6] = b0 * _src[0] + b1 * _src[3] + b2 * _src[6];
    this.mat3[7] = b0 * _src[1] + b1 * _src[4] + b2 * _src[7];
    this.mat3[8] = b0 * _src[2] + b1 * _src[5] + b2 * _src[8];
    return this;
  }
  #transposeNxN() {
    const n2 = this.#sqDimention;
    for (let i = 0;i < n2; i++) {
      for (let j = 0;j < n2; j++) {
        this.matrix[i * n2 + j] = this.matrix[j * n2 + i];
      }
    }
    return this;
  }
  #transpose4x4(a) {
    console.log("====> 4x4");
    let a01, a02, a03, a12, a13, a23;
    if (a instanceof Matrix) {
      a01 = a.matrix[1];
      a02 = a.matrix[2];
      a03 = a.matrix[3];
      a12 = a.matrix[6];
      a13 = a.matrix[7];
      a23 = a.matrix[11];
      this.matrix[0] = a.matrix[0];
      this.matrix[1] = a.matrix[4];
      this.matrix[2] = a.matrix[8];
      this.matrix[3] = a.matrix[12];
      this.matrix[4] = a01;
      this.matrix[5] = a.matrix[5];
      this.matrix[6] = a.matrix[9];
      this.matrix[7] = a.matrix[13];
      this.matrix[8] = a02;
      this.matrix[9] = a12;
      this.matrix[10] = a.matrix[10];
      this.matrix[11] = a.matrix[14];
      this.matrix[12] = a03;
      this.matrix[13] = a13;
      this.matrix[14] = a23;
      this.matrix[15] = a.matrix[15];
    } else if (isMatrixArray2(a)) {
      a01 = a[1];
      a02 = a[2];
      a03 = a[3];
      a12 = a[6];
      a13 = a[7];
      a23 = a[11];
      this.matrix[0] = a[0];
      this.matrix[1] = a[4];
      this.matrix[2] = a[8];
      this.matrix[3] = a[12];
      this.matrix[4] = a01;
      this.matrix[5] = a[5];
      this.matrix[6] = a[9];
      this.matrix[7] = a[13];
      this.matrix[8] = a02;
      this.matrix[9] = a12;
      this.matrix[10] = a[10];
      this.matrix[11] = a[14];
      this.matrix[12] = a03;
      this.matrix[13] = a13;
      this.matrix[14] = a23;
      this.matrix[15] = a[15];
    }
    return this;
  }
  #transpose3x3(mat3) {
    if (mat3 === undefined) {
      mat3 = this.mat3;
    }
    const a01 = mat3[1];
    const a02 = mat3[2];
    const a12 = mat3[5];
    this.mat3[0] = mat3[0];
    this.mat3[1] = mat3[3];
    this.mat3[2] = mat3[6];
    this.mat3[3] = a01;
    this.mat3[4] = mat3[4];
    this.mat3[5] = mat3[7];
    this.mat3[6] = a02;
    this.mat3[7] = a12;
    this.mat3[8] = mat3[8];
    return this;
  }
  #invert4x4(a) {
    let a00, a01, a02, a03, a10, a11, a12, a13;
    let a20, a21, a22, a23, a30, a31, a32, a33;
    if (a instanceof Matrix) {
      a00 = a.matrix[0];
      a01 = a.matrix[1];
      a02 = a.matrix[2];
      a03 = a.matrix[3];
      a10 = a.matrix[4];
      a11 = a.matrix[5];
      a12 = a.matrix[6];
      a13 = a.matrix[7];
      a20 = a.matrix[8];
      a21 = a.matrix[9];
      a22 = a.matrix[10];
      a23 = a.matrix[11];
      a30 = a.matrix[12];
      a31 = a.matrix[13];
      a32 = a.matrix[14];
      a33 = a.matrix[15];
    } else if (isMatrixArray2(a)) {
      a00 = a[0];
      a01 = a[1];
      a02 = a[2];
      a03 = a[3];
      a10 = a[4];
      a11 = a[5];
      a12 = a[6];
      a13 = a[7];
      a20 = a[8];
      a21 = a[9];
      a22 = a[10];
      a23 = a[11];
      a30 = a[12];
      a31 = a[13];
      a32 = a[14];
      a33 = a[15];
    }
    const b00 = a00 * a11 - a01 * a10;
    const b01 = a00 * a12 - a02 * a10;
    const b02 = a00 * a13 - a03 * a10;
    const b03 = a01 * a12 - a02 * a11;
    const b04 = a01 * a13 - a03 * a11;
    const b05 = a02 * a13 - a03 * a12;
    const b06 = a20 * a31 - a21 * a30;
    const b07 = a20 * a32 - a22 * a30;
    const b08 = a20 * a33 - a23 * a30;
    const b09 = a21 * a32 - a22 * a31;
    const b10 = a21 * a33 - a23 * a31;
    const b11 = a22 * a33 - a23 * a32;
    let det = b00 * b11 - b01 * b10 + b02 * b09 + b03 * b08 - b04 * b07 + b05 * b06;
    if (!det) {
      return null;
    }
    det = 1 / det;
    this.matrix[0] = (a11 * b11 - a12 * b10 + a13 * b09) * det;
    this.matrix[1] = (a02 * b10 - a01 * b11 - a03 * b09) * det;
    this.matrix[2] = (a31 * b05 - a32 * b04 + a33 * b03) * det;
    this.matrix[3] = (a22 * b04 - a21 * b05 - a23 * b03) * det;
    this.matrix[4] = (a12 * b08 - a10 * b11 - a13 * b07) * det;
    this.matrix[5] = (a00 * b11 - a02 * b08 + a03 * b07) * det;
    this.matrix[6] = (a32 * b02 - a30 * b05 - a33 * b01) * det;
    this.matrix[7] = (a20 * b05 - a22 * b02 + a23 * b01) * det;
    this.matrix[8] = (a10 * b10 - a11 * b08 + a13 * b06) * det;
    this.matrix[9] = (a01 * b08 - a00 * b10 - a03 * b06) * det;
    this.matrix[10] = (a30 * b04 - a31 * b02 + a33 * b00) * det;
    this.matrix[11] = (a21 * b02 - a20 * b04 - a23 * b00) * det;
    this.matrix[12] = (a11 * b07 - a10 * b09 - a12 * b06) * det;
    this.matrix[13] = (a00 * b09 - a01 * b07 + a02 * b06) * det;
    this.matrix[14] = (a31 * b01 - a30 * b03 - a32 * b00) * det;
    this.matrix[15] = (a20 * b03 - a21 * b01 + a22 * b00) * det;
    return this;
  }
  #invert3x3() {
    const a00 = this.mat3[0];
    const a01 = this.mat3[1];
    const a02 = this.mat3[2];
    const a10 = this.mat3[3];
    const a11 = this.mat3[4];
    const a12 = this.mat3[5];
    const a20 = this.mat3[6];
    const a21 = this.mat3[7];
    const a22 = this.mat3[8];
    const b01 = a22 * a11 - a12 * a21;
    const b11 = -a22 * a10 + a12 * a20;
    const b21 = a21 * a10 - a11 * a20;
    let det = a00 * b01 + a01 * b11 + a02 * b21;
    if (!det) {
      return null;
    }
    det = 1 / det;
    this.mat3[0] = b01 * det;
    this.mat3[1] = (-a22 * a01 + a02 * a21) * det;
    this.mat3[2] = (a12 * a01 - a02 * a11) * det;
    this.mat3[3] = b11 * det;
    this.mat3[4] = (a22 * a00 - a02 * a20) * det;
    this.mat3[5] = (-a12 * a00 + a02 * a10) * det;
    this.mat3[6] = b21 * det;
    this.mat3[7] = (-a21 * a00 + a01 * a20) * det;
    this.mat3[8] = (a11 * a00 - a01 * a10) * det;
    return this;
  }
  #determinant4x4() {
    if (this.#sqDimention !== 4) {
      throw new Error("Determinant is only implemented for 4x4 matrices. We are working on it.");
    }
    const d00 = this.matrix[0] * this.matrix[5] - this.matrix[1] * this.matrix[4], d01 = this.matrix[0] * this.matrix[6] - this.matrix[2] * this.matrix[4], d02 = this.matrix[0] * this.matrix[7] - this.matrix[3] * this.matrix[4], d03 = this.matrix[1] * this.matrix[6] - this.matrix[2] * this.matrix[5], d04 = this.matrix[1] * this.matrix[7] - this.matrix[3] * this.matrix[5], d05 = this.matrix[2] * this.matrix[7] - this.matrix[3] * this.matrix[6], d06 = this.matrix[8] * this.matrix[13] - this.matrix[9] * this.matrix[12], d07 = this.matrix[8] * this.matrix[14] - this.matrix[10] * this.matrix[12], d08 = this.matrix[8] * this.matrix[15] - this.matrix[11] * this.matrix[12], d09 = this.matrix[9] * this.matrix[14] - this.matrix[10] * this.matrix[13], d10 = this.matrix[9] * this.matrix[15] - this.matrix[11] * this.matrix[13], d11 = this.matrix[10] * this.matrix[15] - this.matrix[11] * this.matrix[14];
    return d00 * d11 - d01 * d10 + d02 * d09 + d03 * d08 - d04 * d07 + d05 * d06;
  }
}

// node_modules/p5/dist/math/p5.Matrix.js
function matrix(p52, fn2) {
  p52.Matrix = Matrix;
}
if (typeof p5 !== "undefined") {
  matrix(p5, p5.prototype);
}

// node_modules/p5/dist/webgl/p5.DataArray.js
class DataArray {
  constructor(initialLength = 128) {
    this.length = 0;
    this.data = new Float32Array(initialLength);
    this.initialLength = initialLength;
  }
  dataArray() {
    return this.subArray(0, this.length);
  }
  clear() {
    this.length = 0;
  }
  rescale() {
    if (this.length < this.data.length / 2) {
      const targetLength = 1 << Math.ceil(Math.log2(this.length));
      const newData = new Float32Array(targetLength);
      newData.set(this.data.subarray(0, this.length), 0);
      this.data = newData;
    }
  }
  reset() {
    this.clear();
    this.data = new Float32Array(this.initialLength);
  }
  push(...values) {
    this.ensureLength(this.length + values.length);
    this.data.set(values, this.length);
    this.length += values.length;
  }
  slice(from, to2) {
    return this.data.slice(from, Math.min(to2, this.length));
  }
  subArray(from, to2) {
    return this.data.subarray(from, Math.min(to2, this.length));
  }
  ensureLength(target) {
    while (this.data.length < target) {
      const newData = new Float32Array(this.data.length * 2);
      newData.set(this.data, 0);
      this.data = newData;
    }
  }
}
function dataArray(p52, fn2) {
  p52.DataArray = DataArray;
}
if (typeof p5 !== "undefined") {
  dataArray(p5, p5.prototype);
}

// node_modules/p5/dist/webgl/p5.Geometry.js
var import_file_saver = __toESM(require_FileSaver(), 1);

class Geometry {
  constructor(detailX, detailY, callback, renderer2) {
    this.renderer = renderer2;
    this.vertices = [];
    this.boundingBoxCache = null;
    this.lineVertices = new DataArray;
    this.lineTangentsIn = new DataArray;
    this.lineTangentsOut = new DataArray;
    this.lineSides = new DataArray;
    this.vertexNormals = [];
    this.faces = [];
    this.uvs = [];
    this.edges = [];
    this.vertexColors = [];
    this.vertexStrokeColors = [];
    this.userVertexProperties = {};
    this.lineVertexColors = new DataArray;
    this.detailX = detailX !== undefined ? detailX : 1;
    this.detailY = detailY !== undefined ? detailY : 1;
    this.dirtyFlags = {};
    this._hasFillTransparency = undefined;
    this._hasStrokeTransparency = undefined;
    this.gid = `_p5_Geometry_${Geometry.nextId}`;
    Geometry.nextId++;
    if (callback instanceof Function) {
      callback.call(this);
    }
  }
  calculateBoundingBox() {
    if (this.boundingBoxCache) {
      return this.boundingBoxCache;
    }
    let minVertex = new Vector(Number.MAX_VALUE, Number.MAX_VALUE, Number.MAX_VALUE);
    let maxVertex = new Vector(Number.MIN_VALUE, Number.MIN_VALUE, Number.MIN_VALUE);
    for (let i = 0;i < this.vertices.length; i++) {
      let vertex2 = this.vertices[i];
      minVertex.x = Math.min(minVertex.x, vertex2.x);
      minVertex.y = Math.min(minVertex.y, vertex2.y);
      minVertex.z = Math.min(minVertex.z, vertex2.z);
      maxVertex.x = Math.max(maxVertex.x, vertex2.x);
      maxVertex.y = Math.max(maxVertex.y, vertex2.y);
      maxVertex.z = Math.max(maxVertex.z, vertex2.z);
    }
    let size = new Vector(maxVertex.x - minVertex.x, maxVertex.y - minVertex.y, maxVertex.z - minVertex.z);
    let offset = new Vector((minVertex.x + maxVertex.x) / 2, (minVertex.y + maxVertex.y) / 2, (minVertex.z + maxVertex.z) / 2);
    this.boundingBoxCache = {
      min: minVertex,
      max: maxVertex,
      size,
      offset
    };
    return this.boundingBoxCache;
  }
  reset() {
    this._hasFillTransparency = undefined;
    this._hasStrokeTransparency = undefined;
    this.lineVertices.clear();
    this.lineTangentsIn.clear();
    this.lineTangentsOut.clear();
    this.lineSides.clear();
    this.vertices.length = 0;
    this.edges.length = 0;
    this.vertexColors.length = 0;
    this.vertexStrokeColors.length = 0;
    this.lineVertexColors.clear();
    this.vertexNormals.length = 0;
    this.uvs.length = 0;
    for (const propName in this.userVertexProperties) {
      this.userVertexProperties[propName].delete();
    }
    this.userVertexProperties = {};
    this.dirtyFlags = {};
  }
  hasFillTransparency() {
    if (this._hasFillTransparency === undefined) {
      this._hasFillTransparency = false;
      for (let i = 0;i < this.vertexColors.length; i += 4) {
        if (this.vertexColors[i + 3] < 1) {
          this._hasFillTransparency = true;
          break;
        }
      }
    }
    return this._hasFillTransparency;
  }
  hasStrokeTransparency() {
    if (this._hasStrokeTransparency === undefined) {
      this._hasStrokeTransparency = false;
      for (let i = 0;i < this.lineVertexColors.length; i += 4) {
        if (this.lineVertexColors[i + 3] < 1) {
          this._hasStrokeTransparency = true;
          break;
        }
      }
    }
    return this._hasStrokeTransparency;
  }
  clearColors() {
    this.vertexColors = [];
    return this;
  }
  saveObj(fileName = "model.obj") {
    let objStr = "";
    this.vertices.forEach((v) => {
      objStr += `v ${v.x} ${v.y} ${v.z}
`;
    });
    if (this.uvs && this.uvs.length > 0) {
      for (let i = 0;i < this.uvs.length; i += 2) {
        objStr += `vt ${this.uvs[i]} ${this.uvs[i + 1]}
`;
      }
    }
    if (this.vertexNormals && this.vertexNormals.length > 0) {
      this.vertexNormals.forEach((n2) => {
        objStr += `vn ${n2.x} ${n2.y} ${n2.z}
`;
      });
    }
    this.faces.forEach((face) => {
      let faceStr = "f";
      face.forEach((index) => {
        faceStr += " ";
        faceStr += index + 1;
        if (this.vertexNormals.length > 0 || this.uvs.length > 0) {
          faceStr += "/";
          if (this.uvs.length > 0) {
            faceStr += index + 1;
          }
          faceStr += "/";
          if (this.vertexNormals.length > 0) {
            faceStr += index + 1;
          }
        }
      });
      objStr += faceStr + `
`;
    });
    const blob = new Blob([objStr], { type: "text/plain" });
    downloadFile(blob, fileName, "obj");
  }
  saveStl(fileName = "model.stl", { binary = false } = {}) {
    let modelOutput;
    let name = fileName.substring(0, fileName.lastIndexOf("."));
    let faceNormals = [];
    for (let f of this.faces) {
      const U = Vector.sub(this.vertices[f[1]], this.vertices[f[0]]);
      const V = Vector.sub(this.vertices[f[2]], this.vertices[f[0]]);
      const nx = U.y * V.z - U.z * V.y;
      const ny = U.z * V.x - U.x * V.z;
      const nz = U.x * V.y - U.y * V.x;
      faceNormals.push(new Vector(nx, ny, nz).normalize());
    }
    if (binary) {
      let offset = 80;
      const bufferLength = this.faces.length * 2 + this.faces.length * 3 * 4 * 4 + 80 + 4;
      const arrayBuffer = new ArrayBuffer(bufferLength);
      modelOutput = new DataView(arrayBuffer);
      modelOutput.setUint32(offset, this.faces.length, true);
      offset += 4;
      for (const [key, f] of Object.entries(this.faces)) {
        const norm = faceNormals[key];
        modelOutput.setFloat32(offset, norm.x, true);
        offset += 4;
        modelOutput.setFloat32(offset, norm.y, true);
        offset += 4;
        modelOutput.setFloat32(offset, norm.z, true);
        offset += 4;
        for (let vertexIndex of f) {
          const vert = this.vertices[vertexIndex];
          modelOutput.setFloat32(offset, vert.x, true);
          offset += 4;
          modelOutput.setFloat32(offset, vert.y, true);
          offset += 4;
          modelOutput.setFloat32(offset, vert.z, true);
          offset += 4;
        }
        modelOutput.setUint16(offset, 0, true);
        offset += 2;
      }
    } else {
      modelOutput = "solid " + name + `
`;
      for (const [key, f] of Object.entries(this.faces)) {
        const norm = faceNormals[key];
        modelOutput += " facet norm " + norm.x + " " + norm.y + " " + norm.z + `
`;
        modelOutput += "  outer loop" + `
`;
        for (let vertexIndex of f) {
          const vert = this.vertices[vertexIndex];
          modelOutput += "   vertex " + vert.x + " " + vert.y + " " + vert.z + `
`;
        }
        modelOutput += "  endloop" + `
`;
        modelOutput += " endfacet" + `
`;
      }
      modelOutput += "endsolid " + name + `
`;
    }
    const blob = new Blob([modelOutput], { type: "text/plain" });
    downloadFile(blob, fileName, "stl");
  }
  flipU() {
    this.uvs = this.uvs.flat().map((val, index) => {
      if (index % 2 === 0) {
        return 1 - val;
      } else {
        return val;
      }
    });
  }
  flipV() {
    this.uvs = this.uvs.flat().map((val, index) => {
      if (index % 2 === 0) {
        return val;
      } else {
        return 1 - val;
      }
    });
  }
  computeFaces() {
    this.faces.length = 0;
    const sliceCount = this.detailX + 1;
    let a, b2, c, d2;
    for (let i = 0;i < this.detailY; i++) {
      for (let j = 0;j < this.detailX; j++) {
        a = i * sliceCount + j;
        b2 = i * sliceCount + j + 1;
        c = (i + 1) * sliceCount + j + 1;
        d2 = (i + 1) * sliceCount + j;
        this.faces.push([a, b2, d2]);
        this.faces.push([d2, b2, c]);
      }
    }
    return this;
  }
  _getFaceNormal(faceId) {
    const face = this.faces[faceId];
    const vA = this.vertices[face[0]];
    const vB = this.vertices[face[1]];
    const vC = this.vertices[face[2]];
    const ab = Vector.sub(vB, vA);
    const ac = Vector.sub(vC, vA);
    const n2 = Vector.cross(ab, ac);
    const ln = Vector.mag(n2);
    let sinAlpha = ln / (Vector.mag(ab) * Vector.mag(ac));
    if (sinAlpha === 0 || isNaN(sinAlpha)) {
      console.warn("p5.Geometry.prototype._getFaceNormal:", "face has colinear sides or a repeated vertex");
      return n2;
    }
    if (sinAlpha > 1)
      sinAlpha = 1;
    return n2.mult(Math.asin(sinAlpha) / ln);
  }
  computeNormals(shadingType = FLAT, { roundToPrecision = 3 } = {}) {
    const vertexNormals = this.vertexNormals;
    let vertices = this.vertices;
    const faces = this.faces;
    let iv;
    if (shadingType === SMOOTH) {
      const vertexIndices = {};
      const uniqueVertices = [];
      const power = Math.pow(10, roundToPrecision);
      const rounded = (val) => Math.round(val * power) / power;
      const getKey = (vert) => `${rounded(vert.x)},${rounded(vert.y)},${rounded(vert.z)}`;
      for (let i = 0;i < vertices.length; i++) {
        const vertex2 = vertices[i];
        const key = getKey(vertex2);
        if (vertexIndices[key] === undefined) {
          vertexIndices[key] = uniqueVertices.length;
          uniqueVertices.push(vertex2);
        }
      }
      faces.forEach((face) => {
        for (let fv = 0;fv < 3; ++fv) {
          const originalVertexIndex = face[fv];
          const originalVertex = vertices[originalVertexIndex];
          const key = getKey(originalVertex);
          face[fv] = vertexIndices[key];
        }
      });
      this.edges.forEach((edge) => {
        for (let ev = 0;ev < 2; ++ev) {
          const originalVertexIndex = edge[ev];
          const originalVertex = vertices[originalVertexIndex];
          const key = getKey(originalVertex);
          edge[ev] = vertexIndices[key];
        }
      });
      this.vertices = vertices = uniqueVertices;
    }
    vertexNormals.length = 0;
    for (iv = 0;iv < vertices.length; ++iv) {
      vertexNormals.push(new Vector);
    }
    faces.forEach((face, f) => {
      const faceNormal = this._getFaceNormal(f);
      for (let fv = 0;fv < 3; ++fv) {
        const vertexIndex = face[fv];
        vertexNormals[vertexIndex].add(faceNormal);
      }
    });
    for (iv = 0;iv < vertices.length; ++iv) {
      vertexNormals[iv].normalize();
    }
    return this;
  }
  averageNormals() {
    for (let i = 0;i <= this.detailY; i++) {
      const offset = this.detailX + 1;
      let temp = Vector.add(this.vertexNormals[i * offset], this.vertexNormals[i * offset + this.detailX]);
      temp = Vector.div(temp, 2);
      this.vertexNormals[i * offset] = temp;
      this.vertexNormals[i * offset + this.detailX] = temp;
    }
    return this;
  }
  averagePoleNormals() {
    let sum = new Vector(0, 0, 0);
    for (let i = 0;i < this.detailX; i++) {
      sum.add(this.vertexNormals[i]);
    }
    sum = Vector.div(sum, this.detailX);
    for (let i = 0;i < this.detailX; i++) {
      this.vertexNormals[i] = sum;
    }
    sum = new Vector(0, 0, 0);
    for (let i = this.vertices.length - 1;i > this.vertices.length - 1 - this.detailX; i--) {
      sum.add(this.vertexNormals[i]);
    }
    sum = Vector.div(sum, this.detailX);
    for (let i = this.vertices.length - 1;i > this.vertices.length - 1 - this.detailX; i--) {
      this.vertexNormals[i] = sum;
    }
    return this;
  }
  _makeTriangleEdges() {
    this.edges.length = 0;
    for (let j = 0;j < this.faces.length; j++) {
      this.edges.push([this.faces[j][0], this.faces[j][1]]);
      this.edges.push([this.faces[j][1], this.faces[j][2]]);
      this.edges.push([this.faces[j][2], this.faces[j][0]]);
    }
    return this;
  }
  makeEdgesFromFaces() {
    this._makeTriangleEdges();
  }
  _edgesToVertices() {
    this.lineVertices.clear();
    this.lineTangentsIn.clear();
    this.lineTangentsOut.clear();
    this.lineSides.clear();
    const potentialCaps = new Map;
    const connected = new Set;
    let lastValidDir;
    for (let i = 0;i < this.edges.length; i++) {
      const prevEdge = this.edges[i - 1];
      const currEdge = this.edges[i];
      const begin = this.vertices[currEdge[0]];
      const end = this.vertices[currEdge[1]];
      const prevColor = this.vertexStrokeColors.length > 0 && prevEdge ? this.vertexStrokeColors.slice(prevEdge[1] * 4, (prevEdge[1] + 1) * 4) : [0, 0, 0, 0];
      const fromColor = this.vertexStrokeColors.length > 0 ? this.vertexStrokeColors.slice(currEdge[0] * 4, (currEdge[0] + 1) * 4) : [0, 0, 0, 0];
      const toColor = this.vertexStrokeColors.length > 0 ? this.vertexStrokeColors.slice(currEdge[1] * 4, (currEdge[1] + 1) * 4) : [0, 0, 0, 0];
      const dir = end.copy().sub(begin).normalize();
      const dirOK = dir.magSq() > 0;
      if (dirOK) {
        this._addSegment(begin, end, fromColor, toColor, dir);
      }
      if (!this.renderer?._simpleLines) {
        if (i > 0 && prevEdge[1] === currEdge[0]) {
          if (!connected.has(currEdge[0])) {
            connected.add(currEdge[0]);
            potentialCaps.delete(currEdge[0]);
            if (lastValidDir && dirOK && dir.dot(lastValidDir) < 1 - 0.00000001) {
              this._addJoin(begin, lastValidDir, dir, fromColor);
            }
          }
        } else {
          if (dirOK && !connected.has(currEdge[0])) {
            const existingCap = potentialCaps.get(currEdge[0]);
            if (existingCap) {
              this._addJoin(begin, existingCap.dir, dir, fromColor);
              potentialCaps.delete(currEdge[0]);
              connected.add(currEdge[0]);
            } else {
              potentialCaps.set(currEdge[0], {
                point: begin,
                dir: dir.copy().mult(-1),
                color: fromColor
              });
            }
          }
          if (lastValidDir && !connected.has(prevEdge[1])) {
            const existingCap = potentialCaps.get(prevEdge[1]);
            if (existingCap) {
              this._addJoin(this.vertices[prevEdge[1]], lastValidDir, existingCap.dir.copy().mult(-1), prevColor);
              potentialCaps.delete(prevEdge[1]);
              connected.add(prevEdge[1]);
            } else {
              potentialCaps.set(prevEdge[1], {
                point: this.vertices[prevEdge[1]],
                dir: lastValidDir,
                color: prevColor
              });
            }
            lastValidDir = undefined;
          }
        }
        if (i === this.edges.length - 1 && !connected.has(currEdge[1])) {
          const existingCap = potentialCaps.get(currEdge[1]);
          if (existingCap) {
            this._addJoin(end, dir, existingCap.dir.copy().mult(-1), toColor);
            potentialCaps.delete(currEdge[1]);
            connected.add(currEdge[1]);
          } else {
            potentialCaps.set(currEdge[1], {
              point: end,
              dir,
              color: toColor
            });
          }
        }
        if (dirOK) {
          lastValidDir = dir;
        }
      }
    }
    for (const { point, dir, color: color2 } of potentialCaps.values()) {
      this._addCap(point, dir, color2);
    }
    return this;
  }
  _addSegment(begin, end, fromColor, toColor, dir) {
    const a = begin.array();
    const b2 = end.array();
    const dirArr = dir.array();
    this.lineSides.push(1, 1, -1, 1, -1, -1);
    for (const tangents of [this.lineTangentsIn, this.lineTangentsOut]) {
      for (let i = 0;i < 6; i++) {
        tangents.push(...dirArr);
      }
    }
    this.lineVertices.push(...a, ...b2, ...a, ...b2, ...b2, ...a);
    if (!this.renderer?._simpleLines) {
      this.lineVertexColors.push(...fromColor, ...toColor, ...fromColor, ...toColor, ...toColor, ...fromColor);
    }
    return this;
  }
  _addCap(point, tangent, color2) {
    const ptArray = point.array();
    const tanInArray = tangent.array();
    const tanOutArray = [0, 0, 0];
    for (let i = 0;i < 6; i++) {
      this.lineVertices.push(...ptArray);
      this.lineTangentsIn.push(...tanInArray);
      this.lineTangentsOut.push(...tanOutArray);
      this.lineVertexColors.push(...color2);
    }
    this.lineSides.push(-1, 2, -2, 1, 2, -1);
    return this;
  }
  _addJoin(point, fromTangent, toTangent, color2) {
    const ptArray = point.array();
    const tanInArray = fromTangent.array();
    const tanOutArray = toTangent.array();
    for (let i = 0;i < 12; i++) {
      this.lineVertices.push(...ptArray);
      this.lineTangentsIn.push(...tanInArray);
      this.lineTangentsOut.push(...tanOutArray);
      this.lineVertexColors.push(...color2);
    }
    this.lineSides.push(-1, -3, -2, -1, 0, -3);
    this.lineSides.push(3, 1, 2, 3, 0, 1);
    return this;
  }
  normalize() {
    if (this.vertices.length > 0) {
      const maxPosition = this.vertices[0].copy();
      const minPosition = this.vertices[0].copy();
      for (let i = 0;i < this.vertices.length; i++) {
        maxPosition.x = Math.max(maxPosition.x, this.vertices[i].x);
        minPosition.x = Math.min(minPosition.x, this.vertices[i].x);
        maxPosition.y = Math.max(maxPosition.y, this.vertices[i].y);
        minPosition.y = Math.min(minPosition.y, this.vertices[i].y);
        maxPosition.z = Math.max(maxPosition.z, this.vertices[i].z);
        minPosition.z = Math.min(minPosition.z, this.vertices[i].z);
      }
      const center = Vector.lerp(maxPosition, minPosition, 0.5);
      const dist = Vector.sub(maxPosition, minPosition);
      const longestDist = Math.max(Math.max(dist.x, dist.y), dist.z);
      const scale = 200 / longestDist;
      for (let i = 0;i < this.vertices.length; i++) {
        this.vertices[i].sub(center);
        this.vertices[i].mult(scale);
      }
    }
    return this;
  }
  vertexProperty(propertyName, data, size) {
    let prop;
    if (!this.userVertexProperties[propertyName]) {
      prop = this.userVertexProperties[propertyName] = this._userVertexPropertyHelper(propertyName, data, size);
    }
    prop = this.userVertexProperties[propertyName];
    if (size) {
      prop.pushDirect(data);
    } else {
      prop.setCurrentData(data);
      prop.pushCurrentData();
    }
  }
  _userVertexPropertyHelper(propertyName, data, size) {
    const geometryInstance = this;
    const prop = this.userVertexProperties[propertyName] = {
      name: propertyName,
      dataSize: size ? size : data.length ? data.length : 1,
      geometry: geometryInstance,
      getName() {
        return this.name;
      },
      getCurrentData() {
        if (this.currentData === undefined) {
          this.currentData = new Array(this.getDataSize()).fill(0);
        }
        return this.currentData;
      },
      getDataSize() {
        return this.dataSize;
      },
      getSrcName() {
        const src = this.name.concat("Src");
        return src;
      },
      getDstName() {
        const dst = this.name.concat("Buffer");
        return dst;
      },
      getSrcArray() {
        const srcName = this.getSrcName();
        return this.geometry[srcName];
      },
      setCurrentData(data2) {
        data2.length && data2.length;
        this.currentData = data2;
      },
      pushCurrentData() {
        const data2 = this.getCurrentData();
        this.pushDirect(data2);
      },
      pushDirect(data2) {
        if (data2.length) {
          this.getSrcArray().push(...data2);
        } else {
          this.getSrcArray().push(data2);
        }
      },
      resetSrcArray() {
        this.geometry[this.getSrcName()] = [];
      },
      delete() {
        const srcName = this.getSrcName();
        delete this.geometry[srcName];
        delete this;
      }
    };
    this[prop.getSrcName()] = [];
    return this.userVertexProperties[propertyName];
  }
}
Geometry.nextId = 0;
function geometry(p52, fn2) {
  p52.Geometry = Geometry;
}
if (typeof p5 !== "undefined") {
  geometry(p5, p5.prototype);
}

// node_modules/p5/dist/webgl/GeometryBuilder.js
var import_file_saver2 = __toESM(require_FileSaver(), 1);

class GeometryBuilder {
  constructor(renderer2) {
    this.renderer = renderer2;
    renderer2._pInst.push();
    this.identityMatrix = new Matrix(4);
    renderer2.states.setValue("uModelMatrix", new Matrix(4));
    this.geometry = new Geometry(undefined, undefined, undefined, this.renderer);
    this.geometry.gid = `_p5_GeometryBuilder_${GeometryBuilder.nextGeometryId}`;
    GeometryBuilder.nextGeometryId++;
    this.hasTransform = false;
  }
  transformVertices(vertices) {
    if (!this.hasTransform)
      return vertices;
    return vertices.map((v) => this.renderer.states.uModelMatrix.multiplyPoint(v));
  }
  transformNormals(normals) {
    if (!this.hasTransform)
      return normals;
    return normals.map((v) => this.renderer.scratchMat3.multiplyVec(v));
  }
  addGeometry(input) {
    this.hasTransform = !this.renderer.states.uModelMatrix.mat4.every((v, i) => v === this.identityMatrix.mat4[i]);
    if (this.hasTransform) {
      this.renderer.scratchMat3.inverseTranspose4x4(this.renderer.states.uModelMatrix);
    }
    let startIdx = this.geometry.vertices.length;
    this.geometry.vertices.push(...this.transformVertices(input.vertices));
    this.geometry.vertexNormals.push(...this.transformNormals(input.vertexNormals));
    this.geometry.uvs.push(...input.uvs);
    const inputUserVertexProps = input.userVertexProperties;
    const builtUserVertexProps = this.geometry.userVertexProperties;
    const numPreviousVertices = this.geometry.vertices.length - input.vertices.length;
    for (const propName in builtUserVertexProps) {
      if (propName in inputUserVertexProps) {
        continue;
      }
      const prop = builtUserVertexProps[propName];
      const size = prop.getDataSize();
      const numMissingValues = size * input.vertices.length;
      const missingValues = Array(numMissingValues).fill(0);
      prop.pushDirect(missingValues);
    }
    for (const propName in inputUserVertexProps) {
      const prop = inputUserVertexProps[propName];
      const data = prop.getSrcArray();
      const size = prop.getDataSize();
      if (numPreviousVertices > 0 && !(propName in builtUserVertexProps)) {
        const numMissingValues = size * numPreviousVertices;
        const missingValues = Array(numMissingValues).fill(0);
        this.geometry.vertexProperty(propName, missingValues, size);
      }
      this.geometry.vertexProperty(propName, data, size);
    }
    if (this.renderer.states.fillColor) {
      this.geometry.faces.push(...input.faces.map((f) => f.map((idx) => idx + startIdx)));
    }
    if (this.renderer.states.strokeColor) {
      this.geometry.edges.push(...input.edges.map((edge) => edge.map((idx) => idx + startIdx)));
    }
    const vertexColors = [...input.vertexColors];
    while (vertexColors.length < input.vertices.length * 4) {
      vertexColors.push(...this.renderer.states.curFillColor);
    }
    this.geometry.vertexColors.push(...vertexColors);
  }
  addImmediate(geometry2, shapeMode, { validateFaces = false } = {}) {
    const faces = [];
    if (this.renderer.states.fillColor) {
      if (shapeMode === TRIANGLE_STRIP || shapeMode === QUAD_STRIP) {
        for (let i = 2;i < geometry2.vertices.length; i++) {
          if (i % 2 === 0) {
            faces.push([i, i - 1, i - 2]);
          } else {
            faces.push([i, i - 2, i - 1]);
          }
        }
      } else if (shapeMode === TRIANGLE_FAN) {
        for (let i = 2;i < geometry2.vertices.length; i++) {
          faces.push([0, i - 1, i]);
        }
      } else if (shapeMode === TRIANGLES) {
        for (let i = 0;i < geometry2.vertices.length; i += 3) {
          if (!validateFaces || geometry2.vertices[i].copy().sub(geometry2.vertices[i + 1]).cross(geometry2.vertices[i].copy().sub(geometry2.vertices[i + 2])).magSq() > 0) {
            faces.push([i, i + 1, i + 2]);
          }
        }
      }
    }
    this.addGeometry(Object.assign({}, geometry2, { faces }));
  }
  addRetained(geometry2) {
    this.addGeometry(geometry2);
  }
  finish() {
    this.renderer._pInst.pop();
    return this.geometry;
  }
}
GeometryBuilder.nextGeometryId = 0;

// node_modules/p5/dist/webgl/p5.Quat.js
class Quat {
  constructor(w, x, y, z) {
    this.w = w;
    this.vec = new Vector(x, y, z);
  }
  static fromAxisAngle(angle, x, y, z) {
    const w = Math.cos(angle / 2);
    const vec = new Vector(x, y, z).normalize().mult(Math.sin(angle / 2));
    return new Quat(w, vec.x, vec.y, vec.z);
  }
  conjugate() {
    return new Quat(this.w, -this.vec.x, -this.vec.y, -this.vec.z);
  }
  multiply(quat) {
    return new Quat(this.w * quat.w - this.vec.x * quat.vec.x - this.vec.y * quat.vec.y - this.vec.z - quat.vec.z, this.w * quat.vec.x + this.vec.x * quat.w + this.vec.y * quat.vec.z - this.vec.z * quat.vec.y, this.w * quat.vec.y - this.vec.x * quat.vec.z + this.vec.y * quat.w + this.vec.z * quat.vec.x, this.w * quat.vec.z + this.vec.x * quat.vec.y - this.vec.y * quat.vec.x + this.vec.z * quat.w);
  }
  rotateVector(p2) {
    return Vector.mult(p2, this.w * this.w - this.vec.dot(this.vec)).add(Vector.mult(this.vec, 2 * p2.dot(this.vec))).add(Vector.mult(this.vec, 2 * this.w).cross(p2)).clampToZero();
  }
  rotateBy(axesQuat) {
    return axesQuat.multiply(this).multiply(axesQuat.conjugate()).vec.clampToZero();
  }
}
function quat(p52, fn2) {
  p52.Quat = Quat;
}
if (typeof p5 !== "undefined") {
  quat(p5, p5.prototype);
}

// node_modules/p5/dist/webgl/p5.RenderBuffer.js
class RenderBuffer {
  constructor(size, src, dst, attr, renderer2, map2) {
    this.size = size;
    this.src = src;
    this.dst = dst;
    this.attr = attr;
    this._renderer = renderer2;
    this.map = map2;
  }
  _prepareBuffer(geometry2, shader) {
    const attributes2 = shader.attributes;
    const gl = this._renderer.GL;
    const glBuffers = this._renderer._getOrMakeCachedBuffers(geometry2);
    const attr = attributes2[this.attr];
    if (!attr) {
      return;
    }
    let buffer = glBuffers[this.dst];
    const src = geometry2[this.src];
    if (src && src.length > 0) {
      const createBuffer = !buffer;
      if (createBuffer) {
        glBuffers[this.dst] = buffer = gl.createBuffer();
      }
      gl.bindBuffer(gl.ARRAY_BUFFER, buffer);
      if (createBuffer || geometry2.dirtyFlags[this.src] !== false) {
        const map2 = this.map;
        const values = map2 ? map2(src) : src;
        this._renderer._bindBuffer(buffer, gl.ARRAY_BUFFER, values);
        geometry2.dirtyFlags[this.src] = false;
      }
      shader.enableAttrib(attr, this.size);
    } else {
      const loc = attr.location;
      if (loc === -1 || !this._renderer.registerEnabled.has(loc)) {
        return;
      }
      gl.disableVertexAttribArray(loc);
      this._renderer.registerEnabled.delete(loc);
    }
  }
}
function renderBuffer(p52, fn2) {
  p52.RenderBuffer = RenderBuffer;
}
if (typeof p5 !== "undefined") {
  renderBuffer(p5, p5.prototype);
}

// node_modules/p5/dist/webgl/ShapeBuilder.js
var import_libtess = __toESM(require_libtess_min(), 1);
var import_file_saver3 = __toESM(require_FileSaver(), 1);
var INITIAL_BUFFER_STRIDES = {
  vertices: 1,
  vertexNormals: 1,
  vertexColors: 4,
  vertexStrokeColors: 4,
  uvs: 2
};
var INITIAL_VERTEX_SIZE = Object.values(INITIAL_BUFFER_STRIDES).reduce((acc, next) => acc + next);

class ShapeBuilder {
  constructor(renderer2) {
    this.renderer = renderer2;
    this.shapeMode = PATH;
    this.geometry = new Geometry(undefined, undefined, undefined, this.renderer);
    this.geometry.gid = "__IMMEDIATE_MODE_GEOMETRY__";
    this.contourIndices = [];
    this._useUserVertexProperties = undefined;
    this._bezierVertex = [];
    this._quadraticVertex = [];
    this._curveVertex = [];
    this.isProcessingVertices = false;
    this._tessy = this._initTessy();
    this.tessyVertexSize = INITIAL_VERTEX_SIZE;
    this.bufferStrides = { ...INITIAL_BUFFER_STRIDES };
  }
  constructFromContours(shape, contours) {
    if (this._useUserVertexProperties) {
      this._resetUserVertexProperties();
    }
    this.geometry.reset();
    this.contourIndices = [];
    this.shapeMode = shape.contours[0].kind;
    const shouldProcessEdges = !!this.renderer.states.strokeColor;
    const userVertexPropertyHelpers = {};
    if (shape.userVertexProperties) {
      this._useUserVertexProperties = true;
      for (const key in shape.userVertexProperties) {
        const name = shape.vertexPropertyName(key);
        const prop = this.geometry._userVertexPropertyHelper(name, [], shape.userVertexProperties[key]);
        userVertexPropertyHelpers[key] = prop;
        this.tessyVertexSize += prop.getDataSize();
        this.bufferStrides[prop.getSrcName()] = prop.getDataSize();
        this.renderer.buffers.user.push(new RenderBuffer(prop.getDataSize(), prop.getSrcName(), prop.getDstName(), name, this.renderer));
      }
    } else {
      this._useUserVertexProperties = false;
    }
    for (const contour of contours) {
      this.contourIndices.push(this.geometry.vertices.length);
      for (const vertex2 of contour) {
        if (this.shapeMode === QUADS) {
          if (this.geometry.vertices.length % 6 === 3) {
            for (const key in this.bufferStrides) {
              const stride = this.bufferStrides[key];
              const buffer = this.geometry[key];
              buffer.push(...buffer.slice(buffer.length - 3 * stride, buffer.length - 2 * stride), ...buffer.slice(buffer.length - stride, buffer.length));
            }
          }
        }
        this.geometry.vertices.push(vertex2.position);
        this.geometry.vertexNormals.push(vertex2.normal || new Vector(0, 0, 0));
        this.geometry.uvs.push(vertex2.textureCoordinates.x, vertex2.textureCoordinates.y);
        if (this.renderer.states.fillColor) {
          this.geometry.vertexColors.push(...vertex2.fill.array());
        } else {
          this.geometry.vertexColors.push(0, 0, 0, 0);
        }
        if (this.renderer.states.strokeColor) {
          this.geometry.vertexStrokeColors.push(...vertex2.stroke.array());
        } else {
          this.geometry.vertexStrokeColors.push(0, 0, 0, 0);
        }
        for (const key in userVertexPropertyHelpers) {
          const prop = userVertexPropertyHelpers[key];
          if (key in vertex2) {
            prop.setCurrentData(vertex2[key]);
          }
          prop.pushCurrentData();
        }
      }
    }
    if (shouldProcessEdges) {
      this.geometry.edges = this._calculateEdges(this.shapeMode, this.geometry.vertices);
    }
    if (shouldProcessEdges && !this.renderer.geometryBuilder) {
      this.geometry._edgesToVertices();
    }
    if (this.shapeMode === PATH) {
      this.isProcessingVertices = true;
      this._tesselateShape();
      this.isProcessingVertices = false;
    } else if (this.shapeMode === QUAD_STRIP) {
      this.shapeMode = TRIANGLE_STRIP;
    } else if (this.shapeMode === QUADS) {
      this.shapeMode = TRIANGLES;
    }
    if (this.renderer.states.textureMode === IMAGE && this.renderer.states._tex !== null && this.renderer.states._tex.width > 0 && this.renderer.states._tex.height > 0) {
      this.geometry.uvs = this.geometry.uvs.map((val, i) => {
        if (i % 2 === 0) {
          return val / this.renderer.states._tex.width;
        } else {
          return val / this.renderer.states._tex.height;
        }
      });
    }
  }
  _resetUserVertexProperties() {
    const properties = this.geometry.userVertexProperties;
    for (const propName in properties) {
      const prop = properties[propName];
      delete this.bufferStrides[propName];
      prop.delete();
    }
    this._useUserVertexProperties = false;
    this.tessyVertexSize = INITIAL_VERTEX_SIZE;
    this.geometry.userVertexProperties = {};
  }
  _calculateEdges(shapeMode, verts) {
    const res = [];
    let i = 0;
    const contourIndices = this.contourIndices.slice();
    let contourStart = -1;
    switch (shapeMode) {
      case TRIANGLE_STRIP:
        for (i = 0;i < verts.length - 2; i++) {
          res.push([i, i + 1]);
          res.push([i, i + 2]);
        }
        res.push([i, i + 1]);
        break;
      case TRIANGLE_FAN:
        for (i = 1;i < verts.length - 1; i++) {
          res.push([0, i]);
          res.push([i, i + 1]);
        }
        res.push([0, verts.length - 1]);
        break;
      case TRIANGLES:
        for (i = 0;i < verts.length - 2; i = i + 3) {
          res.push([i, i + 1]);
          res.push([i + 1, i + 2]);
          res.push([i + 2, i]);
        }
        break;
      case LINES:
        for (i = 0;i < verts.length - 1; i = i + 2) {
          res.push([i, i + 1]);
        }
        break;
      case QUADS:
        for (i = 0;i < verts.length - 5; i += 6) {
          res.push([i, i + 1]);
          res.push([i + 1, i + 2]);
          res.push([i + 2, i + 5]);
          res.push([i + 5, i]);
        }
        break;
      case QUAD_STRIP:
        for (i = 0;i < verts.length - 2; i += 2) {
          res.push([i, i + 1]);
          res.push([i + 1, i + 3]);
          res.push([i, i + 2]);
        }
        res.push([i, i + 1]);
        break;
      default:
        for (i = 0;i < verts.length; i++) {
          if (i === contourIndices[0]) {
            contourStart = contourIndices.shift();
          } else if (verts[contourStart] && verts[i].equals(verts[contourStart])) {
            res.push([i - 1, contourStart]);
          } else {
            res.push([i - 1, i]);
          }
        }
        break;
    }
    return res;
  }
  _tesselateShape() {
    const contours = [];
    for (let i = 0;i < this.geometry.vertices.length; i++) {
      if (this.contourIndices.length > 0 && this.contourIndices[0] === i) {
        this.contourIndices.shift();
        contours.push([]);
      }
      contours[contours.length - 1].push(this.geometry.vertices[i].x, this.geometry.vertices[i].y, this.geometry.vertices[i].z, this.geometry.uvs[i * 2], this.geometry.uvs[i * 2 + 1], this.geometry.vertexColors[i * 4], this.geometry.vertexColors[i * 4 + 1], this.geometry.vertexColors[i * 4 + 2], this.geometry.vertexColors[i * 4 + 3], this.geometry.vertexNormals[i].x, this.geometry.vertexNormals[i].y, this.geometry.vertexNormals[i].z);
      for (const propName in this.geometry.userVertexProperties) {
        const prop = this.geometry.userVertexProperties[propName];
        const start = i * prop.getDataSize();
        const end = start + prop.getDataSize();
        const vals = prop.getSrcArray().slice(start, end);
        contours[contours.length - 1].push(...vals);
      }
    }
    const polyTriangles = this._triangulate(contours);
    if (polyTriangles.length === 0) {
      return;
    }
    this.shapeMode = TRIANGLES;
    const originalVertices = this.geometry.vertices;
    this.geometry.vertices = [];
    this.geometry.vertexNormals = [];
    this.geometry.uvs = [];
    for (const propName in this.geometry.userVertexProperties) {
      const prop = this.geometry.userVertexProperties[propName];
      prop.resetSrcArray();
    }
    const colors = [];
    for (let j = 0, polyTriLength = polyTriangles.length;j < polyTriLength; j = j + this.tessyVertexSize) {
      colors.push(...polyTriangles.slice(j + 5, j + 9));
      this.geometry.vertexNormals.push(new Vector(...polyTriangles.slice(j + 9, j + 12)));
      {
        let offset = 12;
        for (const propName in this.geometry.userVertexProperties) {
          const prop = this.geometry.userVertexProperties[propName];
          const size = prop.getDataSize();
          const start = j + offset;
          const end = start + size;
          prop.setCurrentData(polyTriangles.slice(start, end));
          prop.pushCurrentData();
          offset += size;
        }
      }
      this.geometry.vertices.push(new Vector(...polyTriangles.slice(j, j + 3)));
      this.geometry.uvs.push(...polyTriangles.slice(j + 3, j + 5));
    }
    if (this.renderer.geometryBuilder) {
      const newIndex = new Map;
      this.geometry.edges = this.geometry.edges.map((edge) => edge.map((origIdx) => {
        if (!newIndex.has(origIdx)) {
          const orig = originalVertices[origIdx];
          let newVertIndex = this.geometry.vertices.findIndex((v) => orig.x === v.x && orig.y === v.y && orig.z === v.z);
          if (newVertIndex === -1) {
            let closestDist = Infinity;
            let closestIndex = 0;
            for (let i = 0;i < this.geometry.vertices.length; i++) {
              const vert = this.geometry.vertices[i];
              const dX = orig.x - vert.x;
              const dY = orig.y - vert.y;
              const dZ = orig.z - vert.z;
              const dist = dX * dX + dY * dY + dZ * dZ;
              if (dist < closestDist) {
                closestDist = dist;
                closestIndex = i;
              }
            }
            newVertIndex = closestIndex;
          }
          newIndex.set(origIdx, newVertIndex);
        }
        return newIndex.get(origIdx);
      }));
    }
    this.geometry.vertexColors = colors;
  }
  _initTessy() {
    function vertexCallback(data, polyVertArray) {
      for (const element2 of data) {
        polyVertArray.push(element2);
      }
    }
    function begincallback(type2) {
      if (type2 !== import_libtess.default.primitiveType.GL_TRIANGLES) {
        console.log(`expected TRIANGLES but got type: ${type2}`);
      }
    }
    function errorcallback(errno) {
      console.log("error callback");
      console.log(`error number: ${errno}`);
    }
    const combinecallback = (coords, data, weight) => {
      const result = new Array(this.tessyVertexSize).fill(0);
      for (let i = 0;i < weight.length; i++) {
        for (let j = 0;j < result.length; j++) {
          if (weight[i] === 0 || !data[i])
            continue;
          result[j] += data[i][j] * weight[i];
        }
      }
      return result;
    };
    function edgeCallback(flag) {}
    const tessy = new import_libtess.default.GluTesselator;
    tessy.gluTessCallback(import_libtess.default.gluEnum.GLU_TESS_VERTEX_DATA, vertexCallback);
    tessy.gluTessCallback(import_libtess.default.gluEnum.GLU_TESS_BEGIN, begincallback);
    tessy.gluTessCallback(import_libtess.default.gluEnum.GLU_TESS_ERROR, errorcallback);
    tessy.gluTessCallback(import_libtess.default.gluEnum.GLU_TESS_COMBINE, combinecallback);
    tessy.gluTessCallback(import_libtess.default.gluEnum.GLU_TESS_EDGE_FLAG, edgeCallback);
    tessy.gluTessProperty(import_libtess.default.gluEnum.GLU_TESS_WINDING_RULE, import_libtess.default.windingRule.GLU_TESS_WINDING_NONZERO);
    return tessy;
  }
  _triangulate(contours) {
    const z = contours[0] ? contours[0][2] : undefined;
    let allSameZ = true;
    for (const contour of contours) {
      for (let j = 0;j < contour.length; j += this.tessyVertexSize) {
        if (contour[j + 2] !== z) {
          allSameZ = false;
          break;
        }
      }
    }
    if (allSameZ) {
      this._tessy.gluTessNormal(0, 0, 1);
    } else {
      this._tessy.gluTessNormal(0, 0, 0);
    }
    const triangleVerts = [];
    this._tessy.gluTessBeginPolygon(triangleVerts);
    for (const contour of contours) {
      this._tessy.gluTessBeginContour();
      for (let j = 0;j < contour.length; j += this.tessyVertexSize) {
        const coords = contour.slice(j, j + this.tessyVertexSize);
        this._tessy.gluTessVertex(coords, coords);
      }
      this._tessy.gluTessEndContour();
    }
    this._tessy.gluTessEndPolygon();
    return triangleVerts;
  }
}

// node_modules/p5/dist/webgl/GeometryBufferCache.js
class GeometryBufferCache {
  constructor(renderer2) {
    this.renderer = renderer2;
    this.cache = {};
  }
  numCached() {
    return Object.keys(this.cache).length;
  }
  isCached(gid) {
    return this.cache[gid] !== undefined;
  }
  getGeometryByID(gid) {
    return this.cache[gid]?.geometry;
  }
  getCached(model) {
    return this.getCachedID(model.gid);
  }
  getCachedID(gid) {
    return this.cache[gid];
  }
  ensureCached(geometry2) {
    const gid = geometry2.gid;
    if (!gid) {
      throw new Error("The p5.Geometry you passed in has no gid property!");
    }
    if (this.isCached(geometry2.gid))
      return this.getCached(geometry2);
    const gl = this.renderer.GL;
    this.freeBuffers(gid);
    if (Object.keys(this.cache).length > 1000) {
      const key = Object.keys(this.cache)[0];
      this.freeBuffers(key);
    }
    const buffers = {};
    this.cache[gid] = buffers;
    buffers.geometry = geometry2;
    let indexBuffer = buffers.indexBuffer;
    if (geometry2.faces.length) {
      if (!indexBuffer)
        indexBuffer = buffers.indexBuffer = gl.createBuffer();
      const vals = geometry2.faces.flat();
      const hasVertexIndicesOverMaxUInt16 = vals.some((v) => v > 65535);
      let type2 = hasVertexIndicesOverMaxUInt16 ? Uint32Array : Uint16Array;
      this.renderer._bindBuffer(indexBuffer, gl.ELEMENT_ARRAY_BUFFER, vals, type2);
      buffers.indexBufferType = hasVertexIndicesOverMaxUInt16 ? gl.UNSIGNED_INT : gl.UNSIGNED_SHORT;
    } else {
      if (indexBuffer) {
        gl.deleteBuffer(indexBuffer);
        buffers.indexBuffer = null;
      }
    }
    return buffers;
  }
  freeBuffers(gid) {
    const buffers = this.cache[gid];
    if (!buffers) {
      return;
    }
    delete this.cache[gid];
    const gl = this.renderer.GL;
    if (buffers.indexBuffer) {
      gl.deleteBuffer(buffers.indexBuffer);
    }
    function freeBuffers(defs) {
      for (const def of defs) {
        if (buffers[def.dst]) {
          gl.deleteBuffer(buffers[def.dst]);
          buffers[def.dst] = null;
        }
      }
    }
    freeBuffers(this.renderer.buffers.stroke);
    freeBuffers(this.renderer.buffers.fill);
    freeBuffers(this.renderer.buffers.user);
  }
}

// node_modules/p5/dist/image/const.js
var filterParamDefaults = {
  [BLUR]: 3,
  [POSTERIZE]: 4,
  [THRESHOLD]: 0.5
};

// node_modules/p5/dist/math/trigonometry.js
function trigonometry(p52, fn2) {
  const DEGREES = fn2.DEGREES = "degrees";
  const RADIANS = fn2.RADIANS = "radians";
  fn2._angleMode = RADIANS;
  fn2.acos = function(ratio) {
    return this._fromRadians(Math.acos(ratio));
  };
  fn2.asin = function(ratio) {
    return this._fromRadians(Math.asin(ratio));
  };
  fn2.atan = function(ratio) {
    return this._fromRadians(Math.atan(ratio));
  };
  fn2.atan2 = function(y, x) {
    return this._fromRadians(Math.atan2(y, x));
  };
  fn2.cos = function(angle) {
    return Math.cos(this._toRadians(angle));
  };
  fn2.sin = function(angle) {
    return Math.sin(this._toRadians(angle));
  };
  fn2.tan = function(angle) {
    return Math.tan(this._toRadians(angle));
  };
  fn2.degrees = (angle) => angle * RAD_TO_DEG;
  fn2.radians = (angle) => angle * DEG_TO_RAD;
  fn2.angleMode = function(mode) {
    if (typeof mode === "undefined") {
      return this._angleMode;
    } else if (mode === DEGREES || mode === RADIANS) {
      const prevMode = this._angleMode;
      if (mode === prevMode)
        return;
      if (mode === RADIANS) {
        this.pRotationX = this.pRotationX * DEG_TO_RAD;
        this.pRotationY = this.pRotationY * DEG_TO_RAD;
        this.pRotationZ = this.pRotationZ * DEG_TO_RAD;
      } else {
        this.pRotationX = this.pRotationX * RAD_TO_DEG;
        this.pRotationY = this.pRotationY * RAD_TO_DEG;
        this.pRotationZ = this.pRotationZ * RAD_TO_DEG;
      }
      this._angleMode = mode;
    }
  };
  fn2._toRadians = function(angle) {
    if (this._angleMode === DEGREES) {
      return angle * DEG_TO_RAD;
    }
    return angle;
  };
  fn2._toDegrees = function(angle) {
    if (this._angleMode === RADIANS) {
      return angle * RAD_TO_DEG;
    }
    return angle;
  };
  fn2._fromRadians = function(angle) {
    if (this._angleMode === DEGREES) {
      return angle * RAD_TO_DEG;
    }
    return angle;
  };
  fn2._fromDegrees = function(angle) {
    if (this._angleMode === RADIANS) {
      return angle * DEG_TO_RAD;
    }
    return angle;
  };
}
if (typeof p5 !== "undefined") {
  trigonometry(p5, p5.prototype);
}

// node_modules/p5/dist/rendering-CEHgvKUS.js
function image2(p52, fn2) {
  fn2.createImage = function(width, height) {
    return new p52.Image(width, height);
  };
  fn2.saveCanvas = function(...args) {
    let htmlCanvas, filename, extension, temporaryGraphics;
    if (args[0] instanceof HTMLCanvasElement) {
      htmlCanvas = args[0];
      args.shift();
    } else if (args[0] instanceof Element) {
      htmlCanvas = args[0].elt;
      args.shift();
    } else if (args[0] instanceof Framebuffer) {
      const framebuffer = args[0];
      temporaryGraphics = this.createGraphics(framebuffer.width, framebuffer.height);
      temporaryGraphics.pixelDensity(framebuffer.pixelDensity());
      framebuffer.loadPixels();
      temporaryGraphics.loadPixels();
      temporaryGraphics.pixels.set(framebuffer.pixels);
      temporaryGraphics.updatePixels();
      htmlCanvas = temporaryGraphics._renderer.canvas;
      args.shift();
    } else {
      htmlCanvas = this._curElement && this._curElement.elt;
    }
    if (args.length >= 1) {
      filename = args[0];
    }
    if (args.length >= 2) {
      extension = args[1];
    }
    extension = extension || fn2._checkFileExtension(filename, extension)[1] || "png";
    let mimeType;
    switch (extension) {
      default:
        mimeType = "image/png";
        break;
      case "webp":
        mimeType = "image/webp";
        break;
      case "jpeg":
      case "jpg":
        mimeType = "image/jpeg";
        break;
    }
    htmlCanvas.toBlob((blob) => {
      fn2.downloadFile(blob, filename, extension);
      if (temporaryGraphics)
        temporaryGraphics.remove();
    }, mimeType);
  };
  fn2.encodeAndDownloadGif = function(pImg, filename) {
    const props = pImg.gifProperties;
    let loopLimit = props.loopLimit;
    if (loopLimit === 1) {
      loopLimit = null;
    } else if (loopLimit === null) {
      loopLimit = 0;
    }
    const buffer = new Uint8Array(pImg.width * pImg.height * props.numFrames);
    const allFramesPixelColors = [];
    const paletteFreqsAndFrames = {};
    for (let i = 0;i < props.numFrames; i++) {
      const paletteSet = new Set;
      const data = props.frames[i].image.data;
      const dataLength = data.length;
      const pixelColors = new Uint32Array(pImg.width * pImg.height);
      for (let j = 0, k = 0;j < dataLength; j += 4, k++) {
        const r = data[j + 0];
        const g2 = data[j + 1];
        const b2 = data[j + 2];
        const color2 = r << 16 | g2 << 8 | b2 << 0;
        paletteSet.add(color2);
        pixelColors[k] = color2;
      }
      const paletteStr = [...paletteSet].sort().toString();
      if (paletteFreqsAndFrames[paletteStr] === undefined) {
        paletteFreqsAndFrames[paletteStr] = { freq: 1, frames: [i] };
      } else {
        paletteFreqsAndFrames[paletteStr].freq += 1;
        paletteFreqsAndFrames[paletteStr].frames.push(i);
      }
      allFramesPixelColors.push(pixelColors);
    }
    let framesUsingGlobalPalette = [];
    const palettesSortedByFreq = Object.keys(paletteFreqsAndFrames).sort(function(a, b2) {
      return paletteFreqsAndFrames[b2].freq - paletteFreqsAndFrames[a].freq;
    });
    const globalPalette = palettesSortedByFreq[0].split(",").map((a) => parseInt(a));
    framesUsingGlobalPalette = framesUsingGlobalPalette.concat(paletteFreqsAndFrames[globalPalette].frames);
    const globalPaletteSet = new Set(globalPalette);
    for (let i = 1;i < palettesSortedByFreq.length; i++) {
      const palette = palettesSortedByFreq[i].split(",").map((a) => parseInt(a));
      const difference = palette.filter((x) => !globalPaletteSet.has(x));
      if (globalPalette.length + difference.length <= 256) {
        for (let j = 0;j < difference.length; j++) {
          globalPalette.push(difference[j]);
          globalPaletteSet.add(difference[j]);
        }
        framesUsingGlobalPalette = framesUsingGlobalPalette.concat(paletteFreqsAndFrames[palettesSortedByFreq[i]].frames);
      }
    }
    framesUsingGlobalPalette = new Set(framesUsingGlobalPalette);
    const globalIndicesLookup = {};
    for (let i = 0;i < globalPalette.length; i++) {
      if (!globalIndicesLookup[globalPalette[i]]) {
        globalIndicesLookup[globalPalette[i]] = i;
      }
    }
    let powof2 = 1;
    while (powof2 < globalPalette.length) {
      powof2 <<= 1;
    }
    globalPalette.length = powof2;
    const opts = {
      loop: loopLimit,
      palette: new Uint32Array(globalPalette)
    };
    const gifWriter = new omggif2.GifWriter(buffer, pImg.width, pImg.height, opts);
    let previousFrame = {};
    for (let i = 0;i < props.numFrames; i++) {
      const localPaletteRequired = !framesUsingGlobalPalette.has(i);
      const palette = localPaletteRequired ? [] : globalPalette;
      const pixelPaletteIndex = new Uint8Array(pImg.width * pImg.height);
      const colorIndicesLookup = {};
      const cannotBeTransparent = new Set;
      allFramesPixelColors[i].forEach((color2, k) => {
        if (localPaletteRequired) {
          if (colorIndicesLookup[color2] === undefined) {
            colorIndicesLookup[color2] = palette.length;
            palette.push(color2);
          }
          pixelPaletteIndex[k] = colorIndicesLookup[color2];
        } else {
          pixelPaletteIndex[k] = globalIndicesLookup[color2];
        }
        if (i > 0) {
          if (allFramesPixelColors[i - 1][k] !== color2) {
            cannotBeTransparent.add(color2);
          }
        }
      });
      const frameOpts = {};
      const canBeTransparent = palette.filter((a) => !cannotBeTransparent.has(a));
      if (canBeTransparent.length > 0) {
        const transparent = canBeTransparent[0];
        const transparentIndex = localPaletteRequired ? colorIndicesLookup[transparent] : globalIndicesLookup[transparent];
        if (i > 0) {
          for (let k = 0;k < allFramesPixelColors[i].length; k++) {
            if (allFramesPixelColors[i - 1][k] === allFramesPixelColors[i][k]) {
              pixelPaletteIndex[k] = transparentIndex;
            }
          }
          frameOpts.transparent = transparentIndex;
          previousFrame.frameOpts.disposal = 1;
        }
      }
      frameOpts.delay = props.frames[i].delay / 10;
      if (localPaletteRequired) {
        let powof22 = 1;
        while (powof22 < palette.length) {
          powof22 <<= 1;
        }
        palette.length = powof22;
        frameOpts.palette = new Uint32Array(palette);
      }
      if (i > 0) {
        gifWriter.addFrame(0, 0, pImg.width, pImg.height, previousFrame.pixelPaletteIndex, previousFrame.frameOpts);
      }
      previousFrame = {
        pixelPaletteIndex,
        frameOpts
      };
    }
    previousFrame.frameOpts.disposal = 1;
    gifWriter.addFrame(0, 0, pImg.width, pImg.height, previousFrame.pixelPaletteIndex, previousFrame.frameOpts);
    const extension = "gif";
    const blob = new Blob([buffer.slice(0, gifWriter.end())], {
      type: "image/gif"
    });
    fn2.downloadFile(blob, filename, extension);
  };
  fn2.saveFrames = function(fName, ext, _duration, _fps, callback) {
    let duration = _duration || 3;
    duration = Math.max(Math.min(duration, 15), 0);
    duration = duration * 1000;
    let fps = _fps || 15;
    fps = Math.max(Math.min(fps, 22), 0);
    let count = 0;
    const makeFrame = fn2._makeFrame;
    const cnv = this._curElement.elt;
    let frames = [];
    const frameFactory = setInterval(() => {
      frames.push(makeFrame(fName + count, ext, cnv));
      count++;
    }, 1000 / fps);
    setTimeout(() => {
      clearInterval(frameFactory);
      if (callback) {
        callback(frames);
      } else {
        for (const f of frames) {
          fn2.downloadFile(f.imageData, f.filename, f.ext);
        }
      }
      frames = [];
    }, duration + 0.01);
  };
  fn2._makeFrame = function(filename, extension, _cnv) {
    let cnv;
    if (this) {
      cnv = this._curElement.elt;
    } else {
      cnv = _cnv;
    }
    let mimeType;
    if (!extension) {
      extension = "png";
      mimeType = "image/png";
    } else {
      switch (extension.toLowerCase()) {
        case "png":
          mimeType = "image/png";
          break;
        case "jpeg":
          mimeType = "image/jpeg";
          break;
        case "jpg":
          mimeType = "image/jpeg";
          break;
        default:
          mimeType = "image/png";
          break;
      }
    }
    const downloadMime = "image/octet-stream";
    let imageData = cnv.toDataURL(mimeType);
    imageData = imageData.replace(mimeType, downloadMime);
    const thisFrame = {};
    thisFrame.imageData = imageData;
    thisFrame.filename = filename;
    thisFrame.ext = extension;
    return thisFrame;
  };
}
if (typeof p5 !== "undefined") {
  image2(p5, p5.prototype);
}

class HTTPError extends Error {
  status;
  response;
  ok;
}
async function request(path, type2) {
  try {
    const res = await fetch(path);
    if (res.ok) {
      let data;
      switch (type2) {
        case "json":
          data = await res.json();
          break;
        case "text":
          data = await res.text();
          break;
        case "arrayBuffer":
          data = await res.arrayBuffer();
          break;
        case "blob":
          data = await res.blob();
          break;
        case "bytes":
          if (res.bytes) {
            data = await res.bytes();
          } else {
            const d2 = await res.arrayBuffer();
            data = new Uint8Array(d2);
          }
          break;
        default:
          throw new Error("Unsupported response type");
      }
      return { data, headers: res.headers };
    } else {
      const err = new HTTPError(res.statusText);
      err.status = res.status;
      err.response = res;
      err.ok = false;
      throw err;
    }
  } catch (err) {
    if (err instanceof TypeError) {
      console.log("You may have encountered a CORS error");
    } else if (err instanceof HTTPError) {
      console.log("You have encountered a HTTP error");
    } else if (err instanceof SyntaxError) {
      console.log("There is an error parsing the response to requested data structure");
    }
    throw err;
  }
}
function files(p52, fn2) {
  fn2.loadJSON = async function(path, successCallback, errorCallback) {
    try {
      const { data } = await request(path, "json");
      if (successCallback)
        return successCallback(data);
      return data;
    } catch (err) {
      p52._friendlyFileLoadError(5, path);
      if (errorCallback) {
        return errorCallback(err);
      } else {
        throw err;
      }
    }
  };
  fn2.loadStrings = async function(path, successCallback, errorCallback) {
    try {
      let { data } = await request(path, "text");
      data = data.split(/\r?\n/);
      if (successCallback)
        return successCallback(data);
      return data;
    } catch (err) {
      p52._friendlyFileLoadError(3, path);
      if (errorCallback) {
        return errorCallback(err);
      } else {
        throw err;
      }
    }
  };
  fn2.loadTable = async function(path, separator, header, successCallback, errorCallback) {
    if (typeof arguments[arguments.length - 1] === "function") {
      if (typeof arguments[arguments.length - 2] === "function") {
        successCallback = arguments[arguments.length - 2];
        errorCallback = arguments[arguments.length - 1];
      } else {
        successCallback = arguments[arguments.length - 1];
      }
    }
    if (typeof separator !== "string")
      separator = ",";
    if (typeof header === "function")
      header = false;
    try {
      let { data } = await request(path, "text");
      let ret = new p52.Table;
      data = parse2(data, {
        separator
      });
      if (header) {
        ret.columns = data.shift();
      } else {
        ret.columns = Array(data[0].length).fill(null);
      }
      data.forEach((line) => {
        const row = new p52.TableRow(line);
        ret.addRow(row);
      });
      if (successCallback) {
        return successCallback(ret);
      } else {
        return ret;
      }
    } catch (err) {
      p52._friendlyFileLoadError(2, path);
      if (errorCallback) {
        return errorCallback(err);
      } else {
        throw err;
      }
    }
  };
  fn2.loadXML = async function(path, successCallback, errorCallback) {
    try {
      const parser = new DOMParser;
      let { data } = await request(path, "text");
      const parsedDOM = parser.parseFromString(data, "application/xml");
      data = new p52.XML(parsedDOM);
      if (successCallback)
        return successCallback(data);
      return data;
    } catch (err) {
      p52._friendlyFileLoadError(1, path);
      if (errorCallback) {
        return errorCallback(err);
      } else {
        throw err;
      }
    }
  };
  fn2.loadBytes = async function(path, successCallback, errorCallback) {
    try {
      let { data } = await request(path, "arrayBuffer");
      data = new Uint8Array(data);
      if (successCallback)
        return successCallback(data);
      return data;
    } catch (err) {
      p52._friendlyFileLoadError(6, path);
      if (errorCallback) {
        return errorCallback(err);
      } else {
        throw err;
      }
    }
  };
  fn2.loadBlob = async function(path, successCallback, errorCallback) {
    try {
      const { data } = await request(path, "blob");
      if (successCallback)
        return successCallback(data);
      return data;
    } catch (err) {
      if (errorCallback) {
        return errorCallback(err);
      } else {
        throw err;
      }
    }
  };
  fn2.httpGet = async function(path, datatype = "text", successCallback, errorCallback) {
    if (typeof datatype === "function") {
      errorCallback = successCallback;
      successCallback = datatype;
      datatype = "text";
    }
    return this.httpDo(path, "GET", datatype, successCallback, errorCallback);
  };
  fn2.httpPost = async function(path, data, datatype = "text", successCallback, errorCallback) {
    if (typeof data === "function") {
      successCallback = data;
      errorCallback = datatype;
      data = undefined;
      datatype = "text";
    } else if (typeof datatype === "function") {
      errorCallback = successCallback;
      successCallback = datatype;
      datatype = "text";
    }
    let reqData = data;
    let contentType = "text/plain";
    if (data instanceof p52.XML) {
      reqData = data.serialize();
      contentType = "application/xml";
    } else if (data instanceof p52.Image) {
      reqData = await data.toBlob();
      contentType = "image/png";
    } else if (typeof data === "object") {
      reqData = JSON.stringify(data);
      contentType = "application/json";
    }
    const requestOptions = {
      method: "POST",
      body: reqData,
      headers: {
        "Content-Type": contentType
      }
    };
    if (reqData) {
      requestOptions.body = reqData;
    }
    const req = new Request(path, requestOptions);
    return this.httpDo(req, "POST", datatype, successCallback, errorCallback);
  };
  fn2.httpDo = async function(path, method, datatype, successCallback, errorCallback) {
    if (typeof datatype === "function") {
      errorCallback = successCallback;
      successCallback = datatype;
      datatype = undefined;
    }
    if (!datatype) {
      const extension = typeof path === "string" ? path.split(".").pop() : path.url.split(".").pop();
      switch (extension) {
        case "json":
          datatype = "json";
          break;
        case "jpg":
        case "jpeg":
        case "png":
        case "webp":
        case "gif":
          datatype = "blob";
          break;
        case "xml":
        case "txt":
        default:
          datatype = "text";
      }
    }
    const req = new Request(path, {
      method
    });
    try {
      const { data } = await request(req, datatype);
      if (successCallback) {
        return successCallback(data);
      } else {
        return data;
      }
    } catch (err) {
      if (errorCallback) {
        return errorCallback(err);
      } else {
        throw err;
      }
    }
  };
  fn2._pWriters = [];
  fn2.createWriter = function(name, extension) {
    let newPW;
    for (const i in fn2._pWriters) {
      if (fn2._pWriters[i].name === name) {
        newPW = new p52.PrintWriter(name + this.millis(), extension);
        fn2._pWriters.push(newPW);
        return newPW;
      }
    }
    newPW = new p52.PrintWriter(name, extension);
    fn2._pWriters.push(newPW);
    return newPW;
  };
  p52.PrintWriter = function(filename, extension) {
    let self2 = this;
    this.name = filename;
    this.content = "";
    this.write = function(data) {
      this.content += data;
    };
    this.print = function(data) {
      this.content += `${data}
`;
    };
    this.clear = function() {
      this.content = "";
    };
    this.close = function() {
      const arr = [];
      arr.push(this.content);
      fn2.writeFile(arr, filename, extension);
      for (const i in fn2._pWriters) {
        if (fn2._pWriters[i].name === this.name) {
          fn2._pWriters.splice(i, 1);
        }
      }
      self2.clear();
      self2 = {};
    };
  };
  fn2.save = function(object, _filename, _options) {
    const args = arguments;
    const cnv = this._curElement ? this._curElement.elt : this.elt;
    if (args.length === 0) {
      fn2.saveCanvas(cnv);
      return;
    } else if (args[0] instanceof Renderer || args[0] instanceof Graphics) {
      fn2.saveCanvas(args[0].canvas, args[1], args[2]);
      return;
    } else if (args.length === 1 && typeof args[0] === "string") {
      fn2.saveCanvas(cnv, args[0]);
    } else {
      const extension = _checkFileExtension(args[1], args[2])[1];
      switch (extension) {
        case "json":
          fn2.saveJSON(args[0], args[1], args[2]);
          return;
        case "txt":
          fn2.saveStrings(args[0], args[1], args[2]);
          return;
        default:
          if (args[0] instanceof Array) {
            fn2.saveStrings(args[0], args[1], args[2]);
          } else if (args[0] instanceof p52.Table) {
            fn2.saveTable(args[0], args[1], args[2]);
          } else if (args[0] instanceof p52.Image) {
            fn2.saveCanvas(args[0].canvas, args[1]);
          } else if (args[0] instanceof p52.SoundFile) {
            fn2.saveSound(args[0], args[1], args[2], args[3]);
          }
      }
    }
  };
  fn2.saveJSON = function(json, filename, optimize) {
    let stringify2;
    if (optimize) {
      stringify2 = JSON.stringify(json);
    } else {
      stringify2 = JSON.stringify(json, undefined, 2);
    }
    this.saveStrings(stringify2.split(`
`), filename, "json");
  };
  fn2.saveStrings = function(list, filename, extension, isCRLF) {
    const ext = extension || "txt";
    const pWriter = new p52.PrintWriter(filename, ext);
    for (let item of list) {
      isCRLF ? pWriter.write(item + `\r
`) : pWriter.write(item + `
`);
    }
    pWriter.close();
    pWriter.clear();
  };
  function escapeHelper(content) {
    return content.replace(/&/g, "&amp;").replace(/</g, "&lt;").replace(/>/g, "&gt;").replace(/"/g, "&quot;").replace(/'/g, "&#039;");
  }
  fn2.saveTable = function(table, filename, options2) {
    let ext;
    if (options2 === undefined) {
      ext = filename.substring(filename.lastIndexOf(".") + 1, filename.length);
      if (ext === filename)
        ext = "csv";
    } else {
      ext = options2;
    }
    const pWriter = this.createWriter(filename, ext);
    const header = table.columns;
    let sep = ",";
    if (ext === "tsv") {
      sep = "\t";
    }
    if (ext !== "html") {
      const output = table.toString(sep);
      pWriter.write(output);
    } else {
      pWriter.print("<html>");
      pWriter.print("<head>");
      let str = '  <meta http-equiv="content-type" content';
      str += '="text/html;charset=utf-8" />';
      pWriter.print(str);
      pWriter.print("</head>");
      pWriter.print("<body>");
      pWriter.print("  <table>");
      if (header[0] !== "0") {
        pWriter.print("    <tr>");
        for (let k = 0;k < header.length; k++) {
          const e2 = escapeHelper(header[k]);
          pWriter.print(`      <td>${e2}`);
          pWriter.print("      </td>");
        }
        pWriter.print("    </tr>");
      }
      for (let row = 0;row < table.rows.length; row++) {
        pWriter.print("    <tr>");
        for (let col = 0;col < table.columns.length; col++) {
          const entry = table.rows[row].getString(col);
          const htmlEntry = escapeHelper(entry);
          pWriter.print(`      <td>${htmlEntry}`);
          pWriter.print("      </td>");
        }
        pWriter.print("    </tr>");
      }
      pWriter.print("  </table>");
      pWriter.print("</body>");
      pWriter.print("</html>");
    }
    pWriter.close();
    pWriter.clear();
  };
  fn2.writeFile = function(dataToDownload, filename, extension) {
    let type2 = "application/octet-stream";
    if (fn2._isSafari()) {
      type2 = "text/plain";
    }
    const blob = new Blob(dataToDownload, {
      type: type2
    });
    fn2.downloadFile(blob, filename, extension);
  };
  fn2.downloadFile = downloadFile;
  fn2._checkFileExtension = _checkFileExtension;
  fn2._isSafari = function() {
    return /^((?!chrome|android).)*safari/i.test(navigator.userAgent);
  };
}
if (typeof p5 !== "undefined") {
  files(p5, p5.prototype);
}
function loadingDisplaying(p52, fn2) {
  fn2.loadImage = async function(path, successCallback, failureCallback) {
    try {
      let pImg = new p52.Image(1, 1, this);
      const req = new Request(path, {
        method: "GET",
        mode: "cors"
      });
      const { data, headers } = await request(req, "bytes");
      const contentType = headers.get("content-type");
      if (contentType === null) {
        console.warn("The image you loaded does not have a Content-Type header. If you are using the online editor consider reuploading the asset.");
      }
      if (contentType && contentType.includes("image/gif")) {
        await _createGif(data, pImg);
      } else {
        const blob = new Blob([data]);
        const img = await createImageBitmap(blob);
        pImg.width = pImg.canvas.width = img.width;
        pImg.height = pImg.canvas.height = img.height;
        pImg.drawingContext.drawImage(img, 0, 0);
      }
      pImg.modified = true;
      if (successCallback) {
        return successCallback(pImg);
      } else {
        return pImg;
      }
    } catch (err) {
      p52._friendlyFileLoadError(0, path);
      if (typeof failureCallback === "function") {
        return failureCallback(err);
      } else {
        throw err;
      }
    }
  };
  fn2.saveGif = async function(fileName, duration, options2 = {
    delay: 0,
    units: "seconds",
    silent: false,
    notificationDuration: 0,
    notificationID: "progressBar",
    reset: true
  }) {
    if (typeof fileName !== "string") {
      throw TypeError("fileName parameter must be a string");
    }
    if (typeof duration !== "number") {
      throw TypeError("Duration parameter must be a number");
    }
    const delay = options2 && options2.delay || 0;
    const units = options2 && options2.units || "seconds";
    const silent = options2 && options2.silent || false;
    const notificationDuration = options2 && options2.notificationDuration || 0;
    const notificationID = options2 && options2.notificationID || "progressBar";
    const resetAnimation = options2 && options2.reset !== undefined ? options2.reset : true;
    if (typeof delay !== "number") {
      throw TypeError("Delay parameter must be a number");
    }
    if (units !== "seconds" && units !== "frames") {
      throw TypeError('Units parameter must be either "frames" or "seconds"');
    }
    if (typeof silent !== "boolean") {
      throw TypeError("Silent parameter must be a boolean");
    }
    if (typeof notificationDuration !== "number") {
      throw TypeError("Notification duration parameter must be a number");
    }
    if (typeof notificationID !== "string") {
      throw TypeError("Notification ID parameter must be a string");
    }
    this._recording = true;
    let _frameRate = this._targetFrameRate;
    if (_frameRate === Infinity || _frameRate === undefined || _frameRate === 0) {
      _frameRate = 60;
    }
    let gifFrameDelay = 1 / _frameRate * 1000;
    gifFrameDelay = gifFrameDelay < 20 ? 20 : gifFrameDelay;
    const nFrames = units === "seconds" ? duration * _frameRate : duration;
    const nFramesDelay = units === "seconds" ? delay * _frameRate : delay;
    let frameIterator;
    let totalNumberOfFrames;
    if (resetAnimation) {
      frameIterator = nFramesDelay;
      this.frameCount = frameIterator;
      totalNumberOfFrames = nFrames + nFramesDelay;
    } else {
      frameIterator = this.frameCount + nFramesDelay;
      totalNumberOfFrames = frameIterator + nFrames;
    }
    const lastPixelDensity = this._renderer._pixelDensity;
    this.pixelDensity(1);
    let frames = [];
    if (document.getElementById(notificationID) !== null)
      document.getElementById(notificationID).remove();
    let p2;
    if (!silent) {
      p2 = this.createP("");
      p2.id(notificationID);
      p2.style("font-size", "16px");
      p2.style("font-family", "Montserrat");
      p2.style("background-color", "#ffffffa0");
      p2.style("padding", "8px");
      p2.style("border-radius", "10px");
      p2.position(0, 0);
    }
    let pixels2;
    let gl;
    if (this._renderer instanceof p52.RendererGL) {
      gl = this.drawingContext;
      pixels2 = new Uint8Array(gl.drawingBufferWidth * gl.drawingBufferHeight * 4);
    }
    this.noLoop();
    await new Promise(requestAnimationFrame);
    while (frameIterator < totalNumberOfFrames) {
      this.redraw();
      await new Promise(requestAnimationFrame);
      let data = undefined;
      if (this._renderer instanceof p52.RendererGL) {
        pixels2 = new Uint8Array(gl.drawingBufferWidth * gl.drawingBufferHeight * 4);
        gl.readPixels(0, 0, gl.drawingBufferWidth, gl.drawingBufferHeight, gl.RGBA, gl.UNSIGNED_BYTE, pixels2);
        data = _flipPixels(pixels2, this.width, this.height);
      } else {
        data = this.drawingContext.getImageData(0, 0, this.width, this.height).data;
      }
      frames.push(data);
      frameIterator++;
      if (!silent) {
        p2.html("Saved frame <b>" + frames.length.toString() + "</b> out of " + nFrames.toString());
      }
      await new Promise((resolve) => setTimeout(resolve, 0));
    }
    if (!silent)
      p2.html("Frames processed, generating color palette...");
    this.loop();
    this.pixelDensity(lastPixelDensity);
    const gif = import_gifenc.GIFEncoder();
    const globalPalette = _generateGlobalPalette(frames);
    const paletteCache = {};
    const getIndexedFrame = (frame) => {
      const length = frame.length / 4;
      const index = new Uint8Array(length);
      for (let i = 0;i < length; i++) {
        const key = frame[i * 4] << 24 | frame[i * 4 + 1] << 16 | frame[i * 4 + 2] << 8 | frame[i * 4 + 3];
        if (paletteCache[key] === undefined) {
          paletteCache[key] = import_gifenc.nearestColorIndex(globalPalette, frame.slice(i * 4, (i + 1) * 4));
        }
        index[i] = paletteCache[key];
      }
      return index;
    };
    const transparentIndex = globalPalette.length - 1;
    let prevIndexedFrame = [];
    for (let i = 0;i < frames.length; i++) {
      const indexedFrame = getIndexedFrame(frames[i]);
      const originalIndexedFrame = indexedFrame.slice();
      if (i === 0) {
        gif.writeFrame(indexedFrame, this.width, this.height, {
          palette: globalPalette,
          delay: gifFrameDelay,
          dispose: 1
        });
      } else {
        for (let i2 = 0;i2 < indexedFrame.length; i2++) {
          if (indexedFrame[i2] === prevIndexedFrame[i2]) {
            indexedFrame[i2] = transparentIndex;
          }
        }
        gif.writeFrame(indexedFrame, this.width, this.height, {
          delay: gifFrameDelay,
          transparent: true,
          transparentIndex,
          dispose: 1
        });
      }
      prevIndexedFrame = originalIndexedFrame;
      if (!silent) {
        p2.html("Rendered frame <b>" + i.toString() + "</b> out of " + nFrames.toString());
      }
      await new Promise((resolve) => setTimeout(resolve, 0));
    }
    gif.finish();
    const buffer = gif.bytesView();
    const extension = "gif";
    const blob = new Blob([buffer], {
      type: "image/gif"
    });
    frames = [];
    this._recording = false;
    this.loop();
    if (!silent) {
      p2.html("Done. Downloading your gif!\uD83C\uDF38");
      if (notificationDuration > 0)
        setTimeout(() => p2.remove(), notificationDuration * 1000);
    }
    fn2.downloadFile(blob, fileName, extension);
  };
  function _flipPixels(pixels2, width, height) {
    const halfHeight = parseInt(height / 2);
    const bytesPerRow = width * 4;
    const temp = new Uint8Array(width * 4);
    for (let y = 0;y < halfHeight; ++y) {
      const topOffset = y * bytesPerRow;
      const bottomOffset = (height - y - 1) * bytesPerRow;
      temp.set(pixels2.subarray(topOffset, topOffset + bytesPerRow));
      pixels2.copyWithin(topOffset, bottomOffset, bottomOffset + bytesPerRow);
      pixels2.set(temp, bottomOffset);
    }
    return pixels2;
  }
  function _generateGlobalPalette(frames) {
    let allColors = new Uint8Array(frames.length * frames[0].length);
    for (let f = 0;f < frames.length; f++) {
      allColors.set(frames[f], f * frames[0].length);
    }
    let colorPalette = import_gifenc.quantize(allColors, 256, {
      format: "rgba4444",
      oneBitAlpha: true
    });
    if (colorPalette.length === 256) {
      colorPalette[colorPalette.length - 1] = [
        Math.random() * 255,
        Math.random() * 255,
        Math.random() * 255,
        0
      ];
    } else {
      colorPalette.push([
        Math.random() * 255,
        Math.random() * 255,
        Math.random() * 255,
        0
      ]);
    }
    return colorPalette;
  }
  async function _createGif(arrayBuffer, pImg) {
    const gifReader = new omggif2.GifReader(arrayBuffer);
    pImg.width = pImg.canvas.width = gifReader.width;
    pImg.height = pImg.canvas.height = gifReader.height;
    const frames = [];
    const numFrames = gifReader.numFrames();
    let framePixels = new Uint8ClampedArray(pImg.width * pImg.height * 4);
    const loadGIFFrameIntoImage = (frameNum, gifReader2) => {
      try {
        gifReader2.decodeAndBlitFrameRGBA(frameNum, framePixels);
      } catch (e2) {
        p52._friendlyFileLoadError(8, pImg.src);
        throw e2;
      }
    };
    for (let j = 0;j < numFrames; j++) {
      const frameInfo = gifReader.frameInfo(j);
      const prevFrameData = pImg.drawingContext.getImageData(0, 0, pImg.width, pImg.height);
      framePixels = prevFrameData.data.slice();
      loadGIFFrameIntoImage(j, gifReader);
      const imageData = new ImageData(framePixels, pImg.width, pImg.height);
      pImg.drawingContext.putImageData(imageData, 0, 0);
      let frameDelay = frameInfo.delay;
      if (frameDelay === 0) {
        frameDelay = 10;
      }
      frames.push({
        image: pImg.drawingContext.getImageData(0, 0, pImg.width, pImg.height),
        delay: frameDelay * 10
      });
      if (frameInfo.disposal === 2) {
        pImg.drawingContext.clearRect(frameInfo.x, frameInfo.y, frameInfo.width, frameInfo.height);
      } else if (frameInfo.disposal === 3) {
        pImg.drawingContext.putImageData(prevFrameData, 0, 0, frameInfo.x, frameInfo.y, frameInfo.width, frameInfo.height);
      }
    }
    let loopLimit = gifReader.loopCount();
    if (loopLimit === null) {
      loopLimit = 1;
    } else if (loopLimit === 0) {
      loopLimit = null;
    }
    pImg.drawingContext.putImageData(frames[0].image, 0, 0);
    if (frames.length > 1) {
      pImg.gifProperties = {
        displayIndex: 0,
        loopLimit,
        loopCount: 0,
        frames,
        numFrames,
        playing: true,
        timeDisplayed: 0,
        lastChangeTime: 0
      };
    }
    return pImg;
  }
  function _imageContain(xAlign, yAlign, dx, dy, dw, dh, sw, sh) {
    const r = Math.max(sw / dw, sh / dh);
    const [adjusted_dw, adjusted_dh] = [sw / r, sh / r];
    let x = dx;
    let y = dy;
    if (xAlign === CENTER) {
      x += (dw - adjusted_dw) / 2;
    } else if (xAlign === RIGHT) {
      x += dw - adjusted_dw;
    }
    if (yAlign === CENTER) {
      y += (dh - adjusted_dh) / 2;
    } else if (yAlign === BOTTOM) {
      y += dh - adjusted_dh;
    }
    return { x, y, w: adjusted_dw, h: adjusted_dh };
  }
  function _imageCover(xAlign, yAlign, dw, dh, sx, sy, sw, sh) {
    const r = Math.max(dw / sw, dh / sh);
    const [adjusted_sw, adjusted_sh] = [dw / r, dh / r];
    let x = sx;
    let y = sy;
    if (xAlign === CENTER) {
      x += (sw - adjusted_sw) / 2;
    } else if (xAlign === RIGHT) {
      x += sw - adjusted_sw;
    }
    if (yAlign === CENTER) {
      y += (sh - adjusted_sh) / 2;
    } else if (yAlign === BOTTOM) {
      y += sh - adjusted_sh;
    }
    return { x, y, w: adjusted_sw, h: adjusted_sh };
  }
  function _imageFit(fit, xAlign, yAlign, dx, dy, dw, dh, sx, sy, sw, sh) {
    if (fit === COVER) {
      const { x, y, w, h } = _imageCover(xAlign, yAlign, dw, dh, sx, sy, sw, sh);
      sx = x;
      sy = y;
      sw = w;
      sh = h;
    }
    if (fit === CONTAIN) {
      const { x, y, w, h } = _imageContain(xAlign, yAlign, dx, dy, dw, dh, sw, sh);
      dx = x;
      dy = y;
      dw = w;
      dh = h;
    }
    return { sx, sy, sw, sh, dx, dy, dw, dh };
  }
  function _sAssign(sVal, iVal) {
    if (sVal > 0 && sVal < iVal) {
      return sVal;
    } else {
      return iVal;
    }
  }
  fn2.image = function(img, dx, dy, dWidth, dHeight, sx, sy, sWidth, sHeight, fit, xAlign, yAlign) {
    let defW = img.width;
    let defH = img.height;
    yAlign = yAlign || CENTER;
    xAlign = xAlign || CENTER;
    if (img.elt) {
      defW = defW !== undefined ? defW : img.elt.width;
      defH = defH !== undefined ? defH : img.elt.height;
    }
    if (img.elt && img.elt.videoWidth && !img.canvas) {
      defW = defW !== undefined ? defW : img.elt.videoWidth;
      defH = defH !== undefined ? defH : img.elt.videoHeight;
    }
    let _dx = dx;
    let _dy = dy;
    let _dw = dWidth || defW;
    let _dh = dHeight || defH;
    let _sx = sx || 0;
    let _sy = sy || 0;
    let _sw = sWidth !== undefined ? sWidth : defW;
    let _sh = sHeight !== undefined ? sHeight : defH;
    _sw = _sAssign(_sw, defW);
    _sh = _sAssign(_sh, defH);
    let pd = 1;
    if (img.elt && !img.canvas && img.elt.style.width) {
      if (img.elt.videoWidth && !dWidth) {
        pd = img.elt.videoWidth;
      } else {
        pd = img.elt.width;
      }
      pd /= parseInt(img.elt.style.width, 10);
    }
    _sx *= pd;
    _sy *= pd;
    _sh *= pd;
    _sw *= pd;
    let vals = canvas.modeAdjust(_dx, _dy, _dw, _dh, this._renderer.states.imageMode);
    vals = _imageFit(fit, xAlign, yAlign, vals.x, vals.y, vals.w, vals.h, _sx, _sy, _sw, _sh);
    this._renderer.image(img, vals.sx, vals.sy, vals.sw, vals.sh, vals.dx, vals.dy, vals.dw, vals.dh);
  };
  fn2.tint = function(...args) {
    const c = this.color(...args);
    this._renderer.states.setValue("tint", c._getRGBA([255, 255, 255, 255]));
  };
  fn2.noTint = function() {
    this._renderer.states.setValue("tint", null);
  };
  fn2.imageMode = function(m) {
    if (m === CORNER || m === CORNERS || m === CENTER) {
      this._renderer.states.setValue("imageMode", m);
    }
  };
}
if (typeof p5 !== "undefined") {
  loadingDisplaying(p5, p5.prototype);
}

class Camera {
  constructor(renderer2) {
    this._renderer = renderer2;
    this.cameraType = "default";
    this.useLinePerspective = true;
    this.cameraMatrix = new Matrix(4);
    this.projMatrix = new Matrix(4);
    this.yScale = 1;
  }
  perspective(fovy, aspect, near, far) {
    this.cameraType = arguments.length > 0 ? "custom" : "default";
    if (typeof fovy === "undefined") {
      fovy = this.defaultCameraFOV;
      this.cameraFOV = fovy;
    } else {
      this.cameraFOV = this._renderer._pInst._toRadians(fovy);
    }
    if (typeof aspect === "undefined") {
      aspect = this.defaultAspectRatio;
    }
    if (typeof near === "undefined") {
      near = this.defaultCameraNear;
    }
    if (typeof far === "undefined") {
      far = this.defaultCameraFar;
    }
    if (near <= 0.0001) {
      near = 0.01;
      console.log("Avoid perspective near plane values close to or below 0. " + "Setting value to 0.01.");
    }
    if (far < near) {
      console.log("Perspective far plane value is less than near plane value. " + "Nothing will be shown.");
    }
    this.aspectRatio = aspect;
    this.cameraNear = near;
    this.cameraFar = far;
    this.projMatrix = new Matrix(4);
    const f = 1 / Math.tan(this.cameraFOV / 2);
    const nf = 1 / (this.cameraNear - this.cameraFar);
    this.projMatrix.set(f / aspect, 0, 0, 0, 0, -f * this.yScale, 0, 0, 0, 0, (far + near) * nf, -1, 0, 0, 2 * far * near * nf, 0);
    if (this._isActive()) {
      this._renderer.states.setValue("uPMatrix", this._renderer.states.uPMatrix.clone());
      this._renderer.states.uPMatrix.set(this.projMatrix);
    }
  }
  ortho(left, right, bottom, top, near, far) {
    const source = this.fbo || this._renderer;
    if (left === undefined)
      left = -source.width / 2;
    if (right === undefined)
      right = +source.width / 2;
    if (bottom === undefined)
      bottom = -source.height / 2;
    if (top === undefined)
      top = +source.height / 2;
    if (near === undefined)
      near = 0;
    if (far === undefined)
      far = Math.max(source.width, source.height) + 800;
    this.cameraNear = near;
    this.cameraFar = far;
    const w = right - left;
    const h = top - bottom;
    const d2 = far - near;
    const x = 2 / w;
    const y = 2 / h * this.yScale;
    const z = -2 / d2;
    const tx = -(right + left) / w;
    const ty = -(top + bottom) / h;
    const tz = -(far + near) / d2;
    this.projMatrix = new Matrix(4);
    this.projMatrix.set(x, 0, 0, 0, 0, -y, 0, 0, 0, 0, z, 0, tx, ty, tz, 1);
    if (this._isActive()) {
      this._renderer.states.setValue("uPMatrix", this._renderer.states.uPMatrix.clone());
      this._renderer.states.uPMatrix.set(this.projMatrix);
    }
    this.cameraType = "custom";
  }
  frustum(left, right, bottom, top, near, far) {
    if (left === undefined)
      left = -this._renderer.width * 0.05;
    if (right === undefined)
      right = +this._renderer.width * 0.05;
    if (bottom === undefined)
      bottom = +this._renderer.height * 0.05;
    if (top === undefined)
      top = -this._renderer.height * 0.05;
    if (near === undefined)
      near = this.defaultCameraNear;
    if (far === undefined)
      far = this.defaultCameraFar;
    this.cameraNear = near;
    this.cameraFar = far;
    const w = right - left;
    const h = top - bottom;
    const d2 = far - near;
    const x = +(2 * near) / w;
    const y = +(2 * near) / h * this.yScale;
    const z = -(2 * far * near) / d2;
    const tx = (right + left) / w;
    const ty = (top + bottom) / h;
    const tz = -(far + near) / d2;
    this.projMatrix = new Matrix(4);
    this.projMatrix.set(x, 0, 0, 0, 0, -y, 0, 0, tx, ty, tz, -1, 0, 0, z, 0);
    if (this._isActive()) {
      this._renderer.states.setValue("uPMatrix", this._renderer.states.uPMatrix.clone());
      this._renderer.states.uPMatrix.set(this.projMatrix);
    }
    this.cameraType = "custom";
  }
  _rotateView(a, x, y, z) {
    let centerX = this.centerX;
    let centerY = this.centerY;
    let centerZ = this.centerZ;
    centerX -= this.eyeX;
    centerY -= this.eyeY;
    centerZ -= this.eyeZ;
    const rotation = new Matrix(4);
    rotation.rotate4x4(this._renderer._pInst._toRadians(a), x, y, z);
    const rotatedCenter = [
      centerX * rotation.mat4[0] + centerY * rotation.mat4[4] + centerZ * rotation.mat4[8],
      centerX * rotation.mat4[1] + centerY * rotation.mat4[5] + centerZ * rotation.mat4[9],
      centerX * rotation.mat4[2] + centerY * rotation.mat4[6] + centerZ * rotation.mat4[10]
    ];
    rotatedCenter[0] += this.eyeX;
    rotatedCenter[1] += this.eyeY;
    rotatedCenter[2] += this.eyeZ;
    this.camera(this.eyeX, this.eyeY, this.eyeZ, rotatedCenter[0], rotatedCenter[1], rotatedCenter[2], this.upX, this.upY, this.upZ);
  }
  roll(amount) {
    const local = this._getLocalAxes();
    const axisQuaternion = Quat.fromAxisAngle(this._renderer._pInst._toRadians(amount), local.z[0], local.z[1], local.z[2]);
    const newUpVector = axisQuaternion.rotateVector(new Vector(this.upX, this.upY, this.upZ));
    this.camera(this.eyeX, this.eyeY, this.eyeZ, this.centerX, this.centerY, this.centerZ, newUpVector.x, newUpVector.y, newUpVector.z);
  }
  pan(amount) {
    const local = this._getLocalAxes();
    this._rotateView(amount, local.y[0], local.y[1], local.y[2]);
  }
  tilt(amount) {
    const local = this._getLocalAxes();
    this._rotateView(amount, local.x[0], local.x[1], local.x[2]);
  }
  lookAt(x, y, z) {
    this.camera(this.eyeX, this.eyeY, this.eyeZ, x, y, z, this.upX, this.upY, this.upZ);
  }
  camera(eyeX, eyeY, eyeZ, centerX, centerY, centerZ, upX, upY, upZ) {
    if (typeof eyeX === "undefined") {
      eyeX = this.defaultEyeX;
      eyeY = this.defaultEyeY;
      eyeZ = this.defaultEyeZ;
      centerX = eyeX;
      centerY = eyeY;
      centerZ = 0;
      upX = 0;
      upY = 1;
      upZ = 0;
    }
    this.eyeX = eyeX;
    this.eyeY = eyeY;
    this.eyeZ = eyeZ;
    if (typeof centerX !== "undefined") {
      this.centerX = centerX;
      this.centerY = centerY;
      this.centerZ = centerZ;
    }
    if (typeof upX !== "undefined") {
      this.upX = upX;
      this.upY = upY;
      this.upZ = upZ;
    }
    const local = this._getLocalAxes();
    this.cameraMatrix.set(local.x[0], local.y[0], local.z[0], 0, local.x[1], local.y[1], local.z[1], 0, local.x[2], local.y[2], local.z[2], 0, 0, 0, 0, 1);
    const tx = -eyeX;
    const ty = -eyeY;
    const tz = -eyeZ;
    this.cameraMatrix.translate([tx, ty, tz]);
    if (this._isActive()) {
      this._renderer.states.setValue("uViewMatrix", this._renderer.states.uViewMatrix.clone());
      this._renderer.states.uViewMatrix.set(this.cameraMatrix);
    }
    return this;
  }
  move(x, y, z) {
    const local = this._getLocalAxes();
    const dx = [local.x[0] * x, local.x[1] * x, local.x[2] * x];
    const dy = [local.y[0] * y, local.y[1] * y, local.y[2] * y];
    const dz = [local.z[0] * z, local.z[1] * z, local.z[2] * z];
    this.camera(this.eyeX + dx[0] + dy[0] + dz[0], this.eyeY + dx[1] + dy[1] + dz[1], this.eyeZ + dx[2] + dy[2] + dz[2], this.centerX + dx[0] + dy[0] + dz[0], this.centerY + dx[1] + dy[1] + dz[1], this.centerZ + dx[2] + dy[2] + dz[2], this.upX, this.upY, this.upZ);
  }
  setPosition(x, y, z) {
    const diffX = x - this.eyeX;
    const diffY = y - this.eyeY;
    const diffZ = z - this.eyeZ;
    this.camera(x, y, z, this.centerX + diffX, this.centerY + diffY, this.centerZ + diffZ, this.upX, this.upY, this.upZ);
  }
  set(cam) {
    const keyNamesOfThePropToCopy = [
      "eyeX",
      "eyeY",
      "eyeZ",
      "centerX",
      "centerY",
      "centerZ",
      "upX",
      "upY",
      "upZ",
      "cameraFOV",
      "aspectRatio",
      "cameraNear",
      "cameraFar",
      "cameraType",
      "yScale",
      "useLinePerspective"
    ];
    for (const keyName of keyNamesOfThePropToCopy) {
      this[keyName] = cam[keyName];
    }
    this.cameraMatrix = cam.cameraMatrix.copy();
    this.projMatrix = cam.projMatrix.copy();
    if (this._isActive()) {
      this._renderer.states.setValue("uModelMatrix", this._renderer.states.uModelMatrix.clone());
      this._renderer.states.setValue("uViewMatrix", this._renderer.states.uViewMatrix.clone());
      this._renderer.states.setValue("uPMatrix", this._renderer.states.uPMatrix.clone());
      this._renderer.states.uModelMatrix.reset();
      this._renderer.states.uViewMatrix.set(this.cameraMatrix);
      this._renderer.states.uPMatrix.set(this.projMatrix);
    }
  }
  slerp(cam0, cam1, amt) {
    if (amt === 0) {
      this.set(cam0);
      return;
    } else if (amt === 1) {
      this.set(cam1);
      return;
    }
    if (this.projMatrix.mat4[15] !== 0) {
      this.projMatrix.setElement(0, cam0.projMatrix.mat4[0] * Math.pow(cam1.projMatrix.mat4[0] / cam0.projMatrix.mat4[0], amt));
      this.projMatrix.setElement(5, cam0.projMatrix.mat4[5] * Math.pow(cam1.projMatrix.mat4[5] / cam0.projMatrix.mat4[5], amt));
      if (this._isActive()) {
        this._renderer.states.setValue("uPMatrix", this._renderer.states.uPMatrix.clone());
        this._renderer.states.uPMatrix.mat4 = this.projMatrix.mat4.slice();
      }
    }
    const eye0 = new Vector(cam0.eyeX, cam0.eyeY, cam0.eyeZ);
    const eye1 = new Vector(cam1.eyeX, cam1.eyeY, cam1.eyeZ);
    const center0 = new Vector(cam0.centerX, cam0.centerY, cam0.centerZ);
    const center1 = new Vector(cam1.centerX, cam1.centerY, cam1.centerZ);
    const dist0 = Vector.dist(eye0, center0);
    const dist1 = Vector.dist(eye1, center1);
    const lerpedDist = dist0 * Math.pow(dist1 / dist0, amt);
    const eyeDiff = Vector.sub(eye0, eye1);
    const diffDiff = eye0.copy().sub(eye1).sub(center0).add(center1);
    const divider = diffDiff.magSq();
    let ratio = 1;
    if (divider > 0.000001) {
      ratio = Vector.dot(eyeDiff, diffDiff) / divider;
      ratio = Math.max(0, Math.min(ratio, 1));
    }
    const lerpedMedium = Vector.lerp(Vector.lerp(eye0, center0, ratio), Vector.lerp(eye1, center1, ratio), amt);
    const rotMat0 = cam0.cameraMatrix.createSubMatrix3x3();
    const rotMat1 = cam1.cameraMatrix.createSubMatrix3x3();
    const front0 = rotMat0.row(2);
    const front1 = rotMat1.row(2);
    const up0 = rotMat0.row(1);
    const up1 = rotMat1.row(1);
    const newFront = new Vector;
    const newUp = new Vector;
    const newEye = new Vector;
    const newCenter = new Vector;
    const deltaRot = rotMat1.mult(rotMat0.copy().transpose());
    const diag = deltaRot.diagonal();
    let cosTheta = 0.5 * (diag[0] + diag[1] + diag[2] - 1);
    if (1 - cosTheta < 0.0000001) {
      newFront.set(Vector.lerp(front0, front1, amt)).normalize();
      newEye.set(newFront).mult(ratio * lerpedDist).add(lerpedMedium);
      newCenter.set(newFront).mult((ratio - 1) * lerpedDist).add(lerpedMedium);
      newUp.set(Vector.lerp(up0, up1, amt)).normalize();
      this.camera(newEye.x, newEye.y, newEye.z, newCenter.x, newCenter.y, newCenter.z, newUp.x, newUp.y, newUp.z);
      return;
    }
    let a, b2, c, sinTheta;
    let invOneMinusCosTheta = 1 / (1 - cosTheta);
    const maxDiag = Math.max(diag[0], diag[1], diag[2]);
    const offDiagSum13 = deltaRot.mat3[1] + deltaRot.mat3[3];
    const offDiagSum26 = deltaRot.mat3[2] + deltaRot.mat3[6];
    const offDiagSum57 = deltaRot.mat3[5] + deltaRot.mat3[7];
    if (maxDiag === diag[0]) {
      a = Math.sqrt((diag[0] - cosTheta) * invOneMinusCosTheta);
      invOneMinusCosTheta /= a;
      b2 = 0.5 * offDiagSum13 * invOneMinusCosTheta;
      c = 0.5 * offDiagSum26 * invOneMinusCosTheta;
      sinTheta = 0.5 * (deltaRot.mat3[7] - deltaRot.mat3[5]) / a;
    } else if (maxDiag === diag[1]) {
      b2 = Math.sqrt((diag[1] - cosTheta) * invOneMinusCosTheta);
      invOneMinusCosTheta /= b2;
      c = 0.5 * offDiagSum57 * invOneMinusCosTheta;
      a = 0.5 * offDiagSum13 * invOneMinusCosTheta;
      sinTheta = 0.5 * (deltaRot.mat3[2] - deltaRot.mat3[6]) / b2;
    } else {
      c = Math.sqrt((diag[2] - cosTheta) * invOneMinusCosTheta);
      invOneMinusCosTheta /= c;
      a = 0.5 * offDiagSum26 * invOneMinusCosTheta;
      b2 = 0.5 * offDiagSum57 * invOneMinusCosTheta;
      sinTheta = 0.5 * (deltaRot.mat3[3] - deltaRot.mat3[1]) / c;
    }
    const angle = amt * Math.atan2(sinTheta, cosTheta);
    const cosAngle = Math.cos(angle);
    const sinAngle = Math.sin(angle);
    const oneMinusCosAngle = 1 - cosAngle;
    const ab = a * b2;
    const bc = b2 * c;
    const ca = c * a;
    const lerpedRotMat = new Matrix([
      cosAngle + oneMinusCosAngle * a * a,
      oneMinusCosAngle * ab + sinAngle * c,
      oneMinusCosAngle * ca - sinAngle * b2,
      oneMinusCosAngle * ab - sinAngle * c,
      cosAngle + oneMinusCosAngle * b2 * b2,
      oneMinusCosAngle * bc + sinAngle * a,
      oneMinusCosAngle * ca + sinAngle * b2,
      oneMinusCosAngle * bc - sinAngle * a,
      cosAngle + oneMinusCosAngle * c * c
    ]);
    lerpedRotMat.multiplyVec(front0, newFront);
    newEye.set(newFront).mult(ratio * lerpedDist).add(lerpedMedium);
    newCenter.set(newFront).mult((ratio - 1) * lerpedDist).add(lerpedMedium);
    lerpedRotMat.multiplyVec(up0, newUp);
    this.camera(newEye.x, newEye.y, newEye.z, newCenter.x, newCenter.y, newCenter.z, newUp.x, newUp.y, newUp.z);
  }
  _computeCameraDefaultSettings() {
    this.defaultAspectRatio = this._renderer.width / this._renderer.height;
    this.defaultEyeX = 0;
    this.defaultEyeY = 0;
    this.defaultEyeZ = 800;
    this.defaultCameraFOV = 2 * Math.atan(this._renderer.height / 2 / this.defaultEyeZ);
    this.defaultCenterX = 0;
    this.defaultCenterY = 0;
    this.defaultCenterZ = 0;
    this.defaultCameraNear = this.defaultEyeZ * 0.1;
    this.defaultCameraFar = this.defaultEyeZ * 10;
  }
  _setDefaultCamera() {
    this.cameraFOV = this.defaultCameraFOV;
    this.aspectRatio = this.defaultAspectRatio;
    this.eyeX = this.defaultEyeX;
    this.eyeY = this.defaultEyeY;
    this.eyeZ = this.defaultEyeZ;
    this.centerX = this.defaultCenterX;
    this.centerY = this.defaultCenterY;
    this.centerZ = this.defaultCenterZ;
    this.upX = 0;
    this.upY = 1;
    this.upZ = 0;
    this.cameraNear = this.defaultCameraNear;
    this.cameraFar = this.defaultCameraFar;
    this.perspective();
    this.camera();
    this.cameraType = "default";
  }
  _resize() {
    if (this.cameraType === "default") {
      this._computeCameraDefaultSettings();
      this.cameraFOV = this.defaultCameraFOV;
      this.aspectRatio = this.defaultAspectRatio;
      this.perspective();
    }
  }
  copy() {
    const _cam = new Camera(this._renderer);
    _cam.cameraFOV = this.cameraFOV;
    _cam.aspectRatio = this.aspectRatio;
    _cam.eyeX = this.eyeX;
    _cam.eyeY = this.eyeY;
    _cam.eyeZ = this.eyeZ;
    _cam.centerX = this.centerX;
    _cam.centerY = this.centerY;
    _cam.centerZ = this.centerZ;
    _cam.upX = this.upX;
    _cam.upY = this.upY;
    _cam.upZ = this.upZ;
    _cam.cameraNear = this.cameraNear;
    _cam.cameraFar = this.cameraFar;
    _cam.cameraType = this.cameraType;
    _cam.useLinePerspective = this.useLinePerspective;
    _cam.cameraMatrix = this.cameraMatrix.copy();
    _cam.projMatrix = this.projMatrix.copy();
    _cam.yScale = this.yScale;
    return _cam;
  }
  clone() {
    return this.copy();
  }
  _getLocalAxes() {
    let z0 = this.eyeX - this.centerX;
    let z1 = this.eyeY - this.centerY;
    let z2 = this.eyeZ - this.centerZ;
    const eyeDist = Math.sqrt(z0 * z0 + z1 * z1 + z2 * z2);
    if (eyeDist !== 0) {
      z0 /= eyeDist;
      z1 /= eyeDist;
      z2 /= eyeDist;
    }
    let y0 = this.upX;
    let y1 = this.upY;
    let y2 = this.upZ;
    let x0 = y1 * z2 - y2 * z1;
    let x1 = -y0 * z2 + y2 * z0;
    let x2 = y0 * z1 - y1 * z0;
    y0 = z1 * x2 - z2 * x1;
    y1 = -z0 * x2 + z2 * x0;
    y2 = z0 * x1 - z1 * x0;
    const xmag = Math.sqrt(x0 * x0 + x1 * x1 + x2 * x2);
    if (xmag !== 0) {
      x0 /= xmag;
      x1 /= xmag;
      x2 /= xmag;
    }
    const ymag = Math.sqrt(y0 * y0 + y1 * y1 + y2 * y2);
    if (ymag !== 0) {
      y0 /= ymag;
      y1 /= ymag;
      y2 /= ymag;
    }
    return {
      x: [x0, x1, x2],
      y: [y0, y1, y2],
      z: [z0, z1, z2]
    };
  }
  _orbit(dTheta, dPhi, dRadius) {
    const diffX = this.eyeX - this.centerX;
    const diffY = this.eyeY - this.centerY;
    const diffZ = this.eyeZ - this.centerZ;
    let camRadius = Math.hypot(diffX, diffY, diffZ);
    const front = new Vector(diffX, diffY, diffZ).normalize();
    const up = new Vector(this.upX, this.upY, this.upZ).normalize();
    const side = Vector.cross(up, front).normalize();
    const vertical = Vector.cross(side, up);
    camRadius *= Math.pow(10, dRadius);
    if (camRadius < this.cameraNear) {
      camRadius = this.cameraNear;
    }
    if (camRadius > this.cameraFar) {
      camRadius = this.cameraFar;
    }
    const camPhi = Math.acos(Math.max(-1, Math.min(1, Vector.dot(front, up)))) + dPhi;
    const camTheta = dTheta;
    if (camPhi <= 0 || camPhi >= Math.PI) {
      this.upX *= -1;
      this.upY *= -1;
      this.upZ *= -1;
    }
    up.mult(Math.cos(camPhi));
    vertical.mult(Math.cos(camTheta) * Math.sin(camPhi));
    side.mult(Math.sin(camTheta) * Math.sin(camPhi));
    front.set(up).add(vertical).add(side);
    this.eyeX = camRadius * front.x + this.centerX;
    this.eyeY = camRadius * front.y + this.centerY;
    this.eyeZ = camRadius * front.z + this.centerZ;
    this.camera(this.eyeX, this.eyeY, this.eyeZ, this.centerX, this.centerY, this.centerZ, this.upX, this.upY, this.upZ);
  }
  _orbitFree(dx, dy, dRadius) {
    const diffX = this.eyeX - this.centerX;
    const diffY = this.eyeY - this.centerY;
    const diffZ = this.eyeZ - this.centerZ;
    let camRadius = Math.hypot(diffX, diffY, diffZ);
    const front = new Vector(diffX, diffY, diffZ).normalize();
    const up = new Vector(this.upX, this.upY, this.upZ);
    const side = Vector.cross(up, front).normalize();
    const down = Vector.cross(front, side);
    const directionAngle = Math.atan2(dy, dx);
    down.mult(Math.sin(directionAngle));
    side.mult(Math.cos(directionAngle)).add(down);
    const rotAngle = Math.sqrt(dx * dx + dy * dy);
    const axis = Vector.cross(front, side);
    camRadius *= Math.pow(10, dRadius);
    if (camRadius < this.cameraNear) {
      camRadius = this.cameraNear;
    }
    if (camRadius > this.cameraFar) {
      camRadius = this.cameraFar;
    }
    const c = Math.cos(rotAngle);
    const s = Math.sin(rotAngle);
    const dotFront = up.dot(front);
    const dotSide = up.dot(side);
    const ux = dotFront * c + dotSide * s;
    const uy = -dotFront * s + dotSide * c;
    const uz = up.dot(axis);
    up.x = ux * front.x + uy * side.x + uz * axis.x;
    up.y = ux * front.y + uy * side.y + uz * axis.y;
    up.z = ux * front.z + uy * side.z + uz * axis.z;
    side.mult(-s);
    front.mult(c).add(side).mult(camRadius);
    this.camera(front.x + this.centerX, front.y + this.centerY, front.z + this.centerZ, this.centerX, this.centerY, this.centerZ, up.x, up.y, up.z);
  }
  _isActive() {
    return this === this._renderer.states.curCamera;
  }
}
function camera(p52, fn2) {
  fn2.camera = function(...args) {
    this._assert3d("camera");
    this._renderer.camera(...args);
    return this;
  };
  fn2.perspective = function(...args) {
    this._assert3d("perspective");
    this._renderer.perspective(...args);
    return this;
  };
  fn2.linePerspective = function(enable) {
    if (!(this._renderer instanceof RendererGL)) {
      throw new Error("linePerspective() must be called in WebGL mode.");
    }
    return this._renderer.linePerspective(enable);
  };
  fn2.ortho = function(...args) {
    this._assert3d("ortho");
    this._renderer.ortho(...args);
    return this;
  };
  fn2.frustum = function(...args) {
    this._assert3d("frustum");
    this._renderer.frustum(...args);
    return this;
  };
  fn2.createCamera = function() {
    this._assert3d("createCamera");
    return this._renderer.createCamera();
  };
  fn2.setCamera = function(cam) {
    this._renderer.setCamera(cam);
  };
  p52.Camera = Camera;
  RendererGL.prototype.camera = function(...args) {
    this.states.curCamera.camera(...args);
  };
  RendererGL.prototype.perspective = function(...args) {
    this.states.curCamera.perspective(...args);
  };
  RendererGL.prototype.linePerspective = function(enable) {
    if (enable !== undefined) {
      this.states.curCamera.useLinePerspective = enable;
    } else {
      return this.states.curCamera.useLinePerspective;
    }
  };
  RendererGL.prototype.ortho = function(...args) {
    this.states.curCamera.ortho(...args);
  };
  RendererGL.prototype.frustum = function(...args) {
    this.states.curCamera.frustum(...args);
  };
  RendererGL.prototype.createCamera = function() {
    const _cam = new Camera(this);
    _cam._computeCameraDefaultSettings();
    _cam._setDefaultCamera();
    return _cam;
  };
  RendererGL.prototype.setCamera = function(cam) {
    this.states.setValue("curCamera", cam);
    this.states.setValue("uPMatrix", this.states.uPMatrix.clone());
    this.states.uPMatrix.set(cam.projMatrix);
    this.states.setValue("uViewMatrix", this.states.uViewMatrix.clone());
    this.states.uViewMatrix.set(cam.cameraMatrix);
  };
}
if (typeof p5 !== "undefined") {
  camera(p5, p5.prototype);
}

class Shader {
  constructor(renderer2, vertSrc, fragSrc, options2 = {}) {
    this._renderer = renderer2;
    this._vertSrc = vertSrc;
    this._fragSrc = fragSrc;
    this._vertShader = -1;
    this._fragShader = -1;
    this._glProgram = 0;
    this._loadedAttributes = false;
    this.attributes = {};
    this._loadedUniforms = false;
    this.uniforms = {};
    this._bound = false;
    this.samplers = [];
    this.hooks = {
      uniforms: options2.uniforms || {},
      declarations: options2.declarations,
      helpers: options2.helpers || {},
      vertex: options2.vertex || {},
      fragment: options2.fragment || {},
      modified: {
        vertex: options2.modified && options2.modified.vertex || {},
        fragment: options2.modified && options2.modified.fragment || {}
      }
    };
  }
  hookTypes(hookName) {
    let fullSrc = this._vertSrc;
    let body = this.hooks.vertex[hookName];
    if (!body) {
      body = this.hooks.fragment[hookName];
      fullSrc = this._fragSrc;
    }
    if (!body) {
      throw new Error(`Can't find hook ${hookName}!`);
    }
    const nameParts = hookName.split(/\s+/g);
    const functionName = nameParts.pop();
    const returnType = nameParts.pop();
    const returnQualifiers = [...nameParts];
    const parameterMatch = /\(([^\)]*)\)/.exec(body);
    if (!parameterMatch) {
      throw new Error(`Couldn't find function parameters in hook body:
${body}`);
    }
    const structProperties = (structName) => {
      const structDefMatch = new RegExp(`struct\\s+${structName}\\s*{([^}]*)}`).exec(fullSrc);
      if (!structDefMatch)
        return;
      const properties = [];
      for (const defSrc of structDefMatch[1].split(";")) {
        const parts = defSrc.trim().split(/\s+|,/g);
        const typeName = parts.shift();
        const names = [...parts];
        const typeProperties = structProperties(typeName);
        for (const name of names) {
          properties.push({
            name,
            type: {
              typeName,
              qualifiers: [],
              properties: typeProperties
            }
          });
        }
      }
      return properties;
    };
    const parameters = parameterMatch[1].split(",").map((paramString) => {
      const parts = paramString.trim().split(/\s+/g);
      const name = parts.pop();
      const typeName = parts.pop();
      const qualifiers = [...parts];
      const properties = structProperties(typeName);
      return {
        name,
        type: {
          typeName,
          qualifiers,
          properties
        }
      };
    });
    return {
      name: functionName,
      returnType: {
        typeName: returnType,
        qualifiers: returnQualifiers,
        properties: structProperties(returnType)
      },
      parameters
    };
  }
  shaderSrc(src, shaderType) {
    const main = "void main";
    let [preMain, postMain] = src.split(main);
    let hooks2 = "";
    let defines = "";
    for (const key in this.hooks.uniforms) {
      hooks2 += `uniform ${key};
`;
    }
    if (this.hooks.declarations) {
      hooks2 += this.hooks.declarations + `
`;
    }
    if (this.hooks[shaderType].declarations) {
      hooks2 += this.hooks[shaderType].declarations + `
`;
    }
    for (const hookDef in this.hooks.helpers) {
      hooks2 += `${hookDef}${this.hooks.helpers[hookDef]}
`;
    }
    for (const hookDef in this.hooks[shaderType]) {
      if (hookDef === "declarations")
        continue;
      const [hookType, hookName] = hookDef.split(" ");
      if (this.hooks.modified[shaderType][hookDef]) {
        defines += "#define AUGMENTED_HOOK_" + hookName + `
`;
      }
      hooks2 += hookType + " HOOK_" + hookName + this.hooks[shaderType][hookDef] + `
`;
    }
    if (preMain.indexOf("#define HOOK_DEFINES") !== -1) {
      preMain = preMain.replace("#define HOOK_DEFINES", `
` + defines + `
`);
      defines = "";
    }
    return preMain + `
` + defines + hooks2 + main + postMain;
  }
  version() {
    const match = /#version (.+)$/.exec(this.vertSrc());
    if (match) {
      return match[1];
    } else {
      return "100 es";
    }
  }
  vertSrc() {
    return this.shaderSrc(this._vertSrc, "vertex");
  }
  fragSrc() {
    return this.shaderSrc(this._fragSrc, "fragment");
  }
  inspectHooks() {
    console.log("==== Vertex shader hooks: ====");
    for (const key in this.hooks.vertex) {
      console.log((this.hooks.modified.vertex[key] ? "[MODIFIED] " : "") + key + this.hooks.vertex[key]);
    }
    console.log("");
    console.log("==== Fragment shader hooks: ====");
    for (const key in this.hooks.fragment) {
      console.log((this.hooks.modified.fragment[key] ? "[MODIFIED] " : "") + key + this.hooks.fragment[key]);
    }
    console.log("");
    console.log("==== Helper functions: ====");
    for (const key in this.hooks.helpers) {
      console.log(key + this.hooks.helpers[key]);
    }
  }
  modify(hooks2) {
    const newHooks = {
      vertex: {},
      fragment: {},
      helpers: {}
    };
    for (const key in hooks2) {
      if (key === "declarations")
        continue;
      if (key === "uniforms")
        continue;
      if (key === "vertexDeclarations") {
        newHooks.vertex.declarations = (newHooks.vertex.declarations || "") + `
` + hooks2[key];
      } else if (key === "fragmentDeclarations") {
        newHooks.fragment.declarations = (newHooks.fragment.declarations || "") + `
` + hooks2[key];
      } else if (this.hooks.vertex[key]) {
        newHooks.vertex[key] = hooks2[key];
      } else if (this.hooks.fragment[key]) {
        newHooks.fragment[key] = hooks2[key];
      } else {
        newHooks.helpers[key] = hooks2[key];
      }
    }
    const modifiedVertex = Object.assign({}, this.hooks.modified.vertex);
    const modifiedFragment = Object.assign({}, this.hooks.modified.fragment);
    for (const key in newHooks.vertex || {}) {
      if (key === "declarations")
        continue;
      modifiedVertex[key] = true;
    }
    for (const key in newHooks.fragment || {}) {
      if (key === "declarations")
        continue;
      modifiedFragment[key] = true;
    }
    return new Shader(this._renderer, this._vertSrc, this._fragSrc, {
      declarations: (this.hooks.declarations || "") + `
` + (hooks2.declarations || ""),
      uniforms: Object.assign({}, this.hooks.uniforms, hooks2.uniforms || {}),
      fragment: Object.assign({}, this.hooks.fragment, newHooks.fragment || {}),
      vertex: Object.assign({}, this.hooks.vertex, newHooks.vertex || {}),
      helpers: Object.assign({}, this.hooks.helpers, newHooks.helpers || {}),
      modified: {
        vertex: modifiedVertex,
        fragment: modifiedFragment
      }
    });
  }
  init() {
    if (this._glProgram === 0) {
      const gl = this._renderer.GL;
      this._vertShader = gl.createShader(gl.VERTEX_SHADER);
      gl.shaderSource(this._vertShader, this.vertSrc());
      gl.compileShader(this._vertShader);
      if (!gl.getShaderParameter(this._vertShader, gl.COMPILE_STATUS)) {
        const glError = gl.getShaderInfoLog(this._vertShader);
        if (typeof IS_MINIFIED !== "undefined") {
          console.error(glError);
        } else {
          p5._friendlyError(`Yikes! An error occurred compiling the vertex shader:${glError}`);
          throw glError;
        }
        return null;
      }
      this._fragShader = gl.createShader(gl.FRAGMENT_SHADER);
      gl.shaderSource(this._fragShader, this.fragSrc());
      gl.compileShader(this._fragShader);
      if (!gl.getShaderParameter(this._fragShader, gl.COMPILE_STATUS)) {
        const glError = gl.getShaderInfoLog(this._fragShader);
        if (typeof IS_MINIFIED !== "undefined") {
          console.error(glError);
        } else {
          p5._friendlyError(`Darn! An error occurred compiling the fragment shader:${glError}`);
          throw glError;
        }
        return null;
      }
      this._glProgram = gl.createProgram();
      gl.attachShader(this._glProgram, this._vertShader);
      gl.attachShader(this._glProgram, this._fragShader);
      gl.linkProgram(this._glProgram);
      if (!gl.getProgramParameter(this._glProgram, gl.LINK_STATUS)) {
        p5._friendlyError(`Snap! Error linking shader program: ${gl.getProgramInfoLog(this._glProgram)}`);
      }
      this._loadAttributes();
      this._loadUniforms();
    }
    return this;
  }
  setDefaultUniforms() {
    for (const key in this.hooks.uniforms) {
      const [, name] = key.split(" ");
      const initializer = this.hooks.uniforms[key];
      let value;
      if (initializer instanceof Function) {
        value = initializer();
      } else {
        value = initializer;
      }
      if (value !== undefined && value !== null) {
        this.setUniform(name, value);
      }
    }
  }
  copyToContext(context) {
    const shader = new Shader(context._renderer, this._vertSrc, this._fragSrc);
    shader.ensureCompiledOnContext(context._renderer);
    return shader;
  }
  ensureCompiledOnContext(context) {
    if (this._glProgram !== 0 && this._renderer !== context) {
      throw new Error("The shader being run is attached to a different context. Do you need to copy it to this context first with .copyToContext()?");
    } else if (this._glProgram === 0) {
      this._renderer = context?._renderer?.filterRenderer?._renderer || context;
      this.init();
    }
  }
  _loadAttributes() {
    if (this._loadedAttributes) {
      return;
    }
    this.attributes = {};
    const gl = this._renderer.GL;
    const numAttributes = gl.getProgramParameter(this._glProgram, gl.ACTIVE_ATTRIBUTES);
    for (let i = 0;i < numAttributes; ++i) {
      const attributeInfo = gl.getActiveAttrib(this._glProgram, i);
      const name = attributeInfo.name;
      const location2 = gl.getAttribLocation(this._glProgram, name);
      const attribute = {};
      attribute.name = name;
      attribute.location = location2;
      attribute.index = i;
      attribute.type = attributeInfo.type;
      attribute.size = attributeInfo.size;
      this.attributes[name] = attribute;
    }
    this._loadedAttributes = true;
  }
  _loadUniforms() {
    if (this._loadedUniforms) {
      return;
    }
    const gl = this._renderer.GL;
    const numUniforms = gl.getProgramParameter(this._glProgram, gl.ACTIVE_UNIFORMS);
    let samplerIndex = 0;
    for (let i = 0;i < numUniforms; ++i) {
      const uniformInfo = gl.getActiveUniform(this._glProgram, i);
      const uniform = {};
      uniform.location = gl.getUniformLocation(this._glProgram, uniformInfo.name);
      uniform.size = uniformInfo.size;
      let uniformName = uniformInfo.name;
      if (uniformInfo.size > 1) {
        uniformName = uniformName.substring(0, uniformName.indexOf("[0]"));
      }
      uniform.name = uniformName;
      uniform.type = uniformInfo.type;
      uniform._cachedData = undefined;
      if (uniform.type === gl.SAMPLER_2D) {
        uniform.samplerIndex = samplerIndex;
        samplerIndex++;
        this.samplers.push(uniform);
      }
      uniform.isArray = uniformInfo.size > 1 || uniform.type === gl.FLOAT_MAT3 || uniform.type === gl.FLOAT_MAT4 || uniform.type === gl.FLOAT_VEC2 || uniform.type === gl.FLOAT_VEC3 || uniform.type === gl.FLOAT_VEC4 || uniform.type === gl.INT_VEC2 || uniform.type === gl.INT_VEC4 || uniform.type === gl.INT_VEC3;
      this.uniforms[uniformName] = uniform;
    }
    this._loadedUniforms = true;
  }
  compile() {}
  bindShader() {
    this.init();
    if (!this._bound) {
      this.useProgram();
      this._bound = true;
    }
  }
  unbindShader() {
    if (this._bound) {
      this.unbindTextures();
      this._bound = false;
    }
    return this;
  }
  bindTextures() {
    const gl = this._renderer.GL;
    const empty = this._renderer._getEmptyTexture();
    for (const uniform of this.samplers) {
      let tex = uniform.texture;
      if (tex === undefined || false) {
        uniform.texture = tex = empty;
      }
      gl.activeTexture(gl.TEXTURE0 + uniform.samplerIndex);
      tex.bindTexture();
      tex.update();
      gl.uniform1i(uniform.location, uniform.samplerIndex);
    }
  }
  updateTextures() {
    for (const uniform of this.samplers) {
      const tex = uniform.texture;
      if (tex) {
        tex.update();
      }
    }
  }
  unbindTextures() {
    const gl = this._renderer.GL;
    const empty = this._renderer._getEmptyTexture();
    for (const uniform of this.samplers) {
      if (uniform.texture?.isFramebufferTexture) {
        gl.activeTexture(gl.TEXTURE0 + uniform.samplerIndex);
        empty.bindTexture();
        gl.uniform1i(uniform.location, uniform.samplerIndex);
      }
    }
  }
  useProgram() {
    const gl = this._renderer.GL;
    if (this._renderer._curShader !== this) {
      gl.useProgram(this._glProgram);
      this._renderer._curShader = this;
    }
    return this;
  }
  setUniform(uniformName, data) {
    this.init();
    const uniform = this.uniforms[uniformName];
    if (!uniform) {
      return;
    }
    const gl = this._renderer.GL;
    if (uniform.isArray) {
      if (uniform._cachedData && this._renderer._arraysEqual(uniform._cachedData, data)) {
        return;
      } else {
        uniform._cachedData = data.slice(0);
      }
    } else if (uniform._cachedData && uniform._cachedData === data) {
      return;
    } else {
      if (Array.isArray(data)) {
        uniform._cachedData = data.slice(0);
      } else {
        uniform._cachedData = data;
      }
    }
    const location2 = uniform.location;
    this.useProgram();
    switch (uniform.type) {
      case gl.BOOL:
        if (data === true) {
          gl.uniform1i(location2, 1);
        } else {
          gl.uniform1i(location2, 0);
        }
        break;
      case gl.INT:
        if (uniform.size > 1) {
          data.length && gl.uniform1iv(location2, data);
        } else {
          gl.uniform1i(location2, data);
        }
        break;
      case gl.FLOAT:
        if (uniform.size > 1) {
          data.length && gl.uniform1fv(location2, data);
        } else {
          gl.uniform1f(location2, data);
        }
        break;
      case gl.FLOAT_MAT3:
        gl.uniformMatrix3fv(location2, false, data);
        break;
      case gl.FLOAT_MAT4:
        gl.uniformMatrix4fv(location2, false, data);
        break;
      case gl.FLOAT_VEC2:
        if (uniform.size > 1) {
          data.length && gl.uniform2fv(location2, data);
        } else {
          gl.uniform2f(location2, data[0], data[1]);
        }
        break;
      case gl.FLOAT_VEC3:
        if (uniform.size > 1) {
          data.length && gl.uniform3fv(location2, data);
        } else {
          gl.uniform3f(location2, data[0], data[1], data[2]);
        }
        break;
      case gl.FLOAT_VEC4:
        if (uniform.size > 1) {
          data.length && gl.uniform4fv(location2, data);
        } else {
          gl.uniform4f(location2, data[0], data[1], data[2], data[3]);
        }
        break;
      case gl.INT_VEC2:
        if (uniform.size > 1) {
          data.length && gl.uniform2iv(location2, data);
        } else {
          gl.uniform2i(location2, data[0], data[1]);
        }
        break;
      case gl.INT_VEC3:
        if (uniform.size > 1) {
          data.length && gl.uniform3iv(location2, data);
        } else {
          gl.uniform3i(location2, data[0], data[1], data[2]);
        }
        break;
      case gl.INT_VEC4:
        if (uniform.size > 1) {
          data.length && gl.uniform4iv(location2, data);
        } else {
          gl.uniform4i(location2, data[0], data[1], data[2], data[3]);
        }
        break;
      case gl.SAMPLER_2D:
        if (typeof data == "number") {
          if (data < gl.TEXTURE0 || data > gl.TEXTURE31 || data !== Math.ceil(data)) {
            console.log("\uD83C\uDF38 p5.js says: " + "You're trying to use a number as the data for a texture." + "Please use a texture.");
            return this;
          }
          gl.activeTexture(data);
          gl.uniform1i(location2, data);
        } else {
          gl.activeTexture(gl.TEXTURE0 + uniform.samplerIndex);
          uniform.texture = data instanceof Texture ? data : this._renderer.getTexture(data);
          gl.uniform1i(location2, uniform.samplerIndex);
          if (uniform.texture.src.gifProperties) {
            uniform.texture.src._animateGif(this._renderer._pInst);
          }
        }
        break;
      case gl.SAMPLER_CUBE:
      case gl.SAMPLER_3D:
      case gl.SAMPLER_2D_SHADOW:
      case gl.SAMPLER_2D_ARRAY:
      case gl.SAMPLER_2D_ARRAY_SHADOW:
      case gl.SAMPLER_CUBE_SHADOW:
      case gl.INT_SAMPLER_2D:
      case gl.INT_SAMPLER_3D:
      case gl.INT_SAMPLER_CUBE:
      case gl.INT_SAMPLER_2D_ARRAY:
      case gl.UNSIGNED_INT_SAMPLER_2D:
      case gl.UNSIGNED_INT_SAMPLER_3D:
      case gl.UNSIGNED_INT_SAMPLER_CUBE:
      case gl.UNSIGNED_INT_SAMPLER_2D_ARRAY:
        if (typeof data !== "number") {
          break;
        }
        if (data < gl.TEXTURE0 || data > gl.TEXTURE31 || data !== Math.ceil(data)) {
          console.log("\uD83C\uDF38 p5.js says: " + "You're trying to use a number as the data for a texture." + "Please use a texture.");
          break;
        }
        gl.activeTexture(data);
        gl.uniform1i(location2, data);
        break;
    }
    return this;
  }
  enableAttrib(attr, size, type2, normalized, stride, offset) {
    if (attr) {
      if (typeof IS_MINIFIED === "undefined" && this.attributes[attr.name] !== attr) {
        console.warn(`The attribute "${attr.name}"passed to enableAttrib does not belong to this shader.`);
      }
      const loc = attr.location;
      if (loc !== -1) {
        const gl = this._renderer.GL;
        if (!this._renderer.registerEnabled.has(loc)) {
          gl.enableVertexAttribArray(loc);
          this._renderer.registerEnabled.add(loc);
        }
        this._renderer.GL.vertexAttribPointer(loc, size, type2 || gl.FLOAT, normalized || false, stride || 0, offset || 0);
      }
    }
    return this;
  }
  disableRemainingAttributes() {
    for (const location2 of this._renderer.registerEnabled.values()) {
      if (!Object.keys(this.attributes).some((key) => this.attributes[key].location === location2)) {
        this._renderer.GL.disableVertexAttribArray(location2);
        this._renderer.registerEnabled.delete(location2);
      }
    }
  }
}
function shader(p52, fn2) {
  p52.Shader = Shader;
}
if (typeof p5 !== "undefined") {
  shader(p5, p5.prototype);
}
var filterBaseVert = `precision highp int;

uniform mat4 uModelViewMatrix;
uniform mat4 uProjectionMatrix;

IN vec3 aPosition;
IN vec2 aTexCoord;
OUT vec2 vTexCoord;

void main() {
  // transferring texcoords for the frag shader
  vTexCoord = aTexCoord;

  // copy position with a fourth coordinate for projection (1.0 is normal)
  vec4 positionVec4 = vec4(aPosition, 1.0);

  // project to 3D space
  gl_Position = uProjectionMatrix * uModelViewMatrix * positionVec4;
}
`;
var lightingShader = `#define PI 3.141592

precision highp float;
precision highp int;

uniform mat4 uViewMatrix;

uniform bool uUseLighting;

uniform int uAmbientLightCount;
uniform vec3 uAmbientColor[5];
uniform mat3 uCameraRotation;
uniform int uDirectionalLightCount;
uniform vec3 uLightingDirection[5];
uniform vec3 uDirectionalDiffuseColors[5];
uniform vec3 uDirectionalSpecularColors[5];

uniform int uPointLightCount;
uniform vec3 uPointLightLocation[5];
uniform vec3 uPointLightDiffuseColors[5];	
uniform vec3 uPointLightSpecularColors[5];

uniform int uSpotLightCount;
uniform float uSpotLightAngle[5];
uniform float uSpotLightConc[5];
uniform vec3 uSpotLightDiffuseColors[5];
uniform vec3 uSpotLightSpecularColors[5];
uniform vec3 uSpotLightLocation[5];
uniform vec3 uSpotLightDirection[5];

uniform bool uSpecular;
uniform float uShininess;
uniform float uMetallic;

uniform float uConstantAttenuation;
uniform float uLinearAttenuation;
uniform float uQuadraticAttenuation;

// setting from  _setImageLightUniforms()
// boolean to initiate the calculateImageDiffuse and calculateImageSpecular
uniform bool uUseImageLight;
// texture for use in calculateImageDiffuse
uniform sampler2D environmentMapDiffused;
// texture for use in calculateImageSpecular
uniform sampler2D environmentMapSpecular;

const float specularFactor = 2.0;
const float diffuseFactor = 0.73;

struct LightResult {
  float specular;
  float diffuse;
};

float _phongSpecular(
  vec3 lightDirection,
  vec3 viewDirection,
  vec3 surfaceNormal,
  float shininess) {

  vec3 R = reflect(lightDirection, surfaceNormal);
  return pow(max(0.0, dot(R, viewDirection)), shininess);
}

float _lambertDiffuse(vec3 lightDirection, vec3 surfaceNormal) {
  return max(0.0, dot(-lightDirection, surfaceNormal));
}

LightResult _light(vec3 viewDirection, vec3 normal, vec3 lightVector, float shininess, float metallic) {

  vec3 lightDir = normalize(lightVector);

  //compute our diffuse & specular terms
  LightResult lr;
  float specularIntensity = mix(1.0, 0.4, metallic);
  float diffuseIntensity = mix(1.0, 0.1, metallic);
  if (uSpecular)
    lr.specular = (_phongSpecular(lightDir, viewDirection, normal, shininess)) * specularIntensity;
    lr.diffuse = _lambertDiffuse(lightDir, normal) * diffuseIntensity;
  return lr;
}

// converts the range of "value" from [min1 to max1] to [min2 to max2]
float map(float value, float min1, float max1, float min2, float max2) {
  return min2 + (value - min1) * (max2 - min2) / (max1 - min1);
}

vec2 mapTextureToNormal( vec3 v ){
  // x = r sin(phi) cos(theta)   
  // y = r cos(phi)  
  // z = r sin(phi) sin(theta)
  float phi = acos( v.y );
  // if phi is 0, then there are no x, z components
  float theta = 0.0;
  // else 
  theta = acos(v.x / sin(phi));
  float sinTheta = v.z / sin(phi);
  if (sinTheta < 0.0) {
    // Turn it into -theta, but in the 0-2PI range
    theta = 2.0 * PI - theta;
  }
  theta = theta / (2.0 * 3.14159);
  phi = phi / 3.14159 ;
  
  vec2 angles = vec2( fract(theta + 0.25), 1.0 - phi );
  return angles;
}


vec3 calculateImageDiffuse(vec3 vNormal, vec3 vViewPosition, float metallic){
  // make 2 seperate builds 
  vec3 worldCameraPosition =  vec3(0.0, 0.0, 0.0);  // hardcoded world camera position
  vec3 worldNormal = normalize(vNormal * uCameraRotation);
  vec2 newTexCoor = mapTextureToNormal( worldNormal );
  vec4 texture = TEXTURE( environmentMapDiffused, newTexCoor );
  // this is to make the darker sections more dark
  // png and jpg usually flatten the brightness so it is to reverse that
  return mix(smoothstep(vec3(0.0), vec3(1.0), texture.xyz), vec3(0.0), metallic);
}

vec3 calculateImageSpecular(vec3 vNormal, vec3 vViewPosition, float shininess, float metallic){
  vec3 worldCameraPosition =  vec3(0.0, 0.0, 0.0);
  vec3 worldNormal = normalize(vNormal);
  vec3 lightDirection = normalize( vViewPosition - worldCameraPosition );
  vec3 R = reflect(lightDirection, worldNormal) * uCameraRotation;
  vec2 newTexCoor = mapTextureToNormal( R );
#ifdef WEBGL2
  // In p5js the range of shininess is >= 1,
  // Therefore roughness range will be ([0,1]*8)*20 or [0, 160]
  // The factor of 8 is because currently the getSpecularTexture
  // only calculated 8 different levels of roughness
  // The factor of 20 is just to spread up this range so that,
  // [1, max] of shininess is converted to [0,160] of roughness
  float roughness = 20. / shininess;
  vec4 outColor = textureLod(environmentMapSpecular, newTexCoor, roughness * 8.);
#else
  vec4 outColor = TEXTURE(environmentMapSpecular, newTexCoor);
#endif
  // this is to make the darker sections more dark
  // png and jpg usually flatten the brightness so it is to reverse that
  return mix(
    pow(outColor.xyz, vec3(10)),
    pow(outColor.xyz, vec3(1.2)),
    metallic 
  );
}

void totalLight(
  vec3 modelPosition,
  vec3 normal,
  float shininess,
  float metallic,
  out vec3 totalDiffuse,
  out vec3 totalSpecular
) {

  totalSpecular = vec3(0.0);

  if (!uUseLighting) {
    totalDiffuse = vec3(1.0);
    return;
  }

  totalDiffuse = vec3(0.0);

  vec3 viewDirection = normalize(-modelPosition);

  for (int j = 0; j < 5; j++) {
    if (j < uDirectionalLightCount) {
      vec3 lightVector = (uViewMatrix * vec4(uLightingDirection[j], 0.0)).xyz;
      vec3 lightColor = uDirectionalDiffuseColors[j];
      vec3 specularColor = uDirectionalSpecularColors[j];
      LightResult result = _light(viewDirection, normal, lightVector, shininess, metallic);
      totalDiffuse += result.diffuse * lightColor;
      totalSpecular += result.specular * lightColor * specularColor;
    }

    if (j < uPointLightCount) {
      vec3 lightPosition = (uViewMatrix * vec4(uPointLightLocation[j], 1.0)).xyz;
      vec3 lightVector = modelPosition - lightPosition;
      //calculate attenuation
      float lightDistance = length(lightVector);
      float lightFalloff = 1.0 / (uConstantAttenuation + lightDistance * uLinearAttenuation + (lightDistance * lightDistance) * uQuadraticAttenuation);
      vec3 lightColor = lightFalloff * uPointLightDiffuseColors[j];
      vec3 specularColor = lightFalloff * uPointLightSpecularColors[j];

      LightResult result = _light(viewDirection, normal, lightVector, shininess, metallic);
      totalDiffuse += result.diffuse * lightColor;
      totalSpecular += result.specular * lightColor * specularColor;
    }

    if(j < uSpotLightCount) {
      vec3 lightPosition = (uViewMatrix * vec4(uSpotLightLocation[j], 1.0)).xyz;
      vec3 lightVector = modelPosition - lightPosition;
    
      float lightDistance = length(lightVector);
      float lightFalloff = 1.0 / (uConstantAttenuation + lightDistance * uLinearAttenuation + (lightDistance * lightDistance) * uQuadraticAttenuation);

      vec3 lightDirection = (uViewMatrix * vec4(uSpotLightDirection[j], 0.0)).xyz;
      float spotDot = dot(normalize(lightVector), normalize(lightDirection));
      float spotFalloff;
      if(spotDot < uSpotLightAngle[j]) {
        spotFalloff = 0.0;
      }
      else {
        spotFalloff = pow(spotDot, uSpotLightConc[j]);
      }
      lightFalloff *= spotFalloff;

      vec3 lightColor = uSpotLightDiffuseColors[j];
      vec3 specularColor = uSpotLightSpecularColors[j];
     
      LightResult result = _light(viewDirection, normal, lightVector, shininess, metallic);
      
      totalDiffuse += result.diffuse * lightColor * lightFalloff;
      totalSpecular += result.specular * lightColor * specularColor * lightFalloff;
    }
  }

  if( uUseImageLight ){
    totalDiffuse += calculateImageDiffuse(normal, modelPosition, metallic);
    totalSpecular += calculateImageSpecular(normal, modelPosition, shininess, metallic);
  }

  totalDiffuse *= diffuseFactor;
  totalSpecular *= specularFactor;
}
`;
var webgl2CompatibilityShader = `#ifdef WEBGL2

#define IN in
#define OUT out

#ifdef FRAGMENT_SHADER
out vec4 outColor;
#define OUT_COLOR outColor
#endif
#define TEXTURE texture

#else

#ifdef FRAGMENT_SHADER
#define IN varying
#else
#define IN attribute
#endif
#define OUT varying
#define TEXTURE texture2D

#ifdef FRAGMENT_SHADER
#define OUT_COLOR gl_FragColor
#endif

#endif

#ifdef FRAGMENT_SHADER
vec4 getTexture(in sampler2D content, vec2 coord) {
  vec4 color = TEXTURE(content, coord);
  color.rgb /= color.a;
  return color;
}
#endif
`;
var normalVert = `IN vec3 aPosition;
IN vec3 aNormal;
IN vec2 aTexCoord;
IN vec4 aVertexColor;

#define HOOK_DEFINES

#ifdef AUGMENTED_HOOK_getWorldInputs
uniform mat4 uModelMatrix;
uniform mat4 uViewMatrix;
uniform mat3 uModelNormalMatrix;
uniform mat3 uCameraNormalMatrix;
#else
uniform mat4 uModelViewMatrix;
uniform mat3 uNormalMatrix;
#endif
uniform mat4 uProjectionMatrix;

uniform vec4 uMaterialColor;
uniform bool uUseVertexColor;

OUT vec3 vVertexNormal;
OUT highp vec2 vVertTexCoord;
OUT vec4 vColor;

struct Vertex {
  vec3 position;
  vec3 normal;
  vec2 texCoord;
  vec4 color;
};

void main(void) {
  HOOK_beforeVertex();

  Vertex inputs;
  inputs.position = aPosition;
  inputs.normal = aNormal;
  inputs.texCoord = aTexCoord;
  inputs.color = (uUseVertexColor && aVertexColor.x >= 0.0) ? aVertexColor : uMaterialColor;
#ifdef AUGMENTED_HOOK_getObjectInputs
  inputs = HOOK_getObjectInputs(inputs);
#endif

#ifdef AUGMENTED_HOOK_getWorldInputs
  inputs.position = (uModelMatrix * vec4(inputs.position, 1.)).xyz;
  inputs.normal = uModelNormalMatrix * inputs.normal;
  inputs = HOOK_getWorldInputs(inputs);
#endif

#ifdef AUGMENTED_HOOK_getWorldInputs
  // Already multiplied by the model matrix, just apply view
  inputs.position = (uViewMatrix * vec4(inputs.position, 1.)).xyz;
  inputs.normal = uCameraNormalMatrix * inputs.normal;
#else
  // Apply both at once
  inputs.position = (uModelViewMatrix * vec4(inputs.position, 1.)).xyz;
  inputs.normal = uNormalMatrix * inputs.normal;
#endif
#ifdef AUGMENTED_HOOK_getCameraInputs
  inputs = HOOK_getCameraInputs(inputs);
#endif

  // Pass varyings to fragment shader
  vVertTexCoord = inputs.texCoord;
  vVertexNormal = normalize(inputs.normal);
  vColor = inputs.color;

  gl_Position = uProjectionMatrix * vec4(inputs.position, 1.);

  HOOK_afterVertex();
}
`;
var normalFrag = `IN vec3 vVertexNormal;
void main(void) {
  HOOK_beforeFragment();
  OUT_COLOR = HOOK_getFinalColor(vec4(vVertexNormal, 1.0));
  HOOK_afterFragment();
}
`;
var basicFrag = `IN vec4 vColor;
void main(void) {
  HOOK_beforeFragment();
  OUT_COLOR = HOOK_getFinalColor(vec4(vColor.rgb, 1.) * vColor.a);
  HOOK_afterFragment();
}
`;
var sphereMappingFrag = `#define PI 3.141592

precision highp float;
  
uniform sampler2D uEnvMap;
uniform mat3 uNewNormalMatrix;
uniform float uFovY;
uniform float uAspect;

varying vec2 vTexCoord;
  
void main() {
    float uFovX = uFovY * uAspect; 
    float angleY = mix(uFovY/2.0,  -uFovY/2.0, vTexCoord.y);
    float angleX = mix(uFovX/2.0, -uFovX/2.0, vTexCoord.x);
    vec3 rotatedNormal = vec3( angleX, angleY, 1.0 );
    rotatedNormal = uNewNormalMatrix * normalize(rotatedNormal);
    float temp = rotatedNormal.z;
    rotatedNormal.z = rotatedNormal.x;
    rotatedNormal.x = -temp;
    vec2 suv;
    suv.y = 0.5 + 0.5 * (-rotatedNormal.y);
    suv.x = atan(rotatedNormal.z, rotatedNormal.x) / (2.0 * PI) + 0.5;
    vec4 newTexColor = texture2D(uEnvMap, suv.xy);
    gl_FragColor = newTexColor;
}
`;
var lightVert = `// include lighting.glgl

IN vec3 aPosition;
IN vec3 aNormal;
IN vec2 aTexCoord;
IN vec4 aVertexColor;

uniform mat4 uModelViewMatrix;
uniform mat4 uProjectionMatrix;
uniform mat3 uNormalMatrix;

uniform bool uUseVertexColor;
uniform vec4 uMaterialColor;

OUT highp vec2 vVertTexCoord;
OUT vec3 vDiffuseColor;
OUT vec3 vSpecularColor;
OUT vec4 vColor;

void main(void) {

  vec4 viewModelPosition = uModelViewMatrix * vec4(aPosition, 1.0);
  gl_Position = uProjectionMatrix * viewModelPosition;

  vec3 vertexNormal = normalize(uNormalMatrix * aNormal);
  vVertTexCoord = aTexCoord;

  totalLight(viewModelPosition.xyz, vertexNormal, vDiffuseColor, vSpecularColor);

  for (int i = 0; i < 8; i++) {
    if (i < uAmbientLightCount) {
      vDiffuseColor += uAmbientColor[i];
    }
  }
  
  vColor = ((uUseVertexColor && aVertexColor.x >= 0.0) ? aVertexColor : uMaterialColor);
}
`;
var lightTextureFrag = `uniform vec4 uTint;
uniform sampler2D uSampler;
uniform bool isTexture;
uniform bool uEmissive;

IN highp vec2 vVertTexCoord;
IN vec3 vDiffuseColor;
IN vec3 vSpecularColor;
IN vec4 vColor;

void main(void) {
  if(uEmissive && !isTexture) {
    OUT_COLOR = vColor;
  }
  else {
    vec4 baseColor = isTexture
      // Textures come in with premultiplied alpha. To apply tint and still have
      // premultiplied alpha output, we need to multiply the RGB channels by the
      // tint RGB, and all channels by the tint alpha.
      ? TEXTURE(uSampler, vVertTexCoord) * vec4(uTint.rgb/255., 1.) * (uTint.a/255.)
      // Colors come in with unmultiplied alpha, so we need to multiply the RGB
      // channels by alpha to convert it to premultiplied alpha.
      : vec4(vColor.rgb * vColor.a, vColor.a);
    OUT_COLOR = vec4(baseColor.rgb * vDiffuseColor + vSpecularColor, baseColor.a);
  }
}
`;
var phongVert = `precision highp int;

#define HOOK_DEFINES

IN vec3 aPosition;
IN vec3 aNormal;
IN vec2 aTexCoord;
IN vec4 aVertexColor;

uniform vec3 uAmbientColor[5];

#ifdef AUGMENTED_HOOK_getWorldInputs
uniform mat4 uModelMatrix;
uniform mat4 uViewMatrix;
uniform mat3 uModelNormalMatrix;
uniform mat3 uCameraNormalMatrix;
#else
uniform mat4 uModelViewMatrix;
uniform mat3 uNormalMatrix;
#endif
uniform mat4 uProjectionMatrix;
uniform int uAmbientLightCount;

uniform bool uUseVertexColor;
uniform vec4 uMaterialColor;

OUT vec3 vNormal;
OUT vec2 vTexCoord;
OUT vec3 vViewPosition;
OUT vec3 vAmbientColor;
OUT vec4 vColor;

struct Vertex {
  vec3 position;
  vec3 normal;
  vec2 texCoord;
  vec4 color;
};

void main(void) {
  HOOK_beforeVertex();

  Vertex inputs;
  inputs.position = aPosition;
  inputs.normal = aNormal;
  inputs.texCoord = aTexCoord;
  inputs.color = (uUseVertexColor && aVertexColor.x >= 0.0) ? aVertexColor : uMaterialColor;
#ifdef AUGMENTED_HOOK_getObjectInputs
  inputs = HOOK_getObjectInputs(inputs);
#endif

#ifdef AUGMENTED_HOOK_getWorldInputs
  inputs.position = (uModelMatrix * vec4(inputs.position, 1.)).xyz;
  inputs.normal = uModelNormalMatrix * inputs.normal;
  inputs = HOOK_getWorldInputs(inputs);
#endif

#ifdef AUGMENTED_HOOK_getWorldInputs
  // Already multiplied by the model matrix, just apply view
  inputs.position = (uViewMatrix * vec4(inputs.position, 1.)).xyz;
  inputs.normal = uCameraNormalMatrix * inputs.normal;
#else
  // Apply both at once
  inputs.position = (uModelViewMatrix * vec4(inputs.position, 1.)).xyz;
  inputs.normal = uNormalMatrix * inputs.normal;
#endif
#ifdef AUGMENTED_HOOK_getCameraInputs
  inputs = HOOK_getCameraInputs(inputs);
#endif

  // Pass varyings to fragment shader
  vViewPosition = inputs.position;
  vTexCoord = inputs.texCoord;
  vNormal = inputs.normal;
  vColor = inputs.color;

  // TODO: this should be a uniform
  vAmbientColor = vec3(0.0);
  for (int i = 0; i < 5; i++) {
    if (i < uAmbientLightCount) {
      vAmbientColor += uAmbientColor[i];
    }
  }

  gl_Position = uProjectionMatrix * vec4(inputs.position, 1.);
  HOOK_afterVertex();
}
`;
var phongFrag = `// include lighting.glsl
precision highp int;

uniform bool uHasSetAmbient;
uniform vec4 uSpecularMatColor;
uniform vec4 uAmbientMatColor;
uniform vec4 uEmissiveMatColor;

uniform vec4 uTint;
uniform sampler2D uSampler;
uniform bool isTexture;

IN vec3 vNormal;
IN vec2 vTexCoord;
IN vec3 vViewPosition;
IN vec3 vAmbientColor;
IN vec4 vColor;

struct ColorComponents {
  vec3 baseColor;
  float opacity;
  vec3 ambientColor;
  vec3 specularColor;
  vec3 diffuse;
  vec3 ambient;
  vec3 specular;
  vec3 emissive;
};

struct Inputs {
  vec3 normal;
  vec2 texCoord;
  vec3 ambientLight;
  vec3 ambientMaterial;
  vec3 specularMaterial;
  vec3 emissiveMaterial;
  vec4 color;
  float shininess;
  float metalness;
};

void main(void) {
  HOOK_beforeFragment();

  Inputs inputs;
  inputs.normal = normalize(vNormal);
  inputs.texCoord = vTexCoord;
  inputs.ambientLight = vAmbientColor;
  inputs.color = isTexture
      ? TEXTURE(uSampler, vTexCoord) * (vec4(uTint.rgb/255., 1.) * uTint.a/255.)
      : vColor;
  if (isTexture && inputs.color.a > 0.0) {
    // Textures come in with premultiplied alpha. Temporarily unpremultiply it
    // so hooks users don't have to think about premultiplied alpha.
    inputs.color.rgb /= inputs.color.a;
  }
  inputs.shininess = uShininess;
  inputs.metalness = uMetallic;
  inputs.ambientMaterial = uHasSetAmbient ? uAmbientMatColor.rgb : inputs.color.rgb;
  inputs.specularMaterial = uSpecularMatColor.rgb;
  inputs.emissiveMaterial = uEmissiveMatColor.rgb;
  inputs = HOOK_getPixelInputs(inputs);

  vec3 diffuse;
  vec3 specular;
  totalLight(vViewPosition, inputs.normal, inputs.shininess, inputs.metalness, diffuse, specular);

  // Calculating final color as result of all lights (plus emissive term).

  vec2 texCoord = inputs.texCoord;
  vec4 baseColor = inputs.color;
  ColorComponents c;
  c.opacity = baseColor.a;
  c.baseColor = baseColor.rgb;
  c.ambientColor = inputs.ambientMaterial;
  c.specularColor = inputs.specularMaterial;
  c.diffuse = diffuse;
  c.ambient = inputs.ambientLight;
  c.specular = specular;
  c.emissive = inputs.emissiveMaterial;
  OUT_COLOR = HOOK_getFinalColor(HOOK_combineColors(c));
  OUT_COLOR.rgb *= OUT_COLOR.a; // Premultiply alpha before rendering
  HOOK_afterFragment();
}
`;
var fontVert = `IN vec3 aPosition;
IN vec2 aTexCoord;
uniform mat4 uModelViewMatrix;
uniform mat4 uProjectionMatrix;

uniform vec4 uGlyphRect;
uniform float uGlyphOffset;

OUT vec2 vTexCoord;
OUT float w;

void main() {
  vec4 positionVec4 = vec4(aPosition, 1.0);

  // scale by the size of the glyph's rectangle
  positionVec4.xy *= uGlyphRect.zw - uGlyphRect.xy;

  // Expand glyph bounding boxes by 1px on each side to give a bit of room
  // for antialiasing
  vec3 newOrigin = (uModelViewMatrix * vec4(0., 0., 0., 1.)).xyz;
  vec3 newDX = (uModelViewMatrix * vec4(1., 0., 0., 1.)).xyz;
  vec3 newDY = (uModelViewMatrix * vec4(0., 1., 0., 1.)).xyz;
  vec2 pixelScale = vec2(
    1. / length(newOrigin - newDX),
    1. / length(newOrigin - newDY)
  );
  vec2 offset = pixelScale * normalize(aTexCoord - vec2(0.5, 0.5));
  vec2 textureOffset = offset * (1. / vec2(
    uGlyphRect.z - uGlyphRect.x,
    uGlyphRect.w - uGlyphRect.y
  ));

  // move to the corner of the glyph
  positionVec4.xy += uGlyphRect.xy;

  // move to the letter's line offset
  positionVec4.x += uGlyphOffset;

  positionVec4.xy += offset;
  
  gl_Position = uProjectionMatrix * uModelViewMatrix * positionVec4;
  vTexCoord = aTexCoord + textureOffset;
  w = gl_Position.w;
}
`;
var fontFrag = `#ifndef WEBGL2
#extension GL_OES_standard_derivatives : enable
#endif

#if 0
  // simulate integer math using floats
	#define int float
	#define ivec2 vec2
	#define INT(x) float(x)

	int ifloor(float v) { return floor(v); }
	ivec2 ifloor(vec2 v) { return floor(v); }

#else
  // use native integer math
	precision highp int;
	#define INT(x) x

	int ifloor(float v) { return int(v); }
	int ifloor(int v) { return v; }
	ivec2 ifloor(vec2 v) { return ivec2(v); }

#endif

uniform sampler2D uSamplerStrokes;
uniform sampler2D uSamplerRowStrokes;
uniform sampler2D uSamplerRows;
uniform sampler2D uSamplerColStrokes;
uniform sampler2D uSamplerCols;

uniform ivec2 uStrokeImageSize;
uniform ivec2 uCellsImageSize;
uniform ivec2 uGridImageSize;

uniform ivec2 uGridOffset;
uniform ivec2 uGridSize;
uniform vec4 uMaterialColor;

IN vec2 vTexCoord;

// some helper functions
int ROUND(float v) { return ifloor(v + 0.5); }
ivec2 ROUND(vec2 v) { return ifloor(v + 0.5); }
float saturate(float v) { return clamp(v, 0.0, 1.0); }
vec2 saturate(vec2 v) { return clamp(v, 0.0, 1.0); }

int mul(float v1, int v2) {
  return ifloor(v1 * float(v2));
}

ivec2 mul(vec2 v1, ivec2 v2) {
  return ifloor(v1 * vec2(v2) + 0.5);
}

// unpack a 16-bit integer from a float vec2
int getInt16(vec2 v) {
  ivec2 iv = ROUND(v * 255.0);
  return iv.x * INT(128) + iv.y;
}

vec2 pixelScale;
vec2 coverage = vec2(0.0);
vec2 weight = vec2(0.5);
const float minDistance = 1.0/8192.0;
const float hardness = 1.05; // amount of antialias

// the maximum number of curves in a glyph
const int N = INT(250);

// retrieves an indexed pixel from a sampler
vec4 getTexel(sampler2D sampler, int pos, ivec2 size) {
  int width = size.x;
  int y = ifloor(pos / width);
  int x = pos - y * width;  // pos % width

  return TEXTURE(sampler, (vec2(x, y) + 0.5) / vec2(size));
}

void calulateCrossings(vec2 p0, vec2 p1, vec2 p2, out vec2 C1, out vec2 C2) {

  // get the coefficients of the quadratic in t
  vec2 a = p0 - p1 * 2.0 + p2;
  vec2 b = p0 - p1;
  vec2 c = p0 - vTexCoord;

  // found out which values of 't' it crosses the axes
  vec2 surd = sqrt(max(vec2(0.0), b * b - a * c));
  vec2 t1 = ((b - surd) / a).yx;
  vec2 t2 = ((b + surd) / a).yx;

  // approximate straight lines to avoid rounding errors
  if (abs(a.y) < 0.001)
    t1.x = t2.x = c.y / (2.0 * b.y);

  if (abs(a.x) < 0.001)
    t1.y = t2.y = c.x / (2.0 * b.x);

  // plug into quadratic formula to find the corrdinates of the crossings
  C1 = ((a * t1 - b * 2.0) * t1 + c) * pixelScale;
  C2 = ((a * t2 - b * 2.0) * t2 + c) * pixelScale;
}

void coverageX(vec2 p0, vec2 p1, vec2 p2) {

  vec2 C1, C2;
  calulateCrossings(p0, p1, p2, C1, C2);

  // determine on which side of the x-axis the points lie
  bool y0 = p0.y > vTexCoord.y;
  bool y1 = p1.y > vTexCoord.y;
  bool y2 = p2.y > vTexCoord.y;

  // could web be under the curve (after t1)?
  if (y1 ? !y2 : y0) {
    // add the coverage for t1
    coverage.x += saturate(C1.x + 0.5);
    // calculate the anti-aliasing for t1
    weight.x = min(weight.x, abs(C1.x));
  }

  // are we outside the curve (after t2)?
  if (y1 ? !y0 : y2) {
    // subtract the coverage for t2
    coverage.x -= saturate(C2.x + 0.5);
    // calculate the anti-aliasing for t2
    weight.x = min(weight.x, abs(C2.x));
  }
}

// this is essentially the same as coverageX, but with the axes swapped
void coverageY(vec2 p0, vec2 p1, vec2 p2) {

  vec2 C1, C2;
  calulateCrossings(p0, p1, p2, C1, C2);

  bool x0 = p0.x > vTexCoord.x;
  bool x1 = p1.x > vTexCoord.x;
  bool x2 = p2.x > vTexCoord.x;

  if (x1 ? !x2 : x0) {
    coverage.y -= saturate(C1.y + 0.5);
    weight.y = min(weight.y, abs(C1.y));
  }

  if (x1 ? !x0 : x2) {
    coverage.y += saturate(C2.y + 0.5);
    weight.y = min(weight.y, abs(C2.y));
  }
}

void main() {

  // calculate the pixel scale based on screen-coordinates
  pixelScale = hardness / fwidth(vTexCoord);

  // which grid cell is this pixel in?
  ivec2 gridCoord = ifloor(vTexCoord * vec2(uGridSize));

  // intersect curves in this row
  {
    // the index into the row info bitmap
    int rowIndex = gridCoord.y + uGridOffset.y;
    // fetch the info texel
    vec4 rowInfo = getTexel(uSamplerRows, rowIndex, uGridImageSize);
    // unpack the rowInfo
    int rowStrokeIndex = getInt16(rowInfo.xy);
    int rowStrokeCount = getInt16(rowInfo.zw);

    for (int iRowStroke = INT(0); iRowStroke < N; iRowStroke++) {
      if (iRowStroke >= rowStrokeCount)
        break;

      // each stroke is made up of 3 points: the start and control point
      // and the start of the next curve.
      // fetch the indices of this pair of strokes:
      vec4 strokeIndices = getTexel(uSamplerRowStrokes, rowStrokeIndex++, uCellsImageSize);

      // unpack the stroke index
      int strokePos = getInt16(strokeIndices.xy);

      // fetch the two strokes
      vec4 stroke0 = getTexel(uSamplerStrokes, strokePos + INT(0), uStrokeImageSize);
      vec4 stroke1 = getTexel(uSamplerStrokes, strokePos + INT(1), uStrokeImageSize);

      // calculate the coverage
      coverageX(stroke0.xy, stroke0.zw, stroke1.xy);
    }
  }

  // intersect curves in this column
  {
    int colIndex = gridCoord.x + uGridOffset.x;
    vec4 colInfo = getTexel(uSamplerCols, colIndex, uGridImageSize);
    int colStrokeIndex = getInt16(colInfo.xy);
    int colStrokeCount = getInt16(colInfo.zw);
    
    for (int iColStroke = INT(0); iColStroke < N; iColStroke++) {
      if (iColStroke >= colStrokeCount)
        break;

      vec4 strokeIndices = getTexel(uSamplerColStrokes, colStrokeIndex++, uCellsImageSize);

      int strokePos = getInt16(strokeIndices.xy);
      vec4 stroke0 = getTexel(uSamplerStrokes, strokePos + INT(0), uStrokeImageSize);
      vec4 stroke1 = getTexel(uSamplerStrokes, strokePos + INT(1), uStrokeImageSize);
      coverageY(stroke0.xy, stroke0.zw, stroke1.xy);
    }
  }

  weight = saturate(1.0 - weight * 2.0);
  float distance = max(weight.x + weight.y, minDistance); // manhattan approx.
  float antialias = abs(dot(coverage, weight) / distance);
  float cover = min(abs(coverage.x), abs(coverage.y));
  OUT_COLOR = vec4(uMaterialColor.rgb, 1.) * uMaterialColor.a;
  OUT_COLOR *= saturate(max(antialias, cover));
}
`;
var lineVert = `/*
  Part of the Processing project - http://processing.org
  Copyright (c) 2012-15 The Processing Foundation
  Copyright (c) 2004-12 Ben Fry and Casey Reas
  Copyright (c) 2001-04 Massachusetts Institute of Technology
  This library is free software; you can redistribute it and/or
  modify it under the terms of the GNU Lesser General Public
  License as published by the Free Software Foundation, version 2.1.
  This library is distributed in the hope that it will be useful,
  but WITHOUT ANY WARRANTY; without even the implied warranty of
  MERCHANTABILITY or FITNESS FOR A PARTICULAR PURPOSE.  See the GNU
  Lesser General Public License for more details.
  You should have received a copy of the GNU Lesser General
  Public License along with this library; if not, write to the
  Free Software Foundation, Inc., 59 Temple Place, Suite 330,
  Boston, MA  02111-1307  USA
*/

#define PROCESSING_LINE_SHADER

#define HOOK_DEFINES

precision highp int;
precision highp float;

#ifdef AUGMENTED_HOOK_getWorldInputs
uniform mat4 uModelMatrix;
uniform mat4 uViewMatrix;
#else
uniform mat4 uModelViewMatrix;
#endif

uniform mat4 uProjectionMatrix;
uniform float uStrokeWeight;

uniform bool uUseLineColor;
uniform bool uSimpleLines;
uniform vec4 uMaterialColor;

uniform vec4 uViewport;
uniform int uPerspective;
uniform int uStrokeJoin;

IN vec3 aPosition;
IN vec3 aTangentIn;
IN vec3 aTangentOut;
IN float aSide;
IN vec4 aVertexColor;

OUT vec4 vColor;
OUT vec2 vTangent;
OUT vec2 vCenter;
OUT vec2 vPosition;
OUT float vMaxDist;
OUT float vCap;
OUT float vJoin;
OUT float vStrokeWeight;

vec2 lineIntersection(vec2 aPoint, vec2 aDir, vec2 bPoint, vec2 bDir) {
  // Rotate and translate so a starts at the origin and goes out to the right
  bPoint -= aPoint;
  vec2 rotatedBFrom = vec2(
    bPoint.x*aDir.x + bPoint.y*aDir.y,
    bPoint.y*aDir.x - bPoint.x*aDir.y
  );
  vec2 bTo = bPoint + bDir;
  vec2 rotatedBTo = vec2(
    bTo.x*aDir.x + bTo.y*aDir.y,
    bTo.y*aDir.x - bTo.x*aDir.y
  );
  float intersectionDistance =
    rotatedBTo.x + (rotatedBFrom.x - rotatedBTo.x) * rotatedBTo.y /
    (rotatedBTo.y - rotatedBFrom.y);
  return aPoint + aDir * intersectionDistance;
}

struct StrokeVertex {
  vec3 position;
  vec3 tangentIn;
  vec3 tangentOut;
  vec4 color;
  float weight;
};

void main() {
  HOOK_beforeVertex();

  if (!uSimpleLines) {
      // Caps have one of either the in or out tangent set to 0
      vCap = (aTangentIn == vec3(0.)) != (aTangentOut == vec3(0.)) ? 1. : 0.;

      // Joins have two unique, defined tangents
      vJoin = (
          aTangentIn != vec3(0.) &&
          aTangentOut != vec3(0.) &&
          aTangentIn != aTangentOut
      ) ? 1. : 0.;
  }

  StrokeVertex inputs;
  inputs.position = aPosition.xyz;
  inputs.color = uUseLineColor ? aVertexColor : uMaterialColor;
  inputs.weight = uStrokeWeight;
  inputs.tangentIn = aTangentIn;
  inputs.tangentOut = aTangentOut;

#ifdef AUGMENTED_HOOK_getObjectInputs
  inputs = HOOK_getObjectInputs(inputs);
#endif

#ifdef AUGMENTED_HOOK_getWorldInputs
  inputs.position = (uModelMatrix * vec4(inputs.position, 1.)).xyz;
  inputs.tangentIn = (uModelMatrix * vec4(aTangentIn, 0.)).xyz;
  inputs.tangentOut = (uModelMatrix * vec4(aTangentOut, 0.)).xyz;
  inputs = HOOK_getWorldInputs(inputs);
#endif

#ifdef AUGMENTED_HOOK_getWorldInputs
  // Already multiplied by the model matrix, just apply view
  inputs.position = (uViewMatrix * vec4(inputs.position, 1.)).xyz;
  inputs.tangentIn = (uViewMatrix * vec4(aTangentIn, 0.)).xyz;
  inputs.tangentOut = (uViewMatrix * vec4(aTangentOut, 0.)).xyz;
#else
  // Apply both at once
  inputs.position = (uModelViewMatrix * vec4(inputs.position, 1.)).xyz;
  inputs.tangentIn = (uModelViewMatrix * vec4(aTangentIn, 0.)).xyz;
  inputs.tangentOut = (uModelViewMatrix * vec4(aTangentOut, 0.)).xyz;
#endif
#ifdef AUGMENTED_HOOK_getCameraInputs
  inputs = hook_getCameraInputs(inputs);
#endif

  vec4 posp = vec4(inputs.position, 1.);
  vec4 posqIn = vec4(inputs.position + inputs.tangentIn, 1.);
  vec4 posqOut = vec4(inputs.position + inputs.tangentOut, 1.);
  vStrokeWeight = inputs.weight;

  float facingCamera = pow(
    // The word space tangent's z value is 0 if it's facing the camera
    abs(normalize(posqIn-posp).z),

    // Using pow() here to ramp \`facingCamera\` up from 0 to 1 really quickly
    // so most lines get scaled and don't get clipped
    0.25
  );

  // Moving vertices slightly toward the camera
  // to avoid depth-fighting with the fill triangles.
  // A mix of scaling and offsetting is used based on distance
  // Discussion here:
  // https://github.com/processing/p5.js/issues/7200 

  // using a scale <1 moves the lines towards nearby camera
  // in order to prevent popping effects due to half of
  // the line disappearing behind the geometry faces.
  float zDistance = -posp.z; 
  float distanceFactor = smoothstep(0.0, 800.0, zDistance); 
  
  // Discussed here:
  // http://www.opengl.org/discussion_boards/ubbthreads.php?ubb=showflat&Number=252848  
  float scale = mix(1., 0.995, facingCamera);
  float dynamicScale = mix(scale, 1.0, distanceFactor); // Closer = more scale, farther = less

  posp.xyz = posp.xyz * dynamicScale;
  posqIn.xyz = posqIn.xyz * dynamicScale;
  posqOut.xyz = posqOut.xyz * dynamicScale;

  // Moving vertices slightly toward camera when far away 
  // https://github.com/processing/p5.js/issues/6956 
  float zOffset = mix(0., -1., facingCamera);
  float dynamicZAdjustment = mix(0.0, zOffset, distanceFactor); // Closer = less zAdjustment, farther = more

  posp.z -= dynamicZAdjustment;
  posqIn.z -= dynamicZAdjustment;
  posqOut.z -= dynamicZAdjustment;
  
  vec4 p = uProjectionMatrix * posp;
  vec4 qIn = uProjectionMatrix * posqIn;
  vec4 qOut = uProjectionMatrix * posqOut;

  // formula to convert from clip space (range -1..1) to screen space (range 0..[width or height])
  // screen_p = (p.xy/p.w + <1,1>) * 0.5 * uViewport.zw

  // prevent division by W by transforming the tangent formula (div by 0 causes
  // the line to disappear, see https://github.com/processing/processing/issues/5183)
  // t = screen_q - screen_p
  //
  // tangent is normalized and we don't care which aDirection it points to (+-)
  // t = +- normalize( screen_q - screen_p )
  // t = +- normalize( (q.xy/q.w+<1,1>)*0.5*uViewport.zw - (p.xy/p.w+<1,1>)*0.5*uViewport.zw )
  //
  // extract common factor, <1,1> - <1,1> cancels out
  // t = +- normalize( (q.xy/q.w - p.xy/p.w) * 0.5 * uViewport.zw )
  //
  // convert to common divisor
  // t = +- normalize( ((q.xy*p.w - p.xy*q.w) / (p.w*q.w)) * 0.5 * uViewport.zw )
  //
  // remove the common scalar divisor/factor, not needed due to normalize and +-
  // (keep uViewport - can't remove because it has different components for x and y
  //  and corrects for aspect ratio, see https://github.com/processing/processing/issues/5181)
  // t = +- normalize( (q.xy*p.w - p.xy*q.w) * uViewport.zw )

  vec2 tangentIn = normalize((qIn.xy*p.w - p.xy*qIn.w) * uViewport.zw);
  vec2 tangentOut = normalize((qOut.xy*p.w - p.xy*qOut.w) * uViewport.zw);

  vec2 curPerspScale;
  if(uPerspective == 1) {
    // Perspective ---
    // convert from world to clip by multiplying with projection scaling factor
    // to get the right thickness (see https://github.com/processing/processing/issues/5182)

    // The y value of the projection matrix may be flipped if rendering to a Framebuffer.
    // Multiplying again by its sign here negates the flip to get just the scale.
    curPerspScale = (uProjectionMatrix * vec4(1, sign(uProjectionMatrix[1][1]), 0, 0)).xy;
  } else {
    // No Perspective ---
    // multiply by W (to cancel out division by W later in the pipeline) and
    // convert from screen to clip (derived from clip to screen above)
    curPerspScale = p.w / (0.5 * uViewport.zw);
  }

  vec2 offset;
  if (vJoin == 1. && !uSimpleLines) {
    vTangent = normalize(tangentIn + tangentOut);
    vec2 normalIn = vec2(-tangentIn.y, tangentIn.x);
    vec2 normalOut = vec2(-tangentOut.y, tangentOut.x);
    float side = sign(aSide);
    float sideEnum = abs(aSide);

    // We generate vertices for joins on either side of the centerline, but
    // the "elbow" side is the only one needing a join. By not setting the
    // offset for the other side, all its vertices will end up in the same
    // spot and not render, effectively discarding it.
    if (sign(dot(tangentOut, vec2(-tangentIn.y, tangentIn.x))) != side) {
      // Side enums:
      //   1: the side going into the join
      //   2: the middle of the join
      //   3: the side going out of the join
      if (sideEnum == 2.) {
        // Calculate the position + tangent on either side of the join, and
        // find where the lines intersect to find the elbow of the join
        vec2 c = (posp.xy/posp.w + vec2(1.,1.)) * 0.5 * uViewport.zw;
        vec2 intersection = lineIntersection(
          c + (side * normalIn * inputs.weight / 2.),
          tangentIn,
          c + (side * normalOut * inputs.weight / 2.),
          tangentOut
        );
        offset = (intersection - c);

        // When lines are thick and the angle of the join approaches 180, the
        // elbow might be really far from the center. We'll apply a limit to
        // the magnitude to avoid lines going across the whole screen when this
        // happens.
        float mag = length(offset);
        float maxMag = 3. * inputs.weight;
        if (mag > maxMag) {
          offset *= maxMag / mag;
        }
      } else if (sideEnum == 1.) {
        offset = side * normalIn * inputs.weight / 2.;
      } else if (sideEnum == 3.) {
        offset = side * normalOut * inputs.weight / 2.;
      }
    }
    if (uStrokeJoin == STROKE_JOIN_BEVEL) {
      vec2 avgNormal = vec2(-vTangent.y, vTangent.x);
      vMaxDist = abs(dot(avgNormal, normalIn * inputs.weight / 2.));
    } else {
      vMaxDist = inputs.weight / 2.;
    }
  } else {
    vec2 tangent = aTangentIn == vec3(0.) ? tangentOut : tangentIn;
    vTangent = tangent;
    vec2 normal = vec2(-tangent.y, tangent.x);

    float normalOffset = sign(aSide);
    // Caps will have side values of -2 or 2 on the edge of the cap that
    // extends out from the line
    float tangentOffset = abs(aSide) - 1.;
    offset = (normal * normalOffset + tangent * tangentOffset) *
      inputs.weight * 0.5;
    vMaxDist = inputs.weight / 2.;
  }

  vCenter = p.xy;
  vPosition = vCenter + offset;
  vColor = inputs.color;

  gl_Position.xy = p.xy + offset.xy * curPerspScale;
  gl_Position.zw = p.zw;
  
  HOOK_afterVertex();
}
`;
var lineFrag = `precision highp int;
precision highp float;

uniform vec4 uMaterialColor;
uniform int uStrokeCap;
uniform int uStrokeJoin;

IN vec4 vColor;
IN vec2 vTangent;
IN vec2 vCenter;
IN vec2 vPosition;
IN float vStrokeWeight;
IN float vMaxDist;
IN float vCap;
IN float vJoin;

float distSquared(vec2 a, vec2 b) {
  vec2 aToB = b - a;
  return dot(aToB, aToB);
}

struct Inputs {
  vec4 color;
  vec2 tangent;
  vec2 center;
  vec2 position;
  float strokeWeight;
};

void main() {
  HOOK_beforeFragment();

  Inputs inputs;
  inputs.color = vColor;
  inputs.tangent = vTangent;
  inputs.center = vCenter;
  inputs.position = vPosition;
  inputs.strokeWeight = vStrokeWeight;
  inputs = HOOK_getPixelInputs(inputs);

  if (vCap > 0.) {
    if (
      uStrokeCap == STROKE_CAP_ROUND &&
      HOOK_shouldDiscard(distSquared(inputs.position, inputs.center) > inputs.strokeWeight * inputs.strokeWeight * 0.25)
    ) {
      discard;
    } else if (
      uStrokeCap == STROKE_CAP_SQUARE &&
      HOOK_shouldDiscard(dot(inputs.position - inputs.center, inputs.tangent) > 0.)
    ) {
      discard;
    // Use full area for PROJECT
    } else if (HOOK_shouldDiscard(false)) {
      discard;
    }
  } else if (vJoin > 0.) {
    if (
      uStrokeJoin == STROKE_JOIN_ROUND &&
      HOOK_shouldDiscard(distSquared(inputs.position, inputs.center) > inputs.strokeWeight * inputs.strokeWeight * 0.25)
    ) {
      discard;
    } else if (uStrokeJoin == STROKE_JOIN_BEVEL) {
      vec2 normal = vec2(-inputs.tangent.y, inputs.tangent.x);
      if (HOOK_shouldDiscard(abs(dot(inputs.position - inputs.center, normal)) > vMaxDist)) {
        discard;
      }
    // Use full area for MITER
    } else if (HOOK_shouldDiscard(false)) {
      discard;
    }
  }
  OUT_COLOR = HOOK_getFinalColor(vec4(inputs.color.rgb, 1.) * inputs.color.a);
  HOOK_afterFragment();
}
`;
var pointVert = `IN vec3 aPosition;
uniform float uPointSize;
OUT float vStrokeWeight;
uniform mat4 uModelViewMatrix;
uniform mat4 uProjectionMatrix;

void main() {
  HOOK_beforeVertex();
  vec4 viewModelPosition = vec4(HOOK_getWorldPosition(
    (uModelViewMatrix * vec4(HOOK_getLocalPosition(aPosition), 1.0)).xyz
  ), 1.);
  gl_Position = uProjectionMatrix * viewModelPosition;  

  float pointSize = HOOK_getPointSize(uPointSize);

	gl_PointSize = pointSize;
	vStrokeWeight = pointSize;
  HOOK_afterVertex();
}
`;
var pointFrag = `precision mediump int;
uniform vec4 uMaterialColor;
IN float vStrokeWeight;

void main(){
  HOOK_beforeFragment();
  float mask = 0.0;

  // make a circular mask using the gl_PointCoord (goes from 0 - 1 on a point)
  // might be able to get a nicer edge on big strokeweights with smoothstep but slightly less performant

  mask = step(0.98, length(gl_PointCoord * 2.0 - 1.0));

  // if strokeWeight is 1 or less lets just draw a square
  // this prevents weird artifacting from carving circles when our points are really small
  // if strokeWeight is larger than 1, we just use it as is

  mask = mix(0.0, mask, clamp(floor(vStrokeWeight - 0.5),0.0,1.0));

  // throw away the borders of the mask
  // otherwise we get weird alpha blending issues

  if(HOOK_shouldDiscard(mask > 0.98)){
    discard;
  }

  OUT_COLOR = HOOK_getFinalColor(vec4(uMaterialColor.rgb, 1.) * uMaterialColor.a);
  HOOK_afterFragment();
}
`;
var imageLightVert = `precision highp float;
attribute vec3 aPosition;
attribute vec3 aNormal;
attribute vec2 aTexCoord;

varying vec3 localPos;
varying vec3 vWorldNormal;
varying vec3 vWorldPosition;
varying vec2 vTexCoord;

uniform mat4 uModelViewMatrix;
uniform mat4 uProjectionMatrix;
uniform mat3 uNormalMatrix;

void main() {
  // Multiply the position by the matrix.
  vec4 viewModelPosition = uModelViewMatrix * vec4(aPosition, 1.0);
  gl_Position = uProjectionMatrix * viewModelPosition;  
  
  // orient the normals and pass to the fragment shader
  vWorldNormal = uNormalMatrix * aNormal;
  
  // send the view position to the fragment shader
  vWorldPosition = (uModelViewMatrix * vec4(aPosition, 1.0)).xyz;
  
  localPos = vWorldPosition;
  vTexCoord = aTexCoord;
}


/*
in the vertex shader we'll compute the world position and world oriented normal of the vertices and pass those to the fragment shader as varyings.
*/
`;
var imageLightDiffusedFrag = `precision highp float;
varying vec3 localPos;

// the HDR cubemap converted (can be from an equirectangular environment map.)
uniform sampler2D environmentMap;
varying vec2 vTexCoord;

const float PI = 3.14159265359;

vec2 nTOE( vec3 v ){
  // x = r sin(phi) cos(theta)   
  // y = r cos(phi)  
  // z = r sin(phi) sin(theta)
  float phi = acos( v.y );
  // if phi is 0, then there are no x, z components
  float theta = 0.0;
  // else 
  theta = acos(v.x / sin(phi));
  float sinTheta = v.z / sin(phi);
  if (sinTheta < 0.0) {
    // Turn it into -theta, but in the 0-2PI range
    theta = 2.0 * PI - theta;
  }
  theta = theta / (2.0 * 3.14159);
  phi = phi / 3.14159 ;
  
  vec2 angles = vec2( phi, theta );
  return angles;
}

float random(vec2 p) {
  vec3 p3  = fract(vec3(p.xyx) * .1031);
  p3 += dot(p3, p3.yzx + 33.33);
  return fract((p3.x + p3.y) * p3.z);
}

void main()
{   	 
	// the sample direction equals the hemisphere's orientation
  float phi = vTexCoord.x * 2.0 * PI;
  float theta = vTexCoord.y * PI;
  float x = sin(theta) * cos(phi);
  float y = sin(theta) * sin(phi);
  float z = cos(theta);
  vec3 normal = vec3( x, y, z);

	// Discretely sampling the hemisphere given the integral's
  // spherical coordinates translates to the following fragment code:
	vec3 irradiance = vec3(0.0);  
	vec3 up	= vec3(0.0, 1.0, 0.0);
	vec3 right = normalize(cross(up, normal));
	up = normalize(cross(normal, right));

	//  We specify a fixed sampleDelta delta value to traverse
  // the hemisphere; decreasing or increasing the sample delta
  // will increase or decrease the accuracy respectively.
	const float sampleDelta = 0.100;
	float nrSamples = 0.0;
  float randomOffset = random(gl_FragCoord.xy) * sampleDelta;
	for(float rawPhi = 0.0; rawPhi < 2.0 * PI; rawPhi += sampleDelta)
	{
    float phi = rawPhi + randomOffset;
    for(float rawTheta = 0.0; rawTheta < ( 0.5 ) * PI; rawTheta += sampleDelta)
    {
      float theta = rawTheta + randomOffset;
      // spherical to cartesian (in tangent space) // tangent space to world // add each sample result to irradiance
      float x = sin(theta) * cos(phi);
      float y = sin(theta) * sin(phi);
      float z = cos(theta);
      vec3 tangentSample = vec3( x, y, z);
      
      vec3 sampleVec = tangentSample.x * right + tangentSample.y * up + tangentSample.z * normal;
        irradiance += (texture2D(environmentMap, nTOE(sampleVec)).xyz) * cos(theta) * sin(theta);
      nrSamples++;
    }
	}
	// divide by the total number of samples taken, giving us the average sampled irradiance.
	irradiance = PI * irradiance * (1.0 / float(nrSamples )) ;
  
 
	gl_FragColor = vec4(irradiance, 1.0);
}`;
var imageLightSpecularFrag = `precision highp float;\r
varying vec3 localPos;\r
varying vec2 vTexCoord;\r
\r
// our texture\r
uniform sampler2D environmentMap;\r
uniform float roughness;\r
\r
const float PI = 3.14159265359;\r
\r
float VanDerCorput(int bits);\r
vec2 HammersleyNoBitOps(int i, int N);\r
vec3 ImportanceSampleGGX(vec2 Xi, vec3 N, float roughness);\r
\r
\r
vec2 nTOE( vec3 v ){\r
  // x = r sin(phi) cos(theta)   \r
  // y = r cos(phi)  \r
  // z = r sin(phi) sin(theta)\r
  float phi = acos( v.y );\r
  // if phi is 0, then there are no x, z components\r
  float theta = 0.0;\r
  // else \r
  theta = acos(v.x / sin(phi));\r
  float sinTheta = v.z / sin(phi);\r
  if (sinTheta < 0.0) {\r
    // Turn it into -theta, but in the 0-2PI range\r
    theta = 2.0 * PI - theta;\r
  }\r
  theta = theta / (2.0 * 3.14159);\r
  phi = phi / 3.14159 ;\r
  \r
  vec2 angles = vec2( phi, theta );\r
  return angles;\r
}\r
\r
\r
void main(){\r
  const int SAMPLE_COUNT = 400; // 4096\r
  int lowRoughnessLimit = int(pow(2.0,(roughness+0.1)*20.0));\r
  float totalWeight = 0.0;\r
  vec3 prefilteredColor = vec3(0.0);\r
  float phi = vTexCoord.x * 2.0 * PI;\r
  float theta = vTexCoord.y * PI;\r
  float x = sin(theta) * cos(phi);\r
  float y = sin(theta) * sin(phi);\r
  float z = cos(theta);\r
  vec3 N = vec3(x,y,z);\r
  vec3 V = N;\r
  for (int i = 0; i < SAMPLE_COUNT; ++i)\r
  {\r
    // break at smaller sample numbers for low roughness levels\r
    if(i == lowRoughnessLimit)\r
    {\r
      break;\r
    }\r
    vec2 Xi = HammersleyNoBitOps(i, SAMPLE_COUNT);\r
    vec3 H = ImportanceSampleGGX(Xi, N, roughness);\r
    vec3 L = normalize(2.0 * dot(V, H) * H - V);\r
\r
    float NdotL = max(dot(N, L), 0.0);\r
    if (NdotL > 0.0)\r
    {\r
      prefilteredColor += texture2D(environmentMap, nTOE(L)).xyz * NdotL;\r
      totalWeight += NdotL;\r
    }\r
  }\r
  prefilteredColor = prefilteredColor / totalWeight;\r
\r
  gl_FragColor = vec4(prefilteredColor, 1.0);\r
}\r
\r
vec3 ImportanceSampleGGX(vec2 Xi, vec3 N, float roughness){\r
  float a = roughness * roughness;\r
\r
  float phi = 2.0 * PI * Xi.x;\r
  float cosTheta = sqrt((1.0 - Xi.y) / (1.0 + (a * a - 1.0) * Xi.y));\r
  float sinTheta = sqrt(1.0 - cosTheta * cosTheta);\r
  // from spherical coordinates to cartesian coordinates\r
  vec3 H;\r
  H.x = cos(phi) * sinTheta;\r
  H.y = sin(phi) * sinTheta;\r
  H.z = cosTheta;\r
\r
  // from tangent-space vector to world-space sample vector\r
  vec3 up = abs(N.z) < 0.999 ? vec3(0.0, 0.0, 1.0) : vec3(1.0, 0.0, 0.0);\r
  vec3 tangent = normalize(cross(up, N));\r
  vec3 bitangent = cross(N, tangent);\r
\r
  vec3 sampleVec = tangent * H.x + bitangent * H.y + N * H.z;\r
  return normalize(sampleVec);\r
}\r
\r
\r
float VanDerCorput(int n, int base)\r
{\r
#ifdef WEBGL2\r
\r
    uint bits = uint(n);\r
    bits = (bits << 16u) | (bits >> 16u);\r
    bits = ((bits & 0x55555555u) << 1u) | ((bits & 0xAAAAAAAAu) >> 1u);\r
    bits = ((bits & 0x33333333u) << 2u) | ((bits & 0xCCCCCCCCu) >> 2u);\r
    bits = ((bits & 0x0F0F0F0Fu) << 4u) | ((bits & 0xF0F0F0F0u) >> 4u);\r
    bits = ((bits & 0x00FF00FFu) << 8u) | ((bits & 0xFF00FF00u) >> 8u);\r
    return float(bits) * 2.3283064365386963e-10; // / 0x100000000\r
\r
#else\r
\r
  float invBase = 1.0 / float(base);\r
  float denom = 1.0;\r
  float result = 0.0;\r
\r
\r
  for (int i = 0; i < 32; ++i)\r
  {\r
        if (n > 0)\r
        {\r
        denom = mod(float(n), 2.0);\r
        result += denom * invBase;\r
        invBase = invBase / 2.0;\r
        n = int(float(n) / 2.0);\r
        }\r
  }\r
\r
\r
  return result;\r
\r
#endif\r
}\r
\r
vec2 HammersleyNoBitOps(int i, int N)\r
{\r
  return vec2(float(i) / float(N), VanDerCorput(i, 2));\r
}\r
`;
var filterBaseFrag = `precision highp float;

uniform sampler2D tex0;
uniform vec2 canvasSize;
uniform vec2 texelSize;

IN vec2 vTexCoord;

struct FilterInputs {
  vec2 texCoord;
  vec2 canvasSize;
  vec2 texelSize;
};

void main(void) {
  FilterInputs inputs;
  inputs.texCoord = vTexCoord;
  inputs.canvasSize = canvasSize;
  inputs.texelSize = texelSize;
  OUT_COLOR = HOOK_getColor(inputs, tex0);
  OUT_COLOR.rgb *= outColor.a;
}
`;
var filterGrayFrag = `precision highp float;

varying vec2 vTexCoord;

uniform sampler2D tex0;

float luma(vec3 color) {
  // weighted grayscale with luminance values
  return dot(color, vec3(0.2126, 0.7152, 0.0722));
}

void main() {
  vec4 tex = texture2D(tex0, vTexCoord);
  float gray = luma(tex.rgb);
  gl_FragColor = vec4(gray, gray, gray, tex.a);
}
`;
var filterErodeFrag = `// Reduces the bright areas in an image

precision highp float;

varying vec2 vTexCoord;

uniform sampler2D tex0;
uniform vec2 texelSize;

float luma(vec3 color) {
  // weighted grayscale with luminance values
  // weights 77, 151, 28 taken from src/image/filters.js
  return dot(color, vec3(0.300781, 0.589844, 0.109375));
}

void main() {
  vec4 color = texture2D(tex0, vTexCoord);
  float lum = luma(color.rgb);

  // set current color as the darkest neighbor color

  vec4 neighbors[4];
  neighbors[0] = texture2D(tex0, vTexCoord + vec2( texelSize.x, 0.0));
  neighbors[1] = texture2D(tex0, vTexCoord + vec2(-texelSize.x, 0.0));
  neighbors[2] = texture2D(tex0, vTexCoord + vec2(0.0,  texelSize.y));
  neighbors[3] = texture2D(tex0, vTexCoord + vec2(0.0, -texelSize.y));

  for (int i = 0; i < 4; i++) {
    vec4 neighborColor = neighbors[i];
    float neighborLum = luma(neighborColor.rgb);

    if (neighborLum < lum) {
      color = neighborColor;
      lum = neighborLum;
    }
  }

  gl_FragColor = color;
}
`;
var filterDilateFrag = `// Increase the bright areas in an image

precision highp float;

varying vec2 vTexCoord;

uniform sampler2D tex0;
uniform vec2 texelSize;

float luma(vec3 color) {
  // weighted grayscale with luminance values
  // weights 77, 151, 28 taken from src/image/filters.js
  return dot(color, vec3(0.300781, 0.589844, 0.109375));
}

void main() {
  vec4 color = texture2D(tex0, vTexCoord);
  float lum = luma(color.rgb);

  // set current color as the brightest neighbor color

  vec4 neighbors[4];
  neighbors[0] = texture2D(tex0, vTexCoord + vec2( texelSize.x, 0.0));
  neighbors[1] = texture2D(tex0, vTexCoord + vec2(-texelSize.x, 0.0));
  neighbors[2] = texture2D(tex0, vTexCoord + vec2(0.0,  texelSize.y));
  neighbors[3] = texture2D(tex0, vTexCoord + vec2(0.0, -texelSize.y));

  for (int i = 0; i < 4; i++) {
    vec4 neighborColor = neighbors[i];
    float neighborLum = luma(neighborColor.rgb);

    if (neighborLum > lum) {
      color = neighborColor;
      lum = neighborLum;
    }
  }

  gl_FragColor = color;
}
`;
var filterBlurFrag = `precision highp float;

// Two-pass blur filter, unweighted kernel.
// See also a similar blur at Adam Ferriss' repo of shader examples:
// https://github.com/aferriss/p5jsShaderExamples/blob/gh-pages/4_image-effects/4-9_single-pass-blur/effect.frag


uniform sampler2D tex0;
varying vec2 vTexCoord;
uniform vec2 direction;
uniform vec2 canvasSize;
uniform float radius;

float random(vec2 p) {
  vec3 p3  = fract(vec3(p.xyx) * .1031);
  p3 += dot(p3, p3.yzx + 33.33);
  return fract((p3.x + p3.y) * p3.z);
}

// This isn't a real Gaussian weight, it's a quadratic weight. It's what the
// CPU mode's blur uses though, so we also use it here to match.
float quadWeight(float x, float e) {
  return pow(e-abs(x), 2.);
}

void main(){
  vec2 uv = vTexCoord;

  // A reasonable maximum number of samples
  const float maxSamples = 64.0;

  float numSamples = floor(7. * radius);
  if (fract(numSamples / 2.) == 0.) {
    numSamples++;
  }
  vec4 avg = vec4(0.0);
  float total = 0.0;

  // Calculate the spacing to avoid skewing if numSamples > maxSamples
  float spacing = 1.0;
  if (numSamples > maxSamples) {
    spacing = numSamples / maxSamples;
    numSamples = maxSamples;
  }

  float randomOffset = (spacing - 1.0) * mix(-0.5, 0.5, random(gl_FragCoord.xy));
  for (float i = 0.0; i < maxSamples; i++) {
    if (i >= numSamples) break;

    float sample = i * spacing - (numSamples - 1.0) * 0.5 * spacing + randomOffset;
    vec2 sampleCoord = uv + vec2(sample, sample) / canvasSize * direction;
    float weight = quadWeight(sample, (numSamples - 1.0) * 0.5 * spacing);

    avg += weight * texture2D(tex0, sampleCoord);
    total += weight;
  }

  avg /= total;
  gl_FragColor = avg;
}
`;
var filterPosterizeFrag = `// Limit color space for a stylized cartoon / poster effect

precision highp float;

varying vec2 vTexCoord;

uniform sampler2D tex0;
uniform float filterParameter;

vec3 quantize(vec3 color, float n) {
  // restrict values to N options/bins
  // and floor each channel to nearest value
  //
  // eg. when N = 5, values = 0.0, 0.25, 0.50, 0.75, 1.0
  // then quantize (0.1, 0.7, 0.9) -> (0.0, 0.5, 1.0)

  color = color * n;
  color = floor(color);
  color = color / (n - 1.0);
  return color;
}

void main() {
  vec4 color = texture2D(tex0, vTexCoord);

  vec3 restrictedColor = quantize(color.rgb / color.a, filterParameter);

  gl_FragColor = vec4(restrictedColor.rgb * color.a, color.a);
}
`;
var filterOpaqueFrag = `// Set alpha channel to entirely opaque

precision highp float;

varying vec2 vTexCoord;

uniform sampler2D tex0;

void main() {
  vec4 color = texture2D(tex0, vTexCoord);
  gl_FragColor = vec4(color.rgb / color.a, 1.0);
}
`;
var filterInvertFrag = `// Set each pixel to inverse value
// Note that original INVERT does not change the opacity, so this follows suit

precision highp float;

varying vec2 vTexCoord;

uniform sampler2D tex0;

void main() {
vec4 color = texture2D(tex0, vTexCoord);
vec3 origColor = color.rgb / color.a;
vec3 invertedColor = vec3(1.0) - origColor;
gl_FragColor = vec4(invertedColor * color.a, color.a);
}
`;
var filterThresholdFrag = `// Convert pixels to either white or black, 
// depending on if their luma is above or below filterParameter

precision highp float;

varying vec2 vTexCoord;

uniform sampler2D tex0;
uniform float filterParameter;

float luma(vec3 color) {
  // weighted grayscale with luminance values
  return dot(color, vec3(0.2126, 0.7152, 0.0722));
}

void main() {
  vec4 color = texture2D(tex0, vTexCoord);
  float gray = luma(color.rgb / color.a);
  // floor() used to match src/image/filters.js
  float threshold = floor(filterParameter * 255.0) / 255.0;
  float blackOrWhite = step(threshold, gray);
  gl_FragColor = vec4(vec3(blackOrWhite) * color.a, color.a);
}
`;
var filterShaderVert = `uniform mat4 uModelViewMatrix;
uniform mat4 uProjectionMatrix;

attribute vec3 aPosition;
// texcoords only come from p5 to vertex shader
// so pass texcoords on to the fragment shader in a varying variable
attribute vec2 aTexCoord;
varying vec2 vTexCoord;

void main() {
  // transferring texcoords for the frag shader
  vTexCoord = aTexCoord;

  // copy position with a fourth coordinate for projection (1.0 is normal)
  vec4 positionVec4 = vec4(aPosition, 1.0);

  gl_Position = uProjectionMatrix * uModelViewMatrix * positionVec4;
}
`;
var STROKE_CAP_ENUM = {};
var STROKE_JOIN_ENUM = {};
var lineDefs = "";
var defineStrokeCapEnum = function(key, val) {
  lineDefs += `#define STROKE_CAP_${key} ${val}
`;
  STROKE_CAP_ENUM[constants[key]] = val;
};
var defineStrokeJoinEnum = function(key, val) {
  lineDefs += `#define STROKE_JOIN_${key} ${val}
`;
  STROKE_JOIN_ENUM[constants[key]] = val;
};
defineStrokeCapEnum("ROUND", 0);
defineStrokeCapEnum("PROJECT", 1);
defineStrokeCapEnum("SQUARE", 2);
defineStrokeJoinEnum("ROUND", 0);
defineStrokeJoinEnum("MITER", 1);
defineStrokeJoinEnum("BEVEL", 2);
var defaultShaders = {
  normalVert,
  normalFrag,
  basicFrag,
  sphereMappingFrag,
  lightVert: lightingShader + lightVert,
  lightTextureFrag,
  phongVert,
  phongFrag: lightingShader + phongFrag,
  fontVert,
  fontFrag,
  lineVert: lineDefs + lineVert,
  lineFrag: lineDefs + lineFrag,
  pointVert,
  pointFrag,
  imageLightVert,
  imageLightDiffusedFrag,
  imageLightSpecularFrag,
  filterBaseVert,
  filterBaseFrag
};
var sphereMapping = defaultShaders.sphereMappingFrag;
for (const key in defaultShaders) {
  defaultShaders[key] = webgl2CompatibilityShader + defaultShaders[key];
}
var filterShaderFrags = {
  [GRAY]: filterGrayFrag,
  [ERODE]: filterErodeFrag,
  [DILATE]: filterDilateFrag,
  [BLUR]: filterBlurFrag,
  [POSTERIZE]: filterPosterizeFrag,
  [OPAQUE]: filterOpaqueFrag,
  [INVERT]: filterInvertFrag,
  [THRESHOLD]: filterThresholdFrag
};

class RendererGL extends Renderer {
  constructor(pInst, w, h, isMainCanvas, elt, attr) {
    super(pInst, w, h, isMainCanvas);
    this.canvas = this.elt = elt || document.createElement("canvas");
    this._setAttributeDefaults(pInst);
    this._initContext();
    this.GL = this.drawingContext;
    if (this._isMainCanvas) {
      this._pInst._curElement = this;
      this._pInst.canvas = this.canvas;
    } else {
      this.canvas.style.display = "none";
    }
    this.elt.id = "defaultCanvas0";
    this.elt.classList.add("p5Canvas");
    this.wrappedElt = new Element(this.elt, this._pInst);
    for (const p2 of Object.getOwnPropertyNames(Element.prototype)) {
      if (p2 !== "constructor" && p2[0] !== "_") {
        Object.defineProperty(this, p2, {
          get() {
            return this.wrappedElt[p2];
          }
        });
      }
    }
    const dimensions = this._adjustDimensions(w, h);
    w = dimensions.adjustedWidth;
    h = dimensions.adjustedHeight;
    this.width = w;
    this.height = h;
    this.elt.width = w * this._pixelDensity;
    this.elt.height = h * this._pixelDensity;
    this.elt.style.width = `${w}px`;
    this.elt.style.height = `${h}px`;
    this._origViewport = {
      width: this.GL.drawingBufferWidth,
      height: this.GL.drawingBufferHeight
    };
    this.viewport(this._origViewport.width, this._origViewport.height);
    if (this._pInst._userNode) {
      this._pInst._userNode.appendChild(this.elt);
    } else {
      if (document.getElementsByTagName("main").length === 0) {
        let m = document.createElement("main");
        document.body.appendChild(m);
      }
      document.getElementsByTagName("main")[0].appendChild(this.elt);
    }
    this.isP3D = true;
    this.geometryBuilder = undefined;
    this.states.uModelMatrix = new Matrix(4);
    this.states.uViewMatrix = new Matrix(4);
    this.states.uPMatrix = new Matrix(4);
    this.states.curCamera = new Camera(this);
    this.states.uPMatrix.set(this.states.curCamera.projMatrix);
    this.states.uViewMatrix.set(this.states.curCamera.cameraMatrix);
    this.states.enableLighting = false;
    this.states.ambientLightColors = [];
    this.states.specularColors = [1, 1, 1];
    this.states.directionalLightDirections = [];
    this.states.directionalLightDiffuseColors = [];
    this.states.directionalLightSpecularColors = [];
    this.states.pointLightPositions = [];
    this.states.pointLightDiffuseColors = [];
    this.states.pointLightSpecularColors = [];
    this.states.spotLightPositions = [];
    this.states.spotLightDirections = [];
    this.states.spotLightDiffuseColors = [];
    this.states.spotLightSpecularColors = [];
    this.states.spotLightAngle = [];
    this.states.spotLightConc = [];
    this.states.activeImageLight = null;
    this.states.curFillColor = [1, 1, 1, 1];
    this.states.curAmbientColor = [1, 1, 1, 1];
    this.states.curSpecularColor = [0, 0, 0, 0];
    this.states.curEmissiveColor = [0, 0, 0, 0];
    this.states.curStrokeColor = [0, 0, 0, 1];
    this.states.curBlendMode = BLEND;
    this.states._hasSetAmbient = false;
    this.states._useSpecularMaterial = false;
    this.states._useEmissiveMaterial = false;
    this.states._useNormalMaterial = false;
    this.states._useShininess = 1;
    this.states._useMetalness = 0;
    this.states.tint = [255, 255, 255, 255];
    this.states.constantAttenuation = 1;
    this.states.linearAttenuation = 0;
    this.states.quadraticAttenuation = 0;
    this.states._currentNormal = new Vector(0, 0, 1);
    this.states.drawMode = FILL;
    this.states._tex = null;
    this.states.textureMode = IMAGE;
    this.states.textureWrapX = CLAMP;
    this.states.textureWrapY = CLAMP;
    this._isErasing = false;
    this._simpleLines = false;
    this._clipDepths = [];
    this._isClipApplied = false;
    this._stencilTestOn = false;
    this.mixedAmbientLight = [];
    this.mixedSpecularColor = [];
    this.diffusedTextures = new Map;
    this.specularTextures = new Map;
    this.preEraseBlend = undefined;
    this._cachedBlendMode = undefined;
    this._cachedFillStyle = [1, 1, 1, 1];
    this._cachedStrokeStyle = [0, 0, 0, 1];
    if (this.webglVersion === WEBGL2) {
      this.blendExt = this.GL;
    } else {
      this.blendExt = this.GL.getExtension("EXT_blend_minmax");
    }
    this._isBlending = false;
    this._useLineColor = false;
    this._useVertexColor = false;
    this.registerEnabled = new Set;
    this.states.curCamera._computeCameraDefaultSettings();
    this.states.curCamera._setDefaultCamera();
    this.filterCamera = new Camera(this);
    this.filterCamera._computeCameraDefaultSettings();
    this.filterCamera._setDefaultCamera();
    this.prevTouches = [];
    this.zoomVelocity = 0;
    this.rotateVelocity = new Vector(0, 0);
    this.moveVelocity = new Vector(0, 0);
    this.executeZoom = false;
    this.executeRotateAndMove = false;
    this._drawingFilter = false;
    this._drawingImage = false;
    this.specularShader = undefined;
    this.sphereMapping = undefined;
    this.diffusedShader = undefined;
    this._baseFilterShader = undefined;
    this._defaultLightShader = undefined;
    this._defaultImmediateModeShader = undefined;
    this._defaultNormalShader = undefined;
    this._defaultColorShader = undefined;
    this._defaultPointShader = undefined;
    this.states.userFillShader = undefined;
    this.states.userStrokeShader = undefined;
    this.states.userPointShader = undefined;
    this.states.userImageShader = undefined;
    this.states.curveDetail = 1 / 4;
    this.shapeBuilder = new ShapeBuilder(this);
    this.buffers = {
      fill: [
        new RenderBuffer(3, "vertices", "vertexBuffer", "aPosition", this, this._vToNArray),
        new RenderBuffer(3, "vertexNormals", "normalBuffer", "aNormal", this, this._vToNArray),
        new RenderBuffer(4, "vertexColors", "colorBuffer", "aVertexColor", this),
        new RenderBuffer(3, "vertexAmbients", "ambientBuffer", "aAmbientColor", this),
        new RenderBuffer(2, "uvs", "uvBuffer", "aTexCoord", this, (arr) => arr.flat())
      ],
      stroke: [
        new RenderBuffer(4, "lineVertexColors", "lineColorBuffer", "aVertexColor", this),
        new RenderBuffer(3, "lineVertices", "lineVerticesBuffer", "aPosition", this),
        new RenderBuffer(3, "lineTangentsIn", "lineTangentsInBuffer", "aTangentIn", this),
        new RenderBuffer(3, "lineTangentsOut", "lineTangentsOutBuffer", "aTangentOut", this),
        new RenderBuffer(1, "lineSides", "lineSidesBuffer", "aSide", this)
      ],
      text: [
        new RenderBuffer(3, "vertices", "vertexBuffer", "aPosition", this, this._vToNArray),
        new RenderBuffer(2, "uvs", "uvBuffer", "aTexCoord", this, (arr) => arr.flat())
      ],
      point: this.GL.createBuffer(),
      user: []
    };
    this.geometryBufferCache = new GeometryBufferCache(this);
    this.curStrokeCap = ROUND;
    this.curStrokeJoin = ROUND;
    this.textures = new Map;
    this.framebuffers = new Set;
    this.activeFramebuffers = [];
    this.states.filterShader = undefined;
    this.filterLayer = undefined;
    this.filterLayerTemp = undefined;
    this.defaultFilterShaders = {};
    this.fontInfos = {};
    this._curShader = undefined;
    this.drawShapeCount = 1;
    this.scratchMat3 = new Matrix(3);
    this._userEnabledStencil = false;
    this._internalEnable = this.drawingContext.enable;
    this._internalDisable = this.drawingContext.disable;
    this.drawingContext.enable = (key) => {
      if (key === this.drawingContext.STENCIL_TEST) {
        if (!this._clipping) {
          this._userEnabledStencil = true;
        }
      }
      return this._internalEnable.call(this.drawingContext, key);
    };
    this.drawingContext.disable = (key) => {
      if (key === this.drawingContext.STENCIL_TEST) {
        this._userEnabledStencil = false;
      }
      return this._internalDisable.call(this.drawingContext, key);
    };
    this._validateFaces = false;
  }
  remove() {
    this.wrappedElt.remove();
    this.wrappedElt = null;
    this.canvas = null;
    this.elt = null;
  }
  beginGeometry() {
    if (this.geometryBuilder) {
      throw new Error("It looks like `beginGeometry()` is being called while another p5.Geometry is already being build.");
    }
    this.geometryBuilder = new GeometryBuilder(this);
    this.geometryBuilder.prevFillColor = this.states.fillColor;
    this.fill(new Color([-1, -1, -1, -1]));
  }
  endGeometry() {
    if (!this.geometryBuilder) {
      throw new Error("Make sure you call beginGeometry() before endGeometry()!");
    }
    const geometry2 = this.geometryBuilder.finish();
    if (this.geometryBuilder.prevFillColor) {
      this.fill(this.geometryBuilder.prevFillColor);
    } else {
      this.noFill();
    }
    this.geometryBuilder = undefined;
    return geometry2;
  }
  buildGeometry(callback) {
    this.beginGeometry();
    callback();
    return this.endGeometry();
  }
  beginShape(...args) {
    super.beginShape(...args);
  }
  curveDetail(d2) {
    if (d2 === undefined) {
      return this.states.curveDetail;
    } else {
      this.states.setValue("curveDetail", d2);
    }
  }
  drawShape(shape) {
    const visitor = new PrimitiveToVerticesConverter({
      curveDetail: this.states.curveDetail
    });
    shape.accept(visitor);
    this.shapeBuilder.constructFromContours(shape, visitor.contours);
    if (this.geometryBuilder) {
      this.geometryBuilder.addImmediate(this.shapeBuilder.geometry, this.shapeBuilder.shapeMode, { validateFaces: this._validateFaces });
    } else if (this.states.fillColor || this.states.strokeColor) {
      if (this.shapeBuilder.shapeMode === POINTS) {
        this._drawPoints(this.shapeBuilder.geometry.vertices, this.buffers.point);
      } else {
        this._drawGeometry(this.shapeBuilder.geometry, {
          mode: this.shapeBuilder.shapeMode,
          count: this.drawShapeCount
        });
      }
    }
    this.drawShapeCount = 1;
  }
  endShape(mode, count) {
    this.drawShapeCount = count;
    super.endShape(mode, count);
  }
  vertexProperty(...args) {
    this.currentShape.vertexProperty(...args);
  }
  normal(xorv, y, z) {
    if (xorv instanceof Vector) {
      this.states.setValue("_currentNormal", xorv);
    } else {
      this.states.setValue("_currentNormal", new Vector(xorv, y, z));
    }
    this.updateShapeVertexProperties();
  }
  model(model, count = 1) {
    if (model.vertices.length > 0) {
      if (this.geometryBuilder) {
        this.geometryBuilder.addRetained(model);
      } else {
        if (!this.geometryInHash(model.gid)) {
          model._edgesToVertices();
          this._getOrMakeCachedBuffers(model);
        }
        this._drawGeometry(model, { count });
      }
    }
  }
  _drawGeometry(geometry2, { mode = TRIANGLES, count = 1 } = {}) {
    for (const propName in geometry2.userVertexProperties) {
      const prop = geometry2.userVertexProperties[propName];
      this.buffers.user.push(new RenderBuffer(prop.getDataSize(), prop.getSrcName(), prop.getDstName(), prop.getName(), this));
    }
    if (this.states.fillColor && geometry2.vertices.length >= 3 && ![LINES, POINTS].includes(mode)) {
      this._drawFills(geometry2, { mode, count });
    }
    if (this.states.strokeColor && geometry2.lineVertices.length >= 1) {
      this._drawStrokes(geometry2, { count });
    }
    this.buffers.user = [];
  }
  _drawGeometryScaled(model, scaleX, scaleY, scaleZ) {
    let originalModelMatrix = this.states.uModelMatrix;
    this.states.setValue("uModelMatrix", this.states.uModelMatrix.clone());
    try {
      this.states.uModelMatrix.scale(scaleX, scaleY, scaleZ);
      if (this.geometryBuilder) {
        this.geometryBuilder.addRetained(model);
      } else {
        this._drawGeometry(model);
      }
    } finally {
      this.states.setValue("uModelMatrix", originalModelMatrix);
    }
  }
  _drawFills(geometry2, { count, mode } = {}) {
    this._useVertexColor = geometry2.vertexColors.length > 0;
    const shader2 = !this._drawingFilter && this.states.userFillShader ? this.states.userFillShader : this._getFillShader();
    shader2.bindShader();
    this._setGlobalUniforms(shader2);
    this._setFillUniforms(shader2);
    shader2.bindTextures();
    for (const buff of this.buffers.fill) {
      buff._prepareBuffer(geometry2, shader2);
    }
    this._prepareUserAttributes(geometry2, shader2);
    shader2.disableRemainingAttributes();
    this._applyColorBlend(this.states.curFillColor, geometry2.hasFillTransparency());
    this._drawBuffers(geometry2, { mode, count });
    shader2.unbindShader();
  }
  _drawStrokes(geometry2, { count } = {}) {
    const gl = this.GL;
    this._useLineColor = geometry2.vertexStrokeColors.length > 0;
    const shader2 = this._getStrokeShader();
    shader2.bindShader();
    this._setGlobalUniforms(shader2);
    this._setStrokeUniforms(shader2);
    shader2.bindTextures();
    for (const buff of this.buffers.stroke) {
      buff._prepareBuffer(geometry2, shader2);
    }
    this._prepareUserAttributes(geometry2, shader2);
    shader2.disableRemainingAttributes();
    this._applyColorBlend(this.states.curStrokeColor, geometry2.hasStrokeTransparency());
    if (count === 1) {
      gl.drawArrays(gl.TRIANGLES, 0, geometry2.lineVertices.length / 3);
    } else {
      try {
        gl.drawArraysInstanced(gl.TRIANGLES, 0, geometry2.lineVertices.length / 3, count);
      } catch (e2) {
        console.log("\uD83C\uDF38 p5.js says: Instancing is only supported in WebGL2 mode");
      }
    }
    shader2.unbindShader();
  }
  _drawPoints(vertices, vertexBuffer) {
    const gl = this.GL;
    const pointShader = this._getPointShader();
    pointShader.bindShader();
    this._setGlobalUniforms(pointShader);
    this._setPointUniforms(pointShader);
    pointShader.bindTextures();
    this._bindBuffer(vertexBuffer, gl.ARRAY_BUFFER, this._vToNArray(vertices), Float32Array, gl.STATIC_DRAW);
    pointShader.enableAttrib(pointShader.attributes.aPosition, 3);
    this._applyColorBlend(this.states.curStrokeColor);
    gl.drawArrays(gl.Points, 0, vertices.length);
    pointShader.unbindShader();
  }
  _prepareUserAttributes(geometry2, shader2) {
    for (const buff of this.buffers.user) {
      if (!this._pInst.constructor.disableFriendlyErrors) {
        const prop = geometry2.userVertexProperties[buff.attr];
        if (prop) {
          const adjustedLength = prop.getSrcArray().length / prop.getDataSize();
          if (adjustedLength > geometry2.vertices.length) {
            this._pInst.constructor._friendlyError(`One of the geometries has a custom vertex property '${prop.getName()}' with more values than vertices. This is probably caused by directly using the Geometry.vertexProperty() method.`, "vertexProperty()");
          } else if (adjustedLength < geometry2.vertices.length) {
            this._pInst.constructor._friendlyError(`One of the geometries has a custom vertex property '${prop.getName()}' with fewer values than vertices. This is probably caused by directly using the Geometry.vertexProperty() method.`, "vertexProperty()");
          }
        }
      }
      buff._prepareBuffer(geometry2, shader2);
    }
  }
  _drawBuffers(geometry2, { mode = this.GL.TRIANGLES, count }) {
    const gl = this.GL;
    const glBuffers = this.geometryBufferCache.getCached(geometry2);
    if (!glBuffers)
      return;
    if (glBuffers.indexBuffer) {
      this._bindBuffer(glBuffers.indexBuffer, gl.ELEMENT_ARRAY_BUFFER);
      if (this._pInst.webglVersion !== WEBGL2 && glBuffers.indexBufferType === gl.UNSIGNED_INT) {
        if (!gl.getExtension("OES_element_index_uint")) {
          throw new Error("Unable to render a 3d model with > 65535 triangles. Your web browser does not support the WebGL Extension OES_element_index_uint.");
        }
      }
      if (count === 1) {
        gl.drawElements(gl.TRIANGLES, geometry2.faces.length * 3, glBuffers.indexBufferType, 0);
      } else {
        try {
          gl.drawElementsInstanced(gl.TRIANGLES, geometry2.faces.length * 3, glBuffers.indexBufferType, 0, count);
        } catch (e2) {
          console.log("\uD83C\uDF38 p5.js says: Instancing is only supported in WebGL2 mode");
        }
      }
    } else {
      if (count === 1) {
        gl.drawArrays(mode, 0, geometry2.vertices.length);
      } else {
        try {
          gl.drawArraysInstanced(mode, 0, geometry2.vertices.length, count);
        } catch (e2) {
          console.log("\uD83C\uDF38 p5.js says: Instancing is only supported in WebGL2 mode");
        }
      }
    }
  }
  _getOrMakeCachedBuffers(geometry2) {
    return this.geometryBufferCache.ensureCached(geometry2);
  }
  _setAttributeDefaults(pInst) {
    const applyAA = navigator.userAgent.toLowerCase().includes("safari");
    const defaults = {
      alpha: true,
      depth: true,
      stencil: true,
      antialias: applyAA,
      premultipliedAlpha: true,
      preserveDrawingBuffer: true,
      perPixelLighting: true,
      version: 2
    };
    if (pInst._glAttributes === null) {
      pInst._glAttributes = defaults;
    } else {
      pInst._glAttributes = Object.assign(defaults, pInst._glAttributes);
    }
    return;
  }
  _initContext() {
    if (this._pInst._glAttributes?.version !== 1) {
      this.drawingContext = this.canvas.getContext("webgl2", this._pInst._glAttributes);
    }
    this.webglVersion = this.drawingContext ? WEBGL2 : WEBGL;
    this._pInst.webglVersion = this.webglVersion;
    if (!this.drawingContext) {
      this.drawingContext = this.canvas.getContext("webgl", this._pInst._glAttributes) || this.canvas.getContext("experimental-webgl", this._pInst._glAttributes);
    }
    if (this.drawingContext === null) {
      throw new Error("Error creating webgl context");
    } else {
      const gl = this.drawingContext;
      gl.enable(gl.DEPTH_TEST);
      gl.depthFunc(gl.LEQUAL);
      gl.viewport(0, 0, gl.drawingBufferWidth, gl.drawingBufferHeight);
      gl.pixelStorei(gl.UNPACK_PREMULTIPLY_ALPHA_WEBGL, true);
      this._viewport = this.drawingContext.getParameter(this.drawingContext.VIEWPORT);
    }
  }
  _getMaxTextureSize() {
    const gl = this.drawingContext;
    return gl.getParameter(gl.MAX_TEXTURE_SIZE);
  }
  _adjustDimensions(width, height) {
    if (!this._maxTextureSize) {
      this._maxTextureSize = this._getMaxTextureSize();
    }
    let maxTextureSize = this._maxTextureSize;
    let maxAllowedPixelDimensions = Math.floor(maxTextureSize / this._pixelDensity);
    let adjustedWidth = Math.min(width, maxAllowedPixelDimensions);
    let adjustedHeight = Math.min(height, maxAllowedPixelDimensions);
    if (adjustedWidth !== width || adjustedHeight !== height) {
      console.warn("Warning: The requested width/height exceeds hardware limits. " + `Adjusting dimensions to width: ${adjustedWidth}, height: ${adjustedHeight}.`);
    }
    return { adjustedWidth, adjustedHeight };
  }
  _resetContext(options2, callback) {
    const w = this.width;
    const h = this.height;
    const defaultId = this.canvas.id;
    const isPGraphics = this._pInst instanceof Graphics;
    const prevStyle = {
      position: this.canvas.style.position,
      top: this.canvas.style.top,
      left: this.canvas.style.left
    };
    if (isPGraphics) {
      const pg = this._pInst;
      pg.canvas.parentNode.removeChild(pg.canvas);
      pg.canvas = document.createElement("canvas");
      const node = pg._pInst._userNode || document.body;
      node.appendChild(pg.canvas);
      Element.call(pg, pg.canvas, pg._pInst);
      pg.width = w;
      pg.height = h;
    } else {
      let c = this.canvas;
      if (c) {
        c.parentNode.removeChild(c);
      }
      c = document.createElement("canvas");
      c.id = defaultId;
      if (this._pInst._userNode) {
        this._pInst._userNode.appendChild(c);
      } else {
        document.body.appendChild(c);
      }
      this._pInst.canvas = c;
      this.canvas = c;
      this.canvas.style.position = prevStyle.position;
      this.canvas.style.top = prevStyle.top;
      this.canvas.style.left = prevStyle.left;
    }
    const renderer2 = new RendererGL(this._pInst, w, h, !isPGraphics, this._pInst.canvas);
    this._pInst._renderer = renderer2;
    renderer2._applyDefaults();
    if (typeof callback === "function") {
      setTimeout(() => {
        callback.apply(window._renderer, options2);
      }, 0);
    }
  }
  _update() {
    this.states.setValue("uModelMatrix", this.states.uModelMatrix.clone());
    this.states.uModelMatrix.reset();
    this.states.setValue("uViewMatrix", this.states.uViewMatrix.clone());
    this.states.uViewMatrix.set(this.states.curCamera.cameraMatrix);
    this.states.setValue("ambientLightColors", []);
    this.states.setValue("specularColors", [1, 1, 1]);
    this.states.setValue("directionalLightDirections", []);
    this.states.setValue("directionalLightDiffuseColors", []);
    this.states.setValue("directionalLightSpecularColors", []);
    this.states.setValue("pointLightPositions", []);
    this.states.setValue("pointLightDiffuseColors", []);
    this.states.setValue("pointLightSpecularColors", []);
    this.states.setValue("spotLightPositions", []);
    this.states.setValue("spotLightDirections", []);
    this.states.setValue("spotLightDiffuseColors", []);
    this.states.setValue("spotLightSpecularColors", []);
    this.states.setValue("spotLightAngle", []);
    this.states.setValue("spotLightConc", []);
    this.states.setValue("enableLighting", false);
    this.states.setValue("tint", [255, 255, 255, 255]);
    this.GL.clearStencil(0);
    this.GL.clear(this.GL.DEPTH_BUFFER_BIT | this.GL.STENCIL_BUFFER_BIT);
    if (!this._userEnabledStencil) {
      this._internalDisable.call(this.GL, this.GL.STENCIL_TEST);
    }
  }
  background(...args) {
    const _col = this._pInst.color(...args);
    this.clear(..._col._getRGBA());
  }
  get uModelMatrix() {
    return this.states.uModelMatrix;
  }
  get uViewMatrix() {
    return this.states.uViewMatrix;
  }
  get uPMatrix() {
    return this.states.uPMatrix;
  }
  get uMVMatrix() {
    const m = this.uModelMatrix.copy();
    m.mult(this.uViewMatrix);
    return m;
  }
  getWorldToScreenMatrix() {
    const modelMatrix = this.states.uModelMatrix;
    const viewMatrix = this.states.uViewMatrix;
    const projectionMatrix = this.states.uPMatrix;
    const projectedToScreenMatrix = new Matrix(4);
    projectedToScreenMatrix.scale(this.width, this.height, 1);
    projectedToScreenMatrix.translate([0.5, 0.5, 0.5]);
    projectedToScreenMatrix.scale(0.5, -0.5, 0.5);
    const modelViewMatrix = modelMatrix.copy().mult(viewMatrix);
    const modelViewProjectionMatrix = modelViewMatrix.mult(projectionMatrix);
    const worldToScreenMatrix = modelViewProjectionMatrix.mult(projectedToScreenMatrix);
    return worldToScreenMatrix;
  }
  fill(...args) {
    super.fill(...args);
    const color2 = this.states.fillColor;
    this.states.setValue("curFillColor", color2._array);
    this.states.setValue("drawMode", FILL);
    this.states.setValue("_useNormalMaterial", false);
    this.states.setValue("_tex", null);
  }
  stroke(...args) {
    super.stroke(...args);
    this.states.setValue("curStrokeColor", this.states.strokeColor._array);
  }
  getCommonVertexProperties() {
    return {
      ...super.getCommonVertexProperties(),
      stroke: this.states.strokeColor,
      fill: this.states.fillColor,
      normal: this.states._currentNormal
    };
  }
  getSupportedIndividualVertexProperties() {
    return {
      textureCoordinates: true
    };
  }
  strokeCap(cap) {
    this.curStrokeCap = cap;
  }
  strokeJoin(join) {
    this.curStrokeJoin = join;
  }
  getFilterLayer() {
    if (!this.filterLayer) {
      this.filterLayer = new Framebuffer(this);
    }
    return this.filterLayer;
  }
  getFilterLayerTemp() {
    if (!this.filterLayerTemp) {
      this.filterLayerTemp = new Framebuffer(this);
    }
    return this.filterLayerTemp;
  }
  matchSize(fboToMatch, target) {
    if (fboToMatch.width !== target.width || fboToMatch.height !== target.height) {
      fboToMatch.resize(target.width, target.height);
    }
    if (fboToMatch.pixelDensity() !== target.pixelDensity()) {
      fboToMatch.pixelDensity(target.pixelDensity());
    }
  }
  filter(...args) {
    let fbo = this.getFilterLayer();
    let filterParameter = undefined;
    let operation = undefined;
    if (typeof args[0] === "string") {
      operation = args[0];
      let useDefaultParam = operation in filterParamDefaults && args[1] === undefined;
      filterParameter = useDefaultParam ? filterParamDefaults[operation] : args[1];
      if (!(operation in this.defaultFilterShaders)) {
        this.defaultFilterShaders[operation] = new Shader(fbo.renderer, filterShaderVert, filterShaderFrags[operation]);
      }
      this.states.setValue("filterShader", this.defaultFilterShaders[operation]);
    } else {
      this.states.setValue("filterShader", args[0]);
    }
    const target = this.activeFramebuffer() || this;
    this.matchSize(fbo, target);
    fbo.draw(() => this.clear());
    let texelSize = [
      1 / (target.width * target.pixelDensity()),
      1 / (target.height * target.pixelDensity())
    ];
    if (operation === BLUR) {
      const tmp = this.getFilterLayerTemp();
      this.matchSize(tmp, target);
      this.push();
      this.states.setValue("strokeColor", null);
      this.blendMode(BLEND);
      this.shader(this.states.filterShader);
      this.states.filterShader.setUniform("texelSize", texelSize);
      this.states.filterShader.setUniform("canvasSize", [
        target.width,
        target.height
      ]);
      this.states.filterShader.setUniform("radius", Math.max(1, filterParameter));
      tmp.draw(() => {
        this.states.filterShader.setUniform("direction", [1, 0]);
        this.states.filterShader.setUniform("tex0", target);
        this.clear();
        this.shader(this.states.filterShader);
        this.noLights();
        this.plane(target.width, target.height);
      });
      fbo.draw(() => {
        this.states.filterShader.setUniform("direction", [0, 1]);
        this.states.filterShader.setUniform("tex0", tmp);
        this.clear();
        this.shader(this.states.filterShader);
        this.noLights();
        this.plane(target.width, target.height);
      });
      this.pop();
    } else {
      fbo.draw(() => {
        this.states.setValue("strokeColor", null);
        this.blendMode(BLEND);
        this.shader(this.states.filterShader);
        this.states.filterShader.setUniform("tex0", target);
        this.states.filterShader.setUniform("texelSize", texelSize);
        this.states.filterShader.setUniform("canvasSize", [
          target.width,
          target.height
        ]);
        this.states.filterShader.setUniform("filterParameter", filterParameter);
        this.noLights();
        this.plane(target.width, target.height);
      });
    }
    this.push();
    this.states.setValue("strokeColor", null);
    this.clear();
    this.push();
    this.states.setValue("imageMode", CORNER);
    this.blendMode(BLEND);
    target.filterCamera._resize();
    this.setCamera(target.filterCamera);
    this.resetMatrix();
    this._drawingFilter = true;
    this.image(fbo, 0, 0, fbo.width, fbo.height, -target.width / 2, -target.height / 2, target.width, target.height);
    this._drawingFilter = false;
    this.clearDepth();
    this.pop();
    this.pop();
  }
  pixelDensity(newDensity) {
    if (newDensity) {
      return this._pInst.pixelDensity(newDensity);
    }
    return this._pInst.pixelDensity();
  }
  blendMode(mode) {
    if (mode === DARKEST || mode === LIGHTEST || mode === ADD || mode === BLEND || mode === SUBTRACT || mode === SCREEN || mode === EXCLUSION || mode === REPLACE || mode === MULTIPLY || mode === REMOVE)
      this.states.setValue("curBlendMode", mode);
    else if (mode === BURN || mode === OVERLAY || mode === HARD_LIGHT || mode === SOFT_LIGHT || mode === DODGE) {
      console.warn("BURN, OVERLAY, HARD_LIGHT, SOFT_LIGHT, and DODGE only work for blendMode in 2D mode.");
    }
  }
  erase(opacityFill, opacityStroke) {
    if (!this._isErasing) {
      this.preEraseBlend = this.states.curBlendMode;
      this._isErasing = true;
      this.blendMode(REMOVE);
      this._cachedFillStyle = this.states.curFillColor.slice();
      this.states.setValue("curFillColor", [1, 1, 1, opacityFill / 255]);
      this._cachedStrokeStyle = this.states.curStrokeColor.slice();
      this.states.setValue("curStrokeColor", [1, 1, 1, opacityStroke / 255]);
    }
  }
  noErase() {
    if (this._isErasing) {
      this.states.setValue("curFillColor", this._cachedFillStyle.slice());
      this.states.setValue("curStrokeColor", this._cachedStrokeStyle.slice());
      this.states.setValue("curBlendMode", this.preEraseBlend);
      this.blendMode(this.preEraseBlend);
      this._isErasing = false;
      this._applyBlendMode();
    }
  }
  drawTarget() {
    return this.activeFramebuffers[this.activeFramebuffers.length - 1] || this;
  }
  beginClip(options2 = {}) {
    super.beginClip(options2);
    this.drawTarget()._isClipApplied = true;
    const gl = this.GL;
    gl.clearStencil(0);
    gl.clear(gl.STENCIL_BUFFER_BIT);
    this._internalEnable.call(gl, gl.STENCIL_TEST);
    this._stencilTestOn = true;
    gl.stencilFunc(gl.ALWAYS, 1, 255);
    gl.stencilOp(gl.KEEP, gl.KEEP, gl.REPLACE);
    gl.disable(gl.DEPTH_TEST);
    this.push();
    this.resetShader();
    if (this.states.fillColor)
      this.fill(0, 0);
    if (this.states.strokeColor)
      this.stroke(0, 0);
  }
  endClip() {
    this.pop();
    const gl = this.GL;
    gl.stencilOp(gl.KEEP, gl.KEEP, gl.KEEP);
    gl.stencilFunc(this._clipInvert ? gl.EQUAL : gl.NOTEQUAL, 0, 255);
    gl.enable(gl.DEPTH_TEST);
    this._clipDepths.push(this._pushPopDepth);
    super.endClip();
  }
  _clearClip() {
    this.GL.clearStencil(1);
    this.GL.clear(this.GL.STENCIL_BUFFER_BIT);
    if (this._clipDepths.length > 0) {
      this._clipDepths.pop();
    }
    this.drawTarget()._isClipApplied = false;
  }
  _getPixel(x, y) {
    const gl = this.GL;
    return readPixelWebGL(gl, null, x, y, gl.RGBA, gl.UNSIGNED_BYTE, this._pInst.height * this._pInst.pixelDensity());
  }
  loadPixels() {
    if (this._pInst._glAttributes.preserveDrawingBuffer !== true) {
      console.log("loadPixels only works in WebGL when preserveDrawingBuffer " + "is true.");
      return;
    }
    const pd = this._pixelDensity;
    const gl = this.GL;
    this.pixels = readPixelsWebGL(this.pixels, gl, null, 0, 0, this.width * pd, this.height * pd, gl.RGBA, gl.UNSIGNED_BYTE, this.height * pd);
  }
  updatePixels() {
    const fbo = this._getTempFramebuffer();
    fbo.pixels = this.pixels;
    fbo.updatePixels();
    this.push();
    this.resetMatrix();
    this.clear();
    this.states.setValue("imageMode", CORNER);
    this.image(fbo, 0, 0, fbo.width, fbo.height, -fbo.width / 2, -fbo.height / 2, fbo.width, fbo.height);
    this.pop();
    this.GL.clearDepth(1);
    this.GL.clear(this.GL.DEPTH_BUFFER_BIT);
  }
  _getTempFramebuffer() {
    if (!this._tempFramebuffer) {
      this._tempFramebuffer = new Framebuffer(this, {
        format: UNSIGNED_BYTE,
        useDepth: this._pInst._glAttributes.depth,
        depthFormat: UNSIGNED_INT,
        antialias: this._pInst._glAttributes.antialias
      });
    }
    return this._tempFramebuffer;
  }
  geometryInHash(gid) {
    return this.geometryBufferCache.isCached(gid);
  }
  viewport(w, h) {
    this._viewport = [0, 0, w, h];
    this.GL.viewport(0, 0, w, h);
  }
  resize(w, h) {
    super.resize(w, h);
    const props = {};
    for (const key in this.drawingContext) {
      const val = this.drawingContext[key];
      if (typeof val !== "object" && typeof val !== "function") {
        props[key] = val;
      }
    }
    const dimensions = this._adjustDimensions(w, h);
    w = dimensions.adjustedWidth;
    h = dimensions.adjustedHeight;
    this.width = w;
    this.height = h;
    this.canvas.width = w * this._pixelDensity;
    this.canvas.height = h * this._pixelDensity;
    this.canvas.style.width = `${w}px`;
    this.canvas.style.height = `${h}px`;
    this._origViewport = {
      width: this.GL.drawingBufferWidth,
      height: this.GL.drawingBufferHeight
    };
    this.viewport(this._origViewport.width, this._origViewport.height);
    this.states.curCamera._resize();
    if (typeof this.pixels !== "undefined") {
      this.pixels = new Uint8Array(this.GL.drawingBufferWidth * this.GL.drawingBufferHeight * 4);
    }
    for (const framebuffer of this.framebuffers) {
      framebuffer._canvasSizeChanged();
    }
    for (const savedKey in props) {
      try {
        this.drawingContext[savedKey] = props[savedKey];
      } catch (err) {}
    }
  }
  clear(...args) {
    const _r = args[0] || 0;
    const _g = args[1] || 0;
    const _b = args[2] || 0;
    let _a = args[3] || 0;
    const activeFramebuffer = this.activeFramebuffer();
    if (activeFramebuffer && activeFramebuffer.format === UNSIGNED_BYTE && !activeFramebuffer.antialias && _a === 0) {
      _a = 0.0000000001;
    }
    this.GL.clearColor(_r * _a, _g * _a, _b * _a, _a);
    this.GL.clearDepth(1);
    this.GL.clear(this.GL.COLOR_BUFFER_BIT | this.GL.DEPTH_BUFFER_BIT);
  }
  clearDepth(depth = 1) {
    this.GL.clearDepth(depth);
    this.GL.clear(this.GL.DEPTH_BUFFER_BIT);
  }
  applyMatrix(a, b2, c, d2, e2, f) {
    this.states.setValue("uModelMatrix", this.states.uModelMatrix.clone());
    if (arguments.length === 16) {
      Matrix.prototype.apply.apply(this.states.uModelMatrix, arguments);
    } else {
      this.states.uModelMatrix.apply([
        a,
        b2,
        0,
        0,
        c,
        d2,
        0,
        0,
        0,
        0,
        1,
        0,
        e2,
        f,
        0,
        1
      ]);
    }
  }
  translate(x, y, z) {
    if (x instanceof Vector) {
      z = x.z;
      y = x.y;
      x = x.x;
    }
    this.states.setValue("uModelMatrix", this.states.uModelMatrix.clone());
    this.states.uModelMatrix.translate([x, y, z]);
    return this;
  }
  scale(x, y, z) {
    this.states.setValue("uModelMatrix", this.states.uModelMatrix.clone());
    this.states.uModelMatrix.scale(x, y, z);
    return this;
  }
  rotate(rad, axis) {
    if (typeof axis === "undefined") {
      return this.rotateZ(rad);
    }
    this.states.setValue("uModelMatrix", this.states.uModelMatrix.clone());
    Matrix.prototype.rotate4x4.apply(this.states.uModelMatrix, arguments);
    return this;
  }
  rotateX(rad) {
    this.rotate(rad, 1, 0, 0);
    return this;
  }
  rotateY(rad) {
    this.rotate(rad, 0, 1, 0);
    return this;
  }
  rotateZ(rad) {
    this.rotate(rad, 0, 0, 1);
    return this;
  }
  pop(...args) {
    if (this._clipDepths.length > 0 && this._pushPopDepth === this._clipDepths[this._clipDepths.length - 1]) {
      this._clearClip();
      if (!this._userEnabledStencil) {
        this._internalDisable.call(this.GL, this.GL.STENCIL_TEST);
      }
    }
    super.pop(...args);
    this._applyStencilTestIfClipping();
  }
  _applyStencilTestIfClipping() {
    const drawTarget = this.drawTarget();
    if (drawTarget._isClipApplied !== this._stencilTestOn) {
      if (drawTarget._isClipApplied) {
        this._internalEnable.call(this.GL, this.GL.STENCIL_TEST);
        this._stencilTestOn = true;
      } else {
        if (!this._userEnabledStencil) {
          this._internalDisable.call(this.GL, this.GL.STENCIL_TEST);
        }
        this._stencilTestOn = false;
      }
    }
  }
  resetMatrix() {
    this.states.setValue("uModelMatrix", this.states.uModelMatrix.clone());
    this.states.uModelMatrix.reset();
    this.states.setValue("uViewMatrix", this.states.uViewMatrix.clone());
    this.states.uViewMatrix.set(this.states.curCamera.cameraMatrix);
    return this;
  }
  _getStrokeShader() {
    const stroke = this.states.userStrokeShader;
    if (stroke) {
      return stroke;
    }
    return this._getLineShader();
  }
  _getSphereMapping(img) {
    if (!this.sphereMapping) {
      this.sphereMapping = this._pInst.createFilterShader(sphereMapping);
    }
    this.scratchMat3.inverseTranspose4x4(this.states.uViewMatrix);
    this.scratchMat3.invert(this.scratchMat3);
    this.sphereMapping.setUniform("uFovY", this.states.curCamera.cameraFOV);
    this.sphereMapping.setUniform("uAspect", this.states.curCamera.aspectRatio);
    this.sphereMapping.setUniform("uNewNormalMatrix", this.scratchMat3.mat3);
    this.sphereMapping.setUniform("uEnvMap", img);
    return this.sphereMapping;
  }
  _getFillShader() {
    if (this._drawingImage) {
      if (this.states.userImageShader && !this._drawingFilter) {
        return this.states.userImageShader;
      } else {
        return this._getLightShader();
      }
    } else if (this.states.userFillShader) {
      return this.states.userFillShader;
    } else if (this.states._useNormalMaterial) {
      return this._getNormalShader();
    } else if (this.states.enableLighting || this.states._tex) {
      return this._getLightShader();
    }
    return this._getColorShader();
  }
  _getPointShader() {
    const point = this.states.userPointShader;
    if (!point || !point.isPointShader()) {
      return this._getPointShader();
    }
    return point;
  }
  baseMaterialShader() {
    if (!this._pInst._glAttributes.perPixelLighting) {
      throw new Error("The material shader does not support hooks without perPixelLighting. Try turning it back on.");
    }
    return this._getLightShader();
  }
  _getLightShader() {
    if (!this._defaultLightShader) {
      if (this._pInst._glAttributes.perPixelLighting) {
        this._defaultLightShader = new Shader(this, this._webGL2CompatibilityPrefix("vert", "highp") + defaultShaders.phongVert, this._webGL2CompatibilityPrefix("frag", "highp") + defaultShaders.phongFrag, {
          vertex: {
            "void beforeVertex": "() {}",
            "Vertex getObjectInputs": "(Vertex inputs) { return inputs; }",
            "Vertex getWorldInputs": "(Vertex inputs) { return inputs; }",
            "Vertex getCameraInputs": "(Vertex inputs) { return inputs; }",
            "void afterVertex": "() {}"
          },
          fragment: {
            "void beforeFragment": "() {}",
            "Inputs getPixelInputs": "(Inputs inputs) { return inputs; }",
            "vec4 combineColors": `(ColorComponents components) {
                vec4 color = vec4(0.);
                color.rgb += components.diffuse * components.baseColor;
                color.rgb += components.ambient * components.ambientColor;
                color.rgb += components.specular * components.specularColor;
                color.rgb += components.emissive;
                color.a = components.opacity;
                return color;
              }`,
            "vec4 getFinalColor": "(vec4 color) { return color; }",
            "void afterFragment": "() {}"
          }
        });
      } else {
        this._defaultLightShader = new Shader(this, this._webGL2CompatibilityPrefix("vert", "highp") + defaultShaders.lightVert, this._webGL2CompatibilityPrefix("frag", "highp") + defaultShaders.lightTextureFrag);
      }
    }
    return this._defaultLightShader;
  }
  baseNormalShader() {
    return this._getNormalShader();
  }
  _getNormalShader() {
    if (!this._defaultNormalShader) {
      this._defaultNormalShader = new Shader(this, this._webGL2CompatibilityPrefix("vert", "mediump") + defaultShaders.normalVert, this._webGL2CompatibilityPrefix("frag", "mediump") + defaultShaders.normalFrag, {
        vertex: {
          "void beforeVertex": "() {}",
          "Vertex getObjectInputs": "(Vertex inputs) { return inputs; }",
          "Vertex getWorldInputs": "(Vertex inputs) { return inputs; }",
          "Vertex getCameraInputs": "(Vertex inputs) { return inputs; }",
          "void afterVertex": "() {}"
        },
        fragment: {
          "void beforeFragment": "() {}",
          "vec4 getFinalColor": "(vec4 color) { return color; }",
          "void afterFragment": "() {}"
        }
      });
    }
    return this._defaultNormalShader;
  }
  baseColorShader() {
    return this._getColorShader();
  }
  _getColorShader() {
    if (!this._defaultColorShader) {
      this._defaultColorShader = new Shader(this, this._webGL2CompatibilityPrefix("vert", "mediump") + defaultShaders.normalVert, this._webGL2CompatibilityPrefix("frag", "mediump") + defaultShaders.basicFrag, {
        vertex: {
          "void beforeVertex": "() {}",
          "Vertex getObjectInputs": "(Vertex inputs) { return inputs; }",
          "Vertex getWorldInputs": "(Vertex inputs) { return inputs; }",
          "Vertex getCameraInputs": "(Vertex inputs) { return inputs; }",
          "void afterVertex": "() {}"
        },
        fragment: {
          "void beforeFragment": "() {}",
          "vec4 getFinalColor": "(vec4 color) { return color; }",
          "void afterFragment": "() {}"
        }
      });
    }
    return this._defaultColorShader;
  }
  pointShader() {
    return this._getPointShader();
  }
  _getPointShader() {
    if (!this._defaultPointShader) {
      this._defaultPointShader = new Shader(this, this._webGL2CompatibilityPrefix("vert", "mediump") + defaultShaders.pointVert, this._webGL2CompatibilityPrefix("frag", "mediump") + defaultShaders.pointFrag, {
        vertex: {
          "void beforeVertex": "() {}",
          "vec3 getLocalPosition": "(vec3 position) { return position; }",
          "vec3 getWorldPosition": "(vec3 position) { return position; }",
          "float getPointSize": "(float size) { return size; }",
          "void afterVertex": "() {}"
        },
        fragment: {
          "void beforeFragment": "() {}",
          "vec4 getFinalColor": "(vec4 color) { return color; }",
          "bool shouldDiscard": "(bool outside) { return outside; }",
          "void afterFragment": "() {}"
        }
      });
    }
    return this._defaultPointShader;
  }
  baseStrokeShader() {
    return this._getLineShader();
  }
  _getLineShader() {
    if (!this._defaultLineShader) {
      this._defaultLineShader = new Shader(this, this._webGL2CompatibilityPrefix("vert", "mediump") + defaultShaders.lineVert, this._webGL2CompatibilityPrefix("frag", "mediump") + defaultShaders.lineFrag, {
        vertex: {
          "void beforeVertex": "() {}",
          "StrokeVertex getObjectInputs": "(StrokeVertex inputs) { return inputs; }",
          "StrokeVertex getWorldInputs": "(StrokeVertex inputs) { return inputs; }",
          "StrokeVertex getCameraInputs": "(StrokeVertex inputs) { return inputs; }",
          "void afterVertex": "() {}"
        },
        fragment: {
          "void beforeFragment": "() {}",
          "Inputs getPixelInputs": "(Inputs inputs) { return inputs; }",
          "vec4 getFinalColor": "(vec4 color) { return color; }",
          "bool shouldDiscard": "(bool outside) { return outside; }",
          "void afterFragment": "() {}"
        }
      });
    }
    return this._defaultLineShader;
  }
  _getFontShader() {
    if (!this._defaultFontShader) {
      if (this.webglVersion === WEBGL) {
        this.GL.getExtension("OES_standard_derivatives");
      }
      this._defaultFontShader = new Shader(this, this._webGL2CompatibilityPrefix("vert", "highp") + defaultShaders.fontVert, this._webGL2CompatibilityPrefix("frag", "highp") + defaultShaders.fontFrag);
    }
    return this._defaultFontShader;
  }
  baseFilterShader() {
    if (!this._baseFilterShader) {
      this._baseFilterShader = new Shader(this, this._webGL2CompatibilityPrefix("vert", "highp") + defaultShaders.filterBaseVert, this._webGL2CompatibilityPrefix("frag", "highp") + defaultShaders.filterBaseFrag, {
        vertex: {},
        fragment: {
          "vec4 getColor": `(FilterInputs inputs, in sampler2D canvasContent) {
                return getTexture(canvasContent, inputs.texCoord);
              }`
        }
      });
    }
    return this._baseFilterShader;
  }
  _webGL2CompatibilityPrefix(shaderType, floatPrecision) {
    let code = "";
    if (this.webglVersion === WEBGL2) {
      code += `#version 300 es
#define WEBGL2
`;
    }
    if (shaderType === "vert") {
      code += `#define VERTEX_SHADER
`;
    } else if (shaderType === "frag") {
      code += `#define FRAGMENT_SHADER
`;
    }
    if (floatPrecision) {
      code += `precision ${floatPrecision} float;
`;
    }
    return code;
  }
  _getEmptyTexture() {
    if (!this._emptyTexture) {
      const im = new Image(1, 1);
      im.set(0, 0, 255);
      this._emptyTexture = new Texture(this, im);
    }
    return this._emptyTexture;
  }
  getTexture(input) {
    let src = input;
    if (src instanceof Framebuffer) {
      src = src.color;
    }
    const texture = this.textures.get(src);
    if (texture) {
      return texture;
    }
    const tex = new Texture(this, src);
    this.textures.set(src, tex);
    return tex;
  }
  getDiffusedTexture(input) {
    if (this.diffusedTextures.get(input) != null) {
      return this.diffusedTextures.get(input);
    }
    let newFramebuffer;
    let smallWidth = 200;
    let width = smallWidth;
    let height = Math.floor(smallWidth * (input.height / input.width));
    newFramebuffer = new Framebuffer(this, {
      width,
      height,
      density: 1
    });
    if (!this.diffusedShader) {
      this.diffusedShader = this._pInst.createShader(defaultShaders.imageLightVert, defaultShaders.imageLightDiffusedFrag);
    }
    newFramebuffer.draw(() => {
      this.shader(this.diffusedShader);
      this.diffusedShader.setUniform("environmentMap", input);
      this.states.setValue("strokeColor", null);
      this.noLights();
      this.plane(width, height);
    });
    this.diffusedTextures.set(input, newFramebuffer);
    return newFramebuffer;
  }
  getSpecularTexture(input) {
    if (this.specularTextures.get(input) != null) {
      return this.specularTextures.get(input);
    }
    const size = 512;
    let tex;
    const levels = [];
    const framebuffer = new Framebuffer(this, {
      width: size,
      height: size,
      density: 1
    });
    let count = Math.log(size) / Math.log(2);
    if (!this.specularShader) {
      this.specularShader = this._pInst.createShader(defaultShaders.imageLightVert, defaultShaders.imageLightSpecularFrag);
    }
    for (let w = size;w >= 1; w /= 2) {
      framebuffer.resize(w, w);
      let currCount = Math.log(w) / Math.log(2);
      let roughness = 1 - currCount / count;
      framebuffer.draw(() => {
        this.shader(this.specularShader);
        this.clear();
        this.specularShader.setUniform("environmentMap", input);
        this.specularShader.setUniform("roughness", roughness);
        this.states.setValue("strokeColor", null);
        this.noLights();
        this.plane(w, w);
      });
      levels.push(framebuffer.get().drawingContext.getImageData(0, 0, w, w));
    }
    framebuffer.remove();
    tex = new MipmapTexture(this, levels, {});
    this.specularTextures.set(input, tex);
    return tex;
  }
  activeFramebuffer() {
    return this.activeFramebuffers[this.activeFramebuffers.length - 1] || null;
  }
  createFramebuffer(options2) {
    return new Framebuffer(this, options2);
  }
  _setGlobalUniforms(shader2) {
    const modelMatrix = this.states.uModelMatrix;
    const viewMatrix = this.states.uViewMatrix;
    const projectionMatrix = this.states.uPMatrix;
    const modelViewMatrix = modelMatrix.copy().mult(viewMatrix);
    shader2.setUniform("uPerspective", this.states.curCamera.useLinePerspective ? 1 : 0);
    shader2.setUniform("uViewMatrix", viewMatrix.mat4);
    shader2.setUniform("uProjectionMatrix", projectionMatrix.mat4);
    shader2.setUniform("uModelMatrix", modelMatrix.mat4);
    shader2.setUniform("uModelViewMatrix", modelViewMatrix.mat4);
    if (shader2.uniforms.uModelViewProjectionMatrix) {
      const modelViewProjectionMatrix = modelViewMatrix.copy();
      modelViewProjectionMatrix.mult(projectionMatrix);
      shader2.setUniform("uModelViewProjectionMatrix", modelViewProjectionMatrix.mat4);
    }
    if (shader2.uniforms.uNormalMatrix) {
      this.scratchMat3.inverseTranspose4x4(modelViewMatrix);
      shader2.setUniform("uNormalMatrix", this.scratchMat3.mat3);
    }
    if (shader2.uniforms.uModelNormalMatrix) {
      this.scratchMat3.inverseTranspose4x4(this.states.uModelMatrix);
      shader2.setUniform("uModelNormalMatrix", this.scratchMat3.mat3);
    }
    if (shader2.uniforms.uCameraNormalMatrix) {
      this.scratchMat3.inverseTranspose4x4(this.states.uViewMatrix);
      shader2.setUniform("uCameraNormalMatrix", this.scratchMat3.mat3);
    }
    if (shader2.uniforms.uCameraRotation) {
      this.scratchMat3.inverseTranspose4x4(this.states.uViewMatrix);
      shader2.setUniform("uCameraRotation", this.scratchMat3.mat3);
    }
    shader2.setUniform("uViewport", this._viewport);
  }
  _setStrokeUniforms(strokeShader) {
    strokeShader.setUniform("uSimpleLines", this._simpleLines);
    strokeShader.setUniform("uUseLineColor", this._useLineColor);
    strokeShader.setUniform("uMaterialColor", this.states.curStrokeColor);
    strokeShader.setUniform("uStrokeWeight", this.states.strokeWeight);
    strokeShader.setUniform("uStrokeCap", STROKE_CAP_ENUM[this.curStrokeCap]);
    strokeShader.setUniform("uStrokeJoin", STROKE_JOIN_ENUM[this.curStrokeJoin]);
  }
  _setFillUniforms(fillShader) {
    this.mixedSpecularColor = [...this.states.curSpecularColor];
    const empty = this._getEmptyTexture();
    if (this.states._useMetalness > 0) {
      this.mixedSpecularColor = this.mixedSpecularColor.map((mixedSpecularColor, index) => this.states.curFillColor[index] * this.states._useMetalness + mixedSpecularColor * (1 - this.states._useMetalness));
    }
    fillShader.setUniform("uUseVertexColor", this._useVertexColor);
    fillShader.setUniform("uMaterialColor", this.states.curFillColor);
    fillShader.setUniform("isTexture", !!this.states._tex);
    fillShader.setUniform("uSampler", this.states._tex || empty);
    fillShader.setUniform("uTint", this.states.tint);
    fillShader.setUniform("uHasSetAmbient", this.states._hasSetAmbient);
    fillShader.setUniform("uAmbientMatColor", this.states.curAmbientColor);
    fillShader.setUniform("uSpecularMatColor", this.mixedSpecularColor);
    fillShader.setUniform("uEmissiveMatColor", this.states.curEmissiveColor);
    fillShader.setUniform("uSpecular", this.states._useSpecularMaterial);
    fillShader.setUniform("uEmissive", this.states._useEmissiveMaterial);
    fillShader.setUniform("uShininess", this.states._useShininess);
    fillShader.setUniform("uMetallic", this.states._useMetalness);
    this._setImageLightUniforms(fillShader);
    fillShader.setUniform("uUseLighting", this.states.enableLighting);
    const pointLightCount = this.states.pointLightDiffuseColors.length / 3;
    fillShader.setUniform("uPointLightCount", pointLightCount);
    fillShader.setUniform("uPointLightLocation", this.states.pointLightPositions);
    fillShader.setUniform("uPointLightDiffuseColors", this.states.pointLightDiffuseColors);
    fillShader.setUniform("uPointLightSpecularColors", this.states.pointLightSpecularColors);
    const directionalLightCount = this.states.directionalLightDiffuseColors.length / 3;
    fillShader.setUniform("uDirectionalLightCount", directionalLightCount);
    fillShader.setUniform("uLightingDirection", this.states.directionalLightDirections);
    fillShader.setUniform("uDirectionalDiffuseColors", this.states.directionalLightDiffuseColors);
    fillShader.setUniform("uDirectionalSpecularColors", this.states.directionalLightSpecularColors);
    const ambientLightCount = this.states.ambientLightColors.length / 3;
    this.mixedAmbientLight = [...this.states.ambientLightColors];
    if (this.states._useMetalness > 0) {
      this.mixedAmbientLight = this.mixedAmbientLight.map((ambientColors) => {
        let mixing = ambientColors - this.states._useMetalness;
        return Math.max(0, mixing);
      });
    }
    fillShader.setUniform("uAmbientLightCount", ambientLightCount);
    fillShader.setUniform("uAmbientColor", this.mixedAmbientLight);
    const spotLightCount = this.states.spotLightDiffuseColors.length / 3;
    fillShader.setUniform("uSpotLightCount", spotLightCount);
    fillShader.setUniform("uSpotLightAngle", this.states.spotLightAngle);
    fillShader.setUniform("uSpotLightConc", this.states.spotLightConc);
    fillShader.setUniform("uSpotLightDiffuseColors", this.states.spotLightDiffuseColors);
    fillShader.setUniform("uSpotLightSpecularColors", this.states.spotLightSpecularColors);
    fillShader.setUniform("uSpotLightLocation", this.states.spotLightPositions);
    fillShader.setUniform("uSpotLightDirection", this.states.spotLightDirections);
    fillShader.setUniform("uConstantAttenuation", this.states.constantAttenuation);
    fillShader.setUniform("uLinearAttenuation", this.states.linearAttenuation);
    fillShader.setUniform("uQuadraticAttenuation", this.states.quadraticAttenuation);
  }
  _setImageLightUniforms(shader2) {
    shader2.setUniform("uUseImageLight", this.states.activeImageLight != null);
    if (this.states.activeImageLight) {
      let diffusedLight = this.getDiffusedTexture(this.states.activeImageLight);
      shader2.setUniform("environmentMapDiffused", diffusedLight);
      let specularLight = this.getSpecularTexture(this.states.activeImageLight);
      shader2.setUniform("environmentMapSpecular", specularLight);
    }
  }
  _setPointUniforms(pointShader) {
    pointShader.setUniform("uMaterialColor", this.states.curStrokeColor);
    pointShader.setUniform("uPointSize", this.states.strokeWeight * this._pixelDensity);
  }
  _bindBuffer(buffer, target, values, type2, usage) {
    if (!target)
      target = this.GL.ARRAY_BUFFER;
    this.GL.bindBuffer(target, buffer);
    if (values !== undefined) {
      let data = values;
      if (values instanceof DataArray) {
        data = values.dataArray();
      } else if (!(data instanceof (type2 || Float32Array))) {
        data = new (type2 || Float32Array)(data);
      }
      this.GL.bufferData(target, data, usage || this.GL.STATIC_DRAW);
    }
  }
  _arraysEqual(a, b2) {
    const aLength = a.length;
    if (aLength !== b2.length)
      return false;
    return a.every((ai, i) => ai === b2[i]);
  }
  _isTypedArray(arr) {
    return [
      Float32Array,
      Float64Array,
      Int16Array,
      Uint16Array,
      Uint32Array
    ].some((x) => arr instanceof x);
  }
  _vToNArray(arr) {
    return arr.flatMap((item) => [item.x, item.y, item.z]);
  }
}
function rendererGL(p52, fn2) {
  p52.RendererGL = RendererGL;
  fn2.setAttributes = function(key, value) {
    if (typeof this._glAttributes === "undefined") {
      console.log("You are trying to use setAttributes on a p5.Graphics object " + "that does not use a WEBGL renderer.");
      return;
    }
    let unchanged = true;
    if (typeof value !== "undefined") {
      if (this._glAttributes === null) {
        this._glAttributes = {};
      }
      if (this._glAttributes[key] !== value) {
        this._glAttributes[key] = value;
        unchanged = false;
      }
    } else if (key instanceof Object) {
      if (this._glAttributes !== key) {
        this._glAttributes = key;
        unchanged = false;
      }
    }
    if (!this._renderer.isP3D || unchanged) {
      return;
    }
    if (!this._setupDone) {
      if (this._renderer.geometryBufferCache.numCached() > 0) {
        p52._friendlyError("Sorry, Could not set the attributes, you need to call setAttributes() " + "before calling the other drawing methods in setup()");
        return;
      }
    }
    this._renderer._resetContext();
    if (this._renderer.states.curCamera) {
      this._renderer.states.curCamera._renderer = this._renderer;
    }
  };
  fn2._assert3d = function(name) {
    if (!this._renderer.isP3D)
      throw new Error(`${name}() is only supported in WEBGL mode. If you'd like to use 3D graphics and WebGL, see  https://p5js.org/examples/form-3d-primitives.html for more information.`);
  };
  p52.renderers[WEBGL] = p52.RendererGL;
  p52.renderers[WEBGL2] = p52.RendererGL;
}
function readPixelsWebGL(pixels2, gl, framebuffer, x, y, width, height, format, type2, flipY) {
  const prevFramebuffer = gl.getParameter(gl.FRAMEBUFFER_BINDING);
  gl.bindFramebuffer(gl.FRAMEBUFFER, framebuffer);
  const channels = format === gl.RGBA ? 4 : 3;
  const len = width * height * channels;
  const TypedArrayClass = type2 === gl.UNSIGNED_BYTE ? Uint8Array : Float32Array;
  if (!(pixels2 instanceof TypedArrayClass) || pixels2.length !== len) {
    pixels2 = new TypedArrayClass(len);
  }
  gl.readPixels(x, flipY ? flipY - y - height : y, width, height, format, type2, pixels2);
  gl.bindFramebuffer(gl.FRAMEBUFFER, prevFramebuffer);
  if (flipY) {
    const halfHeight = Math.floor(height / 2);
    const tmpRow = new TypedArrayClass(width * channels);
    for (let y2 = 0;y2 < halfHeight; y2++) {
      const topOffset = y2 * width * 4;
      const bottomOffset = (height - y2 - 1) * width * 4;
      tmpRow.set(pixels2.subarray(topOffset, topOffset + width * 4));
      pixels2.copyWithin(topOffset, bottomOffset, bottomOffset + width * 4);
      pixels2.set(tmpRow, bottomOffset);
    }
  }
  return pixels2;
}
function readPixelWebGL(gl, framebuffer, x, y, format, type2, flipY) {
  const prevFramebuffer = gl.getParameter(gl.FRAMEBUFFER_BINDING);
  gl.bindFramebuffer(gl.FRAMEBUFFER, framebuffer);
  const channels = format === gl.RGBA ? 4 : 3;
  const TypedArrayClass = type2 === gl.UNSIGNED_BYTE ? Uint8Array : Float32Array;
  const pixels2 = new TypedArrayClass(channels);
  gl.readPixels(x, flipY ? flipY - y - 1 : y, 1, 1, format, type2, pixels2);
  gl.bindFramebuffer(gl.FRAMEBUFFER, prevFramebuffer);
  return Array.from(pixels2);
}
if (typeof p5 !== "undefined") {
  rendererGL(p5, p5.prototype);
}
function primitives3D(p52, fn2) {
  fn2.strokeMode = function(mode) {
    if (mode === undefined) {
      return this._renderer._simpleLines ? SIMPLE : FULL;
    } else if (mode === SIMPLE) {
      this._renderer._simpleLines = true;
    } else if (mode === FULL) {
      this._renderer._simpleLines = false;
    } else {
      throw Error("no such parameter");
    }
  };
  fn2.buildGeometry = function(callback) {
    return this._renderer.buildGeometry(callback);
  };
  fn2.freeGeometry = function(geometry2) {
    this._renderer.geometryBufferCache.freeBuffers(geometry2.gid);
  };
  fn2.plane = function(width = 50, height = width, detailX = 1, detailY = 1) {
    this._assert3d("plane");
    this._renderer.plane(width, height, detailX, detailY);
    return this;
  };
  fn2.box = function(width, height, depth, detailX, detailY) {
    this._assert3d("box");
    this._renderer.box(width, height, depth, detailX, detailY);
    return this;
  };
  fn2.sphere = function(radius = 50, detailX = 24, detailY = 16) {
    this._assert3d("sphere");
    this._renderer.sphere(radius, detailX, detailY);
    return this;
  };
  fn2.cylinder = function(radius = 50, height = radius, detailX = 24, detailY = 1, bottomCap = true, topCap = true) {
    this._assert3d("cylinder");
    this._renderer.cylinder(radius, height, detailX, detailY, bottomCap, topCap);
    return this;
  };
  fn2.cone = function(radius = 50, height = radius, detailX = 24, detailY = 1, cap = true) {
    this._assert3d("cone");
    this._renderer.cone(radius, height, detailX, detailY, cap);
    return this;
  };
  fn2.ellipsoid = function(radiusX = 50, radiusY = radiusX, radiusZ = radiusX, detailX = 24, detailY = 16) {
    this._assert3d("ellipsoid");
    this._renderer.ellipsoid(radiusX, radiusY, radiusZ, detailX, detailY);
    return this;
  };
  fn2.torus = function(radius, tubeRadius, detailX, detailY) {
    this._assert3d("torus");
    this._renderer.torus(radius, tubeRadius, detailX, detailY);
    return this;
  };
  RendererGL.prototype.point = function(x, y, z = 0) {
    const _vertex = [];
    _vertex.push(new Vector(x, y, z));
    this._drawPoints(_vertex, this.buffers.point);
    return this;
  };
  RendererGL.prototype.triangle = function(args) {
    const x1 = args[0], y1 = args[1];
    const x2 = args[2], y2 = args[3];
    const x3 = args[4], y3 = args[5];
    const gid = "tri";
    if (!this.geometryInHash(gid)) {
      const _triangle = function() {
        const vertices = [];
        vertices.push(new Vector(0, 0, 0));
        vertices.push(new Vector(1, 0, 0));
        vertices.push(new Vector(0, 1, 0));
        this.edges = [[0, 1], [1, 2], [2, 0]];
        this.vertices = vertices;
        this.faces = [[0, 1, 2]];
        this.uvs = [0, 0, 1, 0, 1, 1];
      };
      const triGeom = new Geometry(1, 1, _triangle, this);
      triGeom._edgesToVertices();
      triGeom.computeNormals();
      triGeom.gid = gid;
      this.geometryBufferCache.ensureCached(triGeom);
    }
    const uModelMatrix = this.states.uModelMatrix.copy();
    try {
      const orientation = Math.sign(x1 * y2 - x2 * y1 + x2 * y3 - x3 * y2 + x3 * y1 - x1 * y3);
      const mult = new Matrix([
        x2 - x1,
        y2 - y1,
        0,
        0,
        x3 - x1,
        y3 - y1,
        0,
        0,
        0,
        0,
        orientation,
        0,
        x1,
        y1,
        0,
        1
      ]).mult(this.states.uModelMatrix);
      this.states.setValue("uModelMatrix", mult);
      this.model(this.geometryBufferCache.getGeometryByID(gid));
    } finally {
      this.states.setValue("uModelMatrix", uModelMatrix);
    }
    return this;
  };
  RendererGL.prototype.ellipse = function(args) {
    this.arc(args[0], args[1], args[2], args[3], 0, TWO_PI, OPEN, args[4]);
  };
  RendererGL.prototype.arc = function(...args) {
    const x = args[0];
    const y = args[1];
    const width = args[2];
    const height = args[3];
    const start = args[4];
    const stop = args[5];
    const mode = args[6];
    const detail = args[7] || 25;
    let shape;
    let gid;
    if (Math.abs(stop - start) >= TWO_PI) {
      shape = "ellipse";
      gid = `${shape}|${detail}|`;
    } else {
      shape = "arc";
      gid = `${shape}|${start}|${stop}|${mode}|${detail}|`;
    }
    if (!this.geometryInHash(gid)) {
      const _arc = function() {
        if (start.toFixed(10) !== stop.toFixed(10)) {
          if (mode === PIE || typeof mode === "undefined") {
            this.vertices.push(new Vector(0.5, 0.5, 0));
            this.uvs.push([0.5, 0.5]);
          }
          for (let i = 0;i <= detail; i++) {
            const u = i / detail;
            const theta = (stop - start) * u + start;
            const _x = 0.5 + Math.cos(theta) / 2;
            const _y = 0.5 + Math.sin(theta) / 2;
            this.vertices.push(new Vector(_x, _y, 0));
            this.uvs.push([_x, _y]);
            if (i < detail - 1) {
              this.faces.push([0, i + 1, i + 2]);
              this.edges.push([i + 1, i + 2]);
            }
          }
          switch (mode) {
            case PIE:
              this.faces.push([
                0,
                this.vertices.length - 2,
                this.vertices.length - 1
              ]);
              this.edges.push([0, 1]);
              this.edges.push([
                this.vertices.length - 2,
                this.vertices.length - 1
              ]);
              this.edges.push([0, this.vertices.length - 1]);
              break;
            case CHORD:
              this.edges.push([0, 1]);
              this.edges.push([0, this.vertices.length - 1]);
              break;
            case OPEN:
              this.edges.push([0, 1]);
              break;
            default:
              this.faces.push([
                0,
                this.vertices.length - 2,
                this.vertices.length - 1
              ]);
              this.edges.push([
                this.vertices.length - 2,
                this.vertices.length - 1
              ]);
          }
        }
      };
      const arcGeom = new Geometry(detail, 1, _arc, this);
      arcGeom.computeNormals();
      if (detail <= 50) {
        arcGeom._edgesToVertices(arcGeom);
      } else if (this.states.strokeColor) {
        console.log(`Cannot apply a stroke to an ${shape} with more than 50 detail`);
      }
      arcGeom.gid = gid;
      this.geometryBufferCache.ensureCached(arcGeom);
    }
    const uModelMatrix = this.states.uModelMatrix;
    this.states.setValue("uModelMatrix", this.states.uModelMatrix.clone());
    try {
      this.states.uModelMatrix.translate([x, y, 0]);
      this.states.uModelMatrix.scale(width, height, 1);
      this.model(this.geometryBufferCache.getGeometryByID(gid));
    } finally {
      this.states.setValue("uModelMatrix", uModelMatrix);
    }
    return this;
  };
  RendererGL.prototype.rect = function(args) {
    const x = args[0];
    const y = args[1];
    const width = args[2];
    const height = args[3];
    if (typeof args[4] === "undefined") {
      const perPixelLighting = this._pInst._glAttributes.perPixelLighting;
      const detailX = args[4] || (perPixelLighting ? 1 : 24);
      const detailY = args[5] || (perPixelLighting ? 1 : 16);
      const gid = `rect|${detailX}|${detailY}`;
      if (!this.geometryInHash(gid)) {
        const _rect = function() {
          for (let i = 0;i <= this.detailY; i++) {
            const v = i / this.detailY;
            for (let j = 0;j <= this.detailX; j++) {
              const u = j / this.detailX;
              const p2 = new Vector(u, v, 0);
              this.vertices.push(p2);
              this.uvs.push(u, v);
            }
          }
          if (detailX > 0 && detailY > 0) {
            this.edges = [
              [0, detailX],
              [detailX, (detailX + 1) * (detailY + 1) - 1],
              [(detailX + 1) * (detailY + 1) - 1, (detailX + 1) * detailY],
              [(detailX + 1) * detailY, 0]
            ];
          }
        };
        const rectGeom = new Geometry(detailX, detailY, _rect, this);
        rectGeom.computeFaces().computeNormals()._edgesToVertices();
        rectGeom.gid = gid;
        this.geometryBufferCache.ensureCached(rectGeom);
      }
      const uModelMatrix = this.states.uModelMatrix;
      this.states.setValue("uModelMatrix", this.states.uModelMatrix.copy());
      try {
        this.states.uModelMatrix.translate([x, y, 0]);
        this.states.uModelMatrix.scale(width, height, 1);
        this.model(this.geometryBufferCache.getGeometryByID(gid));
      } finally {
        this.states.setValue("uModelMatrix", uModelMatrix);
      }
    } else {
      let tl = args[4];
      let tr = typeof args[5] === "undefined" ? tl : args[5];
      let br = typeof args[6] === "undefined" ? tr : args[6];
      let bl = typeof args[7] === "undefined" ? br : args[7];
      let a = x;
      let b2 = y;
      let c = width;
      let d2 = height;
      c += a;
      d2 += b2;
      if (a > c) {
        const temp = a;
        a = c;
        c = temp;
      }
      if (b2 > d2) {
        const temp = b2;
        b2 = d2;
        d2 = temp;
      }
      const maxRounding = Math.min((c - a) / 2, (d2 - b2) / 2);
      if (tl > maxRounding)
        tl = maxRounding;
      if (tr > maxRounding)
        tr = maxRounding;
      if (br > maxRounding)
        br = maxRounding;
      if (bl > maxRounding)
        bl = maxRounding;
      let x1 = a;
      let y1 = b2;
      let x2 = c;
      let y2 = d2;
      const prevMode = this.states.textureMode;
      this.states.setValue("textureMode", NORMAL);
      const prevOrder = this.bezierOrder();
      this.bezierOrder(2);
      this.beginShape();
      const addUVs = (x3, y3) => [x3, y3, 0, (x3 - x1) / width, (y3 - y1) / height];
      if (tr !== 0) {
        this.vertex(...addUVs(x2 - tr, y1));
        this.bezierVertex(...addUVs(x2, y1));
        this.bezierVertex(...addUVs(x2, y1 + tr));
      } else {
        this.vertex(...addUVs(x2, y1));
      }
      if (br !== 0) {
        this.vertex(...addUVs(x2, y2 - br));
        this.bezierVertex(...addUVs(x2, y2));
        this.bezierVertex(...addUVs(x2 - br, y2));
      } else {
        this.vertex(...addUVs(x2, y2));
      }
      if (bl !== 0) {
        this.vertex(...addUVs(x1 + bl, y2));
        this.bezierVertex(...addUVs(x1, y2));
        this.bezierVertex(...addUVs(x1, y2 - bl));
      } else {
        this.vertex(...addUVs(x1, y2));
      }
      if (tl !== 0) {
        this.vertex(...addUVs(x1, y1 + tl));
        this.bezierVertex(...addUVs(x1, y1));
        this.bezierVertex(...addUVs(x1 + tl, y1));
      } else {
        this.vertex(...addUVs(x1, y1));
      }
      this.endShape(CLOSE);
      this.states.setValue("textureMode", prevMode);
      this.bezierOrder(prevOrder);
    }
    return this;
  };
  RendererGL.prototype.quad = function(x1, y1, z1, x2, y2, z2, x3, y3, z3, x4, y4, z4, detailX = 2, detailY = 2) {
    const gid = `quad|${x1}|${y1}|${z1}|${x2}|${y2}|${z2}|${x3}|${y3}|${z3}|${x4}|${y4}|${z4}|${detailX}|${detailY}`;
    if (!this.geometryInHash(gid)) {
      const quadGeom = new Geometry(detailX, detailY, function() {
        let xRes = 1 / (this.detailX - 1);
        let yRes = 1 / (this.detailY - 1);
        for (let y = 0;y < this.detailY; y++) {
          for (let x = 0;x < this.detailX; x++) {
            let pctx = x * xRes;
            let pcty = y * yRes;
            let linePt0x = (1 - pcty) * x1 + pcty * x4;
            let linePt0y = (1 - pcty) * y1 + pcty * y4;
            let linePt0z = (1 - pcty) * z1 + pcty * z4;
            let linePt1x = (1 - pcty) * x2 + pcty * x3;
            let linePt1y = (1 - pcty) * y2 + pcty * y3;
            let linePt1z = (1 - pcty) * z2 + pcty * z3;
            let ptx = (1 - pctx) * linePt0x + pctx * linePt1x;
            let pty = (1 - pctx) * linePt0y + pctx * linePt1y;
            let ptz = (1 - pctx) * linePt0z + pctx * linePt1z;
            this.vertices.push(new Vector(ptx, pty, ptz));
            this.uvs.push([pctx, pcty]);
          }
        }
      }, this);
      quadGeom.faces = [];
      for (let y = 0;y < detailY - 1; y++) {
        for (let x = 0;x < detailX - 1; x++) {
          let pt0 = x + y * detailX;
          let pt1 = x + 1 + y * detailX;
          let pt2 = x + 1 + (y + 1) * detailX;
          let pt3 = x + (y + 1) * detailX;
          quadGeom.faces.push([pt0, pt1, pt2]);
          quadGeom.faces.push([pt0, pt2, pt3]);
        }
      }
      quadGeom.computeNormals();
      quadGeom.edges.length = 0;
      const vertexOrder = [0, 2, 3, 1];
      for (let i = 0;i < vertexOrder.length; i++) {
        const startVertex = vertexOrder[i];
        const endVertex = vertexOrder[(i + 1) % vertexOrder.length];
        quadGeom.edges.push([startVertex, endVertex]);
      }
      quadGeom._edgesToVertices();
      quadGeom.gid = gid;
      this.geometryBufferCache.ensureCached(quadGeom);
    }
    this.model(this.geometryBufferCache.getGeometryByID(gid));
    return this;
  };
  RendererGL.prototype.bezier = function(x1, y1, z1, x2, y2, z2, x3, y3, z3, x4, y4, z4) {
    if (arguments.length === 8) {
      y4 = y3;
      x4 = x3;
      y3 = z2;
      x3 = y2;
      y2 = x2;
      x2 = z1;
      z1 = z2 = z3 = z4 = 0;
    }
    this.bezierOrder();
    this.bezierOrder(3);
    this.beginShape();
    this.vertex(x1, y1, z1);
    this.bezierVertex(x2, y2, z2);
    this.bezierVertex(x3, y3, z3);
    this.bezierVertex(x4, y4, z4);
    this.endShape();
  };
  RendererGL.prototype.curve = function(x1, y1, z1, x2, y2, z2, x3, y3, z3, x4, y4, z4) {
    if (arguments.length === 8) {
      x4 = x3;
      y4 = y3;
      x3 = y2;
      y3 = x2;
      x2 = z1;
      y2 = x2;
      z1 = z2 = z3 = z4 = 0;
    }
    this.beginShape();
    this.splineVertex(x1, y1, z1);
    this.splineVertex(x2, y2, z2);
    this.splineVertex(x3, y3, z3);
    this.splineVertex(x4, y4, z4);
    this.endShape();
  };
  RendererGL.prototype.line = function(...args) {
    if (args.length === 6) {
      this.beginShape(LINES);
      this.vertex(args[0], args[1], args[2]);
      this.vertex(args[3], args[4], args[5]);
      this.endShape();
    } else if (args.length === 4) {
      this.beginShape(LINES);
      this.vertex(args[0], args[1], 0);
      this.vertex(args[2], args[3], 0);
      this.endShape();
    }
    return this;
  };
  RendererGL.prototype.image = function(img, sx, sy, sWidth, sHeight, dx, dy, dWidth, dHeight) {
    if (this._isErasing) {
      this.blendMode(this._cachedBlendMode);
    }
    this.push();
    this.noLights();
    this.states.setValue("strokeColor", null);
    this.texture(img);
    this.states.setValue("textureMode", NORMAL);
    let u0 = 0;
    if (sx <= img.width) {
      u0 = sx / img.width;
    }
    let u1 = 1;
    if (sx + sWidth <= img.width) {
      u1 = (sx + sWidth) / img.width;
    }
    let v0 = 0;
    if (sy <= img.height) {
      v0 = sy / img.height;
    }
    let v1 = 1;
    if (sy + sHeight <= img.height) {
      v1 = (sy + sHeight) / img.height;
    }
    this._drawingImage = true;
    this.beginShape();
    this.vertex(dx, dy, 0, u0, v0);
    this.vertex(dx + dWidth, dy, 0, u1, v0);
    this.vertex(dx + dWidth, dy + dHeight, 0, u1, v1);
    this.vertex(dx, dy + dHeight, 0, u0, v1);
    this.endShape(CLOSE);
    this._drawingImage = false;
    this.pop();
    if (this._isErasing) {
      this.blendMode(REMOVE);
    }
  };
  const _truncatedCone = function(bottomRadius, topRadius, height, detailX, detailY, bottomCap, topCap) {
    bottomRadius = bottomRadius <= 0 ? 1 : bottomRadius;
    topRadius = topRadius < 0 ? 0 : topRadius;
    height = height <= 0 ? bottomRadius : height;
    detailX = detailX < 3 ? 3 : detailX;
    detailY = detailY < 1 ? 1 : detailY;
    bottomCap = bottomCap === undefined ? true : bottomCap;
    topCap = topCap === undefined ? topRadius !== 0 : topCap;
    const start = bottomCap ? -2 : 0;
    const end = detailY + (topCap ? 2 : 0);
    const slant = Math.atan2(bottomRadius - topRadius, height);
    const sinSlant = Math.sin(slant);
    const cosSlant = Math.cos(slant);
    let yy, ii, jj;
    for (yy = start;yy <= end; ++yy) {
      let v = yy / detailY;
      let y = height * v;
      let ringRadius;
      if (yy < 0) {
        y = 0;
        v = 0;
        ringRadius = bottomRadius;
      } else if (yy > detailY) {
        y = height;
        v = 1;
        ringRadius = topRadius;
      } else {
        ringRadius = bottomRadius + (topRadius - bottomRadius) * v;
      }
      if (yy === -2 || yy === detailY + 2) {
        ringRadius = 0;
      }
      y -= height / 2;
      for (ii = 0;ii < detailX; ++ii) {
        const u = ii / (detailX - 1);
        const ur = 2 * Math.PI * u;
        const sur = Math.sin(ur);
        const cur = Math.cos(ur);
        this.vertices.push(new Vector(sur * ringRadius, y, cur * ringRadius));
        let vertexNormal;
        if (yy < 0) {
          vertexNormal = new Vector(0, -1, 0);
        } else if (yy > detailY && topRadius) {
          vertexNormal = new Vector(0, 1, 0);
        } else {
          vertexNormal = new Vector(sur * cosSlant, sinSlant, cur * cosSlant);
        }
        this.vertexNormals.push(vertexNormal);
        this.uvs.push(u, v);
      }
    }
    let startIndex = 0;
    if (bottomCap) {
      for (jj = 0;jj < detailX; ++jj) {
        const nextjj = (jj + 1) % detailX;
        this.faces.push([
          startIndex + jj,
          startIndex + detailX + nextjj,
          startIndex + detailX + jj
        ]);
      }
      startIndex += detailX * 2;
    }
    for (yy = 0;yy < detailY; ++yy) {
      for (ii = 0;ii < detailX; ++ii) {
        const nextii = (ii + 1) % detailX;
        this.faces.push([
          startIndex + ii,
          startIndex + nextii,
          startIndex + detailX + nextii
        ]);
        this.faces.push([
          startIndex + ii,
          startIndex + detailX + nextii,
          startIndex + detailX + ii
        ]);
      }
      startIndex += detailX;
    }
    if (topCap) {
      startIndex += detailX;
      for (ii = 0;ii < detailX; ++ii) {
        this.faces.push([
          startIndex + ii,
          startIndex + (ii + 1) % detailX,
          startIndex + detailX
        ]);
      }
    }
  };
  RendererGL.prototype.plane = function(width = 50, height = width, detailX = 1, detailY = 1) {
    const gid = `plane|${detailX}|${detailY}`;
    if (!this.geometryInHash(gid)) {
      const _plane = function() {
        let u, v, p2;
        for (let i = 0;i <= this.detailY; i++) {
          v = i / this.detailY;
          for (let j = 0;j <= this.detailX; j++) {
            u = j / this.detailX;
            p2 = new Vector(u - 0.5, v - 0.5, 0);
            this.vertices.push(p2);
            this.uvs.push(u, v);
          }
        }
      };
      const planeGeom = new Geometry(detailX, detailY, _plane, this);
      planeGeom.computeFaces().computeNormals();
      if (detailX <= 1 && detailY <= 1) {
        planeGeom._makeTriangleEdges()._edgesToVertices();
      } else if (this.states.strokeColor) {
        console.log("Cannot draw stroke on plane objects with more" + " than 1 detailX or 1 detailY");
      }
      planeGeom.gid = gid;
      this.geometryBufferCache.ensureCached(planeGeom);
    }
    this._drawGeometryScaled(this.geometryBufferCache.getGeometryByID(gid), width, height, 1);
  };
  RendererGL.prototype.box = function(width = 50, height = width, depth = height, detailX, detailY) {
    const perPixelLighting = this.attributes && this.attributes.perPixelLighting;
    if (typeof detailX === "undefined") {
      detailX = perPixelLighting ? 1 : 4;
    }
    if (typeof detailY === "undefined") {
      detailY = perPixelLighting ? 1 : 4;
    }
    const gid = `box|${detailX}|${detailY}`;
    if (!this.geometryInHash(gid)) {
      const _box = function() {
        const cubeIndices = [
          [0, 4, 2, 6],
          [1, 3, 5, 7],
          [0, 1, 4, 5],
          [2, 6, 3, 7],
          [0, 2, 1, 3],
          [4, 5, 6, 7]
        ];
        this.edges = [
          [0, 1],
          [1, 3],
          [3, 2],
          [6, 7],
          [8, 9],
          [9, 11],
          [14, 15],
          [16, 17],
          [17, 19],
          [18, 19],
          [20, 21],
          [22, 23]
        ];
        cubeIndices.forEach((cubeIndex, i) => {
          const v = i * 4;
          for (let j = 0;j < 4; j++) {
            const d2 = cubeIndex[j];
            const octant = new Vector(((d2 & 1) * 2 - 1) / 2, ((d2 & 2) - 1) / 2, ((d2 & 4) / 2 - 1) / 2);
            this.vertices.push(octant);
            this.uvs.push(j & 1, (j & 2) / 2);
          }
          this.faces.push([v, v + 1, v + 2]);
          this.faces.push([v + 2, v + 1, v + 3]);
        });
      };
      const boxGeom = new Geometry(detailX, detailY, _box, this);
      boxGeom.computeNormals();
      if (detailX <= 4 && detailY <= 4) {
        boxGeom._edgesToVertices();
      } else if (this.states.strokeColor) {
        console.log("Cannot draw stroke on box objects with more" + " than 4 detailX or 4 detailY");
      }
      boxGeom.gid = gid;
      this.geometryBufferCache.ensureCached(boxGeom);
    }
    this._drawGeometryScaled(this.geometryBufferCache.getGeometryByID(gid), width, height, depth);
  };
  RendererGL.prototype.sphere = function(radius = 50, detailX = 24, detailY = 16) {
    this.ellipsoid(radius, radius, radius, detailX, detailY);
  };
  RendererGL.prototype.ellipsoid = function(radiusX = 50, radiusY = radiusX, radiusZ = radiusX, detailX = 24, detailY = 16) {
    const gid = `ellipsoid|${detailX}|${detailY}`;
    if (!this.geometryInHash(gid)) {
      const _ellipsoid = function() {
        for (let i = 0;i <= this.detailY; i++) {
          const v = i / this.detailY;
          const phi = Math.PI * v - Math.PI / 2;
          const cosPhi = Math.cos(phi);
          const sinPhi = Math.sin(phi);
          for (let j = 0;j <= this.detailX; j++) {
            const u = j / this.detailX;
            const theta = 2 * Math.PI * u;
            const cosTheta = Math.cos(theta);
            const sinTheta = Math.sin(theta);
            const p2 = new p52.Vector(cosPhi * sinTheta, sinPhi, cosPhi * cosTheta);
            this.vertices.push(p2);
            this.vertexNormals.push(p2);
            this.uvs.push(u, v);
          }
        }
      };
      const ellipsoidGeom = new Geometry(detailX, detailY, _ellipsoid, this);
      ellipsoidGeom.computeFaces();
      if (detailX <= 24 && detailY <= 24) {
        ellipsoidGeom._makeTriangleEdges()._edgesToVertices();
      } else if (this.states.strokeColor) {
        console.log("Cannot draw stroke on ellipsoids with more" + " than 24 detailX or 24 detailY");
      }
      ellipsoidGeom.gid = gid;
      this.geometryBufferCache.ensureCached(ellipsoidGeom);
    }
    this._drawGeometryScaled(this.geometryBufferCache.getGeometryByID(gid), radiusX, radiusY, radiusZ);
  };
  RendererGL.prototype.cylinder = function(radius = 50, height = radius, detailX = 24, detailY = 1, bottomCap = true, topCap = true) {
    const gid = `cylinder|${detailX}|${detailY}|${bottomCap}|${topCap}`;
    if (!this.geometryInHash(gid)) {
      const cylinderGeom = new p52.Geometry(detailX, detailY, function() {
        _truncatedCone.call(this, 1, 1, 1, detailX, detailY, bottomCap, topCap);
      }, this);
      if (detailX <= 24 && detailY <= 16) {
        cylinderGeom._makeTriangleEdges()._edgesToVertices();
      } else if (this.states.strokeColor) {
        console.log("Cannot draw stroke on cylinder objects with more" + " than 24 detailX or 16 detailY");
      }
      cylinderGeom.gid = gid;
      this.geometryBufferCache.ensureCached(cylinderGeom);
    }
    this._drawGeometryScaled(this.geometryBufferCache.getGeometryByID(gid), radius, height, radius);
  };
  RendererGL.prototype.cone = function(radius = 50, height = radius, detailX = 24, detailY = 1, cap = true) {
    const gid = `cone|${detailX}|${detailY}|${cap}`;
    if (!this.geometryInHash(gid)) {
      const coneGeom = new Geometry(detailX, detailY, function() {
        _truncatedCone.call(this, 1, 0, 1, detailX, detailY, cap, false);
      }, this);
      if (detailX <= 24 && detailY <= 16) {
        coneGeom._makeTriangleEdges()._edgesToVertices();
      } else if (this.states.strokeColor) {
        console.log("Cannot draw stroke on cone objects with more" + " than 24 detailX or 16 detailY");
      }
      coneGeom.gid = gid;
      this.geometryBufferCache.ensureCached(coneGeom);
    }
    this._drawGeometryScaled(this.geometryBufferCache.getGeometryByID(gid), radius, height, radius);
  };
  RendererGL.prototype.torus = function(radius = 50, tubeRadius = 10, detailX = 24, detailY = 16) {
    if (radius === 0) {
      return;
    }
    if (tubeRadius === 0) {
      return;
    }
    const tubeRatio = (tubeRadius / radius).toPrecision(4);
    const gid = `torus|${tubeRatio}|${detailX}|${detailY}`;
    if (!this.geometryInHash(gid)) {
      const _torus = function() {
        for (let i = 0;i <= this.detailY; i++) {
          const v = i / this.detailY;
          const phi = 2 * Math.PI * v;
          const cosPhi = Math.cos(phi);
          const sinPhi = Math.sin(phi);
          const r = 1 + tubeRatio * cosPhi;
          for (let j = 0;j <= this.detailX; j++) {
            const u = j / this.detailX;
            const theta = 2 * Math.PI * u;
            const cosTheta = Math.cos(theta);
            const sinTheta = Math.sin(theta);
            const p2 = new Vector(r * cosTheta, r * sinTheta, tubeRatio * sinPhi);
            const n2 = new Vector(cosPhi * cosTheta, cosPhi * sinTheta, sinPhi);
            this.vertices.push(p2);
            this.vertexNormals.push(n2);
            this.uvs.push(u, v);
          }
        }
      };
      const torusGeom = new Geometry(detailX, detailY, _torus, this);
      torusGeom.computeFaces();
      if (detailX <= 24 && detailY <= 16) {
        torusGeom._makeTriangleEdges()._edgesToVertices();
      } else if (this.states.strokeColor) {
        console.log("Cannot draw strokes on torus object with more" + " than 24 detailX or 16 detailY");
      }
      torusGeom.gid = gid;
      this.geometryBufferCache.ensureCached(torusGeom);
    }
    this._drawGeometryScaled(this.geometryBufferCache.getGeometryByID(gid), radius, radius, radius);
  };
  fn2.curveDetail = function(d2) {
    if (!(this._renderer instanceof RendererGL)) {
      throw new Error("curveDetail() only works in WebGL mode. Did you mean to call createCanvas(width, height, WEBGL)?");
    }
    return this._renderer.curveDetail(d2);
  };
}
if (typeof p5 !== "undefined") {
  primitives3D(p5, p5.prototype);
}
function light(p52, fn2) {
  fn2.ambientLight = function(v1, v2, v3, a) {
    this._assert3d("ambientLight");
    this._renderer.ambientLight(...arguments);
    return this;
  };
  fn2.specularColor = function(v1, v2, v3) {
    this._assert3d("specularColor");
    this._renderer.specularColor(...arguments);
    return this;
  };
  fn2.directionalLight = function(v1, v2, v3, x, y, z) {
    this._assert3d("directionalLight");
    this._renderer.directionalLight(...arguments);
    return this;
  };
  fn2.pointLight = function(v1, v2, v3, x, y, z) {
    this._assert3d("pointLight");
    this._renderer.pointLight(...arguments);
    return this;
  };
  fn2.imageLight = function(img) {
    this._renderer.imageLight(img);
  };
  fn2.panorama = function(img) {
    this.filter(this._renderer._getSphereMapping(img));
  };
  fn2.lights = function() {
    this._assert3d("lights");
    this._renderer.lights();
    return this;
  };
  fn2.lightFalloff = function(constantAttenuation, linearAttenuation, quadraticAttenuation) {
    this._assert3d("lightFalloff");
    this._renderer.lightFalloff(constantAttenuation, linearAttenuation, quadraticAttenuation);
    return this;
  };
  fn2.spotLight = function(v1, v2, v3, x, y, z, nx, ny, nz, angle, concentration) {
    this._assert3d("spotLight");
    this._renderer.spotLight(...arguments);
    return this;
  };
  fn2.noLights = function(...args) {
    this._assert3d("noLights");
    this._renderer.noLights();
    return this;
  };
  RendererGL.prototype.ambientLight = function(v1, v2, v3, a) {
    const color2 = this._pInst.color(...arguments);
    this.states.setValue("ambientLightColors", [...this.states.ambientLightColors]);
    this.states.ambientLightColors.push(color2._array[0], color2._array[1], color2._array[2]);
    this.states.setValue("enableLighting", true);
  };
  RendererGL.prototype.specularColor = function(v1, v2, v3) {
    const color2 = this._pInst.color(...arguments);
    this.states.setValue("specularColors", [
      color2._array[0],
      color2._array[1],
      color2._array[2]
    ]);
  };
  RendererGL.prototype.directionalLight = function(v1, v2, v3, x, y, z) {
    let color2;
    if (v1 instanceof Color) {
      color2 = v1;
    } else {
      color2 = this._pInst.color(v1, v2, v3);
    }
    let _x, _y, _z;
    const v = arguments[arguments.length - 1];
    if (typeof v === "number") {
      _x = arguments[arguments.length - 3];
      _y = arguments[arguments.length - 2];
      _z = arguments[arguments.length - 1];
    } else {
      _x = v.x;
      _y = v.y;
      _z = v.z;
    }
    const l = Math.sqrt(_x * _x + _y * _y + _z * _z);
    this.states.setValue("directionalLightDirections", [...this.states.directionalLightDirections]);
    this.states.directionalLightDirections.push(_x / l, _y / l, _z / l);
    this.states.setValue("directionalLightDiffuseColors", [...this.states.directionalLightDiffuseColors]);
    this.states.directionalLightDiffuseColors.push(color2._array[0], color2._array[1], color2._array[2]);
    this.states.setValue("directionalLightSpecularColors", [...this.states.directionalLightSpecularColors]);
    Array.prototype.push.apply(this.states.directionalLightSpecularColors, this.states.specularColors);
    this.states.setValue("enableLighting", true);
  };
  RendererGL.prototype.pointLight = function(v1, v2, v3, x, y, z) {
    let color2;
    if (v1 instanceof Color) {
      color2 = v1;
    } else {
      color2 = this._pInst.color(v1, v2, v3);
    }
    let _x, _y, _z;
    const v = arguments[arguments.length - 1];
    if (typeof v === "number") {
      _x = arguments[arguments.length - 3];
      _y = arguments[arguments.length - 2];
      _z = arguments[arguments.length - 1];
    } else {
      _x = v.x;
      _y = v.y;
      _z = v.z;
    }
    this.states.setValue("pointLightPositions", [...this.states.pointLightPositions]);
    this.states.pointLightPositions.push(_x, _y, _z);
    this.states.setValue("pointLightDiffuseColors", [...this.states.pointLightDiffuseColors]);
    this.states.pointLightDiffuseColors.push(color2._array[0], color2._array[1], color2._array[2]);
    this.states.setValue("pointLightSpecularColors", [...this.states.pointLightSpecularColors]);
    Array.prototype.push.apply(this.states.pointLightSpecularColors, this.states.specularColors);
    this.states.setValue("enableLighting", true);
  };
  RendererGL.prototype.imageLight = function(img) {
    this.states.setValue("activeImageLight", img);
    this.states.setValue("enableLighting", true);
  };
  RendererGL.prototype.lights = function() {
    const grayColor = this._pInst.color("rgb(128,128,128)");
    this.ambientLight(grayColor);
    this.directionalLight(grayColor, 0, 0, -1);
  };
  RendererGL.prototype.lightFalloff = function(constantAttenuation, linearAttenuation, quadraticAttenuation) {
    if (constantAttenuation < 0) {
      constantAttenuation = 0;
      console.warn("Value of constant argument in lightFalloff() should be never be negative. Set to 0.");
    }
    if (linearAttenuation < 0) {
      linearAttenuation = 0;
      console.warn("Value of linear argument in lightFalloff() should be never be negative. Set to 0.");
    }
    if (quadraticAttenuation < 0) {
      quadraticAttenuation = 0;
      console.warn("Value of quadratic argument in lightFalloff() should be never be negative. Set to 0.");
    }
    if (constantAttenuation === 0 && (linearAttenuation === 0 && quadraticAttenuation === 0)) {
      constantAttenuation = 1;
      console.warn("Either one of the three arguments in lightFalloff() should be greater than zero. Set constant argument to 1.");
    }
    this.states.setValue("constantAttenuation", constantAttenuation);
    this.states.setValue("linearAttenuation", linearAttenuation);
    this.states.setValue("quadraticAttenuation", quadraticAttenuation);
  };
  RendererGL.prototype.spotLight = function(v1, v2, v3, x, y, z, nx, ny, nz, angle, concentration) {
    let color2, position, direction;
    const length = arguments.length;
    switch (length) {
      case 11:
      case 10:
        color2 = this._pInst.color(v1, v2, v3);
        position = new Vector(x, y, z);
        direction = new Vector(nx, ny, nz);
        break;
      case 9:
        if (v1 instanceof Color) {
          color2 = v1;
          position = new Vector(v2, v3, x);
          direction = new Vector(y, z, nx);
          angle = ny;
          concentration = nz;
        } else if (x instanceof Vector) {
          color2 = this._pInst.color(v1, v2, v3);
          position = x;
          direction = new Vector(y, z, nx);
          angle = ny;
          concentration = nz;
        } else if (nx instanceof Vector) {
          color2 = this._pInst.color(v1, v2, v3);
          position = new Vector(x, y, z);
          direction = nx;
          angle = ny;
          concentration = nz;
        } else {
          color2 = this._pInst.color(v1, v2, v3);
          position = new Vector(x, y, z);
          direction = new Vector(nx, ny, nz);
        }
        break;
      case 8:
        if (v1 instanceof Color) {
          color2 = v1;
          position = new Vector(v2, v3, x);
          direction = new Vector(y, z, nx);
          angle = ny;
        } else if (x instanceof Vector) {
          color2 = this._pInst.color(v1, v2, v3);
          position = x;
          direction = new Vector(y, z, nx);
          angle = ny;
        } else {
          color2 = this._pInst.color(v1, v2, v3);
          position = new Vector(x, y, z);
          direction = nx;
          angle = ny;
        }
        break;
      case 7:
        if (v1 instanceof Color && v2 instanceof Vector) {
          color2 = v1;
          position = v2;
          direction = new Vector(v3, x, y);
          angle = z;
          concentration = nx;
        } else if (v1 instanceof Color && y instanceof Vector) {
          color2 = v1;
          position = new Vector(v2, v3, x);
          direction = y;
          angle = z;
          concentration = nx;
        } else if (x instanceof Vector && y instanceof Vector) {
          color2 = this._pInst.color(v1, v2, v3);
          position = x;
          direction = y;
          angle = z;
          concentration = nx;
        } else if (v1 instanceof Color) {
          color2 = v1;
          position = new Vector(v2, v3, x);
          direction = new Vector(y, z, nx);
        } else if (x instanceof Vector) {
          color2 = this._pInst.color(v1, v2, v3);
          position = x;
          direction = new Vector(y, z, nx);
        } else {
          color2 = this._pInst.color(v1, v2, v3);
          position = new Vector(x, y, z);
          direction = nx;
        }
        break;
      case 6:
        if (x instanceof Vector && y instanceof Vector) {
          color2 = this._pInst.color(v1, v2, v3);
          position = x;
          direction = y;
          angle = z;
        } else if (v1 instanceof Color && y instanceof Vector) {
          color2 = v1;
          position = new Vector(v2, v3, x);
          direction = y;
          angle = z;
        } else if (v1 instanceof Color && v2 instanceof Vector) {
          color2 = v1;
          position = v2;
          direction = new Vector(v3, x, y);
          angle = z;
        }
        break;
      case 5:
        if (v1 instanceof Color && v2 instanceof Vector && v3 instanceof Vector) {
          color2 = v1;
          position = v2;
          direction = v3;
          angle = x;
          concentration = y;
        } else if (x instanceof Vector && y instanceof Vector) {
          color2 = this._pInst.color(v1, v2, v3);
          position = x;
          direction = y;
        } else if (v1 instanceof Color && y instanceof Vector) {
          color2 = v1;
          position = new Vector(v2, v3, x);
          direction = y;
        } else if (v1 instanceof Color && v2 instanceof Vector) {
          color2 = v1;
          position = v2;
          direction = new Vector(v3, x, y);
        }
        break;
      case 4:
        color2 = v1;
        position = v2;
        direction = v3;
        angle = x;
        break;
      case 3:
        color2 = v1;
        position = v2;
        direction = v3;
        break;
      default:
        console.warn(`Sorry, input for spotlight() is not in prescribed format. Too ${length < 3 ? "few" : "many"} arguments were provided`);
        return;
    }
    this.states.setValue("spotLightDiffuseColors", [
      color2._array[0],
      color2._array[1],
      color2._array[2]
    ]);
    this.states.setValue("spotLightSpecularColors", [
      ...this.states.specularColors
    ]);
    this.states.setValue("spotLightPositions", [position.x, position.y, position.z]);
    direction.normalize();
    this.states.setValue("spotLightDirections", [
      direction.x,
      direction.y,
      direction.z
    ]);
    if (angle === undefined) {
      angle = Math.PI / 3;
    }
    if (concentration !== undefined && concentration < 1) {
      concentration = 1;
      console.warn("Value of concentration needs to be greater than 1. Setting it to 1");
    } else if (concentration === undefined) {
      concentration = 100;
    }
    angle = this._pInst._toRadians(angle);
    this.states.setValue("spotLightAngle", [Math.cos(angle)]);
    this.states.setValue("spotLightConc", [concentration]);
    this.states.setValue("enableLighting", true);
  };
  RendererGL.prototype.noLights = function() {
    this.states.setValue("activeImageLight", null);
    this.states.setValue("enableLighting", false);
    this.states.setValue("ambientLightColors", []);
    this.states.setValue("specularColors", [1, 1, 1]);
    this.states.setValue("directionalLightDirections", []);
    this.states.setValue("directionalLightDiffuseColors", []);
    this.states.setValue("directionalLightSpecularColors", []);
    this.states.setValue("pointLightPositions", []);
    this.states.setValue("pointLightDiffuseColors", []);
    this.states.setValue("pointLightSpecularColors", []);
    this.states.setValue("spotLightPositions", []);
    this.states.setValue("spotLightDirections", []);
    this.states.setValue("spotLightDiffuseColors", []);
    this.states.setValue("spotLightSpecularColors", []);
    this.states.setValue("spotLightAngle", []);
    this.states.setValue("spotLightConc", []);
    this.states.setValue("constantAttenuation", 1);
    this.states.setValue("linearAttenuation", 0);
    this.states.setValue("quadraticAttenuation", 0);
    this.states.setValue("_useShininess", 1);
    this.states.setValue("_useMetalness", 0);
  };
}
if (typeof p5 !== "undefined") {
  light(p5, p5.prototype);
}
function material(p52, fn2) {
  fn2.loadShader = async function(vertFilename, fragFilename, successCallback, failureCallback) {
    const loadedShader = new Shader;
    try {
      loadedShader._vertSrc = (await request(vertFilename, "text")).data;
      loadedShader._fragSrc = (await request(fragFilename, "text")).data;
      if (successCallback) {
        return successCallback(loadedShader);
      } else {
        return loadedShader;
      }
    } catch (err) {
      if (failureCallback) {
        return failureCallback(err);
      } else {
        throw err;
      }
    }
  };
  fn2.createShader = function(vertSrc, fragSrc, options2) {
    return new Shader(this._renderer, vertSrc, fragSrc, options2);
  };
  fn2.loadFilterShader = async function(fragFilename, successCallback, failureCallback) {
    try {
      const fragSrc = await this.loadStrings(fragFilename);
      const fragString = await fragSrc.join(`
`);
      const loadedShader = this.createFilterShader(fragString, true);
      if (successCallback) {
        successCallback(loadedShader);
      }
      return loadedShader;
    } catch (err) {
      if (failureCallback) {
        failureCallback(err);
      } else {
        console.error(err);
      }
    }
  };
  fn2.createFilterShader = function(fragSrc, skipContextCheck = false) {
    let defaultVertV1 = `
      uniform mat4 uModelViewMatrix;
      uniform mat4 uProjectionMatrix;

      attribute vec3 aPosition;
      // texcoords only come from p5 to vertex shader
      // so pass texcoords on to the fragment shader in a varying variable
      attribute vec2 aTexCoord;
      varying vec2 vTexCoord;

      void main() {
        // transferring texcoords for the frag shader
        vTexCoord = aTexCoord;

        // copy position with a fourth coordinate for projection (1.0 is normal)
        vec4 positionVec4 = vec4(aPosition, 1.0);

        // project to 3D space
        gl_Position = uProjectionMatrix * uModelViewMatrix * positionVec4;
      }
    `;
    let defaultVertV2 = `#version 300 es
      uniform mat4 uModelViewMatrix;
      uniform mat4 uProjectionMatrix;

      in vec3 aPosition;
      in vec2 aTexCoord;
      out vec2 vTexCoord;

      void main() {
        // transferring texcoords for the frag shader
        vTexCoord = aTexCoord;

        // copy position with a fourth coordinate for projection (1.0 is normal)
        vec4 positionVec4 = vec4(aPosition, 1.0);

        // project to 3D space
        gl_Position = uProjectionMatrix * uModelViewMatrix * positionVec4;
      }
    `;
    let vertSrc = fragSrc.includes("#version 300 es") ? defaultVertV2 : defaultVertV1;
    const shader2 = new Shader(this._renderer, vertSrc, fragSrc);
    if (!skipContextCheck) {
      if (this._renderer.GL) {
        shader2.ensureCompiledOnContext(this._renderer);
      } else {
        shader2.ensureCompiledOnContext(this);
      }
    }
    return shader2;
  };
  fn2.shader = function(s) {
    this._assert3d("shader");
    this._renderer.shader(s);
    return this;
  };
  fn2.strokeShader = function(s) {
    this._assert3d("strokeShader");
    this._renderer.strokeShader(s);
    return this;
  };
  fn2.imageShader = function(s) {
    this._assert3d("imageShader");
    this._renderer.imageShader(s);
    return this;
  };
  fn2.baseMaterialShader = function() {
    this._assert3d("baseMaterialShader");
    return this._renderer.baseMaterialShader();
  };
  fn2.baseFilterShader = function() {
    return (this._renderer.filterRenderer || this._renderer).baseFilterShader();
  };
  fn2.baseNormalShader = function() {
    this._assert3d("baseNormalShader");
    return this._renderer.baseNormalShader();
  };
  fn2.baseColorShader = function() {
    this._assert3d("baseColorShader");
    return this._renderer.baseColorShader();
  };
  fn2.baseStrokeShader = function() {
    this._assert3d("baseStrokeShader");
    return this._renderer.baseStrokeShader();
  };
  fn2.resetShader = function() {
    this._renderer.resetShader();
    return this;
  };
  fn2.texture = function(tex) {
    this._assert3d("texture");
    if (tex.gifProperties) {
      tex._animateGif(this);
    }
    this._renderer.texture(tex);
    return this;
  };
  fn2.textureMode = function(mode) {
    if (mode !== IMAGE && mode !== NORMAL) {
      console.warn(`You tried to set ${mode} textureMode only supports IMAGE & NORMAL `);
    } else {
      this._renderer.states.setValue("textureMode", mode);
    }
  };
  fn2.textureWrap = function(wrapX, wrapY = wrapX) {
    this._renderer.states.setValue("textureWrapX", wrapX);
    this._renderer.states.setValue("textureWrapY", wrapY);
    for (const texture of this._renderer.textures.values()) {
      texture.setWrapMode(wrapX, wrapY);
    }
  };
  fn2.normalMaterial = function(...args) {
    this._assert3d("normalMaterial");
    this._renderer.normalMaterial(...args);
    return this;
  };
  fn2.ambientMaterial = function(v1, v2, v3) {
    this._assert3d("ambientMaterial");
    const color2 = fn2.color.apply(this, arguments);
    this._renderer.states.setValue("_hasSetAmbient", true);
    this._renderer.states.setValue("curAmbientColor", color2._array);
    this._renderer.states.setValue("_useNormalMaterial", false);
    this._renderer.states.setValue("enableLighting", true);
    if (!this._renderer.states.fillColor) {
      this._renderer.states.setValue("fillColor", new Color([1, 1, 1]));
    }
    return this;
  };
  fn2.emissiveMaterial = function(v1, v2, v3, a) {
    this._assert3d("emissiveMaterial");
    const color2 = fn2.color.apply(this, arguments);
    this._renderer.states.setValue("curEmissiveColor", color2._array);
    this._renderer.states.setValue("_useEmissiveMaterial", true);
    this._renderer.states.setValue("_useNormalMaterial", false);
    this._renderer.states.setValue("enableLighting", true);
    return this;
  };
  fn2.specularMaterial = function(v1, v2, v3, alpha) {
    this._assert3d("specularMaterial");
    const color2 = fn2.color.apply(this, arguments);
    this._renderer.states.setValue("curSpecularColor", color2._array);
    this._renderer.states.setValue("_useSpecularMaterial", true);
    this._renderer.states.setValue("_useNormalMaterial", false);
    this._renderer.states.setValue("enableLighting", true);
    return this;
  };
  fn2.shininess = function(shine) {
    this._assert3d("shininess");
    this._renderer.shininess(shine);
    return this;
  };
  fn2.metalness = function(metallic) {
    this._assert3d("metalness");
    this._renderer.metalness(metallic);
    return this;
  };
  RendererGL.prototype._applyColorBlend = function(colors, hasTransparency) {
    const gl = this.GL;
    const isTexture = this.states.drawMode === TEXTURE;
    const doBlend = hasTransparency || this.states.userFillShader || this.states.userStrokeShader || this.states.userPointShader || isTexture || this.states.curBlendMode !== BLEND || colors[colors.length - 1] < 1 || this._isErasing;
    if (doBlend !== this._isBlending) {
      if (doBlend || this.states.curBlendMode !== BLEND && this.states.curBlendMode !== ADD) {
        gl.enable(gl.BLEND);
      } else {
        gl.disable(gl.BLEND);
      }
      gl.depthMask(true);
      this._isBlending = doBlend;
    }
    this._applyBlendMode();
    return colors;
  };
  RendererGL.prototype._applyBlendMode = function() {
    if (this._cachedBlendMode === this.states.curBlendMode) {
      return;
    }
    const gl = this.GL;
    switch (this.states.curBlendMode) {
      case BLEND:
        gl.blendEquation(gl.FUNC_ADD);
        gl.blendFunc(gl.ONE, gl.ONE_MINUS_SRC_ALPHA);
        break;
      case ADD:
        gl.blendEquation(gl.FUNC_ADD);
        gl.blendFunc(gl.ONE, gl.ONE);
        break;
      case REMOVE:
        gl.blendEquation(gl.FUNC_ADD);
        gl.blendFunc(gl.ZERO, gl.ONE_MINUS_SRC_ALPHA);
        break;
      case MULTIPLY:
        gl.blendEquation(gl.FUNC_ADD);
        gl.blendFunc(gl.DST_COLOR, gl.ONE_MINUS_SRC_ALPHA);
        break;
      case SCREEN:
        gl.blendEquation(gl.FUNC_ADD);
        gl.blendFunc(gl.ONE, gl.ONE_MINUS_SRC_COLOR);
        break;
      case EXCLUSION:
        gl.blendEquationSeparate(gl.FUNC_ADD, gl.FUNC_ADD);
        gl.blendFuncSeparate(gl.ONE_MINUS_DST_COLOR, gl.ONE_MINUS_SRC_COLOR, gl.ONE, gl.ONE);
        break;
      case REPLACE:
        gl.blendEquation(gl.FUNC_ADD);
        gl.blendFunc(gl.ONE, gl.ZERO);
        break;
      case SUBTRACT:
        gl.blendEquationSeparate(gl.FUNC_REVERSE_SUBTRACT, gl.FUNC_ADD);
        gl.blendFuncSeparate(gl.ONE, gl.ONE, gl.ONE, gl.ONE_MINUS_SRC_ALPHA);
        break;
      case DARKEST:
        if (this.blendExt) {
          gl.blendEquationSeparate(this.blendExt.MIN || this.blendExt.MIN_EXT, gl.FUNC_ADD);
          gl.blendFuncSeparate(gl.ONE, gl.ONE, gl.ONE, gl.ONE);
        } else {
          console.warn("blendMode(DARKEST) does not work in your browser in WEBGL mode.");
        }
        break;
      case LIGHTEST:
        if (this.blendExt) {
          gl.blendEquationSeparate(this.blendExt.MAX || this.blendExt.MAX_EXT, gl.FUNC_ADD);
          gl.blendFuncSeparate(gl.ONE, gl.ONE, gl.ONE, gl.ONE);
        } else {
          console.warn("blendMode(LIGHTEST) does not work in your browser in WEBGL mode.");
        }
        break;
      default:
        console.error("Oops! Somehow RendererGL set curBlendMode to an unsupported mode.");
        break;
    }
    this._cachedBlendMode = this.states.curBlendMode;
  };
  RendererGL.prototype.shader = function(s) {
    this.states.setValue("userFillShader", s);
    this.states.setValue("_useNormalMaterial", false);
    s.ensureCompiledOnContext(this);
    s.setDefaultUniforms();
  };
  RendererGL.prototype.strokeShader = function(s) {
    this.states.setValue("userStrokeShader", s);
    s.ensureCompiledOnContext(this);
    s.setDefaultUniforms();
  };
  RendererGL.prototype.imageShader = function(s) {
    this.states.setValue("userImageShader", s);
    s.ensureCompiledOnContext(this);
    s.setDefaultUniforms();
  };
  RendererGL.prototype.resetShader = function() {
    this.states.setValue("userFillShader", null);
    this.states.setValue("userStrokeShader", null);
    this.states.setValue("userImageShader", null);
  };
  RendererGL.prototype.texture = function(tex) {
    this.states.setValue("drawMode", TEXTURE);
    this.states.setValue("_useNormalMaterial", false);
    this.states.setValue("_tex", tex);
    this.states.setValue("fillColor", new Color([1, 1, 1]));
  };
  RendererGL.prototype.normalMaterial = function(...args) {
    this.states.setValue("drawMode", FILL);
    this.states.setValue("_useSpecularMaterial", false);
    this.states.setValue("_useEmissiveMaterial", false);
    this.states.setValue("_useNormalMaterial", true);
    this.states.setValue("curFillColor", [1, 1, 1, 1]);
    this.states.setValue("fillColor", new Color([1, 1, 1]));
    this.states.setValue("strokeColor", null);
  };
  RendererGL.prototype.shininess = function(shine) {
    if (shine < 1) {
      shine = 1;
    }
    this.states.setValue("_useShininess", shine);
  };
  RendererGL.prototype.metalness = function(metallic) {
    const metalMix = 1 - Math.exp(-metallic / 100);
    this.states.setValue("_useMetalness", metalMix);
  };
}
if (typeof p5 !== "undefined") {
  loading(p5, p5.prototype);
}

class Graphics {
  constructor(w, h, renderer2, pInst, canvas2) {
    const r = renderer2 || P2D;
    this._pInst = pInst;
    this._renderer = new renderers[r](this, w, h, false, canvas2);
    this._initializeInstanceVariables(this);
    this._renderer._applyDefaults();
    return this;
  }
  get elt() {
    return this.canvas;
  }
  get deltaTime() {
    return this._pInst.deltaTime;
  }
  get canvas() {
    return this._renderer?.canvas;
  }
  get drawingContext() {
    return this._renderer.drawingContext;
  }
  get width() {
    return this._renderer?.width;
  }
  get height() {
    return this._renderer?.height;
  }
  get pixels() {
    return this._renderer?.pixels;
  }
  pixelDensity(val) {
    let returnValue;
    if (typeof val === "number") {
      if (val !== this._renderer._pixelDensity) {
        this._renderer._pixelDensity = val;
      }
      returnValue = this;
      this.resizeCanvas(this.width, this.height, true);
    } else {
      returnValue = this._renderer._pixelDensity;
    }
    return returnValue;
  }
  resizeCanvas(w, h) {
    this._renderer.resize(w, h);
  }
  reset() {
    this._renderer.resetMatrix();
    if (this._renderer.isP3D) {
      this._renderer._update();
    }
  }
  remove() {
    this._renderer.remove();
    this._renderer = undefined;
  }
  createFramebuffer(options2) {
    return new Framebuffer(this._renderer, options2);
  }
  _assert3d(name) {
    if (!this._renderer.isP3D)
      throw new Error(`${name}() is only supported in WEBGL mode. If you'd like to use 3D graphics and WebGL, see  https://p5js.org/examples/form-3d-primitives.html for more information.`);
  }
  _initializeInstanceVariables() {
    this._accessibleOutputs = {
      text: false,
      grid: false,
      textLabel: false,
      gridLabel: false
    };
    this._styles = [];
    this._downKeys = {};
  }
}
function graphics(p52, fn2) {
  p52.Graphics = Graphics;
  primitives(p52, p52.Graphics.prototype);
  attributes(p52, p52.Graphics.prototype);
  curves(p52, p52.Graphics.prototype);
  vertex(p52, p52.Graphics.prototype);
  customShapes(p52, p52.Graphics.prototype);
  setting(p52, p52.Graphics.prototype);
  loadingDisplaying(p52, p52.Graphics.prototype);
  image2(p52, p52.Graphics.prototype);
  pixels(p52, p52.Graphics.prototype);
  transform(p52, p52.Graphics.prototype);
  primitives3D(p52, p52.Graphics.prototype);
  light(p52, p52.Graphics.prototype);
  material(p52, p52.Graphics.prototype);
  creatingReading(p52, p52.Graphics.prototype);
  trigonometry(p52, p52.Graphics.prototype);
}

class Texture {
  constructor(renderer2, obj, settings) {
    this._renderer = renderer2;
    const gl = this._renderer.GL;
    settings = settings || {};
    this.src = obj;
    this.glTex = undefined;
    this.glTarget = gl.TEXTURE_2D;
    this.glFormat = settings.format || gl.RGBA;
    this.mipmaps = false;
    this.glMinFilter = settings.minFilter || gl.LINEAR;
    this.glMagFilter = settings.magFilter || gl.LINEAR;
    this.glWrapS = settings.wrapS || gl.CLAMP_TO_EDGE;
    this.glWrapT = settings.wrapT || gl.CLAMP_TO_EDGE;
    this.glDataType = settings.dataType || gl.UNSIGNED_BYTE;
    const support = checkWebGLCapabilities(renderer2);
    if (this.glFormat === gl.HALF_FLOAT && !support.halfFloat) {
      console.log("This device does not support dataType HALF_FLOAT. Falling back to FLOAT.");
      this.glDataType = gl.FLOAT;
    }
    if (this.glFormat === gl.HALF_FLOAT && (this.glMinFilter === gl.LINEAR || this.glMagFilter === gl.LINEAR) && !support.halfFloatLinear) {
      console.log("This device does not support linear filtering for dataType FLOAT. Falling back to NEAREST.");
      if (this.glMinFilter === gl.LINEAR)
        this.glMinFilter = gl.NEAREST;
      if (this.glMagFilter === gl.LINEAR)
        this.glMagFilter = gl.NEAREST;
    }
    if (this.glFormat === gl.FLOAT && !support.float) {
      console.log("This device does not support dataType FLOAT. Falling back to UNSIGNED_BYTE.");
      this.glDataType = gl.UNSIGNED_BYTE;
    }
    if (this.glFormat === gl.FLOAT && (this.glMinFilter === gl.LINEAR || this.glMagFilter === gl.LINEAR) && !support.floatLinear) {
      console.log("This device does not support linear filtering for dataType FLOAT. Falling back to NEAREST.");
      if (this.glMinFilter === gl.LINEAR)
        this.glMinFilter = gl.NEAREST;
      if (this.glMagFilter === gl.LINEAR)
        this.glMagFilter = gl.NEAREST;
    }
    this.isSrcMediaElement = false;
    this._videoPrevUpdateTime = 0;
    this.isSrcHTMLElement = typeof Element !== "undefined" && obj instanceof Element && !(obj instanceof Graphics) && !(obj instanceof Renderer);
    this.isSrcP5Image = obj instanceof Image;
    this.isSrcP5Graphics = obj instanceof Graphics;
    this.isSrcP5Renderer = obj instanceof Renderer;
    this.isImageData = typeof ImageData !== "undefined" && obj instanceof ImageData;
    this.isFramebufferTexture = obj instanceof FramebufferTexture;
    const textureData = this._getTextureDataFromSource();
    this.width = textureData.width;
    this.height = textureData.height;
    this.init(textureData);
    return this;
  }
  remove() {
    if (this.glTex) {
      const gl = this._renderer.GL;
      gl.deleteTexture(this.glTex);
      this.glTex = undefined;
    }
  }
  _getTextureDataFromSource() {
    let textureData;
    if (this.isFramebufferTexture) {
      textureData = this.src.rawTexture();
    } else if (this.isSrcP5Image) {
      textureData = this.src.canvas;
    } else if (this.isSrcMediaElement || this.isSrcHTMLElement) {
      if (this.src._ensureCanvas) {
        this.src._ensureCanvas();
      }
      textureData = this.src.elt;
    } else if (this.isSrcP5Graphics || this.isSrcP5Renderer) {
      textureData = this.src.canvas;
    } else if (this.isImageData) {
      textureData = this.src;
    }
    return textureData;
  }
  init(data) {
    const gl = this._renderer.GL;
    if (!this.isFramebufferTexture) {
      this.glTex = gl.createTexture();
    }
    this.glWrapS = this._renderer.states.textureWrapX;
    this.glWrapT = this._renderer.states.textureWrapY;
    this.setWrapMode(this.glWrapS, this.glWrapT);
    this.bindTexture();
    gl.texParameteri(gl.TEXTURE_2D, gl.TEXTURE_MAG_FILTER, this.glMagFilter);
    gl.texParameteri(gl.TEXTURE_2D, gl.TEXTURE_MIN_FILTER, this.glMinFilter);
    if (this.isFramebufferTexture)
      ;
    else if (this.width === 0 || this.height === 0 || this.isSrcMediaElement && !this.src.loadedmetadata) {
      const tmpdata = new Uint8Array([1, 1, 1, 1]);
      gl.texImage2D(this.glTarget, 0, gl.RGBA, 1, 1, 0, this.glFormat, this.glDataType, tmpdata);
    } else {
      gl.texImage2D(this.glTarget, 0, this.glFormat, this.glFormat, this.glDataType, data);
    }
  }
  update() {
    const data = this.src;
    if (data.width === 0 || data.height === 0) {
      return false;
    }
    if (this.isFramebufferTexture) {
      this.src.update();
      return false;
    }
    const textureData = this._getTextureDataFromSource();
    let updated = false;
    const gl = this._renderer.GL;
    if (textureData.width !== this.width || textureData.height !== this.height) {
      updated = true;
      this.width = textureData.width || data.width;
      this.height = textureData.height || data.height;
      if (this.isSrcP5Image) {
        data.setModified(false);
      } else if (this.isSrcMediaElement || this.isSrcHTMLElement) {
        data.setModified && data.setModified(true);
      }
    } else if (this.isSrcP5Image) {
      if (data.isModified()) {
        updated = true;
        data.setModified(false);
      }
    } else if (this.isSrcMediaElement) {
      if (data.isModified()) {
        updated = true;
        data.setModified(false);
      } else if (data.loadedmetadata) {
        if (this._videoPrevUpdateTime !== data.time()) {
          this._videoPrevUpdateTime = data.time();
          updated = true;
        }
      }
    } else if (this.isImageData) {
      if (data._dirty) {
        data._dirty = false;
        updated = true;
      }
    } else {
      updated = true;
    }
    if (updated) {
      this.bindTexture();
      gl.texImage2D(this.glTarget, 0, this.glFormat, this.glFormat, this.glDataType, textureData);
    }
    return updated;
  }
  bindTexture() {
    const gl = this._renderer.GL;
    gl.bindTexture(this.glTarget, this.getTexture());
    return this;
  }
  unbindTexture() {
    const gl = this._renderer.GL;
    gl.bindTexture(this.glTarget, null);
  }
  getTexture() {
    if (this.isFramebufferTexture) {
      return this.src.rawTexture();
    } else {
      return this.glTex;
    }
  }
  setInterpolation(downScale, upScale) {
    const gl = this._renderer.GL;
    this.glMinFilter = this.glFilter(downScale);
    this.glMagFilter = this.glFilter(upScale);
    this.bindTexture();
    gl.texParameteri(gl.TEXTURE_2D, gl.TEXTURE_MIN_FILTER, this.glMinFilter);
    gl.texParameteri(gl.TEXTURE_2D, gl.TEXTURE_MAG_FILTER, this.glMagFilter);
    this.unbindTexture();
  }
  glFilter(filter) {
    const gl = this._renderer.GL;
    if (filter === NEAREST) {
      return gl.NEAREST;
    } else {
      return gl.LINEAR;
    }
  }
  setWrapMode(wrapX, wrapY) {
    const gl = this._renderer.GL;
    const isPowerOfTwo = (x) => (x & x - 1) === 0;
    const textureData = this._getTextureDataFromSource();
    let wrapWidth;
    let wrapHeight;
    if (textureData.naturalWidth && textureData.naturalHeight) {
      wrapWidth = textureData.naturalWidth;
      wrapHeight = textureData.naturalHeight;
    } else {
      wrapWidth = this.width;
      wrapHeight = this.height;
    }
    const widthPowerOfTwo = isPowerOfTwo(wrapWidth);
    const heightPowerOfTwo = isPowerOfTwo(wrapHeight);
    if (wrapX === REPEAT) {
      if (this._renderer.webglVersion === WEBGL2 || widthPowerOfTwo && heightPowerOfTwo) {
        this.glWrapS = gl.REPEAT;
      } else {
        console.warn("You tried to set the wrap mode to REPEAT but the texture size is not a power of two. Setting to CLAMP instead");
        this.glWrapS = gl.CLAMP_TO_EDGE;
      }
    } else if (wrapX === MIRROR) {
      if (this._renderer.webglVersion === WEBGL2 || widthPowerOfTwo && heightPowerOfTwo) {
        this.glWrapS = gl.MIRRORED_REPEAT;
      } else {
        console.warn("You tried to set the wrap mode to MIRROR but the texture size is not a power of two. Setting to CLAMP instead");
        this.glWrapS = gl.CLAMP_TO_EDGE;
      }
    } else {
      this.glWrapS = gl.CLAMP_TO_EDGE;
    }
    if (wrapY === REPEAT) {
      if (this._renderer.webglVersion === WEBGL2 || widthPowerOfTwo && heightPowerOfTwo) {
        this.glWrapT = gl.REPEAT;
      } else {
        console.warn("You tried to set the wrap mode to REPEAT but the texture size is not a power of two. Setting to CLAMP instead");
        this.glWrapT = gl.CLAMP_TO_EDGE;
      }
    } else if (wrapY === MIRROR) {
      if (this._renderer.webglVersion === WEBGL2 || widthPowerOfTwo && heightPowerOfTwo) {
        this.glWrapT = gl.MIRRORED_REPEAT;
      } else {
        console.warn("You tried to set the wrap mode to MIRROR but the texture size is not a power of two. Setting to CLAMP instead");
        this.glWrapT = gl.CLAMP_TO_EDGE;
      }
    } else {
      this.glWrapT = gl.CLAMP_TO_EDGE;
    }
    this.bindTexture();
    gl.texParameteri(gl.TEXTURE_2D, gl.TEXTURE_WRAP_S, this.glWrapS);
    gl.texParameteri(gl.TEXTURE_2D, gl.TEXTURE_WRAP_T, this.glWrapT);
    this.unbindTexture();
  }
}

class MipmapTexture extends Texture {
  constructor(renderer2, levels, settings) {
    super(renderer2, levels, settings);
    const gl = this._renderer.GL;
    if (this.glMinFilter === gl.LINEAR) {
      this.glMinFilter = gl.LINEAR_MIPMAP_LINEAR;
    }
  }
  glFilter(_filter) {
    const gl = this._renderer.GL;
    return gl.LINEAR_MIPMAP_LINEAR;
  }
  _getTextureDataFromSource() {
    return this.src;
  }
  init(levels) {
    const gl = this._renderer.GL;
    this.glTex = gl.createTexture();
    this.bindTexture();
    for (let level = 0;level < levels.length; level++) {
      gl.texImage2D(this.glTarget, level, this.glFormat, this.glFormat, this.glDataType, levels[level]);
    }
    this.glMinFilter = gl.LINEAR_MIPMAP_LINEAR;
    gl.texParameteri(gl.TEXTURE_2D, gl.TEXTURE_MAG_FILTER, this.glMagFilter);
    gl.texParameteri(gl.TEXTURE_2D, gl.TEXTURE_MIN_FILTER, this.glMinFilter);
    this.unbindTexture();
  }
  update() {}
}
function texture(p52, fn2) {
  p52.Texture = Texture;
  p52.MipmapTexture = MipmapTexture;
}
function checkWebGLCapabilities({ GL, webglVersion }) {
  const gl = GL;
  const supportsFloat = webglVersion === WEBGL2 ? gl.getExtension("EXT_color_buffer_float") && gl.getExtension("EXT_float_blend") : gl.getExtension("OES_texture_float");
  const supportsFloatLinear = supportsFloat && gl.getExtension("OES_texture_float_linear");
  const supportsHalfFloat = webglVersion === WEBGL2 ? gl.getExtension("EXT_color_buffer_float") : gl.getExtension("OES_texture_half_float");
  const supportsHalfFloatLinear = supportsHalfFloat && gl.getExtension("OES_texture_half_float_linear");
  return {
    float: supportsFloat,
    floatLinear: supportsFloatLinear,
    halfFloat: supportsHalfFloat,
    halfFloatLinear: supportsHalfFloatLinear
  };
}
if (typeof p5 !== "undefined") {
  texture(p5, p5.prototype);
}
var constrain2 = (n2, low, high) => Math.max(Math.min(n2, high), low);

class FramebufferCamera extends Camera {
  constructor(framebuffer) {
    super(framebuffer.renderer);
    this.fbo = framebuffer;
    this.yScale = -1;
  }
  _computeCameraDefaultSettings() {
    super._computeCameraDefaultSettings();
    this.defaultAspectRatio = this.fbo.width / this.fbo.height;
    this.defaultCameraFOV = 2 * Math.atan(this.fbo.height / 2 / this.defaultEyeZ);
  }
}

class FramebufferTexture {
  constructor(framebuffer, property) {
    this.framebuffer = framebuffer;
    this.property = property;
  }
  get width() {
    return this.framebuffer.width * this.framebuffer.density;
  }
  get height() {
    return this.framebuffer.height * this.framebuffer.density;
  }
  update() {
    this.framebuffer._update(this.property);
  }
  rawTexture() {
    return this.framebuffer[this.property];
  }
}

class Framebuffer {
  constructor(renderer2, settings = {}) {
    this.renderer = renderer2;
    this.renderer.framebuffers.add(this);
    this._isClipApplied = false;
    this.dirty = { colorTexture: false, depthTexture: false };
    this.pixels = [];
    this.format = settings.format || UNSIGNED_BYTE;
    this.channels = settings.channels || (this.renderer._pInst._glAttributes.alpha ? RGBA : RGB);
    this.useDepth = settings.depth === undefined ? true : settings.depth;
    this.depthFormat = settings.depthFormat || FLOAT;
    this.textureFiltering = settings.textureFiltering || LINEAR;
    if (settings.antialias === undefined) {
      this.antialiasSamples = this.renderer._pInst._glAttributes.antialias ? 2 : 0;
    } else if (typeof settings.antialias === "number") {
      this.antialiasSamples = settings.antialias;
    } else {
      this.antialiasSamples = settings.antialias ? 2 : 0;
    }
    this.antialias = this.antialiasSamples > 0;
    if (this.antialias && this.renderer.webglVersion !== WEBGL2) {
      console.warn("Antialiasing is unsupported in a WebGL 1 context");
      this.antialias = false;
    }
    this.density = settings.density || this.renderer._pixelDensity;
    const gl = this.renderer.GL;
    this.gl = gl;
    if (settings.width && settings.height) {
      const dimensions = this.renderer._adjustDimensions(settings.width, settings.height);
      this.width = dimensions.adjustedWidth;
      this.height = dimensions.adjustedHeight;
      this._autoSized = false;
    } else {
      if (settings.width === undefined !== (settings.height === undefined)) {
        console.warn("Please supply both width and height for a framebuffer to give it a " + "size. Only one was given, so the framebuffer will match the size " + "of its canvas.");
      }
      this.width = this.renderer.width;
      this.height = this.renderer.height;
      this._autoSized = true;
    }
    this._checkIfFormatsAvailable();
    if (settings.stencil && !this.useDepth) {
      console.warn("A stencil buffer can only be used if also using depth. Since the framebuffer has no depth buffer, the stencil buffer will be ignored.");
    }
    this.useStencil = this.useDepth && (settings.stencil === undefined ? true : settings.stencil);
    this.framebuffer = gl.createFramebuffer();
    if (!this.framebuffer) {
      throw new Error("Unable to create a framebuffer");
    }
    if (this.antialias) {
      this.aaFramebuffer = gl.createFramebuffer();
      if (!this.aaFramebuffer) {
        throw new Error("Unable to create a framebuffer for antialiasing");
      }
    }
    this._recreateTextures();
    const prevCam = this.renderer.states.curCamera;
    this.defaultCamera = this.createCamera();
    this.filterCamera = this.createCamera();
    this.renderer.states.setValue("curCamera", prevCam);
    this.draw(() => this.renderer.clear());
  }
  resize(width, height) {
    this._autoSized = false;
    const dimensions = this.renderer._adjustDimensions(width, height);
    width = dimensions.adjustedWidth;
    height = dimensions.adjustedHeight;
    this.width = width;
    this.height = height;
    this._handleResize();
  }
  pixelDensity(density) {
    if (density) {
      this._autoSized = false;
      this.density = density;
      this._handleResize();
    } else {
      return this.density;
    }
  }
  autoSized(autoSized) {
    if (autoSized === undefined) {
      return this._autoSized;
    } else {
      this._autoSized = autoSized;
      this._handleResize();
    }
  }
  _checkIfFormatsAvailable() {
    const gl = this.gl;
    if (this.useDepth && this.renderer.webglVersion === WEBGL && !gl.getExtension("WEBGL_depth_texture")) {
      console.warn("Unable to create depth textures in this environment. Falling back " + "to a framebuffer without depth.");
      this.useDepth = false;
    }
    if (this.useDepth && this.renderer.webglVersion === WEBGL && this.depthFormat === FLOAT) {
      console.warn("FLOAT depth format is unavailable in WebGL 1. " + "Defaulting to UNSIGNED_INT.");
      this.depthFormat = UNSIGNED_INT;
    }
    if (![
      UNSIGNED_BYTE,
      FLOAT,
      HALF_FLOAT
    ].includes(this.format)) {
      console.warn("Unknown Framebuffer format. " + "Please use UNSIGNED_BYTE, FLOAT, or HALF_FLOAT. " + "Defaulting to UNSIGNED_BYTE.");
      this.format = UNSIGNED_BYTE;
    }
    if (this.useDepth && ![
      UNSIGNED_INT,
      FLOAT
    ].includes(this.depthFormat)) {
      console.warn("Unknown Framebuffer depth format. " + "Please use UNSIGNED_INT or FLOAT. Defaulting to FLOAT.");
      this.depthFormat = FLOAT;
    }
    const support = checkWebGLCapabilities(this.renderer);
    if (!support.float && this.format === FLOAT) {
      console.warn("This environment does not support FLOAT textures. " + "Falling back to UNSIGNED_BYTE.");
      this.format = UNSIGNED_BYTE;
    }
    if (this.useDepth && !support.float && this.depthFormat === FLOAT) {
      console.warn("This environment does not support FLOAT depth textures. " + "Falling back to UNSIGNED_INT.");
      this.depthFormat = UNSIGNED_INT;
    }
    if (!support.halfFloat && this.format === HALF_FLOAT) {
      console.warn("This environment does not support HALF_FLOAT textures. " + "Falling back to UNSIGNED_BYTE.");
      this.format = UNSIGNED_BYTE;
    }
    if (this.channels === RGB && [FLOAT, HALF_FLOAT].includes(this.format)) {
      console.warn("FLOAT and HALF_FLOAT formats do not work cross-platform with only " + "RGB channels. Falling back to RGBA.");
      this.channels = RGBA;
    }
  }
  _recreateTextures() {
    const gl = this.gl;
    this._updateSize();
    const prevBoundTexture = gl.getParameter(gl.TEXTURE_BINDING_2D);
    const prevBoundFramebuffer = gl.getParameter(gl.FRAMEBUFFER_BINDING);
    const colorTexture = gl.createTexture();
    if (!colorTexture) {
      throw new Error("Unable to create color texture");
    }
    gl.bindTexture(gl.TEXTURE_2D, colorTexture);
    const colorFormat = this._glColorFormat();
    gl.texImage2D(gl.TEXTURE_2D, 0, colorFormat.internalFormat, this.width * this.density, this.height * this.density, 0, colorFormat.format, colorFormat.type, null);
    this.colorTexture = colorTexture;
    gl.bindFramebuffer(gl.FRAMEBUFFER, this.framebuffer);
    gl.framebufferTexture2D(gl.FRAMEBUFFER, gl.COLOR_ATTACHMENT0, gl.TEXTURE_2D, colorTexture, 0);
    if (this.useDepth) {
      const depthTexture = gl.createTexture();
      if (!depthTexture) {
        throw new Error("Unable to create depth texture");
      }
      const depthFormat = this._glDepthFormat();
      gl.bindTexture(gl.TEXTURE_2D, depthTexture);
      gl.texImage2D(gl.TEXTURE_2D, 0, depthFormat.internalFormat, this.width * this.density, this.height * this.density, 0, depthFormat.format, depthFormat.type, null);
      gl.framebufferTexture2D(gl.FRAMEBUFFER, this.useStencil ? gl.DEPTH_STENCIL_ATTACHMENT : gl.DEPTH_ATTACHMENT, gl.TEXTURE_2D, depthTexture, 0);
      this.depthTexture = depthTexture;
    }
    if (this.antialias) {
      this.colorRenderbuffer = gl.createRenderbuffer();
      gl.bindRenderbuffer(gl.RENDERBUFFER, this.colorRenderbuffer);
      gl.renderbufferStorageMultisample(gl.RENDERBUFFER, Math.max(0, Math.min(this.antialiasSamples, gl.getParameter(gl.MAX_SAMPLES))), colorFormat.internalFormat, this.width * this.density, this.height * this.density);
      if (this.useDepth) {
        const depthFormat = this._glDepthFormat();
        this.depthRenderbuffer = gl.createRenderbuffer();
        gl.bindRenderbuffer(gl.RENDERBUFFER, this.depthRenderbuffer);
        gl.renderbufferStorageMultisample(gl.RENDERBUFFER, Math.max(0, Math.min(this.antialiasSamples, gl.getParameter(gl.MAX_SAMPLES))), depthFormat.internalFormat, this.width * this.density, this.height * this.density);
      }
      gl.bindFramebuffer(gl.FRAMEBUFFER, this.aaFramebuffer);
      gl.framebufferRenderbuffer(gl.FRAMEBUFFER, gl.COLOR_ATTACHMENT0, gl.RENDERBUFFER, this.colorRenderbuffer);
      if (this.useDepth) {
        gl.framebufferRenderbuffer(gl.FRAMEBUFFER, this.useStencil ? gl.DEPTH_STENCIL_ATTACHMENT : gl.DEPTH_ATTACHMENT, gl.RENDERBUFFER, this.depthRenderbuffer);
      }
    }
    if (this.useDepth) {
      this.depth = new FramebufferTexture(this, "depthTexture");
      const depthFilter = gl.NEAREST;
      this.depthP5Texture = new Texture(this.renderer, this.depth, {
        minFilter: depthFilter,
        magFilter: depthFilter
      });
      this.renderer.textures.set(this.depth, this.depthP5Texture);
    }
    this.color = new FramebufferTexture(this, "colorTexture");
    const filter = this.textureFiltering === LINEAR ? gl.LINEAR : gl.NEAREST;
    this.colorP5Texture = new Texture(this.renderer, this.color, {
      minFilter: filter,
      magFilter: filter
    });
    this.renderer.textures.set(this.color, this.colorP5Texture);
    gl.bindTexture(gl.TEXTURE_2D, prevBoundTexture);
    gl.bindFramebuffer(gl.FRAMEBUFFER, prevBoundFramebuffer);
  }
  _glColorFormat() {
    let type2, format, internalFormat;
    const gl = this.gl;
    if (this.format === FLOAT) {
      type2 = gl.FLOAT;
    } else if (this.format === HALF_FLOAT) {
      type2 = this.renderer.webglVersion === WEBGL2 ? gl.HALF_FLOAT : gl.getExtension("OES_texture_half_float").HALF_FLOAT_OES;
    } else {
      type2 = gl.UNSIGNED_BYTE;
    }
    if (this.channels === RGBA) {
      format = gl.RGBA;
    } else {
      format = gl.RGB;
    }
    if (this.renderer.webglVersion === WEBGL2) {
      const table = {
        [gl.FLOAT]: {
          [gl.RGBA]: gl.RGBA32F
        },
        [gl.HALF_FLOAT]: {
          [gl.RGBA]: gl.RGBA16F
        },
        [gl.UNSIGNED_BYTE]: {
          [gl.RGBA]: gl.RGBA8,
          [gl.RGB]: gl.RGB8
        }
      };
      internalFormat = table[type2][format];
    } else if (this.format === HALF_FLOAT) {
      internalFormat = gl.RGBA;
    } else {
      internalFormat = format;
    }
    return { internalFormat, format, type: type2 };
  }
  _glDepthFormat() {
    let type2, format, internalFormat;
    const gl = this.gl;
    if (this.useStencil) {
      if (this.depthFormat === FLOAT) {
        type2 = gl.FLOAT_32_UNSIGNED_INT_24_8_REV;
      } else if (this.renderer.webglVersion === WEBGL2) {
        type2 = gl.UNSIGNED_INT_24_8;
      } else {
        type2 = gl.getExtension("WEBGL_depth_texture").UNSIGNED_INT_24_8_WEBGL;
      }
    } else {
      if (this.depthFormat === FLOAT) {
        type2 = gl.FLOAT;
      } else {
        type2 = gl.UNSIGNED_INT;
      }
    }
    if (this.useStencil) {
      format = gl.DEPTH_STENCIL;
    } else {
      format = gl.DEPTH_COMPONENT;
    }
    if (this.useStencil) {
      if (this.depthFormat === FLOAT) {
        internalFormat = gl.DEPTH32F_STENCIL8;
      } else if (this.renderer.webglVersion === WEBGL2) {
        internalFormat = gl.DEPTH24_STENCIL8;
      } else {
        internalFormat = gl.DEPTH_STENCIL;
      }
    } else if (this.renderer.webglVersion === WEBGL2) {
      if (this.depthFormat === FLOAT) {
        internalFormat = gl.DEPTH_COMPONENT32F;
      } else {
        internalFormat = gl.DEPTH_COMPONENT24;
      }
    } else {
      internalFormat = gl.DEPTH_COMPONENT;
    }
    return { internalFormat, format, type: type2 };
  }
  _updateSize() {
    if (this._autoSized) {
      this.width = this.renderer.width;
      this.height = this.renderer.height;
      this.density = this.renderer._pixelDensity;
    }
  }
  _canvasSizeChanged() {
    if (this._autoSized) {
      this._handleResize();
    }
  }
  _handleResize() {
    const oldColor = this.color;
    const oldDepth = this.depth;
    const oldColorRenderbuffer = this.colorRenderbuffer;
    const oldDepthRenderbuffer = this.depthRenderbuffer;
    this._deleteTexture(oldColor);
    if (oldDepth)
      this._deleteTexture(oldDepth);
    const gl = this.gl;
    if (oldColorRenderbuffer)
      gl.deleteRenderbuffer(oldColorRenderbuffer);
    if (oldDepthRenderbuffer)
      gl.deleteRenderbuffer(oldDepthRenderbuffer);
    this._recreateTextures();
    this.defaultCamera._resize();
  }
  createCamera() {
    const cam = new FramebufferCamera(this);
    cam._computeCameraDefaultSettings();
    cam._setDefaultCamera();
    return cam;
  }
  _deleteTexture(texture2) {
    const gl = this.gl;
    gl.deleteTexture(texture2.rawTexture());
    this.renderer.textures.delete(texture2);
  }
  remove() {
    const gl = this.gl;
    this._deleteTexture(this.color);
    if (this.depth)
      this._deleteTexture(this.depth);
    gl.deleteFramebuffer(this.framebuffer);
    if (this.aaFramebuffer) {
      gl.deleteFramebuffer(this.aaFramebuffer);
    }
    if (this.depthRenderbuffer) {
      gl.deleteRenderbuffer(this.depthRenderbuffer);
    }
    if (this.colorRenderbuffer) {
      gl.deleteRenderbuffer(this.colorRenderbuffer);
    }
    this.renderer.framebuffers.delete(this);
  }
  begin() {
    this.prevFramebuffer = this.renderer.activeFramebuffer();
    if (this.prevFramebuffer) {
      this.prevFramebuffer._beforeEnd();
    }
    this.renderer.activeFramebuffers.push(this);
    this._beforeBegin();
    this.renderer.push();
    this.renderer.states.setValue("curCamera", this.defaultCamera);
    this.renderer.states.setValue("uPMatrix", this.renderer.states.uPMatrix.clone());
    this.renderer.states.uPMatrix.set(this.defaultCamera.projMatrix);
    this.renderer.states.setValue("uViewMatrix", this.renderer.states.uViewMatrix.clone());
    this.renderer.states.uViewMatrix.set(this.defaultCamera.cameraMatrix);
    this.renderer.resetMatrix();
    this.renderer.states.uViewMatrix.set(this.renderer.states.curCamera.cameraMatrix);
    this.renderer.states.uModelMatrix.reset();
    this.renderer._applyStencilTestIfClipping();
  }
  _framebufferToBind() {
    if (this.antialias) {
      return this.aaFramebuffer;
    } else {
      return this.framebuffer;
    }
  }
  _update(property) {
    if (this.dirty[property] && this.antialias) {
      const gl = this.gl;
      gl.bindFramebuffer(gl.READ_FRAMEBUFFER, this.aaFramebuffer);
      gl.bindFramebuffer(gl.DRAW_FRAMEBUFFER, this.framebuffer);
      const partsToCopy = {
        colorTexture: [gl.COLOR_BUFFER_BIT, this.colorP5Texture.glMagFilter]
      };
      if (this.useDepth) {
        partsToCopy.depthTexture = [
          gl.DEPTH_BUFFER_BIT,
          this.depthP5Texture.glMagFilter
        ];
      }
      const [flag, filter] = partsToCopy[property];
      gl.blitFramebuffer(0, 0, this.width * this.density, this.height * this.density, 0, 0, this.width * this.density, this.height * this.density, flag, filter);
      this.dirty[property] = false;
      const activeFbo = this.renderer.activeFramebuffer();
      if (activeFbo) {
        gl.bindFramebuffer(gl.FRAMEBUFFER, activeFbo._framebufferToBind());
      } else {
        gl.bindFramebuffer(gl.FRAMEBUFFER, null);
      }
    }
  }
  _beforeBegin() {
    const gl = this.gl;
    gl.bindFramebuffer(gl.FRAMEBUFFER, this._framebufferToBind());
    this.renderer.viewport(this.width * this.density, this.height * this.density);
  }
  _beforeEnd() {
    if (this.antialias) {
      this.dirty = { colorTexture: true, depthTexture: true };
    }
  }
  end() {
    const gl = this.gl;
    this.renderer.pop();
    const fbo = this.renderer.activeFramebuffers.pop();
    if (fbo !== this) {
      throw new Error("It looks like you've called end() while another Framebuffer is active.");
    }
    this._beforeEnd();
    if (this.prevFramebuffer) {
      this.prevFramebuffer._beforeBegin();
    } else {
      gl.bindFramebuffer(gl.FRAMEBUFFER, null);
      this.renderer.viewport(this.renderer._origViewport.width, this.renderer._origViewport.height);
    }
    this.renderer._applyStencilTestIfClipping();
  }
  draw(callback) {
    this.begin();
    callback();
    this.end();
  }
  loadPixels() {
    this._update("colorTexture");
    const gl = this.gl;
    const prevFramebuffer = this.renderer.activeFramebuffer();
    gl.bindFramebuffer(gl.FRAMEBUFFER, this.framebuffer);
    const colorFormat = this._glColorFormat();
    this.pixels = readPixelsWebGL(this.pixels, gl, this.framebuffer, 0, 0, this.width * this.density, this.height * this.density, colorFormat.format, colorFormat.type);
    if (prevFramebuffer) {
      gl.bindFramebuffer(gl.FRAMEBUFFER, prevFramebuffer._framebufferToBind());
    } else {
      gl.bindFramebuffer(gl.FRAMEBUFFER, null);
    }
  }
  get(x, y, w, h) {
    this._update("colorTexture");
    const colorFormat = this._glColorFormat();
    if (x === undefined && y === undefined) {
      x = 0;
      y = 0;
      w = this.width;
      h = this.height;
    } else if (w === undefined && h === undefined) {
      if (x < 0 || y < 0 || x >= this.width || y >= this.height) {
        console.warn("The x and y values passed to p5.Framebuffer.get are outside of its range and will be clamped.");
        x = constrain2(x, 0, this.width - 1);
        y = constrain2(y, 0, this.height - 1);
      }
      return readPixelWebGL(this.gl, this.framebuffer, x * this.density, y * this.density, colorFormat.format, colorFormat.type);
    }
    x = constrain2(x, 0, this.width - 1);
    y = constrain2(y, 0, this.height - 1);
    w = constrain2(w, 1, this.width - x);
    h = constrain2(h, 1, this.height - y);
    const rawData = readPixelsWebGL(undefined, this.gl, this.framebuffer, x * this.density, y * this.density, w * this.density, h * this.density, colorFormat.format, colorFormat.type);
    const fullData = new Uint8ClampedArray(w * h * this.density * this.density * 4);
    fullData.fill(255);
    const channels = colorFormat.type === this.gl.RGB ? 3 : 4;
    for (let y2 = 0;y2 < h * this.density; y2++) {
      for (let x2 = 0;x2 < w * this.density; x2++) {
        for (let channel = 0;channel < 4; channel++) {
          const idx = (y2 * w * this.density + x2) * 4 + channel;
          if (channel < channels) {
            const rawDataIdx = channels === 4 ? idx : (y2 * w * this.density + x2) * channels + channel;
            fullData[idx] = rawData[rawDataIdx];
          }
        }
      }
    }
    const region = new Image(w * this.density, h * this.density);
    region.imageData = region.canvas.getContext("2d").createImageData(region.width, region.height);
    region.imageData.data.set(fullData);
    region.pixels = region.imageData.data;
    region.updatePixels();
    if (this.density !== 1) {
      region.resize(w, h);
    }
    return region;
  }
  updatePixels() {
    const gl = this.gl;
    this.colorP5Texture.bindTexture();
    const colorFormat = this._glColorFormat();
    const channels = colorFormat.format === gl.RGBA ? 4 : 3;
    const len = this.width * this.height * this.density * this.density * channels;
    const TypedArrayClass = colorFormat.type === gl.UNSIGNED_BYTE ? Uint8Array : Float32Array;
    if (!(this.pixels instanceof TypedArrayClass) || this.pixels.length !== len) {
      throw new Error("The pixels array has not been set correctly. Please call loadPixels() before updatePixels().");
    }
    gl.texImage2D(gl.TEXTURE_2D, 0, colorFormat.internalFormat, this.width * this.density, this.height * this.density, 0, colorFormat.format, colorFormat.type, this.pixels);
    this.colorP5Texture.unbindTexture();
    this.dirty.colorTexture = false;
    const prevFramebuffer = this.renderer.activeFramebuffer();
    if (this.antialias) {
      this.begin();
      this.renderer.push();
      this.renderer.states.setValue("imageMode", CORNER);
      this.renderer.setCamera(this.filterCamera);
      this.renderer.resetMatrix();
      this.renderer.states.setValue("strokeColor", null);
      this.renderer.clear();
      this.renderer._drawingFilter = true;
      this.renderer.image(this, 0, 0, this.width, this.height, -this.renderer.width / 2, -this.renderer.height / 2, this.renderer.width, this.renderer.height);
      this.renderer._drawingFilter = false;
      this.renderer.pop();
      if (this.useDepth) {
        gl.clearDepth(1);
        gl.clear(gl.DEPTH_BUFFER_BIT);
      }
      this.end();
    } else {
      gl.bindFramebuffer(gl.FRAMEBUFFER, this.framebuffer);
      if (this.useDepth) {
        gl.clearDepth(1);
        gl.clear(gl.DEPTH_BUFFER_BIT);
      }
      if (prevFramebuffer) {
        gl.bindFramebuffer(gl.FRAMEBUFFER, prevFramebuffer._framebufferToBind());
      } else {
        gl.bindFramebuffer(gl.FRAMEBUFFER, null);
      }
    }
  }
}
function framebuffer(p52, fn2) {
  p52.FramebufferCamera = FramebufferCamera;
  p52.FramebufferTexture = FramebufferTexture;
  p52.Framebuffer = Framebuffer;
}
if (typeof p5 !== "undefined") {
  framebuffer(p5, p5.prototype);
}
var renderers;
function rendering(p52, fn2) {
  renderers = p52.renderers = {};
  fn2.createCanvas = function(w, h, renderer2, ...args) {
    let selectedRenderer = P2D;
    if (Reflect.ownKeys(renderers).includes(renderer2)) {
      selectedRenderer = renderer2;
    } else {
      args.unshift(renderer2);
    }
    if (this._renderer)
      this._renderer.remove();
    this._renderer = new renderers[selectedRenderer](this, w, h, true, ...args);
    this._defaultGraphicsCreated = true;
    this._elements.push(this._renderer);
    this._renderer._applyDefaults();
    if (!Object.hasOwn(this, "pixels")) {
      Object.defineProperty(this, "pixels", {
        get() {
          return this._renderer?.pixels;
        }
      });
    }
    return this._renderer;
  };
  fn2.resizeCanvas = function(w, h, noRedraw) {
    if (this._renderer) {
      this._renderer.resize(w, h);
      if (!noRedraw) {
        this.redraw();
      }
    }
    if (this._addAccsOutput()) {
      this._updateAccsOutput();
    }
  };
  fn2.noCanvas = function() {
    if (this.canvas) {
      this.canvas.parentNode.removeChild(this.canvas);
    }
  };
  fn2.createGraphics = function(w, h, ...args) {
    if (args[0] instanceof HTMLCanvasElement) {
      args[1] = args[0];
      args[0] = P2D;
    }
    return new p52.Graphics(w, h, args[0], this, args[1]);
  };
  fn2.createFramebuffer = function(options2) {
    return new Framebuffer(this._renderer, options2);
  };
  fn2.clearDepth = function(depth) {
    this._assert3d("clearDepth");
    this._renderer.clearDepth(depth);
  };
}
if (typeof p5 !== "undefined") {
  rendering(p5, p5.prototype);
}

// node_modules/p5/dist/image/filterRenderer2D.js
var import_omggif = __toESM(require_omggif(), 1);
var import_file_saver4 = __toESM(require_FileSaver(), 1);
var import_gifenc2 = __toESM(require_gifenc(), 1);
var import_libtess2 = __toESM(require_libtess_min(), 1);
class FilterRenderer2D {
  constructor(pInst) {
    this.pInst = pInst;
    this.canvas = document.createElement("canvas");
    this.canvas.width = pInst.width;
    this.canvas.height = pInst.height;
    let webglVersion = WEBGL2;
    this.gl = this.canvas.getContext("webgl2");
    if (!this.gl) {
      webglVersion = WEBGL;
      this.gl = this.canvas.getContext("webgl");
    }
    if (!this.gl) {
      console.error("WebGL not supported, cannot apply filter.");
      return;
    }
    this._renderer = {
      GL: this.gl,
      registerEnabled: new Set,
      _curShader: null,
      _emptyTexture: null,
      webglVersion,
      states: {
        textureWrapX: this.gl.CLAMP_TO_EDGE,
        textureWrapY: this.gl.CLAMP_TO_EDGE
      },
      _arraysEqual: (a, b2) => JSON.stringify(a) === JSON.stringify(b2),
      _getEmptyTexture: () => {
        if (!this._emptyTexture) {
          const im = new Image(1, 1);
          im.set(0, 0, 255);
          this._emptyTexture = new Texture(this._renderer, im);
        }
        return this._emptyTexture;
      }
    };
    this._baseFilterShader = undefined;
    this.filterShaderSources = {
      [BLUR]: filterBlurFrag,
      [INVERT]: filterInvertFrag,
      [THRESHOLD]: filterThresholdFrag,
      [ERODE]: filterErodeFrag,
      [GRAY]: filterGrayFrag,
      [DILATE]: filterDilateFrag,
      [POSTERIZE]: filterPosterizeFrag,
      [OPAQUE]: filterOpaqueFrag
    };
    this.filterShaders = {};
    this.operation = null;
    this.filterParameter = 1;
    this.customShader = null;
    this._shader = null;
    this.vertexBuffer = this.gl.createBuffer();
    this.texcoordBuffer = this.gl.createBuffer();
    this.vertices = new Float32Array([-1, -1, 1, -1, -1, 1, 1, 1]);
    this.texcoords = new Float32Array([0, 1, 1, 1, 0, 0, 1, 0]);
    this._bindBufferData(this.vertexBuffer, this.gl.ARRAY_BUFFER, this.vertices);
    this._bindBufferData(this.texcoordBuffer, this.gl.ARRAY_BUFFER, this.texcoords);
  }
  _webGL2CompatibilityPrefix(shaderType, floatPrecision) {
    let code = "";
    if (this._renderer.webglVersion === WEBGL2) {
      code += `#version 300 es
#define WEBGL2
`;
    }
    if (shaderType === "vert") {
      code += `#define VERTEX_SHADER
`;
    } else if (shaderType === "frag") {
      code += `#define FRAGMENT_SHADER
`;
    }
    if (floatPrecision) {
      code += `precision ${floatPrecision} float;
`;
    }
    return code;
  }
  baseFilterShader() {
    if (!this._baseFilterShader) {
      this._baseFilterShader = new Shader(this._renderer, this._webGL2CompatibilityPrefix("vert", "highp") + webgl2CompatibilityShader + filterBaseVert, this._webGL2CompatibilityPrefix("frag", "highp") + webgl2CompatibilityShader + filterBaseFrag, {
        vertex: {},
        fragment: {
          "vec4 getColor": `(FilterInputs inputs, in sampler2D canvasContent) {
              return getTexture(canvasContent, inputs.texCoord);
            }`
        }
      });
    }
    return this._baseFilterShader;
  }
  setOperation(operation, filterParameter, customShader = null) {
    this.operation = operation;
    this.filterParameter = filterParameter;
    let useDefaultParam = operation in filterParamDefaults && filterParameter === undefined;
    if (useDefaultParam) {
      this.filterParameter = filterParamDefaults[operation];
    }
    this.customShader = customShader;
    this._initializeShader();
  }
  _initializeShader() {
    if (this.customShader) {
      this._shader = this.customShader;
      return;
    }
    if (!this.operation) {
      console.error("No operation set for FilterRenderer2D, cannot initialize shader.");
      return;
    }
    if (this.filterShaders[this.operation]) {
      this._shader = this.filterShaders[this.operation];
      return;
    }
    const fragShaderSrc = this.filterShaderSources[this.operation];
    if (!fragShaderSrc) {
      console.error("No shader available for this operation:", this.operation);
      return;
    }
    const newShader = new Shader(this._renderer, filterShaderVert, fragShaderSrc);
    this.filterShaders[this.operation] = newShader;
    this._shader = newShader;
  }
  _bindBufferData(buffer, target, values) {
    const gl = this.gl;
    gl.bindBuffer(target, buffer);
    gl.bufferData(target, values, gl.STATIC_DRAW);
  }
  get canvasTexture() {
    if (!this._canvasTexture) {
      this._canvasTexture = new Texture(this._renderer, this.pInst.wrappedElt);
    }
    return this._canvasTexture;
  }
  _renderPass() {
    const gl = this.gl;
    this._shader.bindShader();
    const pixelDensity = this.pInst.pixelDensity ? this.pInst.pixelDensity() : 1;
    const texelSize = [
      1 / (this.pInst.width * pixelDensity),
      1 / (this.pInst.height * pixelDensity)
    ];
    const canvasTexture = this.canvasTexture;
    this._shader.setUniform("tex0", canvasTexture);
    this._shader.setUniform("texelSize", texelSize);
    this._shader.setUniform("canvasSize", [this.pInst.width, this.pInst.height]);
    this._shader.setUniform("radius", Math.max(1, this.filterParameter));
    this._shader.setUniform("filterParameter", this.filterParameter);
    this._shader.setDefaultUniforms();
    this.pInst.states.setValue("rectMode", CORNER);
    this.pInst.states.setValue("imageMode", CORNER);
    this.pInst.blendMode(BLEND);
    this.pInst.resetMatrix();
    const identityMatrix = [
      1,
      0,
      0,
      0,
      0,
      1,
      0,
      0,
      0,
      0,
      1,
      0,
      0,
      0,
      0,
      1
    ];
    this._shader.setUniform("uModelViewMatrix", identityMatrix);
    this._shader.setUniform("uProjectionMatrix", identityMatrix);
    gl.bindBuffer(gl.ARRAY_BUFFER, this.vertexBuffer);
    this._shader.enableAttrib(this._shader.attributes.aPosition, 2);
    gl.bindBuffer(gl.ARRAY_BUFFER, this.texcoordBuffer);
    this._shader.enableAttrib(this._shader.attributes.aTexCoord, 2);
    this._shader.bindTextures();
    this._shader.disableRemainingAttributes();
    gl.drawArrays(gl.TRIANGLE_STRIP, 0, 4);
    this._shader.unbindShader();
  }
  applyFilter() {
    if (!this._shader) {
      console.error("Cannot apply filter: shader not initialized.");
      return;
    }
    this.pInst.push();
    this.pInst.resetMatrix();
    if (this.operation === BLUR && !this.customShader) {
      this._shader.setUniform("direction", [1, 0]);
      this._renderPass();
      this.pInst.clear();
      this.pInst.drawingContext.drawImage(this.canvas, 0, 0, this.pInst.width, this.pInst.height);
      this._shader.setUniform("direction", [0, 1]);
      this._renderPass();
      this.pInst.clear();
      this.pInst.drawingContext.drawImage(this.canvas, 0, 0, this.pInst.width, this.pInst.height);
    } else {
      this._renderPass();
      this.pInst.clear();
      this.pInst.blendMode(BLEND);
      this.pInst.drawingContext.drawImage(this.canvas, 0, 0, this.pInst.width, this.pInst.height);
    }
    this.pInst.pop();
  }
}

// node_modules/p5/dist/main-Bnx3mbbg.js
var styleEmpty = "rgba(0,0,0,0)";

class Renderer2D extends Renderer {
  constructor(pInst, w, h, isMainCanvas, elt, attributes2 = {}) {
    super(pInst, w, h, isMainCanvas);
    this.canvas = this.elt = elt || document.createElement("canvas");
    if (isMainCanvas) {
      this._pInst._curElement = this;
      this._pInst.canvas = this.canvas;
    } else {
      this.canvas.style.display = "none";
    }
    this.elt.id = "defaultCanvas0";
    this.elt.classList.add("p5Canvas");
    for (const p2 of Object.getOwnPropertyNames(Element.prototype)) {
      if (p2 !== "constructor" && p2[0] !== "_") {
        Object.defineProperty(this, p2, {
          get() {
            return this.wrappedElt[p2];
          }
        });
      }
    }
    this.elt.width = w * this._pixelDensity;
    this.elt.height = h * this._pixelDensity;
    this.elt.style.width = `${w}px`;
    this.elt.style.height = `${h}px`;
    if (this._pInst._userNode) {
      this._pInst._userNode.appendChild(this.elt);
    } else {
      if (document.getElementsByTagName("main").length === 0) {
        let m = document.createElement("main");
        document.body.appendChild(m);
      }
      document.getElementsByTagName("main")[0].appendChild(this.elt);
    }
    this.drawingContext = this.canvas.getContext("2d", attributes2);
    if (attributes2.colorSpace === "display-p3") {
      this.states.colorMode = RGBHDR;
    }
    this.scale(this._pixelDensity, this._pixelDensity);
    this.wrappedElt = new Element(this.elt, this._pInst);
    this.clipPath = null;
  }
  get filterRenderer() {
    if (!this._filterRenderer) {
      this._filterRenderer = new FilterRenderer2D(this);
    }
    return this._filterRenderer;
  }
  remove() {
    this.wrappedElt.remove();
    this.wrappedElt = null;
    this.canvas = null;
    this.elt = null;
  }
  getFilterGraphicsLayer() {
    if (!this.filterGraphicsLayer) {
      const pInst = this._pInst;
      this.filterGraphicsLayer = new Graphics(this.width, this.height, WEBGL, pInst);
    }
    if (this.filterGraphicsLayer.width !== this.width || this.filterGraphicsLayer.height !== this.height) {
      this.filterGraphicsLayer.resizeCanvas(this.width, this.height);
    }
    if (this.filterGraphicsLayer.pixelDensity() !== this._pInst.pixelDensity()) {
      this.filterGraphicsLayer.pixelDensity(this._pInst.pixelDensity());
    }
    return this.filterGraphicsLayer;
  }
  _applyDefaults() {
    this.states.setValue("_cachedFillStyle", undefined);
    this.states.setValue("_cachedStrokeStyle", undefined);
    this._cachedBlendMode = BLEND;
    this._setFill(_DEFAULT_FILL);
    this._setStroke(_DEFAULT_STROKE);
    this.drawingContext.lineCap = ROUND;
    this.drawingContext.font = "normal 12px sans-serif";
  }
  resize(w, h) {
    super.resize(w, h);
    const props = {};
    for (const key in this.drawingContext) {
      const val = this.drawingContext[key];
      if (typeof val !== "object" && typeof val !== "function") {
        props[key] = val;
      }
    }
    this.canvas.width = w * this._pixelDensity;
    this.canvas.height = h * this._pixelDensity;
    this.canvas.style.width = `${w}px`;
    this.canvas.style.height = `${h}px`;
    this.drawingContext.scale(this._pixelDensity, this._pixelDensity);
    for (const savedKey in props) {
      try {
        this.drawingContext[savedKey] = props[savedKey];
      } catch (err) {}
    }
  }
  background(...args) {
    this.push();
    this.resetMatrix();
    if (args[0] instanceof Image) {
      if (args[1] >= 0) {
        const img = args[0];
        this.drawingContext.globalAlpha = args[1] / 255;
        this._pInst.image(img, 0, 0, this.width, this.height);
      } else {
        this._pInst.image(args[0], 0, 0, this.width, this.height);
      }
    } else {
      const color2 = this._pInst.color(...args);
      if (this._pInst._addAccsOutput?.()) {
        this._pInst._accsBackground?.(color2._getRGBA([255, 255, 255, 255]));
      }
      const newFill = color2.toString();
      this._setFill(newFill);
      if (this._isErasing) {
        this.blendMode(this._cachedBlendMode);
      }
      this.drawingContext.fillRect(0, 0, this.width, this.height);
      if (this._isErasing) {
        this._pInst.erase();
      }
    }
    this.pop();
  }
  clear() {
    this.drawingContext.save();
    this.resetMatrix();
    this.drawingContext.clearRect(0, 0, this.width, this.height);
    this.drawingContext.restore();
  }
  fill(...args) {
    super.fill(...args);
    const color2 = this.states.fillColor;
    this._setFill(color2.toString());
    if (this._pInst._addAccsOutput?.()) {
      this._pInst._accsCanvasColors?.("fill", color2._getRGBA([255, 255, 255, 255]));
    }
  }
  stroke(...args) {
    super.stroke(...args);
    const color2 = this.states.strokeColor;
    this._setStroke(color2.toString());
    if (this._pInst._addAccsOutput?.()) {
      this._pInst._accsCanvasColors?.("stroke", color2._getRGBA([255, 255, 255, 255]));
    }
  }
  erase(opacityFill, opacityStroke) {
    if (!this._isErasing) {
      this.states.setValue("_cachedFillStyle", this.drawingContext.fillStyle);
      const newFill = this._pInst.color(255, opacityFill).toString();
      this.drawingContext.fillStyle = newFill;
      this.states.setValue("_cachedStrokeStyle", this.drawingContext.strokeStyle);
      const newStroke = this._pInst.color(255, opacityStroke).toString();
      this.drawingContext.strokeStyle = newStroke;
      const tempBlendMode = this._cachedBlendMode;
      this.blendMode(REMOVE);
      this._cachedBlendMode = tempBlendMode;
      this._isErasing = true;
    }
  }
  noErase() {
    if (this._isErasing) {
      this.drawingContext.fillStyle = this.states._cachedFillStyle;
      this.drawingContext.strokeStyle = this.states._cachedStrokeStyle;
      this.blendMode(this._cachedBlendMode);
      this._isErasing = false;
    }
  }
  drawShape(shape) {
    const visitor = new PrimitiveToPath2DConverter({
      strokeWeight: this.states.strokeWeight
    });
    shape.accept(visitor);
    if (this._clipping) {
      this.clipPath.addPath(visitor.path);
      this.clipPath.closePath();
    } else {
      if (this.states.fillColor) {
        this.drawingContext.fill(visitor.path);
      }
      if (this.states.strokeColor) {
        this.drawingContext.stroke(visitor.path);
      }
    }
  }
  beginClip(options2 = {}) {
    super.beginClip(options2);
    this.states.setValue("_cachedFillStyle", this.drawingContext.fillStyle);
    const newFill = this._pInst.color(255, 0).toString();
    this.drawingContext.fillStyle = newFill;
    this.states.setValue("_cachedStrokeStyle", this.drawingContext.strokeStyle);
    const newStroke = this._pInst.color(255, 0).toString();
    this.drawingContext.strokeStyle = newStroke;
    const tempBlendMode = this._cachedBlendMode;
    this.blendMode(BLEND);
    this._cachedBlendMode = tempBlendMode;
    this.clipPath = new Path2D;
    if (this._clipInvert) {
      this.clipPath.moveTo(-2 * this.width, -2 * this.height);
      this.clipPath.lineTo(-2 * this.width, 2 * this.height);
      this.clipPath.lineTo(2 * this.width, 2 * this.height);
      this.clipPath.lineTo(2 * this.width, -2 * this.height);
      this.clipPath.closePath();
    }
  }
  endClip() {
    this.drawingContext.clip(this.clipPath);
    this.clipPath = null;
    super.endClip();
    this.drawingContext.fillStyle = this.states._cachedFillStyle;
    this.drawingContext.strokeStyle = this.states._cachedStrokeStyle;
    this.blendMode(this._cachedBlendMode);
  }
  image(img, sx, sy, sWidth, sHeight, dx, dy, dWidth, dHeight) {
    let cnv;
    if (img.gifProperties) {
      img._animateGif(this._pInst);
    }
    try {
      if (img instanceof MediaElement) {
        img._ensureCanvas();
      }
      if (this.states.tint && img.canvas) {
        cnv = this._getTintedImageCanvas(img);
      }
      if (!cnv) {
        cnv = img.canvas || img.elt;
      }
      let s = 1;
      if (img.width && img.width > 0) {
        s = cnv.width / img.width;
      }
      if (this._isErasing) {
        this.blendMode(this._cachedBlendMode);
      }
      this.drawingContext.drawImage(cnv, s * sx, s * sy, s * sWidth, s * sHeight, dx, dy, dWidth, dHeight);
      if (this._isErasing) {
        this._pInst.erase();
      }
    } catch (e2) {
      if (e2.name !== "NS_ERROR_NOT_AVAILABLE") {
        throw e2;
      }
    }
  }
  _getTintedImageCanvas(img) {
    if (!img.canvas) {
      return img;
    }
    if (!img.tintCanvas) {
      img.tintCanvas = document.createElement("canvas");
    }
    if (img.tintCanvas.width !== img.canvas.width) {
      img.tintCanvas.width = img.canvas.width;
    }
    if (img.tintCanvas.height !== img.canvas.height) {
      img.tintCanvas.height = img.canvas.height;
    }
    const ctx = img.tintCanvas.getContext("2d");
    ctx.save();
    ctx.clearRect(0, 0, img.canvas.width, img.canvas.height);
    if (this.states.tint[0] < 255 || this.states.tint[1] < 255 || this.states.tint[2] < 255) {
      ctx.drawImage(img.canvas, 0, 0);
      ctx.globalCompositeOperation = "luminosity";
      ctx.drawImage(img.canvas, 0, 0);
      ctx.globalCompositeOperation = "color";
      ctx.drawImage(img.canvas, 0, 0);
      ctx.globalCompositeOperation = "multiply";
      ctx.fillStyle = `rgb(${this.states.tint.slice(0, 3).join(", ")})`;
      ctx.fillRect(0, 0, img.canvas.width, img.canvas.height);
      ctx.globalCompositeOperation = "destination-in";
      ctx.globalAlpha = this.states.tint[3] / 255;
      ctx.drawImage(img.canvas, 0, 0);
    } else {
      ctx.globalAlpha = this.states.tint[3] / 255;
      ctx.drawImage(img.canvas, 0, 0);
    }
    ctx.restore();
    return img.tintCanvas;
  }
  blendMode(mode) {
    if (mode === SUBTRACT) {
      console.warn("blendMode(SUBTRACT) only works in WEBGL mode.");
    } else if (mode === BLEND || mode === REMOVE || mode === DARKEST || mode === LIGHTEST || mode === DIFFERENCE || mode === MULTIPLY || mode === EXCLUSION || mode === SCREEN || mode === REPLACE || mode === OVERLAY || mode === HARD_LIGHT || mode === SOFT_LIGHT || mode === DODGE || mode === BURN || mode === ADD) {
      this._cachedBlendMode = mode;
      this.drawingContext.globalCompositeOperation = mode;
    } else {
      throw new Error(`Mode ${mode} not recognized.`);
    }
  }
  blend(...args) {
    const currBlend = this.drawingContext.globalCompositeOperation;
    const blendMode = args[args.length - 1];
    const copyArgs = Array.prototype.slice.call(args, 0, args.length - 1);
    this.drawingContext.globalCompositeOperation = blendMode;
    p52.prototype.copy.apply(this, copyArgs);
    this.drawingContext.globalCompositeOperation = currBlend;
  }
  _getPixel(x, y) {
    let imageData, index;
    imageData = this.drawingContext.getImageData(x, y, 1, 1).data;
    index = 0;
    return [
      imageData[index + 0],
      imageData[index + 1],
      imageData[index + 2],
      imageData[index + 3]
    ];
  }
  loadPixels() {
    const pd = this._pixelDensity;
    const w = this.width * pd;
    const h = this.height * pd;
    const imageData = this.drawingContext.getImageData(0, 0, w, h);
    this.imageData = imageData;
    this.pixels = imageData.data;
  }
  set(x, y, imgOrCol) {
    x = Math.floor(x);
    y = Math.floor(y);
    if (imgOrCol instanceof Image) {
      this.drawingContext.save();
      this.drawingContext.setTransform(1, 0, 0, 1, 0, 0);
      this.drawingContext.scale(this._pixelDensity, this._pixelDensity);
      this.drawingContext.clearRect(x, y, imgOrCol.width, imgOrCol.height);
      this.drawingContext.drawImage(imgOrCol.canvas, x, y);
      this.drawingContext.restore();
    } else {
      let r = 0, g2 = 0, b2 = 0, a = 0;
      let idx = 4 * (y * this._pixelDensity * (this.width * this._pixelDensity) + x * this._pixelDensity);
      if (!this.imageData) {
        this.loadPixels();
      }
      if (typeof imgOrCol === "number") {
        if (idx < this.pixels.length) {
          r = imgOrCol;
          g2 = imgOrCol;
          b2 = imgOrCol;
          a = 255;
        }
      } else if (Array.isArray(imgOrCol)) {
        if (imgOrCol.length < 4) {
          throw new Error("pixel array must be of the form [R, G, B, A]");
        }
        if (idx < this.pixels.length) {
          r = imgOrCol[0];
          g2 = imgOrCol[1];
          b2 = imgOrCol[2];
          a = imgOrCol[3];
        }
      } else if (imgOrCol instanceof p52.Color) {
        if (idx < this.pixels.length) {
          [r, g2, b2, a] = imgOrCol._getRGBA([255, 255, 255, 255]);
        }
      }
      for (let i = 0;i < this._pixelDensity; i++) {
        for (let j = 0;j < this._pixelDensity; j++) {
          idx = 4 * ((y * this._pixelDensity + j) * this.width * this._pixelDensity + (x * this._pixelDensity + i));
          this.pixels[idx] = r;
          this.pixels[idx + 1] = g2;
          this.pixels[idx + 2] = b2;
          this.pixels[idx + 3] = a;
        }
      }
    }
  }
  updatePixels(x, y, w, h) {
    const pd = this._pixelDensity;
    if (x === undefined && y === undefined && w === undefined && h === undefined) {
      x = 0;
      y = 0;
      w = this.width;
      h = this.height;
    }
    x *= pd;
    y *= pd;
    w *= pd;
    h *= pd;
    if (this.gifProperties) {
      this.gifProperties.frames[this.gifProperties.displayIndex].image = this.imageData;
    }
    this.drawingContext.putImageData(this.imageData, 0, 0, x, y, w, h);
  }
  arc(x, y, w, h, start, stop, mode) {
    const ctx = this.clipPa || this.drawingContext;
    const centerX = x + w / 2, centerY = y + h / 2, radiusX = w / 2, radiusY = h / 2;
    const createPieSlice = !(mode === CHORD || mode === OPEN || (stop - start) % TWO_PI === 0);
    if (this.states.fillColor) {
      if (!this._clipping)
        ctx.beginPath();
      ctx.ellipse(centerX, centerY, radiusX, radiusY, 0, start, stop);
      if (createPieSlice)
        ctx.lineTo(centerX, centerY);
      ctx.closePath();
      if (!this._clipping)
        ctx.fill();
    }
    if (this.states.strokeColor) {
      if (!this._clipping)
        ctx.beginPath();
      ctx.ellipse(centerX, centerY, radiusX, radiusY, 0, start, stop);
      if (mode === PIE && createPieSlice) {
        ctx.lineTo(centerX, centerY);
      }
      if (mode === PIE || mode === CHORD) {
        ctx.closePath();
      }
      if (!this._clipping)
        ctx.stroke();
    }
    return this;
  }
  ellipse(args) {
    const ctx = this.clipPath || this.drawingContext;
    const doFill = !!this.states.fillColor, doStroke = this.states.strokeColor;
    const x = parseFloat(args[0]), y = parseFloat(args[1]), w = parseFloat(args[2]), h = parseFloat(args[3]);
    if (doFill && !doStroke) {
      if (this._getFill() === styleEmpty) {
        return this;
      }
    } else if (!doFill && doStroke) {
      if (this._getStroke() === styleEmpty) {
        return this;
      }
    }
    const centerX = x + w / 2, centerY = y + h / 2, radiusX = w / 2, radiusY = h / 2;
    if (!this._clipping)
      ctx.beginPath();
    ctx.ellipse(centerX, centerY, radiusX, radiusY, 0, 0, 2 * Math.PI);
    ctx.closePath();
    if (!this._clipping && doFill) {
      ctx.fill();
    }
    if (!this._clipping && doStroke) {
      ctx.stroke();
    }
  }
  line(x1, y1, x2, y2) {
    const ctx = this.clipPath || this.drawingContext;
    if (!this.states.strokeColor) {
      return this;
    } else if (this._getStroke() === styleEmpty) {
      return this;
    }
    if (!this._clipping)
      ctx.beginPath();
    ctx.moveTo(x1, y1);
    ctx.lineTo(x2, y2);
    ctx.stroke();
    return this;
  }
  point(x, y) {
    const ctx = this.clipPath || this.drawingContext;
    if (!this.states.strokeColor) {
      return this;
    } else if (this._getStroke() === styleEmpty) {
      return this;
    }
    const s = this._getStroke();
    const f = this._getFill();
    if (!this._clipping) {
      this._setFill(s);
    }
    if (!this._clipping)
      ctx.beginPath();
    ctx.arc(x, y, ctx.lineWidth / 2, 0, TWO_PI, false);
    if (!this._clipping) {
      ctx.fill();
      this._setFill(f);
    }
  }
  quad(x1, y1, x2, y2, x3, y3, x4, y4) {
    const ctx = this.clipPath || this.drawingContext;
    const doFill = !!this.states.fillColor, doStroke = this.states.strokeColor;
    if (doFill && !doStroke) {
      if (this._getFill() === styleEmpty) {
        return this;
      }
    } else if (!doFill && doStroke) {
      if (this._getStroke() === styleEmpty) {
        return this;
      }
    }
    if (!this._clipping)
      ctx.beginPath();
    ctx.moveTo(x1, y1);
    ctx.lineTo(x2, y2);
    ctx.lineTo(x3, y3);
    ctx.lineTo(x4, y4);
    ctx.closePath();
    if (!this._clipping && doFill) {
      ctx.fill();
    }
    if (!this._clipping && doStroke) {
      ctx.stroke();
    }
    return this;
  }
  rect(args) {
    const x = args[0];
    const y = args[1];
    const w = args[2];
    const h = args[3];
    let tl = args[4];
    let tr = args[5];
    let br = args[6];
    let bl = args[7];
    const ctx = this.clipPath || this.drawingContext;
    const doFill = !!this.states.fillColor, doStroke = this.states.strokeColor;
    if (doFill && !doStroke) {
      if (this._getFill() === styleEmpty) {
        return this;
      }
    } else if (!doFill && doStroke) {
      if (this._getStroke() === styleEmpty) {
        return this;
      }
    }
    if (!this._clipping)
      ctx.beginPath();
    if (typeof tl === "undefined") {
      ctx.rect(x, y, w, h);
    } else {
      if (typeof tr === "undefined") {
        tr = tl;
      }
      if (typeof br === "undefined") {
        br = tr;
      }
      if (typeof bl === "undefined") {
        bl = br;
      }
      const absW = Math.abs(w);
      const absH = Math.abs(h);
      const hw = absW / 2;
      const hh = absH / 2;
      if (absW < 2 * tl) {
        tl = hw;
      }
      if (absH < 2 * tl) {
        tl = hh;
      }
      if (absW < 2 * tr) {
        tr = hw;
      }
      if (absH < 2 * tr) {
        tr = hh;
      }
      if (absW < 2 * br) {
        br = hw;
      }
      if (absH < 2 * br) {
        br = hh;
      }
      if (absW < 2 * bl) {
        bl = hw;
      }
      if (absH < 2 * bl) {
        bl = hh;
      }
      ctx.roundRect(x, y, w, h, [tl, tr, br, bl]);
    }
    if (!this._clipping && this.states.fillColor) {
      ctx.fill();
    }
    if (!this._clipping && this.states.strokeColor) {
      ctx.stroke();
    }
    return this;
  }
  triangle(args) {
    const ctx = this.clipPath || this.drawingContext;
    const doFill = !!this.states.fillColor, doStroke = this.states.strokeColor;
    const x1 = args[0], y1 = args[1];
    const x2 = args[2], y2 = args[3];
    const x3 = args[4], y3 = args[5];
    if (doFill && !doStroke) {
      if (this._getFill() === styleEmpty) {
        return this;
      }
    } else if (!doFill && doStroke) {
      if (this._getStroke() === styleEmpty) {
        return this;
      }
    }
    if (!this._clipping)
      ctx.beginPath();
    ctx.moveTo(x1, y1);
    ctx.lineTo(x2, y2);
    ctx.lineTo(x3, y3);
    ctx.closePath();
    if (!this._clipping && doFill) {
      ctx.fill();
    }
    if (!this._clipping && doStroke) {
      ctx.stroke();
    }
  }
  strokeCap(cap) {
    if (cap === ROUND || cap === SQUARE || cap === PROJECT) {
      this.drawingContext.lineCap = cap;
    }
    return this;
  }
  strokeJoin(join) {
    if (join === ROUND || join === BEVEL || join === MITER) {
      this.drawingContext.lineJoin = join;
    }
    return this;
  }
  strokeWeight(w) {
    super.strokeWeight(w);
    if (typeof w === "undefined" || w === 0) {
      this.drawingContext.lineWidth = 0.0001;
    } else {
      this.drawingContext.lineWidth = w;
    }
    return this;
  }
  _getFill() {
    if (!this.states._cachedFillStyle) {
      this.states.setValue("_cachedFillStyle", this.drawingContext.fillStyle);
    }
    return this.states._cachedFillStyle;
  }
  _setFill(fillStyle) {
    if (fillStyle !== this.states._cachedFillStyle) {
      this.drawingContext.fillStyle = fillStyle;
      this.states.setValue("_cachedFillStyle", fillStyle);
    }
  }
  _getStroke() {
    if (!this.states._cachedStrokeStyle) {
      this.states.setValue("_cachedStrokeStyle", this.drawingContext.strokeStyle);
    }
    return this.states._cachedStrokeStyle;
  }
  _setStroke(strokeStyle) {
    if (strokeStyle !== this.states._cachedStrokeStyle) {
      this.drawingContext.strokeStyle = strokeStyle;
      this.states.setValue("_cachedStrokeStyle", strokeStyle);
    }
  }
  applyMatrix(a, b2, c, d2, e2, f) {
    this.drawingContext.transform(a, b2, c, d2, e2, f);
  }
  getWorldToScreenMatrix() {
    let domMatrix = new DOMMatrix().scale(1 / this._pixelDensity).multiply(this.drawingContext.getTransform());
    return new Matrix(domMatrix.toFloat32Array());
  }
  resetMatrix() {
    this.drawingContext.setTransform(1, 0, 0, 1, 0, 0);
    this.drawingContext.scale(this._pixelDensity, this._pixelDensity);
    return this;
  }
  rotate(rad) {
    this.drawingContext.rotate(rad);
  }
  scale(x, y) {
    this.drawingContext.scale(x, y);
    return this;
  }
  translate(x, y) {
    if (x instanceof p52.Vector) {
      y = x.y;
      x = x.x;
    }
    this.drawingContext.translate(x, y);
    return this;
  }
  push() {
    this.drawingContext.save();
    return super.push();
  }
  pop(style) {
    this.drawingContext.restore();
    super.pop(style);
  }
}
function renderer2D(p52, fn2) {
  p52.Renderer2D = Renderer2D;
  p52.renderers[P2D] = Renderer2D;
  p52.renderers["p2d-hdr"] = new Proxy(Renderer2D, {
    construct(target, [pInst, w, h, isMainCanvas, elt]) {
      return new target(pInst, w, h, isMainCanvas, elt, { colorSpace: "display-p3" });
    }
  });
}

class p52 {
  static VERSION = VERSION;
  static instance = null;
  static lifecycleHooks = {
    presetup: [],
    postsetup: [],
    predraw: [],
    postdraw: [],
    remove: []
  };
  static _checkForUserDefinedFunctions = () => {};
  static _friendlyFileLoadError = () => {};
  constructor(sketch, node) {
    if (p52.decorations.size > 0) {
      for (const [patternArray, decoration] of p52.decorations) {
        for (const member in p52.prototype) {
          if (typeof p52.prototype[member] !== "function")
            continue;
          if (!patternArray.some((pattern) => {
            if (typeof pattern === "string") {
              return pattern === member;
            } else if (pattern instanceof RegExp) {
              return pattern.test(member);
            }
          }))
            continue;
          p52.prototype[member] = decoration(p52.prototype[member], {
            kind: "method",
            name: member,
            access: {},
            static: false,
            private: false,
            addInitializer(initializer) {}
          });
        }
      }
      p52.decorations.clear();
    }
    this.hitCriticalError = false;
    this._setupDone = false;
    this._userNode = node;
    this._curElement = null;
    this._elements = [];
    this._glAttributes = null;
    this._requestAnimId = 0;
    this._isGlobal = false;
    this._loop = true;
    this._startListener = null;
    this._initializeInstanceVariables();
    this._events = {};
    this._removeAbortController = new AbortController;
    this._removeSignal = this._removeAbortController.signal;
    this._millisStart = -1;
    this._recording = false;
    this._lcg_random_state = null;
    this._gaussian_previous = false;
    this._updateWindowSize();
    const bindGlobal = createBindGlobal(this);
    if (!sketch) {
      this._isGlobal = true;
      if (window.hitCriticalError) {
        return;
      }
      p52.instance = this;
      for (const p2 of Object.getOwnPropertyNames(p52.prototype)) {
        if (p2[0] === "_")
          continue;
        bindGlobal(p2);
      }
      const protectedProperties = ["constructor", "length"];
      for (const p2 in this) {
        if (this.hasOwnProperty(p2)) {
          if (p2[0] === "_" || protectedProperties.includes(p2))
            continue;
          bindGlobal(p2);
        }
      }
    } else {
      sketch(this);
      p52._checkForUserDefinedFunctions(this);
    }
    const focusHandler = () => {
      this.focused = true;
    };
    const blurHandler = () => {
      this.focused = false;
    };
    window.addEventListener("focus", focusHandler);
    window.addEventListener("blur", blurHandler);
    p52.lifecycleHooks.remove.push(function() {
      window.removeEventListener("focus", focusHandler);
      window.removeEventListener("blur", blurHandler);
    });
    if (document.readyState === "complete") {
      this.#_start();
    } else {
      this._startListener = this.#_start.bind(this);
      window.addEventListener("load", this._startListener, false);
    }
  }
  get pixels() {
    return this._renderer.pixels;
  }
  get drawingContext() {
    return this._renderer.drawingContext;
  }
  static registerAddon(addon) {
    const lifecycles = {};
    addon(p52, p52.prototype, lifecycles);
    const validLifecycles = Object.keys(p52.lifecycleHooks);
    for (const name of validLifecycles) {
      if (typeof lifecycles[name] === "function") {
        p52.lifecycleHooks[name].push(lifecycles[name]);
      }
    }
  }
  static decorations = new Map;
  static decorateHelper(pattern, decoration) {
    let patternArray = pattern;
    if (!Array.isArray(pattern))
      patternArray = [pattern];
    p52.decorations.set(patternArray, decoration);
  }
  #customActions = {};
  _customActions = new Proxy({}, {
    get: (target, prop) => {
      if (!this.#customActions[prop]) {
        const context = this._isGlobal ? window : this;
        if (typeof context[prop] === "function") {
          this.#customActions[prop] = context[prop].bind(this);
        }
      }
      return this.#customActions[prop];
    }
  });
  async#_start() {
    if (this.hitCriticalError)
      return;
    if (this._userNode) {
      if (typeof this._userNode === "string") {
        this._userNode = document.getElementById(this._userNode);
      }
    }
    await this.#_setup();
    if (this.hitCriticalError)
      return;
    if (!this._recording) {
      this._draw();
    }
  }
  async#_setup() {
    await this._runLifecycleHook("presetup");
    if (this.hitCriticalError)
      return;
    this.createCanvas(100, 100, P2D);
    this._millisStart = window.performance.now();
    const context = this._isGlobal ? window : this;
    if (typeof context.setup === "function") {
      await context.setup();
    }
    if (this.hitCriticalError)
      return;
    const canvases = document.getElementsByTagName("canvas");
    for (const k of canvases) {
      k.style.touchAction = "none";
      if (k.dataset.hidden === "true") {
        k.style.visibility = "";
        delete k.dataset.hidden;
      }
    }
    this._lastTargetFrameTime = window.performance.now();
    this._lastRealFrameTime = window.performance.now();
    this._setupDone = true;
    if (this._accessibleOutputs.grid || this._accessibleOutputs.text) {
      this._updateAccsOutput();
    }
    await this._runLifecycleHook("postsetup");
    this._millisStart = window.performance.now();
  }
  async _draw(requestAnimationFrameTimestamp) {
    if (this.hitCriticalError)
      return;
    const now = requestAnimationFrameTimestamp || window.performance.now();
    const timeSinceLastFrame = now - this._lastTargetFrameTime;
    const targetTimeBetweenFrames = 1000 / this._targetFrameRate;
    const epsilon = 5;
    if (!this._loop || timeSinceLastFrame >= targetTimeBetweenFrames - epsilon) {
      this.deltaTime = now - this._lastRealFrameTime;
      this._frameRate = 1000 / this.deltaTime;
      await this.redraw();
      this._lastTargetFrameTime = Math.max(this._lastTargetFrameTime + targetTimeBetweenFrames, now);
      this._lastRealFrameTime = now;
      if (typeof this._updateMouseCoords !== "undefined") {
        this._updateMouseCoords();
        this.movedX = 0;
        this.movedY = 0;
      }
    }
    if (this._loop) {
      this._requestAnimId = window.requestAnimationFrame(this._draw.bind(this));
    }
  }
  async remove() {
    if (this._startListener) {
      window.removeEventListener("load", this._startListener, false);
    }
    if (this._curElement) {
      this._loop = false;
      if (this._requestAnimId) {
        window.cancelAnimationFrame(this._requestAnimId);
      }
      this._removeAbortController.abort();
      for (const e2 of this._elements) {
        if (e2.elt && e2.elt.parentNode) {
          e2.elt.parentNode.removeChild(e2.elt);
        }
      }
      await this._runLifecycleHook("remove");
    }
    if (this._isGlobal) {
      for (const p2 in p52.prototype) {
        try {
          delete window[p2];
        } catch (x) {
          window[p2] = undefined;
        }
      }
      for (const p2 in this) {
        if (this.hasOwnProperty(p2)) {
          try {
            delete window[p2];
          } catch (x) {
            window[p2] = undefined;
          }
        }
      }
      p52.instance = null;
    }
  }
  async _runLifecycleHook(hookName) {
    await Promise.all(p52.lifecycleHooks[hookName].map((hook) => {
      return hook.call(this);
    }));
  }
  _initializeInstanceVariables() {
    this._accessibleOutputs = {
      text: false,
      grid: false,
      textLabel: false,
      gridLabel: false
    };
    this._styles = [];
    this._downKeys = {};
    this._downKeyCodes = {};
  }
}
function createBindGlobal(instance) {
  return function bindGlobal(property) {
    if (property === "constructor")
      return;
    const instanceDescriptor = Object.getOwnPropertyDescriptor(instance, property);
    const prototypeDescriptor = Object.getOwnPropertyDescriptor(p52.prototype, property);
    const hasGetter = instanceDescriptor && instanceDescriptor.get || prototypeDescriptor && prototypeDescriptor.get;
    let isPrototypeFunction = false;
    let isConstant = false;
    let constantValue;
    if (!hasGetter) {
      const prototypeValue = p52.prototype[property];
      isPrototypeFunction = typeof prototypeValue === "function";
      if (!isPrototypeFunction && constants[property] !== undefined) {
        isConstant = true;
        constantValue = prototypeValue;
      }
    }
    if (isPrototypeFunction) {
      const boundFunction = p52.prototype[property].bind(instance);
      Object.defineProperty(window, property, {
        configurable: true,
        enumerable: true,
        value: boundFunction
      });
    } else if (isConstant) {
      Object.defineProperty(window, property, {
        configurable: true,
        enumerable: true,
        value: constantValue
      });
    } else if (hasGetter || !isPrototypeFunction) {
      let lastFunction = null;
      let boundFunction = null;
      let isFunction = null;
      Object.defineProperty(window, property, {
        configurable: true,
        enumerable: true,
        get: () => {
          const currentValue = instance[property];
          if (isFunction === null) {
            isFunction = typeof currentValue === "function";
            if (isFunction) {
              lastFunction = currentValue;
              boundFunction = currentValue.bind(instance);
              return boundFunction;
            } else {
              return currentValue;
            }
          } else if (isFunction) {
            if (currentValue !== lastFunction) {
              lastFunction = currentValue;
              boundFunction = currentValue.bind(instance);
            }
            return boundFunction;
          } else {
            return currentValue;
          }
        }
      });
    }
  };
}
for (const k in constants) {
  p52.prototype[k] = constants[k];
}
p52.registerAddon(transform);
p52.registerAddon(structure);
p52.registerAddon(environment);
p52.registerAddon(rendering);
p52.registerAddon(renderer);
p52.registerAddon(renderer2D);
p52.registerAddon(graphics);

// node_modules/p5/dist/shape/index.js
function shape(p53) {
  p53.registerAddon(primitives);
  p53.registerAddon(attributes);
  p53.registerAddon(curves);
  p53.registerAddon(vertex);
  p53.registerAddon(customShapes);
}

// node_modules/p5/dist/accessibility/describe.js
function describe(p53, fn2) {
  const descContainer = "_Description";
  const fallbackDescId = "_fallbackDesc";
  const fallbackTableId = "_fallbackTable";
  const fallbackTableElId = "_fte_";
  const labelContainer = "_Label";
  const labelDescId = "_labelDesc";
  const labelTableId = "_labelTable";
  const labelTableElId = "_lte_";
  fn2.describe = function(text, display) {
    if (typeof text !== "string") {
      return;
    }
    const cnvId = this.canvas.id;
    text = _descriptionText(text);
    if (!this.dummyDOM) {
      this.dummyDOM = document.getElementById(cnvId).parentNode;
    }
    if (!this.descriptions) {
      this.descriptions = {};
    }
    if (this.descriptions.fallback) {
      if (this.descriptions.fallback.innerHTML !== text) {
        this.descriptions.fallback.innerHTML = text;
      }
    } else {
      this._describeHTML("fallback", text);
    }
    if (display === this.LABEL) {
      if (this.descriptions.label) {
        if (this.descriptions.label.innerHTML !== text) {
          this.descriptions.label.innerHTML = text;
        }
      } else {
        this._describeHTML("label", text);
      }
    }
  };
  fn2.describeElement = function(name, text, display) {
    if (typeof text !== "string" || typeof name !== "string") {
      return;
    }
    const cnvId = this.canvas.id;
    text = _descriptionText(text);
    let elementName = _elementName(name);
    name = name.replace(/[^a-zA-Z0-9]/g, "");
    let inner = `<th scope="row">${elementName}</th><td>${text}</td>`;
    if (!this.dummyDOM) {
      this.dummyDOM = document.getElementById(cnvId).parentNode;
    }
    if (!this.descriptions) {
      this.descriptions = { fallbackElements: {} };
    } else if (!this.descriptions.fallbackElements) {
      this.descriptions.fallbackElements = {};
    }
    if (this.descriptions.fallbackElements[name]) {
      if (this.descriptions.fallbackElements[name].innerHTML !== inner) {
        this.descriptions.fallbackElements[name].innerHTML = inner;
      }
    } else {
      this._describeElementHTML("fallback", name, inner);
    }
    if (display === this.LABEL) {
      if (!this.descriptions.labelElements) {
        this.descriptions.labelElements = {};
      }
      if (this.descriptions.labelElements[name]) {
        if (this.descriptions.labelElements[name].innerHTML !== inner) {
          this.descriptions.labelElements[name].innerHTML = inner;
        }
      } else {
        this._describeElementHTML("label", name, inner);
      }
    }
  };
  function _descriptionText(text) {
    if (text === "label" || text === "fallback") {
      throw new Error("description should not be LABEL or FALLBACK");
    }
    if (!text.endsWith(".") && !text.endsWith(";") && !text.endsWith(",") && !text.endsWith("?") && !text.endsWith("!")) {
      text = text + ".";
    }
    return text;
  }
  fn2._describeHTML = function(type2, text) {
    const cnvId = this.canvas.id;
    if (type2 === "fallback") {
      if (!this.dummyDOM.querySelector(`#${cnvId + descContainer}`)) {
        let html = `<div id="${cnvId}${descContainer}" role="region" aria-label="Canvas Description"><p id="${cnvId}${fallbackDescId}"></p></div>`;
        if (!this.dummyDOM.querySelector(`#${cnvId}accessibleOutput`)) {
          this.dummyDOM.querySelector(`#${cnvId}`).innerHTML = html;
        } else {
          this.dummyDOM.querySelector(`#${cnvId}accessibleOutput`).insertAdjacentHTML("beforebegin", html);
        }
      } else {
        this.dummyDOM.querySelector("#" + cnvId + fallbackTableId).insertAdjacentHTML("beforebegin", `<p id="${cnvId + fallbackDescId}"></p>`);
      }
      this.descriptions.fallback = this.dummyDOM.querySelector(`#${cnvId}${fallbackDescId}`);
      this.descriptions.fallback.innerHTML = text;
      return;
    } else if (type2 === "label") {
      if (!this.dummyDOM.querySelector(`#${cnvId + labelContainer}`)) {
        let html = `<div id="${cnvId}${labelContainer}" class="p5Label"><p id="${cnvId}${labelDescId}"></p></div>`;
        if (!this.dummyDOM.querySelector(`#${cnvId}accessibleOutputLabel`)) {
          this.dummyDOM.querySelector("#" + cnvId).insertAdjacentHTML("afterend", html);
        } else {
          this.dummyDOM.querySelector(`#${cnvId}accessibleOutputLabel`).insertAdjacentHTML("beforebegin", html);
        }
      } else if (this.dummyDOM.querySelector(`#${cnvId + labelTableId}`)) {
        this.dummyDOM.querySelector(`#${cnvId + labelTableId}`).insertAdjacentHTML("beforebegin", `<p id="${cnvId}${labelDescId}"></p>`);
      }
      this.descriptions.label = this.dummyDOM.querySelector("#" + cnvId + labelDescId);
      this.descriptions.label.innerHTML = text;
      return;
    }
  };
  function _elementName(name) {
    if (name === "label" || name === "fallback") {
      throw new Error("element name should not be LABEL or FALLBACK");
    }
    if (name.endsWith(".") || name.endsWith(";") || name.endsWith(",")) {
      name = name.replace(/.$/, ":");
    } else if (!name.endsWith(":")) {
      name = name + ":";
    }
    return name;
  }
  fn2._describeElementHTML = function(type2, name, text) {
    const cnvId = this.canvas.id;
    if (type2 === "fallback") {
      if (!this.dummyDOM.querySelector(`#${cnvId + descContainer}`)) {
        let html = `<div id="${cnvId}${descContainer}" role="region" aria-label="Canvas Description"><table id="${cnvId}${fallbackTableId}"><caption>Canvas elements and their descriptions</caption></table></div>`;
        if (!this.dummyDOM.querySelector(`#${cnvId}accessibleOutput`)) {
          this.dummyDOM.querySelector("#" + cnvId).innerHTML = html;
        } else {
          this.dummyDOM.querySelector(`#${cnvId}accessibleOutput`).insertAdjacentHTML("beforebegin", html);
        }
      } else if (!this.dummyDOM.querySelector("#" + cnvId + fallbackTableId)) {
        this.dummyDOM.querySelector("#" + cnvId + fallbackDescId).insertAdjacentHTML("afterend", `<table id="${cnvId}${fallbackTableId}"><caption>Canvas elements and their descriptions</caption></table>`);
      }
      let tableRow = document.createElement("tr");
      tableRow.id = cnvId + fallbackTableElId + name;
      this.dummyDOM.querySelector("#" + cnvId + fallbackTableId).appendChild(tableRow);
      this.descriptions.fallbackElements[name] = this.dummyDOM.querySelector(`#${cnvId}${fallbackTableElId}${name}`);
      this.descriptions.fallbackElements[name].innerHTML = text;
      return;
    } else if (type2 === "label") {
      if (!this.dummyDOM.querySelector(`#${cnvId + labelContainer}`)) {
        let html = `<div id="${cnvId}${labelContainer}" class="p5Label"><table id="${cnvId}${labelTableId}"></table></div>`;
        if (!this.dummyDOM.querySelector(`#${cnvId}accessibleOutputLabel`)) {
          this.dummyDOM.querySelector("#" + cnvId).insertAdjacentHTML("afterend", html);
        } else {
          this.dummyDOM.querySelector(`#${cnvId}accessibleOutputLabel`).insertAdjacentHTML("beforebegin", html);
        }
      } else if (!this.dummyDOM.querySelector(`#${cnvId + labelTableId}`)) {
        this.dummyDOM.querySelector("#" + cnvId + labelDescId).insertAdjacentHTML("afterend", `<table id="${cnvId + labelTableId}"></table>`);
      }
      let tableRow = document.createElement("tr");
      tableRow.id = cnvId + labelTableElId + name;
      this.dummyDOM.querySelector("#" + cnvId + labelTableId).appendChild(tableRow);
      this.descriptions.labelElements[name] = this.dummyDOM.querySelector(`#${cnvId}${labelTableElId}${name}`);
      this.descriptions.labelElements[name].innerHTML = text;
    }
  };
}
if (typeof p5 !== "undefined") {
  describe(p5, p5.prototype);
}

// node_modules/p5/dist/accessibility/gridOutput.js
function gridOutput(p53, fn2) {
  fn2._updateGridOutput = function(idT) {
    if (this._renderer && this._renderer instanceof p53.RendererGL) {
      if (!this._didOutputGridWebGLMessage) {
        this._didOutputGridWebGLMessage = true;
        console.error("gridOutput() does not yet work in WebGL mode.");
      }
      return;
    }
    if (!this.dummyDOM.querySelector(`#${idT}_summary`)) {
      return;
    }
    let current = this._accessibleOutputs[idT];
    let innerShapeDetails = _gridShapeDetails(idT, this.ingredients.shapes);
    let innerSummary = _gridSummary(innerShapeDetails.numShapes, this.ingredients.colors.background, this.width, this.height);
    let innerMap = _gridMap(idT, this.ingredients.shapes);
    if (innerSummary !== current.summary.innerHTML) {
      current.summary.innerHTML = innerSummary;
    }
    if (innerMap !== current.map.innerHTML) {
      current.map.innerHTML = innerMap;
    }
    if (innerShapeDetails.details !== current.shapeDetails.innerHTML) {
      current.shapeDetails.innerHTML = innerShapeDetails.details;
    }
    this._accessibleOutputs[idT] = current;
  };
  function _gridMap(idT, ingredients) {
    let shapeNumber = 0;
    let table = "";
    let cells = Array.from(Array(10), () => Array(10));
    for (let x in ingredients) {
      for (let y in ingredients[x]) {
        let fill;
        if (x !== "line") {
          fill = `<a href="#${idT}shape${shapeNumber}">${ingredients[x][y].color} ${x}</a>`;
        } else {
          fill = `<a href="#${idT}shape${shapeNumber}">${ingredients[x][y].color} ${x} midpoint</a>`;
        }
        if (ingredients[x][y].loc.locY < cells.length && ingredients[x][y].loc.locX < cells[ingredients[x][y].loc.locY].length) {
          if (!cells[ingredients[x][y].loc.locY][ingredients[x][y].loc.locX]) {
            cells[ingredients[x][y].loc.locY][ingredients[x][y].loc.locX] = fill;
          } else {
            cells[ingredients[x][y].loc.locY][ingredients[x][y].loc.locX] = cells[ingredients[x][y].loc.locY][ingredients[x][y].loc.locX] + "  " + fill;
          }
          shapeNumber++;
        }
      }
    }
    for (let _r in cells) {
      let row = "<tr>";
      for (let c in cells[_r]) {
        row = row + "<td>";
        if (cells[_r][c] !== undefined) {
          row = row + cells[_r][c];
        }
        row = row + "</td>";
      }
      table = table + row + "</tr>";
    }
    return table;
  }
  function _gridSummary(numShapes, background, width, height) {
    let text = `${background} canvas, ${width} by ${height} pixels, contains ${numShapes[0]}`;
    if (numShapes[0] === 1) {
      text = `${text} shape: ${numShapes[1]}`;
    } else {
      text = `${text} shapes: ${numShapes[1]}`;
    }
    return text;
  }
  function _gridShapeDetails(idT, ingredients) {
    let shapeDetails = "";
    let shapes = "";
    let totalShapes = 0;
    for (let x in ingredients) {
      let shapeNum = 0;
      for (let y in ingredients[x]) {
        let line = `<li id="${idT}shape${totalShapes}">${ingredients[x][y].color} ${x},`;
        if (x === "line") {
          line = line + ` location = ${ingredients[x][y].pos}, length = ${ingredients[x][y].length} pixels`;
        } else {
          line = line + ` location = ${ingredients[x][y].pos}`;
          if (x !== "point") {
            line = line + `, area = ${ingredients[x][y].area} %`;
          }
          line = line + "</li>";
        }
        shapeDetails = shapeDetails + line;
        shapeNum++;
        totalShapes++;
      }
      if (shapeNum > 1) {
        shapes = `${shapes} ${shapeNum} ${x}s`;
      } else {
        shapes = `${shapes} ${shapeNum} ${x}`;
      }
    }
    return { numShapes: [totalShapes, shapes], details: shapeDetails };
  }
}
if (typeof p5 !== "undefined") {
  gridOutput(p5, p5.prototype);
}

// node_modules/p5/dist/accessibility/textOutput.js
function textOutput(p53, fn2) {
  fn2._updateTextOutput = function(idT) {
    if (this._renderer && this._renderer instanceof p53.RendererGL) {
      if (!this._didOutputTextWebGLMessage) {
        this._didOutputTextWebGLMessage = true;
        console.error("textOutput() does not yet work in WebGL mode.");
      }
      return;
    }
    if (!this.dummyDOM.querySelector(`#${idT}_summary`)) {
      return;
    }
    let current = this._accessibleOutputs[idT];
    let innerList = _shapeList(idT, this.ingredients.shapes);
    let innerSummary = _textSummary(innerList.numShapes, this.ingredients.colors.background, this.width, this.height);
    let innerShapeDetails = _shapeDetails(idT, this.ingredients.shapes);
    if (innerSummary !== current.summary.innerHTML) {
      current.summary.innerHTML = innerSummary;
    }
    if (innerList.listShapes !== current.list.innerHTML) {
      current.list.innerHTML = innerList.listShapes;
    }
    if (innerShapeDetails !== current.shapeDetails.innerHTML) {
      current.shapeDetails.innerHTML = innerShapeDetails;
    }
    this._accessibleOutputs[idT] = current;
  };
  function _textSummary(numShapes, background, width, height) {
    let text = `Your output is a, ${width} by ${height} pixels, ${background} canvas containing the following`;
    if (numShapes === 1) {
      text = `${text} shape:`;
    } else {
      text = `${text} ${numShapes} shapes:`;
    }
    return text;
  }
  function _shapeDetails(idT, ingredients) {
    let shapeDetails = "";
    let shapeNumber = 0;
    for (let x in ingredients) {
      for (let y in ingredients[x]) {
        let row = `<tr id="${idT}shape${shapeNumber}"><th>${ingredients[x][y].color} ${x}</th>`;
        if (x === "line") {
          row = row + `<td>location = ${ingredients[x][y].pos}</td><td>length = ${ingredients[x][y].length} pixels</td></tr>`;
        } else {
          row = row + `<td>location = ${ingredients[x][y].pos}</td>`;
          if (x !== "point") {
            row = row + `<td> area = ${ingredients[x][y].area}%</td>`;
          }
          row = row + "</tr>";
        }
        shapeDetails = shapeDetails + row;
        shapeNumber++;
      }
    }
    return shapeDetails;
  }
  function _shapeList(idT, ingredients) {
    let shapeList = "";
    let shapeNumber = 0;
    for (let x in ingredients) {
      for (let y in ingredients[x]) {
        let _line = `<li><a href="#${idT}shape${shapeNumber}">${ingredients[x][y].color} ${x}</a>`;
        if (x === "line") {
          _line = _line + `, ${ingredients[x][y].pos}, ${ingredients[x][y].length} pixels long.</li>`;
        } else {
          _line = _line + `, at ${ingredients[x][y].pos}`;
          if (x !== "point") {
            _line = _line + `, covering ${ingredients[x][y].area}% of the canvas`;
          }
          _line = _line + ".</li>";
        }
        shapeList = shapeList + _line;
        shapeNumber++;
      }
    }
    return { numShapes: shapeNumber, listShapes: shapeList };
  }
}
if (typeof p5 !== "undefined") {
  textOutput(p5, p5.prototype);
}

// node_modules/p5/dist/accessibility/outputs.js
function outputs(p53, fn2) {
  fn2.textOutput = function(display) {
    if (this._accessibleOutputs.text) {
      return;
    } else {
      this._accessibleOutputs.text = true;
      this._createOutput("textOutput", "Fallback");
      if (display === this.LABEL) {
        this._accessibleOutputs.textLabel = true;
        this._createOutput("textOutput", "Label");
      }
    }
  };
  fn2.gridOutput = function(display) {
    if (this._accessibleOutputs.grid) {
      return;
    } else {
      this._accessibleOutputs.grid = true;
      this._createOutput("gridOutput", "Fallback");
      if (display === this.LABEL) {
        this._accessibleOutputs.gridLabel = true;
        this._createOutput("gridOutput", "Label");
      }
    }
  };
  fn2._addAccsOutput = function() {
    if (!this._accessibleOutputs) {
      this._accessibleOutputs = {
        text: false,
        grid: false,
        textLabel: false,
        gridLabel: false
      };
    }
    return this._accessibleOutputs.grid || this._accessibleOutputs.text;
  };
  fn2._createOutput = function(type2, display) {
    let cnvId = this.canvas.id;
    if (!this.ingredients) {
      this.ingredients = {
        shapes: {},
        colors: { background: "white", fill: "white", stroke: "black" },
        pShapes: "",
        pBackground: ""
      };
    }
    if (!this.dummyDOM) {
      this.dummyDOM = document.getElementById(cnvId).parentNode;
    }
    let cIdT, container, inner;
    let query = "";
    if (display === "Fallback") {
      cIdT = cnvId + type2;
      container = cnvId + "accessibleOutput";
      if (!this.dummyDOM.querySelector(`#${container}`)) {
        if (!this.dummyDOM.querySelector(`#${cnvId}_Description`)) {
          this.dummyDOM.querySelector(`#${cnvId}`).innerHTML = `<div id="${container}" role="region" aria-label="Canvas Outputs"></div>`;
        } else {
          this.dummyDOM.querySelector(`#${cnvId}_Description`).insertAdjacentHTML("afterend", `<div id="${container}" role="region" aria-label="Canvas Outputs"></div>`);
        }
      }
    } else if (display === "Label") {
      query = display;
      cIdT = cnvId + type2 + display;
      container = cnvId + "accessibleOutput" + display;
      if (!this.dummyDOM.querySelector(`#${container}`)) {
        if (!this.dummyDOM.querySelector(`#${cnvId}_Label`)) {
          this.dummyDOM.querySelector(`#${cnvId}`).insertAdjacentHTML("afterend", `<div id="${container}"></div>`);
        } else {
          this.dummyDOM.querySelector(`#${cnvId}_Label`).insertAdjacentHTML("afterend", `<div id="${container}"></div>`);
        }
      }
    }
    this._accessibleOutputs[cIdT] = {};
    if (type2 === "textOutput") {
      query = `#${cnvId}gridOutput${query}`;
      inner = `<div id="${cIdT}">Text Output<div id="${cIdT}Summary" aria-label="text output summary"><p id="${cIdT}_summary"></p><ul id="${cIdT}_list"></ul></div><table id="${cIdT}_shapeDetails" summary="text output shape details"></table></div>`;
      if (this.dummyDOM.querySelector(query)) {
        this.dummyDOM.querySelector(query).insertAdjacentHTML("beforebegin", inner);
      } else {
        this.dummyDOM.querySelector(`#${container}`).innerHTML = inner;
      }
      this._accessibleOutputs[cIdT].list = this.dummyDOM.querySelector(`#${cIdT}_list`);
    } else if (type2 === "gridOutput") {
      query = `#${cnvId}textOutput${query}`;
      inner = `<div id="${cIdT}">Grid Output<p id="${cIdT}_summary" aria-label="grid output summary"><table id="${cIdT}_map" summary="grid output content"></table><ul id="${cIdT}_shapeDetails" aria-label="grid output shape details"></ul></div>`;
      if (this.dummyDOM.querySelector(query)) {
        this.dummyDOM.querySelector(query).insertAdjacentHTML("afterend", inner);
      } else {
        this.dummyDOM.querySelector(`#${container}`).innerHTML = inner;
      }
      this._accessibleOutputs[cIdT].map = this.dummyDOM.querySelector(`#${cIdT}_map`);
    }
    this._accessibleOutputs[cIdT].shapeDetails = this.dummyDOM.querySelector(`#${cIdT}_shapeDetails`);
    this._accessibleOutputs[cIdT].summary = this.dummyDOM.querySelector(`#${cIdT}_summary`);
  };
  fn2._updateAccsOutput = function() {
    let cnvId = this.canvas.id;
    if (JSON.stringify(this.ingredients.shapes) !== this.ingredients.pShapes || this.ingredients.colors.background !== this.ingredients.pBackground) {
      this.ingredients.pShapes = JSON.stringify(this.ingredients.shapes);
      if (this._accessibleOutputs.text) {
        this._updateTextOutput(cnvId + "textOutput");
      }
      if (this._accessibleOutputs.grid) {
        this._updateGridOutput(cnvId + "gridOutput");
      }
      if (this._accessibleOutputs.textLabel) {
        this._updateTextOutput(cnvId + "textOutputLabel");
      }
      if (this._accessibleOutputs.gridLabel) {
        this._updateGridOutput(cnvId + "gridOutputLabel");
      }
    }
  };
  fn2._accsBackground = function(args) {
    this.ingredients.pShapes = JSON.stringify(this.ingredients.shapes);
    this.ingredients.pBackground = this.ingredients.colors.background;
    this.ingredients.shapes = {};
    if (this.ingredients.colors.backgroundRGBA !== args) {
      this.ingredients.colors.backgroundRGBA = args;
      this.ingredients.colors.background = this._rgbColorName(args);
    }
  };
  fn2._accsCanvasColors = function(f, args) {
    if (f === "fill") {
      if (this.ingredients.colors.fillRGBA !== args) {
        this.ingredients.colors.fillRGBA = args;
        this.ingredients.colors.fill = this._rgbColorName(args);
      }
    } else if (f === "stroke") {
      if (this.ingredients.colors.strokeRGBA !== args) {
        this.ingredients.colors.strokeRGBA = args;
        this.ingredients.colors.stroke = this._rgbColorName(args);
      }
    }
  };
  fn2._accsOutput = function(f, args) {
    if (f === "ellipse" && args[2] === args[3]) {
      f = "circle";
    } else if (f === "rectangle" && args[2] === args[3]) {
      f = "square";
    }
    let include = {};
    let add = true;
    let middle = _getMiddle(f, args);
    if (f === "line") {
      include.color = this.ingredients.colors.stroke;
      include.length = Math.round(Math.hypot(args[2] - args[0], args[3] - args[1]));
      let p1 = this._getPos(args[0], [1]);
      let p2 = this._getPos(args[2], [3]);
      include.loc = _canvasLocator(middle, this.width, this.height);
      if (p1 === p2) {
        include.pos = `at ${p1}`;
      } else {
        include.pos = `from ${p1} to ${p2}`;
      }
    } else {
      if (f === "point") {
        include.color = this.ingredients.colors.stroke;
      } else {
        include.color = this.ingredients.colors.fill;
        include.area = this._getArea(f, args);
      }
      include.pos = this._getPos(...middle);
      include.loc = _canvasLocator(middle, this.width, this.height);
    }
    if (!this.ingredients.shapes[f]) {
      this.ingredients.shapes[f] = [include];
    } else {
      for (let y in this.ingredients.shapes[f]) {
        if (JSON.stringify(this.ingredients.shapes[f][y]) === JSON.stringify(include)) {
          add = false;
        }
      }
      if (add === true) {
        this.ingredients.shapes[f].push(include);
      }
    }
  };
  function _getMiddle(f, args) {
    let x, y;
    if (f === "rectangle" || f === "ellipse" || f === "arc" || f === "circle" || f === "square") {
      x = Math.round(args[0] + args[2] / 2);
      y = Math.round(args[1] + args[3] / 2);
    } else if (f === "triangle") {
      x = (args[0] + args[2] + args[4]) / 3;
      y = (args[1] + args[3] + args[5]) / 3;
    } else if (f === "quadrilateral") {
      x = (args[0] + args[2] + args[4] + args[6]) / 4;
      y = (args[1] + args[3] + args[5] + args[7]) / 4;
    } else if (f === "line") {
      x = (args[0] + args[2]) / 2;
      y = (args[1] + args[3]) / 2;
    } else {
      x = args[0];
      y = args[1];
    }
    return [x, y];
  }
  fn2._getPos = function(x, y) {
    const { x: transformedX, y: transformedY } = this.worldToScreen(new p53.Vector(x, y));
    const canvasWidth = this.width;
    const canvasHeight = this.height;
    if (transformedX < 0.4 * canvasWidth) {
      if (transformedY < 0.4 * canvasHeight) {
        return "top left";
      } else if (transformedY > 0.6 * canvasHeight) {
        return "bottom left";
      } else {
        return "mid left";
      }
    } else if (transformedX > 0.6 * canvasWidth) {
      if (transformedY < 0.4 * canvasHeight) {
        return "top right";
      } else if (transformedY > 0.6 * canvasHeight) {
        return "bottom right";
      } else {
        return "mid right";
      }
    } else {
      if (transformedY < 0.4 * canvasHeight) {
        return "top middle";
      } else if (transformedY > 0.6 * canvasHeight) {
        return "bottom middle";
      } else {
        return "middle";
      }
    }
  };
  function _canvasLocator(args, canvasWidth, canvasHeight) {
    const noRows = 10;
    const noCols = 10;
    let locX = Math.floor(args[0] / canvasWidth * noRows);
    let locY = Math.floor(args[1] / canvasHeight * noCols);
    if (locX === noRows) {
      locX = locX - 1;
    }
    if (locY === noCols) {
      locY = locY - 1;
    }
    return {
      locX,
      locY
    };
  }
  fn2._getArea = function(objectType, shapeArgs) {
    let objectArea = 0;
    if (objectType === "arc") {
      const arcSizeInRadians = ((shapeArgs[5] - shapeArgs[4]) % (Math.PI * 2) + Math.PI * 2) % (Math.PI * 2);
      objectArea = arcSizeInRadians * shapeArgs[2] * shapeArgs[3] / 8;
      if (shapeArgs[6] === "open" || shapeArgs[6] === "chord") {
        const Ax = shapeArgs[0];
        const Ay = shapeArgs[1];
        const Bx = shapeArgs[0] + shapeArgs[2] / 2 * Math.cos(shapeArgs[4]).toFixed(2);
        const By = shapeArgs[1] + shapeArgs[3] / 2 * Math.sin(shapeArgs[4]).toFixed(2);
        const Cx = shapeArgs[0] + shapeArgs[2] / 2 * Math.cos(shapeArgs[5]).toFixed(2);
        const Cy = shapeArgs[1] + shapeArgs[3] / 2 * Math.sin(shapeArgs[5]).toFixed(2);
        const areaOfExtraTriangle = Math.abs(Ax * (By - Cy) + Bx * (Cy - Ay) + Cx * (Ay - By)) / 2;
        if (arcSizeInRadians > Math.PI) {
          objectArea = objectArea + areaOfExtraTriangle;
        } else {
          objectArea = objectArea - areaOfExtraTriangle;
        }
      }
    } else if (objectType === "ellipse" || objectType === "circle") {
      objectArea = 3.14 * shapeArgs[2] / 2 * shapeArgs[3] / 2;
    } else if (objectType === "line") {
      objectArea = 0;
    } else if (objectType === "point") {
      objectArea = 0;
    } else if (objectType === "quadrilateral") {
      objectArea = Math.abs((shapeArgs[6] + shapeArgs[0]) * (shapeArgs[7] - shapeArgs[1]) + (shapeArgs[0] + shapeArgs[2]) * (shapeArgs[1] - shapeArgs[3]) + (shapeArgs[2] + shapeArgs[4]) * (shapeArgs[3] - shapeArgs[5]) + (shapeArgs[4] + shapeArgs[6]) * (shapeArgs[5] - shapeArgs[7])) / 2;
    } else if (objectType === "rectangle" || objectType === "square") {
      objectArea = shapeArgs[2] * shapeArgs[3];
    } else if (objectType === "triangle") {
      objectArea = Math.abs(shapeArgs[0] * (shapeArgs[3] - shapeArgs[5]) + shapeArgs[2] * (shapeArgs[5] - shapeArgs[1]) + shapeArgs[4] * (shapeArgs[1] - shapeArgs[3])) / 2;
    }
    const canvasWidth = this.width * this._renderer._pixelDensity;
    const canvasHeight = this.height * this._renderer._pixelDensity;
    const canvasCorners = [
      new DOMPoint(0, 0),
      new DOMPoint(canvasWidth, 0),
      new DOMPoint(canvasWidth, canvasHeight),
      new DOMPoint(0, canvasHeight)
    ];
    const currentTransform = this._renderer.isP3D ? new DOMMatrix(this._renderer.uMVMatrix.mat4) : this.drawingContext.getTransform();
    const invertedTransform = currentTransform.inverse();
    const tc = canvasCorners.map((corner) => corner.matrixTransform(invertedTransform));
    const transformedCanvasArea = Math.abs((tc[3].x + tc[0].x) * (tc[3].y - tc[0].y) + (tc[0].x + tc[1].x) * (tc[0].y - tc[1].y) + (tc[1].x + tc[2].x) * (tc[1].y - tc[2].y) + (tc[2].x + tc[3].x) * (tc[2].y - tc[3].y)) / 2;
    const untransformedArea = Math.round(objectArea * 100 / transformedCanvasArea);
    return untransformedArea;
  };
}
if (typeof p5 !== "undefined") {
  outputs(p5, p5.prototype);
}

// node_modules/p5/dist/color/color_conversion.js
var import_file_saver5 = __toESM(require_FileSaver(), 1);
var import_omggif2 = __toESM(require_omggif(), 1);
var import_gifenc3 = __toESM(require_gifenc(), 1);
var import_libtess3 = __toESM(require_libtess_min(), 1);
p52.ColorConversion = {
  _hsbaToHSLA(hsba) {
    const hue = hsba[0];
    let sat = hsba[1];
    const val = hsba[2];
    const li = (2 - sat) * val / 2;
    if (li !== 0) {
      if (li === 1) {
        sat = 0;
      } else if (li < 0.5) {
        sat = sat / (2 - sat);
      } else {
        sat = sat * val / (2 - li * 2);
      }
    }
    return [hue, sat, li, hsba[3]];
  },
  _hsbaToRGBA(hsba) {
    const hue = hsba[0] * 6;
    const sat = hsba[1];
    const val = hsba[2];
    let RGBA2 = [];
    if (sat === 0) {
      RGBA2 = [val, val, val, hsba[3]];
    } else {
      const sector = Math.floor(hue);
      const tint1 = val * (1 - sat);
      const tint2 = val * (1 - sat * (hue - sector));
      const tint3 = val * (1 - sat * (1 + sector - hue));
      let red, green, blue;
      if (sector === 1) {
        red = tint2;
        green = val;
        blue = tint1;
      } else if (sector === 2) {
        red = tint1;
        green = val;
        blue = tint3;
      } else if (sector === 3) {
        red = tint1;
        green = tint2;
        blue = val;
      } else if (sector === 4) {
        red = tint3;
        green = tint1;
        blue = val;
      } else if (sector === 5) {
        red = val;
        green = tint1;
        blue = tint2;
      } else {
        red = val;
        green = tint3;
        blue = tint1;
      }
      RGBA2 = [red, green, blue, hsba[3]];
    }
    return RGBA2;
  },
  _hslaToHSBA(hsla) {
    const hue = hsla[0];
    let sat = hsla[1];
    const li = hsla[2];
    let val;
    if (li < 0.5) {
      val = (1 + sat) * li;
    } else {
      val = li + sat - li * sat;
    }
    sat = 2 * (val - li) / val;
    return [hue, sat, val, hsla[3]];
  },
  _hslaToRGBA(hsla) {
    const hue = hsla[0] * 6;
    const sat = hsla[1];
    const li = hsla[2];
    let RGBA2 = [];
    if (sat === 0) {
      RGBA2 = [li, li, li, hsla[3]];
    } else {
      let val;
      if (li < 0.5) {
        val = (1 + sat) * li;
      } else {
        val = li + sat - li * sat;
      }
      const zest = 2 * li - val;
      const hzvToRGB = (hue2, zest2, val2) => {
        if (hue2 < 0) {
          hue2 += 6;
        } else if (hue2 >= 6) {
          hue2 -= 6;
        }
        if (hue2 < 1) {
          return zest2 + (val2 - zest2) * hue2;
        } else if (hue2 < 3) {
          return val2;
        } else if (hue2 < 4) {
          return zest2 + (val2 - zest2) * (4 - hue2);
        } else {
          return zest2;
        }
      };
      RGBA2 = [
        hzvToRGB(hue + 2, zest, val),
        hzvToRGB(hue, zest, val),
        hzvToRGB(hue - 2, zest, val),
        hsla[3]
      ];
    }
    return RGBA2;
  },
  _rgbaToHSBA(rgba) {
    const red = rgba[0];
    const green = rgba[1];
    const blue = rgba[2];
    const val = Math.max(red, green, blue);
    const chroma = val - Math.min(red, green, blue);
    let hue, sat;
    if (chroma === 0) {
      hue = 0;
      sat = 0;
    } else {
      sat = chroma / val;
      if (red === val) {
        hue = (green - blue) / chroma;
      } else if (green === val) {
        hue = 2 + (blue - red) / chroma;
      } else if (blue === val) {
        hue = 4 + (red - green) / chroma;
      }
      if (hue < 0) {
        hue += 6;
      } else if (hue >= 6) {
        hue -= 6;
      }
    }
    return [hue / 6, sat, val, rgba[3]];
  },
  _rgbaToHSLA(rgba) {
    const red = rgba[0];
    const green = rgba[1];
    const blue = rgba[2];
    const val = Math.max(red, green, blue);
    const min = Math.min(red, green, blue);
    const li = val + min;
    const chroma = val - min;
    let hue, sat;
    if (chroma === 0) {
      hue = 0;
      sat = 0;
    } else {
      if (li < 1) {
        sat = chroma / li;
      } else {
        sat = chroma / (2 - li);
      }
      if (red === val) {
        hue = (green - blue) / chroma;
      } else if (green === val) {
        hue = 2 + (blue - red) / chroma;
      } else if (blue === val) {
        hue = 4 + (red - green) / chroma;
      }
      if (hue < 0) {
        hue += 6;
      } else if (hue >= 6) {
        hue -= 6;
      }
    }
    return [hue / 6, sat, li / 2, rgba[3]];
  }
};
var color_conversion = p52.ColorConversion;

// node_modules/p5/dist/accessibility/color_namer.js
var import_file_saver6 = __toESM(require_FileSaver(), 1);
var import_omggif3 = __toESM(require_omggif(), 1);
var import_gifenc4 = __toESM(require_gifenc(), 1);
var import_libtess4 = __toESM(require_libtess_min(), 1);
function colorNamer(p53, fn2) {
  let originalHSB;
  const colorExceptions = [
    {
      h: 0,
      s: 0,
      b: 0.8275,
      name: "gray"
    },
    {
      h: 0,
      s: 0,
      b: 0.8627,
      name: "gray"
    },
    {
      h: 0,
      s: 0,
      b: 0.7529,
      name: "gray"
    },
    {
      h: 0.0167,
      s: 0.1176,
      b: 1,
      name: "light pink"
    }
  ];
  const colorLookUp = [
    {
      h: 0,
      s: 0,
      b: 0,
      name: "black"
    },
    {
      h: 0,
      s: 0,
      b: 0.5,
      name: "gray"
    },
    {
      h: 0,
      s: 0,
      b: 1,
      name: "white"
    },
    {
      h: 0,
      s: 0.5,
      b: 0.5,
      name: "dark maroon"
    },
    {
      h: 0,
      s: 0.5,
      b: 1,
      name: "salmon pink"
    },
    {
      h: 0,
      s: 1,
      b: 0,
      name: "black"
    },
    {
      h: 0,
      s: 1,
      b: 0.5,
      name: "dark red"
    },
    {
      h: 0,
      s: 1,
      b: 1,
      name: "red"
    },
    {
      h: 5,
      s: 0,
      b: 1,
      name: "very light peach"
    },
    {
      h: 5,
      s: 0.5,
      b: 0.5,
      name: "brown"
    },
    {
      h: 5,
      s: 0.5,
      b: 1,
      name: "peach"
    },
    {
      h: 5,
      s: 1,
      b: 0.5,
      name: "brick red"
    },
    {
      h: 5,
      s: 1,
      b: 1,
      name: "crimson"
    },
    {
      h: 10,
      s: 0,
      b: 1,
      name: "light peach"
    },
    {
      h: 10,
      s: 0.5,
      b: 0.5,
      name: "brown"
    },
    {
      h: 10,
      s: 0.5,
      b: 1,
      name: "light orange"
    },
    {
      h: 10,
      s: 1,
      b: 0.5,
      name: "brown"
    },
    {
      h: 10,
      s: 1,
      b: 1,
      name: "orange"
    },
    {
      h: 15,
      s: 0,
      b: 1,
      name: "very light yellow"
    },
    {
      h: 15,
      s: 0.5,
      b: 0.5,
      name: "olive green"
    },
    {
      h: 15,
      s: 0.5,
      b: 1,
      name: "light yellow"
    },
    {
      h: 15,
      s: 1,
      b: 0,
      name: "dark olive green"
    },
    {
      h: 15,
      s: 1,
      b: 0.5,
      name: "olive green"
    },
    {
      h: 15,
      s: 1,
      b: 1,
      name: "yellow"
    },
    {
      h: 20,
      s: 0,
      b: 1,
      name: "very light yellow"
    },
    {
      h: 20,
      s: 0.5,
      b: 0.5,
      name: "olive green"
    },
    {
      h: 20,
      s: 0.5,
      b: 1,
      name: "light yellow green"
    },
    {
      h: 20,
      s: 1,
      b: 0,
      name: "dark olive green"
    },
    {
      h: 20,
      s: 1,
      b: 0.5,
      name: "dark yellow green"
    },
    {
      h: 20,
      s: 1,
      b: 1,
      name: "yellow green"
    },
    {
      h: 25,
      s: 0.5,
      b: 0.5,
      name: "dark yellow green"
    },
    {
      h: 25,
      s: 0.5,
      b: 1,
      name: "light green"
    },
    {
      h: 25,
      s: 1,
      b: 0.5,
      name: "dark green"
    },
    {
      h: 25,
      s: 1,
      b: 1,
      name: "green"
    },
    {
      h: 30,
      s: 0.5,
      b: 1,
      name: "light green"
    },
    {
      h: 30,
      s: 1,
      b: 0.5,
      name: "dark green"
    },
    {
      h: 30,
      s: 1,
      b: 1,
      name: "green"
    },
    {
      h: 35,
      s: 0,
      b: 0.5,
      name: "light green"
    },
    {
      h: 35,
      s: 0,
      b: 1,
      name: "very light green"
    },
    {
      h: 35,
      s: 0.5,
      b: 0.5,
      name: "dark green"
    },
    {
      h: 35,
      s: 0.5,
      b: 1,
      name: "light green"
    },
    {
      h: 35,
      s: 1,
      b: 0,
      name: "very dark green"
    },
    {
      h: 35,
      s: 1,
      b: 0.5,
      name: "dark green"
    },
    {
      h: 35,
      s: 1,
      b: 1,
      name: "green"
    },
    {
      h: 40,
      s: 0,
      b: 1,
      name: "very light green"
    },
    {
      h: 40,
      s: 0.5,
      b: 0.5,
      name: "dark green"
    },
    {
      h: 40,
      s: 0.5,
      b: 1,
      name: "light green"
    },
    {
      h: 40,
      s: 1,
      b: 0.5,
      name: "dark green"
    },
    {
      h: 40,
      s: 1,
      b: 1,
      name: "green"
    },
    {
      h: 45,
      s: 0.5,
      b: 1,
      name: "light turquoise"
    },
    {
      h: 45,
      s: 1,
      b: 0.5,
      name: "dark turquoise"
    },
    {
      h: 45,
      s: 1,
      b: 1,
      name: "turquoise"
    },
    {
      h: 50,
      s: 0,
      b: 1,
      name: "light sky blue"
    },
    {
      h: 50,
      s: 0.5,
      b: 0.5,
      name: "dark cyan"
    },
    {
      h: 50,
      s: 0.5,
      b: 1,
      name: "light cyan"
    },
    {
      h: 50,
      s: 1,
      b: 0.5,
      name: "dark cyan"
    },
    {
      h: 50,
      s: 1,
      b: 1,
      name: "cyan"
    },
    {
      h: 55,
      s: 0,
      b: 1,
      name: "light sky blue"
    },
    {
      h: 55,
      s: 0.5,
      b: 1,
      name: "light sky blue"
    },
    {
      h: 55,
      s: 1,
      b: 0.5,
      name: "dark blue"
    },
    {
      h: 55,
      s: 1,
      b: 1,
      name: "sky blue"
    },
    {
      h: 60,
      s: 0,
      b: 0.5,
      name: "gray"
    },
    {
      h: 60,
      s: 0,
      b: 1,
      name: "very light blue"
    },
    {
      h: 60,
      s: 0.5,
      b: 0.5,
      name: "blue"
    },
    {
      h: 60,
      s: 0.5,
      b: 1,
      name: "light blue"
    },
    {
      h: 60,
      s: 1,
      b: 0.5,
      name: "navy blue"
    },
    {
      h: 60,
      s: 1,
      b: 1,
      name: "blue"
    },
    {
      h: 65,
      s: 0,
      b: 1,
      name: "lavender"
    },
    {
      h: 65,
      s: 0.5,
      b: 0.5,
      name: "navy blue"
    },
    {
      h: 65,
      s: 0.5,
      b: 1,
      name: "light purple"
    },
    {
      h: 65,
      s: 1,
      b: 0.5,
      name: "dark navy blue"
    },
    {
      h: 65,
      s: 1,
      b: 1,
      name: "blue"
    },
    {
      h: 70,
      s: 0,
      b: 1,
      name: "lavender"
    },
    {
      h: 70,
      s: 0.5,
      b: 0.5,
      name: "navy blue"
    },
    {
      h: 70,
      s: 0.5,
      b: 1,
      name: "lavender blue"
    },
    {
      h: 70,
      s: 1,
      b: 0.5,
      name: "dark navy blue"
    },
    {
      h: 70,
      s: 1,
      b: 1,
      name: "blue"
    },
    {
      h: 75,
      s: 0.5,
      b: 1,
      name: "lavender"
    },
    {
      h: 75,
      s: 1,
      b: 0.5,
      name: "dark purple"
    },
    {
      h: 75,
      s: 1,
      b: 1,
      name: "purple"
    },
    {
      h: 80,
      s: 0.5,
      b: 1,
      name: "pinkish purple"
    },
    {
      h: 80,
      s: 1,
      b: 0.5,
      name: "dark purple"
    },
    {
      h: 80,
      s: 1,
      b: 1,
      name: "purple"
    },
    {
      h: 85,
      s: 0,
      b: 1,
      name: "light pink"
    },
    {
      h: 85,
      s: 0.5,
      b: 0.5,
      name: "purple"
    },
    {
      h: 85,
      s: 0.5,
      b: 1,
      name: "light fuchsia"
    },
    {
      h: 85,
      s: 1,
      b: 0.5,
      name: "dark fuchsia"
    },
    {
      h: 85,
      s: 1,
      b: 1,
      name: "fuchsia"
    },
    {
      h: 90,
      s: 0.5,
      b: 0.5,
      name: "dark fuchsia"
    },
    {
      h: 90,
      s: 0.5,
      b: 1,
      name: "hot pink"
    },
    {
      h: 90,
      s: 1,
      b: 0.5,
      name: "dark fuchsia"
    },
    {
      h: 90,
      s: 1,
      b: 1,
      name: "fuchsia"
    },
    {
      h: 95,
      s: 0,
      b: 1,
      name: "pink"
    },
    {
      h: 95,
      s: 0.5,
      b: 1,
      name: "light pink"
    },
    {
      h: 95,
      s: 1,
      b: 0.5,
      name: "dark magenta"
    },
    {
      h: 95,
      s: 1,
      b: 1,
      name: "magenta"
    }
  ];
  function _calculateColor(hsb) {
    let colortext;
    if (hsb[0] !== 0) {
      hsb[0] = Math.round(hsb[0] * 100);
      let hue = hsb[0].toString().split("");
      const last2 = hue.length - 1;
      hue[last2] = parseInt(hue[last2]);
      if (hue[last2] < 2.5) {
        hue[last2] = 0;
      } else if (hue[last2] >= 2.5 && hue[last2] < 7.5) {
        hue[last2] = 5;
      }
      if (hue.length === 2) {
        hue[0] = parseInt(hue[0]);
        if (hue[last2] >= 7.5) {
          hue[last2] = 0;
          hue[0] = hue[0] + 1;
        }
        hsb[0] = hue[0] * 10 + hue[1];
      } else {
        if (hue[last2] >= 7.5) {
          hsb[0] = 10;
        } else {
          hsb[0] = hue[last2];
        }
      }
    }
    hsb[2] = hsb[2] / 255;
    for (let i = hsb.length - 1;i >= 1; i--) {
      if (hsb[i] <= 0.25) {
        hsb[i] = 0;
      } else if (hsb[i] > 0.25 && hsb[i] < 0.75) {
        hsb[i] = 0.5;
      } else {
        hsb[i] = 1;
      }
    }
    if (hsb[0] === 0 && hsb[1] === 0 && hsb[2] === 1) {
      for (let i = 2;i >= 0; i--) {
        originalHSB[i] = Math.round(originalHSB[i] * 1e4) / 1e4;
      }
      for (let e2 = 0;e2 < colorExceptions.length; e2++) {
        if (colorExceptions[e2].h === originalHSB[0] && colorExceptions[e2].s === originalHSB[1] && colorExceptions[e2].b === originalHSB[2]) {
          colortext = colorExceptions[e2].name;
          break;
        } else {
          colortext = "white";
        }
      }
    } else {
      for (let i = 0;i < colorLookUp.length; i++) {
        if (colorLookUp[i].h === hsb[0] && colorLookUp[i].s === hsb[1] && colorLookUp[i].b === hsb[2]) {
          colortext = colorLookUp[i].name;
          break;
        }
      }
    }
    return colortext;
  }
  fn2._rgbColorName = function(arg) {
    let hsb = color_conversion._rgbaToHSBA(arg);
    originalHSB = hsb;
    return _calculateColor([hsb[0], hsb[1], hsb[2]]);
  };
}
if (typeof p5 !== "undefined") {
  colorNamer(p5, p5.prototype);
}

// node_modules/p5/dist/accessibility/index.js
var import_file_saver7 = __toESM(require_FileSaver(), 1);
var import_omggif4 = __toESM(require_omggif(), 1);
var import_gifenc5 = __toESM(require_gifenc(), 1);
var import_libtess5 = __toESM(require_libtess_min(), 1);
function accessibility(p53) {
  p53.registerAddon(describe);
  p53.registerAddon(gridOutput);
  p53.registerAddon(textOutput);
  p53.registerAddon(outputs);
  p53.registerAddon(colorNamer);
}

// node_modules/p5/dist/color/index.js
function color2(p53) {
  p53.registerAddon(creatingReading);
  p53.registerAddon(color);
  p53.registerAddon(setting);
}

// node_modules/@babel/runtime/helpers/esm/typeof.js
function _typeof(o) {
  "@babel/helpers - typeof";
  return _typeof = typeof Symbol == "function" && typeof Symbol.iterator == "symbol" ? function(o2) {
    return typeof o2;
  } : function(o2) {
    return o2 && typeof Symbol == "function" && o2.constructor === Symbol && o2 !== Symbol.prototype ? "symbol" : typeof o2;
  }, _typeof(o);
}

// node_modules/@babel/runtime/helpers/esm/toPrimitive.js
function toPrimitive(t, r) {
  if (_typeof(t) != "object" || !t)
    return t;
  var e2 = t[Symbol.toPrimitive];
  if (e2 !== undefined) {
    var i = e2.call(t, r || "default");
    if (_typeof(i) != "object")
      return i;
    throw new TypeError("@@toPrimitive must return a primitive value.");
  }
  return (r === "string" ? String : Number)(t);
}

// node_modules/@babel/runtime/helpers/esm/toPropertyKey.js
function toPropertyKey(t) {
  var i = toPrimitive(t, "string");
  return _typeof(i) == "symbol" ? i : i + "";
}

// node_modules/@babel/runtime/helpers/esm/defineProperty.js
function _defineProperty(e2, r, t) {
  return (r = toPropertyKey(r)) in e2 ? Object.defineProperty(e2, r, {
    value: t,
    enumerable: true,
    configurable: true,
    writable: true
  }) : e2[r] = t, e2;
}

// node_modules/@babel/runtime/helpers/esm/objectSpread.js
function _objectSpread(e2) {
  for (var r = 1;r < arguments.length; r++) {
    var t = arguments[r] != null ? Object(arguments[r]) : {}, o = Object.keys(t);
    typeof Object.getOwnPropertySymbols == "function" && o.push.apply(o, Object.getOwnPropertySymbols(t).filter(function(e3) {
      return Object.getOwnPropertyDescriptor(t, e3).enumerable;
    })), o.forEach(function(r2) {
      _defineProperty(e2, r2, t[r2]);
    });
  }
  return e2;
}

// node_modules/@babel/runtime/helpers/esm/classCallCheck.js
function _classCallCheck(a, n2) {
  if (!(a instanceof n2))
    throw new TypeError("Cannot call a class as a function");
}

// node_modules/@babel/runtime/helpers/esm/createClass.js
function _defineProperties(e2, r) {
  for (var t = 0;t < r.length; t++) {
    var o = r[t];
    o.enumerable = o.enumerable || false, o.configurable = true, "value" in o && (o.writable = true), Object.defineProperty(e2, toPropertyKey(o.key), o);
  }
}
function _createClass(e2, r, t) {
  return r && _defineProperties(e2.prototype, r), t && _defineProperties(e2, t), Object.defineProperty(e2, "prototype", {
    writable: false
  }), e2;
}

// node_modules/@babel/runtime/helpers/esm/assertThisInitialized.js
function _assertThisInitialized(e2) {
  if (e2 === undefined)
    throw new ReferenceError("this hasn't been initialised - super() hasn't been called");
  return e2;
}

// node_modules/@babel/runtime/helpers/esm/possibleConstructorReturn.js
function _possibleConstructorReturn(t, e2) {
  if (e2 && (_typeof(e2) == "object" || typeof e2 == "function"))
    return e2;
  if (e2 !== undefined)
    throw new TypeError("Derived constructors may only return object or undefined");
  return _assertThisInitialized(t);
}

// node_modules/@babel/runtime/helpers/esm/getPrototypeOf.js
function _getPrototypeOf(t) {
  return _getPrototypeOf = Object.setPrototypeOf ? Object.getPrototypeOf.bind() : function(t2) {
    return t2.__proto__ || Object.getPrototypeOf(t2);
  }, _getPrototypeOf(t);
}

// node_modules/@babel/runtime/helpers/esm/setPrototypeOf.js
function _setPrototypeOf(t, e2) {
  return _setPrototypeOf = Object.setPrototypeOf ? Object.setPrototypeOf.bind() : function(t2, e3) {
    return t2.__proto__ = e3, t2;
  }, _setPrototypeOf(t, e2);
}

// node_modules/@babel/runtime/helpers/esm/inherits.js
function _inherits(t, e2) {
  if (typeof e2 != "function" && e2 !== null)
    throw new TypeError("Super expression must either be null or a function");
  t.prototype = Object.create(e2 && e2.prototype, {
    constructor: {
      value: t,
      writable: true,
      configurable: true
    }
  }), Object.defineProperty(t, "prototype", {
    writable: false
  }), e2 && _setPrototypeOf(t, e2);
}

// node_modules/i18next/dist/esm/i18next.js
var consoleLogger = {
  type: "logger",
  log: function log(args) {
    this.output("log", args);
  },
  warn: function warn2(args) {
    this.output("warn", args);
  },
  error: function error(args) {
    this.output("error", args);
  },
  output: function output(type2, args) {
    if (console && console[type2])
      console[type2].apply(console, args);
  }
};
var Logger = function() {
  function Logger2(concreteLogger) {
    var options2 = arguments.length > 1 && arguments[1] !== undefined ? arguments[1] : {};
    _classCallCheck(this, Logger2);
    this.init(concreteLogger, options2);
  }
  _createClass(Logger2, [{
    key: "init",
    value: function init(concreteLogger) {
      var options2 = arguments.length > 1 && arguments[1] !== undefined ? arguments[1] : {};
      this.prefix = options2.prefix || "i18next:";
      this.logger = concreteLogger || consoleLogger;
      this.options = options2;
      this.debug = options2.debug;
    }
  }, {
    key: "setDebug",
    value: function setDebug(bool) {
      this.debug = bool;
    }
  }, {
    key: "log",
    value: function log() {
      for (var _len = arguments.length, args = new Array(_len), _key = 0;_key < _len; _key++) {
        args[_key] = arguments[_key];
      }
      return this.forward(args, "log", "", true);
    }
  }, {
    key: "warn",
    value: function warn() {
      for (var _len2 = arguments.length, args = new Array(_len2), _key2 = 0;_key2 < _len2; _key2++) {
        args[_key2] = arguments[_key2];
      }
      return this.forward(args, "warn", "", true);
    }
  }, {
    key: "error",
    value: function error() {
      for (var _len3 = arguments.length, args = new Array(_len3), _key3 = 0;_key3 < _len3; _key3++) {
        args[_key3] = arguments[_key3];
      }
      return this.forward(args, "error", "");
    }
  }, {
    key: "deprecate",
    value: function deprecate() {
      for (var _len4 = arguments.length, args = new Array(_len4), _key4 = 0;_key4 < _len4; _key4++) {
        args[_key4] = arguments[_key4];
      }
      return this.forward(args, "warn", "WARNING DEPRECATED: ", true);
    }
  }, {
    key: "forward",
    value: function forward(args, lvl, prefix, debugOnly) {
      if (debugOnly && !this.debug)
        return null;
      if (typeof args[0] === "string")
        args[0] = "".concat(prefix).concat(this.prefix, " ").concat(args[0]);
      return this.logger[lvl](args);
    }
  }, {
    key: "create",
    value: function create(moduleName) {
      return new Logger2(this.logger, _objectSpread({}, {
        prefix: "".concat(this.prefix, ":").concat(moduleName, ":")
      }, this.options));
    }
  }]);
  return Logger2;
}();
var baseLogger = new Logger;
var EventEmitter = function() {
  function EventEmitter2() {
    _classCallCheck(this, EventEmitter2);
    this.observers = {};
  }
  _createClass(EventEmitter2, [{
    key: "on",
    value: function on(events, listener) {
      var _this = this;
      events.split(" ").forEach(function(event) {
        _this.observers[event] = _this.observers[event] || [];
        _this.observers[event].push(listener);
      });
      return this;
    }
  }, {
    key: "off",
    value: function off(event, listener) {
      if (!this.observers[event])
        return;
      if (!listener) {
        delete this.observers[event];
        return;
      }
      this.observers[event] = this.observers[event].filter(function(l) {
        return l !== listener;
      });
    }
  }, {
    key: "emit",
    value: function emit(event) {
      for (var _len = arguments.length, args = new Array(_len > 1 ? _len - 1 : 0), _key = 1;_key < _len; _key++) {
        args[_key - 1] = arguments[_key];
      }
      if (this.observers[event]) {
        var cloned = [].concat(this.observers[event]);
        cloned.forEach(function(observer) {
          observer.apply(undefined, args);
        });
      }
      if (this.observers["*"]) {
        var _cloned = [].concat(this.observers["*"]);
        _cloned.forEach(function(observer) {
          observer.apply(observer, [event].concat(args));
        });
      }
    }
  }]);
  return EventEmitter2;
}();
function defer() {
  var res;
  var rej;
  var promise = new Promise(function(resolve, reject) {
    res = resolve;
    rej = reject;
  });
  promise.resolve = res;
  promise.reject = rej;
  return promise;
}
function makeString(object) {
  if (object == null)
    return "";
  return "" + object;
}
function copy(a, s, t) {
  a.forEach(function(m) {
    if (s[m])
      t[m] = s[m];
  });
}
function getLastOfPath(object, path, Empty) {
  function cleanKey(key2) {
    return key2 && key2.indexOf("###") > -1 ? key2.replace(/###/g, ".") : key2;
  }
  function canNotTraverseDeeper() {
    return !object || typeof object === "string";
  }
  var stack = typeof path !== "string" ? [].concat(path) : path.split(".");
  while (stack.length > 1) {
    if (canNotTraverseDeeper())
      return {};
    var key = cleanKey(stack.shift());
    if (!object[key] && Empty)
      object[key] = new Empty;
    if (Object.prototype.hasOwnProperty.call(object, key)) {
      object = object[key];
    } else {
      object = {};
    }
  }
  if (canNotTraverseDeeper())
    return {};
  return {
    obj: object,
    k: cleanKey(stack.shift())
  };
}
function setPath(object, path, newValue) {
  var _getLastOfPath = getLastOfPath(object, path, Object), obj = _getLastOfPath.obj, k = _getLastOfPath.k;
  obj[k] = newValue;
}
function pushPath(object, path, newValue, concat) {
  var _getLastOfPath2 = getLastOfPath(object, path, Object), obj = _getLastOfPath2.obj, k = _getLastOfPath2.k;
  obj[k] = obj[k] || [];
  if (concat)
    obj[k] = obj[k].concat(newValue);
  if (!concat)
    obj[k].push(newValue);
}
function getPath2(object, path) {
  var _getLastOfPath3 = getLastOfPath(object, path), obj = _getLastOfPath3.obj, k = _getLastOfPath3.k;
  if (!obj)
    return;
  return obj[k];
}
function getPathWithDefaults(data, defaultData, key) {
  var value = getPath2(data, key);
  if (value !== undefined) {
    return value;
  }
  return getPath2(defaultData, key);
}
function deepExtend(target, source, overwrite) {
  for (var prop in source) {
    if (prop !== "__proto__" && prop !== "constructor") {
      if (prop in target) {
        if (typeof target[prop] === "string" || target[prop] instanceof String || typeof source[prop] === "string" || source[prop] instanceof String) {
          if (overwrite)
            target[prop] = source[prop];
        } else {
          deepExtend(target[prop], source[prop], overwrite);
        }
      } else {
        target[prop] = source[prop];
      }
    }
  }
  return target;
}
function regexEscape(str) {
  return str.replace(/[\-\[\]\/\{\}\(\)\*\+\?\.\\\^\$\|]/g, "\\$&");
}
var _entityMap = {
  "&": "&amp;",
  "<": "&lt;",
  ">": "&gt;",
  '"': "&quot;",
  "'": "&#39;",
  "/": "&#x2F;"
};
function escape(data) {
  if (typeof data === "string") {
    return data.replace(/[&<>"'\/]/g, function(s) {
      return _entityMap[s];
    });
  }
  return data;
}
var isIE10 = typeof window !== "undefined" && window.navigator && window.navigator.userAgent && window.navigator.userAgent.indexOf("MSIE") > -1;
var ResourceStore = function(_EventEmitter) {
  _inherits(ResourceStore2, _EventEmitter);
  function ResourceStore2(data) {
    var _this;
    var options2 = arguments.length > 1 && arguments[1] !== undefined ? arguments[1] : {
      ns: ["translation"],
      defaultNS: "translation"
    };
    _classCallCheck(this, ResourceStore2);
    _this = _possibleConstructorReturn(this, _getPrototypeOf(ResourceStore2).call(this));
    if (isIE10) {
      EventEmitter.call(_assertThisInitialized(_this));
    }
    _this.data = data || {};
    _this.options = options2;
    if (_this.options.keySeparator === undefined) {
      _this.options.keySeparator = ".";
    }
    return _this;
  }
  _createClass(ResourceStore2, [{
    key: "addNamespaces",
    value: function addNamespaces(ns) {
      if (this.options.ns.indexOf(ns) < 0) {
        this.options.ns.push(ns);
      }
    }
  }, {
    key: "removeNamespaces",
    value: function removeNamespaces(ns) {
      var index = this.options.ns.indexOf(ns);
      if (index > -1) {
        this.options.ns.splice(index, 1);
      }
    }
  }, {
    key: "getResource",
    value: function getResource(lng, ns, key) {
      var options2 = arguments.length > 3 && arguments[3] !== undefined ? arguments[3] : {};
      var keySeparator = options2.keySeparator !== undefined ? options2.keySeparator : this.options.keySeparator;
      var path = [lng, ns];
      if (key && typeof key !== "string")
        path = path.concat(key);
      if (key && typeof key === "string")
        path = path.concat(keySeparator ? key.split(keySeparator) : key);
      if (lng.indexOf(".") > -1) {
        path = lng.split(".");
      }
      return getPath2(this.data, path);
    }
  }, {
    key: "addResource",
    value: function addResource(lng, ns, key, value) {
      var options2 = arguments.length > 4 && arguments[4] !== undefined ? arguments[4] : {
        silent: false
      };
      var keySeparator = this.options.keySeparator;
      if (keySeparator === undefined)
        keySeparator = ".";
      var path = [lng, ns];
      if (key)
        path = path.concat(keySeparator ? key.split(keySeparator) : key);
      if (lng.indexOf(".") > -1) {
        path = lng.split(".");
        value = ns;
        ns = path[1];
      }
      this.addNamespaces(ns);
      setPath(this.data, path, value);
      if (!options2.silent)
        this.emit("added", lng, ns, key, value);
    }
  }, {
    key: "addResources",
    value: function addResources(lng, ns, resources) {
      var options2 = arguments.length > 3 && arguments[3] !== undefined ? arguments[3] : {
        silent: false
      };
      for (var m in resources) {
        if (typeof resources[m] === "string" || Object.prototype.toString.apply(resources[m]) === "[object Array]")
          this.addResource(lng, ns, m, resources[m], {
            silent: true
          });
      }
      if (!options2.silent)
        this.emit("added", lng, ns, resources);
    }
  }, {
    key: "addResourceBundle",
    value: function addResourceBundle(lng, ns, resources, deep, overwrite) {
      var options2 = arguments.length > 5 && arguments[5] !== undefined ? arguments[5] : {
        silent: false
      };
      var path = [lng, ns];
      if (lng.indexOf(".") > -1) {
        path = lng.split(".");
        deep = resources;
        resources = ns;
        ns = path[1];
      }
      this.addNamespaces(ns);
      var pack = getPath2(this.data, path) || {};
      if (deep) {
        deepExtend(pack, resources, overwrite);
      } else {
        pack = _objectSpread({}, pack, resources);
      }
      setPath(this.data, path, pack);
      if (!options2.silent)
        this.emit("added", lng, ns, resources);
    }
  }, {
    key: "removeResourceBundle",
    value: function removeResourceBundle(lng, ns) {
      if (this.hasResourceBundle(lng, ns)) {
        delete this.data[lng][ns];
      }
      this.removeNamespaces(ns);
      this.emit("removed", lng, ns);
    }
  }, {
    key: "hasResourceBundle",
    value: function hasResourceBundle(lng, ns) {
      return this.getResource(lng, ns) !== undefined;
    }
  }, {
    key: "getResourceBundle",
    value: function getResourceBundle(lng, ns) {
      if (!ns)
        ns = this.options.defaultNS;
      if (this.options.compatibilityAPI === "v1")
        return _objectSpread({}, {}, this.getResource(lng, ns));
      return this.getResource(lng, ns);
    }
  }, {
    key: "getDataByLanguage",
    value: function getDataByLanguage(lng) {
      return this.data[lng];
    }
  }, {
    key: "toJSON",
    value: function toJSON() {
      return this.data;
    }
  }]);
  return ResourceStore2;
}(EventEmitter);
var postProcessor = {
  processors: {},
  addPostProcessor: function addPostProcessor(module) {
    this.processors[module.name] = module;
  },
  handle: function handle(processors, value, key, options2, translator) {
    var _this = this;
    processors.forEach(function(processor) {
      if (_this.processors[processor])
        value = _this.processors[processor].process(value, key, options2, translator);
    });
    return value;
  }
};
var checkedLoadedFor = {};
var Translator = function(_EventEmitter) {
  _inherits(Translator2, _EventEmitter);
  function Translator2(services) {
    var _this;
    var options2 = arguments.length > 1 && arguments[1] !== undefined ? arguments[1] : {};
    _classCallCheck(this, Translator2);
    _this = _possibleConstructorReturn(this, _getPrototypeOf(Translator2).call(this));
    if (isIE10) {
      EventEmitter.call(_assertThisInitialized(_this));
    }
    copy(["resourceStore", "languageUtils", "pluralResolver", "interpolator", "backendConnector", "i18nFormat", "utils"], services, _assertThisInitialized(_this));
    _this.options = options2;
    if (_this.options.keySeparator === undefined) {
      _this.options.keySeparator = ".";
    }
    _this.logger = baseLogger.create("translator");
    return _this;
  }
  _createClass(Translator2, [{
    key: "changeLanguage",
    value: function changeLanguage(lng) {
      if (lng)
        this.language = lng;
    }
  }, {
    key: "exists",
    value: function exists(key) {
      var options2 = arguments.length > 1 && arguments[1] !== undefined ? arguments[1] : {
        interpolation: {}
      };
      var resolved = this.resolve(key, options2);
      return resolved && resolved.res !== undefined;
    }
  }, {
    key: "extractFromKey",
    value: function extractFromKey(key, options2) {
      var nsSeparator = options2.nsSeparator !== undefined ? options2.nsSeparator : this.options.nsSeparator;
      if (nsSeparator === undefined)
        nsSeparator = ":";
      var keySeparator = options2.keySeparator !== undefined ? options2.keySeparator : this.options.keySeparator;
      var namespaces = options2.ns || this.options.defaultNS;
      if (nsSeparator && key.indexOf(nsSeparator) > -1) {
        var m = key.match(this.interpolator.nestingRegexp);
        if (m && m.length > 0) {
          return {
            key,
            namespaces
          };
        }
        var parts = key.split(nsSeparator);
        if (nsSeparator !== keySeparator || nsSeparator === keySeparator && this.options.ns.indexOf(parts[0]) > -1)
          namespaces = parts.shift();
        key = parts.join(keySeparator);
      }
      if (typeof namespaces === "string")
        namespaces = [namespaces];
      return {
        key,
        namespaces
      };
    }
  }, {
    key: "translate",
    value: function translate(keys, options2, lastKey) {
      var _this2 = this;
      if (_typeof(options2) !== "object" && this.options.overloadTranslationOptionHandler) {
        options2 = this.options.overloadTranslationOptionHandler(arguments);
      }
      if (!options2)
        options2 = {};
      if (keys === undefined || keys === null)
        return "";
      if (!Array.isArray(keys))
        keys = [String(keys)];
      var keySeparator = options2.keySeparator !== undefined ? options2.keySeparator : this.options.keySeparator;
      var _this$extractFromKey = this.extractFromKey(keys[keys.length - 1], options2), key = _this$extractFromKey.key, namespaces = _this$extractFromKey.namespaces;
      var namespace = namespaces[namespaces.length - 1];
      var lng = options2.lng || this.language;
      var appendNamespaceToCIMode = options2.appendNamespaceToCIMode || this.options.appendNamespaceToCIMode;
      if (lng && lng.toLowerCase() === "cimode") {
        if (appendNamespaceToCIMode) {
          var nsSeparator = options2.nsSeparator || this.options.nsSeparator;
          return namespace + nsSeparator + key;
        }
        return key;
      }
      var resolved = this.resolve(keys, options2);
      var res = resolved && resolved.res;
      var resUsedKey = resolved && resolved.usedKey || key;
      var resExactUsedKey = resolved && resolved.exactUsedKey || key;
      var resType = Object.prototype.toString.apply(res);
      var noObject = ["[object Number]", "[object Function]", "[object RegExp]"];
      var joinArrays = options2.joinArrays !== undefined ? options2.joinArrays : this.options.joinArrays;
      var handleAsObjectInI18nFormat = !this.i18nFormat || this.i18nFormat.handleAsObject;
      var handleAsObject = typeof res !== "string" && typeof res !== "boolean" && typeof res !== "number";
      if (handleAsObjectInI18nFormat && res && handleAsObject && noObject.indexOf(resType) < 0 && !(typeof joinArrays === "string" && resType === "[object Array]")) {
        if (!options2.returnObjects && !this.options.returnObjects) {
          this.logger.warn("accessing an object - but returnObjects options is not enabled!");
          return this.options.returnedObjectHandler ? this.options.returnedObjectHandler(resUsedKey, res, options2) : "key '".concat(key, " (").concat(this.language, ")' returned an object instead of string.");
        }
        if (keySeparator) {
          var resTypeIsArray = resType === "[object Array]";
          var copy2 = resTypeIsArray ? [] : {};
          var newKeyToUse = resTypeIsArray ? resExactUsedKey : resUsedKey;
          for (var m in res) {
            if (Object.prototype.hasOwnProperty.call(res, m)) {
              var deepKey = "".concat(newKeyToUse).concat(keySeparator).concat(m);
              copy2[m] = this.translate(deepKey, _objectSpread({}, options2, {
                joinArrays: false,
                ns: namespaces
              }));
              if (copy2[m] === deepKey)
                copy2[m] = res[m];
            }
          }
          res = copy2;
        }
      } else if (handleAsObjectInI18nFormat && typeof joinArrays === "string" && resType === "[object Array]") {
        res = res.join(joinArrays);
        if (res)
          res = this.extendTranslation(res, keys, options2, lastKey);
      } else {
        var usedDefault = false;
        var usedKey = false;
        var needsPluralHandling = options2.count !== undefined && typeof options2.count !== "string";
        var hasDefaultValue = Translator2.hasDefaultValue(options2);
        var defaultValueSuffix = needsPluralHandling ? this.pluralResolver.getSuffix(lng, options2.count) : "";
        var defaultValue = options2["defaultValue".concat(defaultValueSuffix)] || options2.defaultValue;
        if (!this.isValidLookup(res) && hasDefaultValue) {
          usedDefault = true;
          res = defaultValue;
        }
        if (!this.isValidLookup(res)) {
          usedKey = true;
          res = key;
        }
        var updateMissing = hasDefaultValue && defaultValue !== res && this.options.updateMissing;
        if (usedKey || usedDefault || updateMissing) {
          this.logger.log(updateMissing ? "updateKey" : "missingKey", lng, namespace, key, updateMissing ? defaultValue : res);
          if (keySeparator) {
            var fk = this.resolve(key, _objectSpread({}, options2, {
              keySeparator: false
            }));
            if (fk && fk.res)
              this.logger.warn("Seems the loaded translations were in flat JSON format instead of nested. Either set keySeparator: false on init or make sure your translations are published in nested format.");
          }
          var lngs = [];
          var fallbackLngs = this.languageUtils.getFallbackCodes(this.options.fallbackLng, options2.lng || this.language);
          if (this.options.saveMissingTo === "fallback" && fallbackLngs && fallbackLngs[0]) {
            for (var i = 0;i < fallbackLngs.length; i++) {
              lngs.push(fallbackLngs[i]);
            }
          } else if (this.options.saveMissingTo === "all") {
            lngs = this.languageUtils.toResolveHierarchy(options2.lng || this.language);
          } else {
            lngs.push(options2.lng || this.language);
          }
          var send = function send(l, k, fallbackValue) {
            if (_this2.options.missingKeyHandler) {
              _this2.options.missingKeyHandler(l, namespace, k, updateMissing ? fallbackValue : res, updateMissing, options2);
            } else if (_this2.backendConnector && _this2.backendConnector.saveMissing) {
              _this2.backendConnector.saveMissing(l, namespace, k, updateMissing ? fallbackValue : res, updateMissing, options2);
            }
            _this2.emit("missingKey", l, namespace, k, res);
          };
          if (this.options.saveMissing) {
            if (this.options.saveMissingPlurals && needsPluralHandling) {
              lngs.forEach(function(language) {
                _this2.pluralResolver.getSuffixes(language).forEach(function(suffix) {
                  send([language], key + suffix, options2["defaultValue".concat(suffix)] || defaultValue);
                });
              });
            } else {
              send(lngs, key, defaultValue);
            }
          }
        }
        res = this.extendTranslation(res, keys, options2, resolved, lastKey);
        if (usedKey && res === key && this.options.appendNamespaceToMissingKey)
          res = "".concat(namespace, ":").concat(key);
        if (usedKey && this.options.parseMissingKeyHandler)
          res = this.options.parseMissingKeyHandler(res);
      }
      return res;
    }
  }, {
    key: "extendTranslation",
    value: function extendTranslation(res, key, options2, resolved, lastKey) {
      var _this3 = this;
      if (this.i18nFormat && this.i18nFormat.parse) {
        res = this.i18nFormat.parse(res, options2, resolved.usedLng, resolved.usedNS, resolved.usedKey, {
          resolved
        });
      } else if (!options2.skipInterpolation) {
        if (options2.interpolation)
          this.interpolator.init(_objectSpread({}, options2, {
            interpolation: _objectSpread({}, this.options.interpolation, options2.interpolation)
          }));
        var skipOnVariables = options2.interpolation && options2.interpolation.skipOnVariables || this.options.interpolation.skipOnVariables;
        var nestBef;
        if (skipOnVariables) {
          var nb = res.match(this.interpolator.nestingRegexp);
          nestBef = nb && nb.length;
        }
        var data = options2.replace && typeof options2.replace !== "string" ? options2.replace : options2;
        if (this.options.interpolation.defaultVariables)
          data = _objectSpread({}, this.options.interpolation.defaultVariables, data);
        res = this.interpolator.interpolate(res, data, options2.lng || this.language, options2);
        if (skipOnVariables) {
          var na = res.match(this.interpolator.nestingRegexp);
          var nestAft = na && na.length;
          if (nestBef < nestAft)
            options2.nest = false;
        }
        if (options2.nest !== false)
          res = this.interpolator.nest(res, function() {
            for (var _len = arguments.length, args = new Array(_len), _key = 0;_key < _len; _key++) {
              args[_key] = arguments[_key];
            }
            if (lastKey && lastKey[0] === args[0] && !options2.context) {
              _this3.logger.warn("It seems you are nesting recursively key: ".concat(args[0], " in key: ").concat(key[0]));
              return null;
            }
            return _this3.translate.apply(_this3, args.concat([key]));
          }, options2);
        if (options2.interpolation)
          this.interpolator.reset();
      }
      var postProcess = options2.postProcess || this.options.postProcess;
      var postProcessorNames = typeof postProcess === "string" ? [postProcess] : postProcess;
      if (res !== undefined && res !== null && postProcessorNames && postProcessorNames.length && options2.applyPostProcessor !== false) {
        res = postProcessor.handle(postProcessorNames, res, key, this.options && this.options.postProcessPassResolved ? _objectSpread({
          i18nResolved: resolved
        }, options2) : options2, this);
      }
      return res;
    }
  }, {
    key: "resolve",
    value: function resolve(keys) {
      var _this4 = this;
      var options2 = arguments.length > 1 && arguments[1] !== undefined ? arguments[1] : {};
      var found;
      var usedKey;
      var exactUsedKey;
      var usedLng;
      var usedNS;
      if (typeof keys === "string")
        keys = [keys];
      keys.forEach(function(k) {
        if (_this4.isValidLookup(found))
          return;
        var extracted = _this4.extractFromKey(k, options2);
        var key = extracted.key;
        usedKey = key;
        var namespaces = extracted.namespaces;
        if (_this4.options.fallbackNS)
          namespaces = namespaces.concat(_this4.options.fallbackNS);
        var needsPluralHandling = options2.count !== undefined && typeof options2.count !== "string";
        var needsContextHandling = options2.context !== undefined && typeof options2.context === "string" && options2.context !== "";
        var codes = options2.lngs ? options2.lngs : _this4.languageUtils.toResolveHierarchy(options2.lng || _this4.language, options2.fallbackLng);
        namespaces.forEach(function(ns) {
          if (_this4.isValidLookup(found))
            return;
          usedNS = ns;
          if (!checkedLoadedFor["".concat(codes[0], "-").concat(ns)] && _this4.utils && _this4.utils.hasLoadedNamespace && !_this4.utils.hasLoadedNamespace(usedNS)) {
            checkedLoadedFor["".concat(codes[0], "-").concat(ns)] = true;
            _this4.logger.warn('key "'.concat(usedKey, '" for languages "').concat(codes.join(", "), `" won't get resolved as namespace "`).concat(usedNS, '" was not yet loaded'), "This means something IS WRONG in your setup. You access the t function before i18next.init / i18next.loadNamespace / i18next.changeLanguage was done. Wait for the callback or Promise to resolve before accessing it!!!");
          }
          codes.forEach(function(code) {
            if (_this4.isValidLookup(found))
              return;
            usedLng = code;
            var finalKey = key;
            var finalKeys = [finalKey];
            if (_this4.i18nFormat && _this4.i18nFormat.addLookupKeys) {
              _this4.i18nFormat.addLookupKeys(finalKeys, key, code, ns, options2);
            } else {
              var pluralSuffix;
              if (needsPluralHandling)
                pluralSuffix = _this4.pluralResolver.getSuffix(code, options2.count);
              if (needsPluralHandling && needsContextHandling)
                finalKeys.push(finalKey + pluralSuffix);
              if (needsContextHandling)
                finalKeys.push(finalKey += "".concat(_this4.options.contextSeparator).concat(options2.context));
              if (needsPluralHandling)
                finalKeys.push(finalKey += pluralSuffix);
            }
            var possibleKey;
            while (possibleKey = finalKeys.pop()) {
              if (!_this4.isValidLookup(found)) {
                exactUsedKey = possibleKey;
                found = _this4.getResource(code, ns, possibleKey, options2);
              }
            }
          });
        });
      });
      return {
        res: found,
        usedKey,
        exactUsedKey,
        usedLng,
        usedNS
      };
    }
  }, {
    key: "isValidLookup",
    value: function isValidLookup(res) {
      return res !== undefined && !(!this.options.returnNull && res === null) && !(!this.options.returnEmptyString && res === "");
    }
  }, {
    key: "getResource",
    value: function getResource(code, ns, key) {
      var options2 = arguments.length > 3 && arguments[3] !== undefined ? arguments[3] : {};
      if (this.i18nFormat && this.i18nFormat.getResource)
        return this.i18nFormat.getResource(code, ns, key, options2);
      return this.resourceStore.getResource(code, ns, key, options2);
    }
  }], [{
    key: "hasDefaultValue",
    value: function hasDefaultValue(options2) {
      var prefix = "defaultValue";
      for (var option in options2) {
        if (Object.prototype.hasOwnProperty.call(options2, option) && prefix === option.substring(0, prefix.length) && options2[option] !== undefined) {
          return true;
        }
      }
      return false;
    }
  }]);
  return Translator2;
}(EventEmitter);
function capitalize(string) {
  return string.charAt(0).toUpperCase() + string.slice(1);
}
var LanguageUtil = function() {
  function LanguageUtil2(options2) {
    _classCallCheck(this, LanguageUtil2);
    this.options = options2;
    this.whitelist = this.options.supportedLngs || false;
    this.supportedLngs = this.options.supportedLngs || false;
    this.logger = baseLogger.create("languageUtils");
  }
  _createClass(LanguageUtil2, [{
    key: "getScriptPartFromCode",
    value: function getScriptPartFromCode(code) {
      if (!code || code.indexOf("-") < 0)
        return null;
      var p2 = code.split("-");
      if (p2.length === 2)
        return null;
      p2.pop();
      if (p2[p2.length - 1].toLowerCase() === "x")
        return null;
      return this.formatLanguageCode(p2.join("-"));
    }
  }, {
    key: "getLanguagePartFromCode",
    value: function getLanguagePartFromCode(code) {
      if (!code || code.indexOf("-") < 0)
        return code;
      var p2 = code.split("-");
      return this.formatLanguageCode(p2[0]);
    }
  }, {
    key: "formatLanguageCode",
    value: function formatLanguageCode(code) {
      if (typeof code === "string" && code.indexOf("-") > -1) {
        var specialCases = ["hans", "hant", "latn", "cyrl", "cans", "mong", "arab"];
        var p2 = code.split("-");
        if (this.options.lowerCaseLng) {
          p2 = p2.map(function(part) {
            return part.toLowerCase();
          });
        } else if (p2.length === 2) {
          p2[0] = p2[0].toLowerCase();
          p2[1] = p2[1].toUpperCase();
          if (specialCases.indexOf(p2[1].toLowerCase()) > -1)
            p2[1] = capitalize(p2[1].toLowerCase());
        } else if (p2.length === 3) {
          p2[0] = p2[0].toLowerCase();
          if (p2[1].length === 2)
            p2[1] = p2[1].toUpperCase();
          if (p2[0] !== "sgn" && p2[2].length === 2)
            p2[2] = p2[2].toUpperCase();
          if (specialCases.indexOf(p2[1].toLowerCase()) > -1)
            p2[1] = capitalize(p2[1].toLowerCase());
          if (specialCases.indexOf(p2[2].toLowerCase()) > -1)
            p2[2] = capitalize(p2[2].toLowerCase());
        }
        return p2.join("-");
      }
      return this.options.cleanCode || this.options.lowerCaseLng ? code.toLowerCase() : code;
    }
  }, {
    key: "isWhitelisted",
    value: function isWhitelisted(code) {
      this.logger.deprecate("languageUtils.isWhitelisted", `function "isWhitelisted" will be renamed to "isSupportedCode" in the next major - please make sure to rename it's usage asap.`);
      return this.isSupportedCode(code);
    }
  }, {
    key: "isSupportedCode",
    value: function isSupportedCode(code) {
      if (this.options.load === "languageOnly" || this.options.nonExplicitSupportedLngs) {
        code = this.getLanguagePartFromCode(code);
      }
      return !this.supportedLngs || !this.supportedLngs.length || this.supportedLngs.indexOf(code) > -1;
    }
  }, {
    key: "getBestMatchFromCodes",
    value: function getBestMatchFromCodes(codes) {
      var _this = this;
      if (!codes)
        return null;
      var found;
      codes.forEach(function(code) {
        if (found)
          return;
        var cleanedLng = _this.formatLanguageCode(code);
        if (!_this.options.supportedLngs || _this.isSupportedCode(cleanedLng))
          found = cleanedLng;
      });
      if (!found && this.options.supportedLngs) {
        codes.forEach(function(code) {
          if (found)
            return;
          var lngOnly = _this.getLanguagePartFromCode(code);
          if (_this.isSupportedCode(lngOnly))
            return found = lngOnly;
          found = _this.options.supportedLngs.find(function(supportedLng) {
            if (supportedLng.indexOf(lngOnly) === 0)
              return supportedLng;
          });
        });
      }
      if (!found)
        found = this.getFallbackCodes(this.options.fallbackLng)[0];
      return found;
    }
  }, {
    key: "getFallbackCodes",
    value: function getFallbackCodes(fallbacks, code) {
      if (!fallbacks)
        return [];
      if (typeof fallbacks === "function")
        fallbacks = fallbacks(code);
      if (typeof fallbacks === "string")
        fallbacks = [fallbacks];
      if (Object.prototype.toString.apply(fallbacks) === "[object Array]")
        return fallbacks;
      if (!code)
        return fallbacks["default"] || [];
      var found = fallbacks[code];
      if (!found)
        found = fallbacks[this.getScriptPartFromCode(code)];
      if (!found)
        found = fallbacks[this.formatLanguageCode(code)];
      if (!found)
        found = fallbacks[this.getLanguagePartFromCode(code)];
      if (!found)
        found = fallbacks["default"];
      return found || [];
    }
  }, {
    key: "toResolveHierarchy",
    value: function toResolveHierarchy(code, fallbackCode) {
      var _this2 = this;
      var fallbackCodes = this.getFallbackCodes(fallbackCode || this.options.fallbackLng || [], code);
      var codes = [];
      var addCode = function addCode(c) {
        if (!c)
          return;
        if (_this2.isSupportedCode(c)) {
          codes.push(c);
        } else {
          _this2.logger.warn("rejecting language code not found in supportedLngs: ".concat(c));
        }
      };
      if (typeof code === "string" && code.indexOf("-") > -1) {
        if (this.options.load !== "languageOnly")
          addCode(this.formatLanguageCode(code));
        if (this.options.load !== "languageOnly" && this.options.load !== "currentOnly")
          addCode(this.getScriptPartFromCode(code));
        if (this.options.load !== "currentOnly")
          addCode(this.getLanguagePartFromCode(code));
      } else if (typeof code === "string") {
        addCode(this.formatLanguageCode(code));
      }
      fallbackCodes.forEach(function(fc) {
        if (codes.indexOf(fc) < 0)
          addCode(_this2.formatLanguageCode(fc));
      });
      return codes;
    }
  }]);
  return LanguageUtil2;
}();
var sets = [{
  lngs: ["ach", "ak", "am", "arn", "br", "fil", "gun", "ln", "mfe", "mg", "mi", "oc", "pt", "pt-BR", "tg", "tl", "ti", "tr", "uz", "wa"],
  nr: [1, 2],
  fc: 1
}, {
  lngs: ["af", "an", "ast", "az", "bg", "bn", "ca", "da", "de", "dev", "el", "en", "eo", "es", "et", "eu", "fi", "fo", "fur", "fy", "gl", "gu", "ha", "hi", "hu", "hy", "ia", "it", "kn", "ku", "lb", "mai", "ml", "mn", "mr", "nah", "nap", "nb", "ne", "nl", "nn", "no", "nso", "pa", "pap", "pms", "ps", "pt-PT", "rm", "sco", "se", "si", "so", "son", "sq", "sv", "sw", "ta", "te", "tk", "ur", "yo"],
  nr: [1, 2],
  fc: 2
}, {
  lngs: ["ay", "bo", "cgg", "fa", "ht", "id", "ja", "jbo", "ka", "kk", "km", "ko", "ky", "lo", "ms", "sah", "su", "th", "tt", "ug", "vi", "wo", "zh"],
  nr: [1],
  fc: 3
}, {
  lngs: ["be", "bs", "cnr", "dz", "hr", "ru", "sr", "uk"],
  nr: [1, 2, 5],
  fc: 4
}, {
  lngs: ["ar"],
  nr: [0, 1, 2, 3, 11, 100],
  fc: 5
}, {
  lngs: ["cs", "sk"],
  nr: [1, 2, 5],
  fc: 6
}, {
  lngs: ["csb", "pl"],
  nr: [1, 2, 5],
  fc: 7
}, {
  lngs: ["cy"],
  nr: [1, 2, 3, 8],
  fc: 8
}, {
  lngs: ["fr"],
  nr: [1, 2],
  fc: 9
}, {
  lngs: ["ga"],
  nr: [1, 2, 3, 7, 11],
  fc: 10
}, {
  lngs: ["gd"],
  nr: [1, 2, 3, 20],
  fc: 11
}, {
  lngs: ["is"],
  nr: [1, 2],
  fc: 12
}, {
  lngs: ["jv"],
  nr: [0, 1],
  fc: 13
}, {
  lngs: ["kw"],
  nr: [1, 2, 3, 4],
  fc: 14
}, {
  lngs: ["lt"],
  nr: [1, 2, 10],
  fc: 15
}, {
  lngs: ["lv"],
  nr: [1, 2, 0],
  fc: 16
}, {
  lngs: ["mk"],
  nr: [1, 2],
  fc: 17
}, {
  lngs: ["mnk"],
  nr: [0, 1, 2],
  fc: 18
}, {
  lngs: ["mt"],
  nr: [1, 2, 11, 20],
  fc: 19
}, {
  lngs: ["or"],
  nr: [2, 1],
  fc: 2
}, {
  lngs: ["ro"],
  nr: [1, 2, 20],
  fc: 20
}, {
  lngs: ["sl"],
  nr: [5, 1, 2, 3],
  fc: 21
}, {
  lngs: ["he", "iw"],
  nr: [1, 2, 20, 21],
  fc: 22
}];
var _rulesPluralsTypes = {
  1: function _(n2) {
    return Number(n2 > 1);
  },
  2: function _2(n2) {
    return Number(n2 != 1);
  },
  3: function _3(n2) {
    return 0;
  },
  4: function _4(n2) {
    return Number(n2 % 10 == 1 && n2 % 100 != 11 ? 0 : n2 % 10 >= 2 && n2 % 10 <= 4 && (n2 % 100 < 10 || n2 % 100 >= 20) ? 1 : 2);
  },
  5: function _5(n2) {
    return Number(n2 == 0 ? 0 : n2 == 1 ? 1 : n2 == 2 ? 2 : n2 % 100 >= 3 && n2 % 100 <= 10 ? 3 : n2 % 100 >= 11 ? 4 : 5);
  },
  6: function _6(n2) {
    return Number(n2 == 1 ? 0 : n2 >= 2 && n2 <= 4 ? 1 : 2);
  },
  7: function _7(n2) {
    return Number(n2 == 1 ? 0 : n2 % 10 >= 2 && n2 % 10 <= 4 && (n2 % 100 < 10 || n2 % 100 >= 20) ? 1 : 2);
  },
  8: function _8(n2) {
    return Number(n2 == 1 ? 0 : n2 == 2 ? 1 : n2 != 8 && n2 != 11 ? 2 : 3);
  },
  9: function _9(n2) {
    return Number(n2 >= 2);
  },
  10: function _10(n2) {
    return Number(n2 == 1 ? 0 : n2 == 2 ? 1 : n2 < 7 ? 2 : n2 < 11 ? 3 : 4);
  },
  11: function _11(n2) {
    return Number(n2 == 1 || n2 == 11 ? 0 : n2 == 2 || n2 == 12 ? 1 : n2 > 2 && n2 < 20 ? 2 : 3);
  },
  12: function _12(n2) {
    return Number(n2 % 10 != 1 || n2 % 100 == 11);
  },
  13: function _13(n2) {
    return Number(n2 !== 0);
  },
  14: function _14(n2) {
    return Number(n2 == 1 ? 0 : n2 == 2 ? 1 : n2 == 3 ? 2 : 3);
  },
  15: function _15(n2) {
    return Number(n2 % 10 == 1 && n2 % 100 != 11 ? 0 : n2 % 10 >= 2 && (n2 % 100 < 10 || n2 % 100 >= 20) ? 1 : 2);
  },
  16: function _16(n2) {
    return Number(n2 % 10 == 1 && n2 % 100 != 11 ? 0 : n2 !== 0 ? 1 : 2);
  },
  17: function _17(n2) {
    return Number(n2 == 1 || n2 % 10 == 1 && n2 % 100 != 11 ? 0 : 1);
  },
  18: function _18(n2) {
    return Number(n2 == 0 ? 0 : n2 == 1 ? 1 : 2);
  },
  19: function _19(n2) {
    return Number(n2 == 1 ? 0 : n2 == 0 || n2 % 100 > 1 && n2 % 100 < 11 ? 1 : n2 % 100 > 10 && n2 % 100 < 20 ? 2 : 3);
  },
  20: function _20(n2) {
    return Number(n2 == 1 ? 0 : n2 == 0 || n2 % 100 > 0 && n2 % 100 < 20 ? 1 : 2);
  },
  21: function _21(n2) {
    return Number(n2 % 100 == 1 ? 1 : n2 % 100 == 2 ? 2 : n2 % 100 == 3 || n2 % 100 == 4 ? 3 : 0);
  },
  22: function _22(n2) {
    return Number(n2 == 1 ? 0 : n2 == 2 ? 1 : (n2 < 0 || n2 > 10) && n2 % 10 == 0 ? 2 : 3);
  }
};
function createRules() {
  var rules = {};
  sets.forEach(function(set2) {
    set2.lngs.forEach(function(l) {
      rules[l] = {
        numbers: set2.nr,
        plurals: _rulesPluralsTypes[set2.fc]
      };
    });
  });
  return rules;
}
var PluralResolver = function() {
  function PluralResolver2(languageUtils) {
    var options2 = arguments.length > 1 && arguments[1] !== undefined ? arguments[1] : {};
    _classCallCheck(this, PluralResolver2);
    this.languageUtils = languageUtils;
    this.options = options2;
    this.logger = baseLogger.create("pluralResolver");
    this.rules = createRules();
  }
  _createClass(PluralResolver2, [{
    key: "addRule",
    value: function addRule(lng, obj) {
      this.rules[lng] = obj;
    }
  }, {
    key: "getRule",
    value: function getRule(code) {
      return this.rules[code] || this.rules[this.languageUtils.getLanguagePartFromCode(code)];
    }
  }, {
    key: "needsPlural",
    value: function needsPlural(code) {
      var rule = this.getRule(code);
      return rule && rule.numbers.length > 1;
    }
  }, {
    key: "getPluralFormsOfKey",
    value: function getPluralFormsOfKey(code, key) {
      return this.getSuffixes(code).map(function(suffix) {
        return key + suffix;
      });
    }
  }, {
    key: "getSuffixes",
    value: function getSuffixes(code) {
      var _this = this;
      var rule = this.getRule(code);
      if (!rule) {
        return [];
      }
      return rule.numbers.map(function(number) {
        return _this.getSuffix(code, number);
      });
    }
  }, {
    key: "getSuffix",
    value: function getSuffix(code, count) {
      var _this2 = this;
      var rule = this.getRule(code);
      if (rule) {
        var idx = rule.noAbs ? rule.plurals(count) : rule.plurals(Math.abs(count));
        var suffix = rule.numbers[idx];
        if (this.options.simplifyPluralSuffix && rule.numbers.length === 2 && rule.numbers[0] === 1) {
          if (suffix === 2) {
            suffix = "plural";
          } else if (suffix === 1) {
            suffix = "";
          }
        }
        var returnSuffix = function returnSuffix() {
          return _this2.options.prepend && suffix.toString() ? _this2.options.prepend + suffix.toString() : suffix.toString();
        };
        if (this.options.compatibilityJSON === "v1") {
          if (suffix === 1)
            return "";
          if (typeof suffix === "number")
            return "_plural_".concat(suffix.toString());
          return returnSuffix();
        } else if (this.options.compatibilityJSON === "v2") {
          return returnSuffix();
        } else if (this.options.simplifyPluralSuffix && rule.numbers.length === 2 && rule.numbers[0] === 1) {
          return returnSuffix();
        }
        return this.options.prepend && idx.toString() ? this.options.prepend + idx.toString() : idx.toString();
      }
      this.logger.warn("no plural rule found for: ".concat(code));
      return "";
    }
  }]);
  return PluralResolver2;
}();
var Interpolator = function() {
  function Interpolator2() {
    var options2 = arguments.length > 0 && arguments[0] !== undefined ? arguments[0] : {};
    _classCallCheck(this, Interpolator2);
    this.logger = baseLogger.create("interpolator");
    this.options = options2;
    this.format = options2.interpolation && options2.interpolation.format || function(value) {
      return value;
    };
    this.init(options2);
  }
  _createClass(Interpolator2, [{
    key: "init",
    value: function init() {
      var options2 = arguments.length > 0 && arguments[0] !== undefined ? arguments[0] : {};
      if (!options2.interpolation)
        options2.interpolation = {
          escapeValue: true
        };
      var iOpts = options2.interpolation;
      this.escape = iOpts.escape !== undefined ? iOpts.escape : escape;
      this.escapeValue = iOpts.escapeValue !== undefined ? iOpts.escapeValue : true;
      this.useRawValueToEscape = iOpts.useRawValueToEscape !== undefined ? iOpts.useRawValueToEscape : false;
      this.prefix = iOpts.prefix ? regexEscape(iOpts.prefix) : iOpts.prefixEscaped || "{{";
      this.suffix = iOpts.suffix ? regexEscape(iOpts.suffix) : iOpts.suffixEscaped || "}}";
      this.formatSeparator = iOpts.formatSeparator ? iOpts.formatSeparator : iOpts.formatSeparator || ",";
      this.unescapePrefix = iOpts.unescapeSuffix ? "" : iOpts.unescapePrefix || "-";
      this.unescapeSuffix = this.unescapePrefix ? "" : iOpts.unescapeSuffix || "";
      this.nestingPrefix = iOpts.nestingPrefix ? regexEscape(iOpts.nestingPrefix) : iOpts.nestingPrefixEscaped || regexEscape("$t(");
      this.nestingSuffix = iOpts.nestingSuffix ? regexEscape(iOpts.nestingSuffix) : iOpts.nestingSuffixEscaped || regexEscape(")");
      this.nestingOptionsSeparator = iOpts.nestingOptionsSeparator ? iOpts.nestingOptionsSeparator : iOpts.nestingOptionsSeparator || ",";
      this.maxReplaces = iOpts.maxReplaces ? iOpts.maxReplaces : 1000;
      this.alwaysFormat = iOpts.alwaysFormat !== undefined ? iOpts.alwaysFormat : false;
      this.resetRegExp();
    }
  }, {
    key: "reset",
    value: function reset() {
      if (this.options)
        this.init(this.options);
    }
  }, {
    key: "resetRegExp",
    value: function resetRegExp() {
      var regexpStr = "".concat(this.prefix, "(.+?)").concat(this.suffix);
      this.regexp = new RegExp(regexpStr, "g");
      var regexpUnescapeStr = "".concat(this.prefix).concat(this.unescapePrefix, "(.+?)").concat(this.unescapeSuffix).concat(this.suffix);
      this.regexpUnescape = new RegExp(regexpUnescapeStr, "g");
      var nestingRegexpStr = "".concat(this.nestingPrefix, "(.+?)").concat(this.nestingSuffix);
      this.nestingRegexp = new RegExp(nestingRegexpStr, "g");
    }
  }, {
    key: "interpolate",
    value: function interpolate(str, data, lng, options2) {
      var _this = this;
      var match;
      var value;
      var replaces;
      var defaultData = this.options && this.options.interpolation && this.options.interpolation.defaultVariables || {};
      function regexSafe(val) {
        return val.replace(/\$/g, "$$$$");
      }
      var handleFormat = function handleFormat(key) {
        if (key.indexOf(_this.formatSeparator) < 0) {
          var path = getPathWithDefaults(data, defaultData, key);
          return _this.alwaysFormat ? _this.format(path, undefined, lng) : path;
        }
        var p2 = key.split(_this.formatSeparator);
        var k = p2.shift().trim();
        var f = p2.join(_this.formatSeparator).trim();
        return _this.format(getPathWithDefaults(data, defaultData, k), f, lng, options2);
      };
      this.resetRegExp();
      var missingInterpolationHandler = options2 && options2.missingInterpolationHandler || this.options.missingInterpolationHandler;
      var skipOnVariables = options2 && options2.interpolation && options2.interpolation.skipOnVariables || this.options.interpolation.skipOnVariables;
      var todos = [{
        regex: this.regexpUnescape,
        safeValue: function safeValue(val) {
          return regexSafe(val);
        }
      }, {
        regex: this.regexp,
        safeValue: function safeValue(val) {
          return _this.escapeValue ? regexSafe(_this.escape(val)) : regexSafe(val);
        }
      }];
      todos.forEach(function(todo) {
        replaces = 0;
        while (match = todo.regex.exec(str)) {
          value = handleFormat(match[1].trim());
          if (value === undefined) {
            if (typeof missingInterpolationHandler === "function") {
              var temp = missingInterpolationHandler(str, match, options2);
              value = typeof temp === "string" ? temp : "";
            } else if (skipOnVariables) {
              value = match[0];
              continue;
            } else {
              _this.logger.warn("missed to pass in variable ".concat(match[1], " for interpolating ").concat(str));
              value = "";
            }
          } else if (typeof value !== "string" && !_this.useRawValueToEscape) {
            value = makeString(value);
          }
          str = str.replace(match[0], todo.safeValue(value));
          todo.regex.lastIndex = 0;
          replaces++;
          if (replaces >= _this.maxReplaces) {
            break;
          }
        }
      });
      return str;
    }
  }, {
    key: "nest",
    value: function nest(str, fc) {
      var _this2 = this;
      var options2 = arguments.length > 2 && arguments[2] !== undefined ? arguments[2] : {};
      var match;
      var value;
      var clonedOptions = _objectSpread({}, options2);
      clonedOptions.applyPostProcessor = false;
      delete clonedOptions.defaultValue;
      function handleHasOptions(key, inheritedOptions) {
        var sep = this.nestingOptionsSeparator;
        if (key.indexOf(sep) < 0)
          return key;
        var c = key.split(new RegExp("".concat(sep, "[ ]*{")));
        var optionsString = "{".concat(c[1]);
        key = c[0];
        optionsString = this.interpolate(optionsString, clonedOptions);
        optionsString = optionsString.replace(/'/g, '"');
        try {
          clonedOptions = JSON.parse(optionsString);
          if (inheritedOptions)
            clonedOptions = _objectSpread({}, inheritedOptions, clonedOptions);
        } catch (e2) {
          this.logger.warn("failed parsing options string in nesting for key ".concat(key), e2);
          return "".concat(key).concat(sep).concat(optionsString);
        }
        delete clonedOptions.defaultValue;
        return key;
      }
      while (match = this.nestingRegexp.exec(str)) {
        var formatters = [];
        var doReduce = false;
        if (match[0].includes(this.formatSeparator) && !/{.*}/.test(match[1])) {
          var r = match[1].split(this.formatSeparator).map(function(elem) {
            return elem.trim();
          });
          match[1] = r.shift();
          formatters = r;
          doReduce = true;
        }
        value = fc(handleHasOptions.call(this, match[1].trim(), clonedOptions), clonedOptions);
        if (value && match[0] === str && typeof value !== "string")
          return value;
        if (typeof value !== "string")
          value = makeString(value);
        if (!value) {
          this.logger.warn("missed to resolve ".concat(match[1], " for nesting ").concat(str));
          value = "";
        }
        if (doReduce) {
          value = formatters.reduce(function(v, f) {
            return _this2.format(v, f, options2.lng, options2);
          }, value.trim());
        }
        str = str.replace(match[0], value);
        this.regexp.lastIndex = 0;
      }
      return str;
    }
  }]);
  return Interpolator2;
}();
function remove(arr, what) {
  var found = arr.indexOf(what);
  while (found !== -1) {
    arr.splice(found, 1);
    found = arr.indexOf(what);
  }
}
var Connector = function(_EventEmitter) {
  _inherits(Connector2, _EventEmitter);
  function Connector2(backend, store, services) {
    var _this;
    var options2 = arguments.length > 3 && arguments[3] !== undefined ? arguments[3] : {};
    _classCallCheck(this, Connector2);
    _this = _possibleConstructorReturn(this, _getPrototypeOf(Connector2).call(this));
    if (isIE10) {
      EventEmitter.call(_assertThisInitialized(_this));
    }
    _this.backend = backend;
    _this.store = store;
    _this.services = services;
    _this.languageUtils = services.languageUtils;
    _this.options = options2;
    _this.logger = baseLogger.create("backendConnector");
    _this.state = {};
    _this.queue = [];
    if (_this.backend && _this.backend.init) {
      _this.backend.init(services, options2.backend, options2);
    }
    return _this;
  }
  _createClass(Connector2, [{
    key: "queueLoad",
    value: function queueLoad(languages, namespaces, options2, callback) {
      var _this2 = this;
      var toLoad = [];
      var pending = [];
      var toLoadLanguages = [];
      var toLoadNamespaces = [];
      languages.forEach(function(lng) {
        var hasAllNamespaces = true;
        namespaces.forEach(function(ns) {
          var name = "".concat(lng, "|").concat(ns);
          if (!options2.reload && _this2.store.hasResourceBundle(lng, ns)) {
            _this2.state[name] = 2;
          } else if (_this2.state[name] < 0)
            ;
          else if (_this2.state[name] === 1) {
            if (pending.indexOf(name) < 0)
              pending.push(name);
          } else {
            _this2.state[name] = 1;
            hasAllNamespaces = false;
            if (pending.indexOf(name) < 0)
              pending.push(name);
            if (toLoad.indexOf(name) < 0)
              toLoad.push(name);
            if (toLoadNamespaces.indexOf(ns) < 0)
              toLoadNamespaces.push(ns);
          }
        });
        if (!hasAllNamespaces)
          toLoadLanguages.push(lng);
      });
      if (toLoad.length || pending.length) {
        this.queue.push({
          pending,
          loaded: {},
          errors: [],
          callback
        });
      }
      return {
        toLoad,
        pending,
        toLoadLanguages,
        toLoadNamespaces
      };
    }
  }, {
    key: "loaded",
    value: function loaded(name, err, data) {
      var s = name.split("|");
      var lng = s[0];
      var ns = s[1];
      if (err)
        this.emit("failedLoading", lng, ns, err);
      if (data) {
        this.store.addResourceBundle(lng, ns, data);
      }
      this.state[name] = err ? -1 : 2;
      var loaded = {};
      this.queue.forEach(function(q) {
        pushPath(q.loaded, [lng], ns);
        remove(q.pending, name);
        if (err)
          q.errors.push(err);
        if (q.pending.length === 0 && !q.done) {
          Object.keys(q.loaded).forEach(function(l) {
            if (!loaded[l])
              loaded[l] = [];
            if (q.loaded[l].length) {
              q.loaded[l].forEach(function(ns2) {
                if (loaded[l].indexOf(ns2) < 0)
                  loaded[l].push(ns2);
              });
            }
          });
          q.done = true;
          if (q.errors.length) {
            q.callback(q.errors);
          } else {
            q.callback();
          }
        }
      });
      this.emit("loaded", loaded);
      this.queue = this.queue.filter(function(q) {
        return !q.done;
      });
    }
  }, {
    key: "read",
    value: function read(lng, ns, fcName) {
      var _this3 = this;
      var tried = arguments.length > 3 && arguments[3] !== undefined ? arguments[3] : 0;
      var wait = arguments.length > 4 && arguments[4] !== undefined ? arguments[4] : 350;
      var callback = arguments.length > 5 ? arguments[5] : undefined;
      if (!lng.length)
        return callback(null, {});
      return this.backend[fcName](lng, ns, function(err, data) {
        if (err && data && tried < 5) {
          setTimeout(function() {
            _this3.read.call(_this3, lng, ns, fcName, tried + 1, wait * 2, callback);
          }, wait);
          return;
        }
        callback(err, data);
      });
    }
  }, {
    key: "prepareLoading",
    value: function prepareLoading(languages, namespaces) {
      var _this4 = this;
      var options2 = arguments.length > 2 && arguments[2] !== undefined ? arguments[2] : {};
      var callback = arguments.length > 3 ? arguments[3] : undefined;
      if (!this.backend) {
        this.logger.warn("No backend was added via i18next.use. Will not load resources.");
        return callback && callback();
      }
      if (typeof languages === "string")
        languages = this.languageUtils.toResolveHierarchy(languages);
      if (typeof namespaces === "string")
        namespaces = [namespaces];
      var toLoad = this.queueLoad(languages, namespaces, options2, callback);
      if (!toLoad.toLoad.length) {
        if (!toLoad.pending.length)
          callback();
        return null;
      }
      toLoad.toLoad.forEach(function(name) {
        _this4.loadOne(name);
      });
    }
  }, {
    key: "load",
    value: function load(languages, namespaces, callback) {
      this.prepareLoading(languages, namespaces, {}, callback);
    }
  }, {
    key: "reload",
    value: function reload(languages, namespaces, callback) {
      this.prepareLoading(languages, namespaces, {
        reload: true
      }, callback);
    }
  }, {
    key: "loadOne",
    value: function loadOne(name) {
      var _this5 = this;
      var prefix = arguments.length > 1 && arguments[1] !== undefined ? arguments[1] : "";
      var s = name.split("|");
      var lng = s[0];
      var ns = s[1];
      this.read(lng, ns, "read", undefined, undefined, function(err, data) {
        if (err)
          _this5.logger.warn("".concat(prefix, "loading namespace ").concat(ns, " for language ").concat(lng, " failed"), err);
        if (!err && data)
          _this5.logger.log("".concat(prefix, "loaded namespace ").concat(ns, " for language ").concat(lng), data);
        _this5.loaded(name, err, data);
      });
    }
  }, {
    key: "saveMissing",
    value: function saveMissing(languages, namespace, key, fallbackValue, isUpdate) {
      var options2 = arguments.length > 5 && arguments[5] !== undefined ? arguments[5] : {};
      if (this.services.utils && this.services.utils.hasLoadedNamespace && !this.services.utils.hasLoadedNamespace(namespace)) {
        this.logger.warn('did not save key "'.concat(key, '" as the namespace "').concat(namespace, '" was not yet loaded'), "This means something IS WRONG in your setup. You access the t function before i18next.init / i18next.loadNamespace / i18next.changeLanguage was done. Wait for the callback or Promise to resolve before accessing it!!!");
        return;
      }
      if (key === undefined || key === null || key === "")
        return;
      if (this.backend && this.backend.create) {
        this.backend.create(languages, namespace, key, fallbackValue, null, _objectSpread({}, options2, {
          isUpdate
        }));
      }
      if (!languages || !languages[0])
        return;
      this.store.addResource(languages[0], namespace, key, fallbackValue);
    }
  }]);
  return Connector2;
}(EventEmitter);
function get2() {
  return {
    debug: false,
    initImmediate: true,
    ns: ["translation"],
    defaultNS: ["translation"],
    fallbackLng: ["dev"],
    fallbackNS: false,
    whitelist: false,
    nonExplicitWhitelist: false,
    supportedLngs: false,
    nonExplicitSupportedLngs: false,
    load: "all",
    preload: false,
    simplifyPluralSuffix: true,
    keySeparator: ".",
    nsSeparator: ":",
    pluralSeparator: "_",
    contextSeparator: "_",
    partialBundledLanguages: false,
    saveMissing: false,
    updateMissing: false,
    saveMissingTo: "fallback",
    saveMissingPlurals: true,
    missingKeyHandler: false,
    missingInterpolationHandler: false,
    postProcess: false,
    postProcessPassResolved: false,
    returnNull: true,
    returnEmptyString: true,
    returnObjects: false,
    joinArrays: false,
    returnedObjectHandler: false,
    parseMissingKeyHandler: false,
    appendNamespaceToMissingKey: false,
    appendNamespaceToCIMode: false,
    overloadTranslationOptionHandler: function handle(args) {
      var ret = {};
      if (_typeof(args[1]) === "object")
        ret = args[1];
      if (typeof args[1] === "string")
        ret.defaultValue = args[1];
      if (typeof args[2] === "string")
        ret.tDescription = args[2];
      if (_typeof(args[2]) === "object" || _typeof(args[3]) === "object") {
        var options2 = args[3] || args[2];
        Object.keys(options2).forEach(function(key) {
          ret[key] = options2[key];
        });
      }
      return ret;
    },
    interpolation: {
      escapeValue: true,
      format: function format(value, _format, lng, options2) {
        return value;
      },
      prefix: "{{",
      suffix: "}}",
      formatSeparator: ",",
      unescapePrefix: "-",
      nestingPrefix: "$t(",
      nestingSuffix: ")",
      nestingOptionsSeparator: ",",
      maxReplaces: 1000,
      skipOnVariables: false
    }
  };
}
function transformOptions(options2) {
  if (typeof options2.ns === "string")
    options2.ns = [options2.ns];
  if (typeof options2.fallbackLng === "string")
    options2.fallbackLng = [options2.fallbackLng];
  if (typeof options2.fallbackNS === "string")
    options2.fallbackNS = [options2.fallbackNS];
  if (options2.whitelist) {
    if (options2.whitelist && options2.whitelist.indexOf("cimode") < 0) {
      options2.whitelist = options2.whitelist.concat(["cimode"]);
    }
    options2.supportedLngs = options2.whitelist;
  }
  if (options2.nonExplicitWhitelist) {
    options2.nonExplicitSupportedLngs = options2.nonExplicitWhitelist;
  }
  if (options2.supportedLngs && options2.supportedLngs.indexOf("cimode") < 0) {
    options2.supportedLngs = options2.supportedLngs.concat(["cimode"]);
  }
  return options2;
}
function noop() {}
var I18n = function(_EventEmitter) {
  _inherits(I18n2, _EventEmitter);
  function I18n2() {
    var _this;
    var options2 = arguments.length > 0 && arguments[0] !== undefined ? arguments[0] : {};
    var callback = arguments.length > 1 ? arguments[1] : undefined;
    _classCallCheck(this, I18n2);
    _this = _possibleConstructorReturn(this, _getPrototypeOf(I18n2).call(this));
    if (isIE10) {
      EventEmitter.call(_assertThisInitialized(_this));
    }
    _this.options = transformOptions(options2);
    _this.services = {};
    _this.logger = baseLogger;
    _this.modules = {
      external: []
    };
    if (callback && !_this.isInitialized && !options2.isClone) {
      if (!_this.options.initImmediate) {
        _this.init(options2, callback);
        return _possibleConstructorReturn(_this, _assertThisInitialized(_this));
      }
      setTimeout(function() {
        _this.init(options2, callback);
      }, 0);
    }
    return _this;
  }
  _createClass(I18n2, [{
    key: "init",
    value: function init() {
      var _this2 = this;
      var options2 = arguments.length > 0 && arguments[0] !== undefined ? arguments[0] : {};
      var callback = arguments.length > 1 ? arguments[1] : undefined;
      if (typeof options2 === "function") {
        callback = options2;
        options2 = {};
      }
      if (options2.whitelist && !options2.supportedLngs) {
        this.logger.deprecate("whitelist", 'option "whitelist" will be renamed to "supportedLngs" in the next major - please make sure to rename this option asap.');
      }
      if (options2.nonExplicitWhitelist && !options2.nonExplicitSupportedLngs) {
        this.logger.deprecate("whitelist", 'options "nonExplicitWhitelist" will be renamed to "nonExplicitSupportedLngs" in the next major - please make sure to rename this option asap.');
      }
      this.options = _objectSpread({}, get2(), this.options, transformOptions(options2));
      this.format = this.options.interpolation.format;
      if (!callback)
        callback = noop;
      function createClassOnDemand(ClassOrObject) {
        if (!ClassOrObject)
          return null;
        if (typeof ClassOrObject === "function")
          return new ClassOrObject;
        return ClassOrObject;
      }
      if (!this.options.isClone) {
        if (this.modules.logger) {
          baseLogger.init(createClassOnDemand(this.modules.logger), this.options);
        } else {
          baseLogger.init(null, this.options);
        }
        var lu = new LanguageUtil(this.options);
        this.store = new ResourceStore(this.options.resources, this.options);
        var s = this.services;
        s.logger = baseLogger;
        s.resourceStore = this.store;
        s.languageUtils = lu;
        s.pluralResolver = new PluralResolver(lu, {
          prepend: this.options.pluralSeparator,
          compatibilityJSON: this.options.compatibilityJSON,
          simplifyPluralSuffix: this.options.simplifyPluralSuffix
        });
        s.interpolator = new Interpolator(this.options);
        s.utils = {
          hasLoadedNamespace: this.hasLoadedNamespace.bind(this)
        };
        s.backendConnector = new Connector(createClassOnDemand(this.modules.backend), s.resourceStore, s, this.options);
        s.backendConnector.on("*", function(event) {
          for (var _len = arguments.length, args = new Array(_len > 1 ? _len - 1 : 0), _key = 1;_key < _len; _key++) {
            args[_key - 1] = arguments[_key];
          }
          _this2.emit.apply(_this2, [event].concat(args));
        });
        if (this.modules.languageDetector) {
          s.languageDetector = createClassOnDemand(this.modules.languageDetector);
          s.languageDetector.init(s, this.options.detection, this.options);
        }
        if (this.modules.i18nFormat) {
          s.i18nFormat = createClassOnDemand(this.modules.i18nFormat);
          if (s.i18nFormat.init)
            s.i18nFormat.init(this);
        }
        this.translator = new Translator(this.services, this.options);
        this.translator.on("*", function(event) {
          for (var _len2 = arguments.length, args = new Array(_len2 > 1 ? _len2 - 1 : 0), _key2 = 1;_key2 < _len2; _key2++) {
            args[_key2 - 1] = arguments[_key2];
          }
          _this2.emit.apply(_this2, [event].concat(args));
        });
        this.modules.external.forEach(function(m) {
          if (m.init)
            m.init(_this2);
        });
      }
      if (this.options.fallbackLng && !this.services.languageDetector && !this.options.lng) {
        var codes = this.services.languageUtils.getFallbackCodes(this.options.fallbackLng);
        if (codes.length > 0 && codes[0] !== "dev")
          this.options.lng = codes[0];
      }
      if (!this.services.languageDetector && !this.options.lng) {
        this.logger.warn("init: no languageDetector is used and no lng is defined");
      }
      var storeApi = ["getResource", "hasResourceBundle", "getResourceBundle", "getDataByLanguage"];
      storeApi.forEach(function(fcName) {
        _this2[fcName] = function() {
          var _this2$store;
          return (_this2$store = _this2.store)[fcName].apply(_this2$store, arguments);
        };
      });
      var storeApiChained = ["addResource", "addResources", "addResourceBundle", "removeResourceBundle"];
      storeApiChained.forEach(function(fcName) {
        _this2[fcName] = function() {
          var _this2$store2;
          (_this2$store2 = _this2.store)[fcName].apply(_this2$store2, arguments);
          return _this2;
        };
      });
      var deferred = defer();
      var load = function load() {
        var finish = function finish(err, t) {
          if (_this2.isInitialized)
            _this2.logger.warn("init: i18next is already initialized. You should call init just once!");
          _this2.isInitialized = true;
          if (!_this2.options.isClone)
            _this2.logger.log("initialized", _this2.options);
          _this2.emit("initialized", _this2.options);
          deferred.resolve(t);
          callback(err, t);
        };
        if (_this2.languages && _this2.options.compatibilityAPI !== "v1" && !_this2.isInitialized)
          return finish(null, _this2.t.bind(_this2));
        _this2.changeLanguage(_this2.options.lng, finish);
      };
      if (this.options.resources || !this.options.initImmediate) {
        load();
      } else {
        setTimeout(load, 0);
      }
      return deferred;
    }
  }, {
    key: "loadResources",
    value: function loadResources(language) {
      var _this3 = this;
      var callback = arguments.length > 1 && arguments[1] !== undefined ? arguments[1] : noop;
      var usedCallback = callback;
      var usedLng = typeof language === "string" ? language : this.language;
      if (typeof language === "function")
        usedCallback = language;
      if (!this.options.resources || this.options.partialBundledLanguages) {
        if (usedLng && usedLng.toLowerCase() === "cimode")
          return usedCallback();
        var toLoad = [];
        var append = function append(lng) {
          if (!lng)
            return;
          var lngs = _this3.services.languageUtils.toResolveHierarchy(lng);
          lngs.forEach(function(l) {
            if (toLoad.indexOf(l) < 0)
              toLoad.push(l);
          });
        };
        if (!usedLng) {
          var fallbacks = this.services.languageUtils.getFallbackCodes(this.options.fallbackLng);
          fallbacks.forEach(function(l) {
            return append(l);
          });
        } else {
          append(usedLng);
        }
        if (this.options.preload) {
          this.options.preload.forEach(function(l) {
            return append(l);
          });
        }
        this.services.backendConnector.load(toLoad, this.options.ns, usedCallback);
      } else {
        usedCallback(null);
      }
    }
  }, {
    key: "reloadResources",
    value: function reloadResources(lngs, ns, callback) {
      var deferred = defer();
      if (!lngs)
        lngs = this.languages;
      if (!ns)
        ns = this.options.ns;
      if (!callback)
        callback = noop;
      this.services.backendConnector.reload(lngs, ns, function(err) {
        deferred.resolve();
        callback(err);
      });
      return deferred;
    }
  }, {
    key: "use",
    value: function use(module) {
      if (!module)
        throw new Error("You are passing an undefined module! Please check the object you are passing to i18next.use()");
      if (!module.type)
        throw new Error("You are passing a wrong module! Please check the object you are passing to i18next.use()");
      if (module.type === "backend") {
        this.modules.backend = module;
      }
      if (module.type === "logger" || module.log && module.warn && module.error) {
        this.modules.logger = module;
      }
      if (module.type === "languageDetector") {
        this.modules.languageDetector = module;
      }
      if (module.type === "i18nFormat") {
        this.modules.i18nFormat = module;
      }
      if (module.type === "postProcessor") {
        postProcessor.addPostProcessor(module);
      }
      if (module.type === "3rdParty") {
        this.modules.external.push(module);
      }
      return this;
    }
  }, {
    key: "changeLanguage",
    value: function changeLanguage(lng, callback) {
      var _this4 = this;
      this.isLanguageChangingTo = lng;
      var deferred = defer();
      this.emit("languageChanging", lng);
      var done = function done(err, l) {
        if (l) {
          _this4.language = l;
          _this4.languages = _this4.services.languageUtils.toResolveHierarchy(l);
          _this4.translator.changeLanguage(l);
          _this4.isLanguageChangingTo = undefined;
          _this4.emit("languageChanged", l);
          _this4.logger.log("languageChanged", l);
        } else {
          _this4.isLanguageChangingTo = undefined;
        }
        deferred.resolve(function() {
          return _this4.t.apply(_this4, arguments);
        });
        if (callback)
          callback(err, function() {
            return _this4.t.apply(_this4, arguments);
          });
      };
      var setLng = function setLng(lngs) {
        var l = typeof lngs === "string" ? lngs : _this4.services.languageUtils.getBestMatchFromCodes(lngs);
        if (l) {
          if (!_this4.language) {
            _this4.language = l;
            _this4.languages = _this4.services.languageUtils.toResolveHierarchy(l);
          }
          if (!_this4.translator.language)
            _this4.translator.changeLanguage(l);
          if (_this4.services.languageDetector)
            _this4.services.languageDetector.cacheUserLanguage(l);
        }
        _this4.loadResources(l, function(err) {
          done(err, l);
        });
      };
      if (!lng && this.services.languageDetector && !this.services.languageDetector.async) {
        setLng(this.services.languageDetector.detect());
      } else if (!lng && this.services.languageDetector && this.services.languageDetector.async) {
        this.services.languageDetector.detect(setLng);
      } else {
        setLng(lng);
      }
      return deferred;
    }
  }, {
    key: "getFixedT",
    value: function getFixedT(lng, ns) {
      var _this5 = this;
      var fixedT = function fixedT(key, opts) {
        var options2;
        if (_typeof(opts) !== "object") {
          for (var _len3 = arguments.length, rest = new Array(_len3 > 2 ? _len3 - 2 : 0), _key3 = 2;_key3 < _len3; _key3++) {
            rest[_key3 - 2] = arguments[_key3];
          }
          options2 = _this5.options.overloadTranslationOptionHandler([key, opts].concat(rest));
        } else {
          options2 = _objectSpread({}, opts);
        }
        options2.lng = options2.lng || fixedT.lng;
        options2.lngs = options2.lngs || fixedT.lngs;
        options2.ns = options2.ns || fixedT.ns;
        return _this5.t(key, options2);
      };
      if (typeof lng === "string") {
        fixedT.lng = lng;
      } else {
        fixedT.lngs = lng;
      }
      fixedT.ns = ns;
      return fixedT;
    }
  }, {
    key: "t",
    value: function t() {
      var _this$translator;
      return this.translator && (_this$translator = this.translator).translate.apply(_this$translator, arguments);
    }
  }, {
    key: "exists",
    value: function exists() {
      var _this$translator2;
      return this.translator && (_this$translator2 = this.translator).exists.apply(_this$translator2, arguments);
    }
  }, {
    key: "setDefaultNamespace",
    value: function setDefaultNamespace(ns) {
      this.options.defaultNS = ns;
    }
  }, {
    key: "hasLoadedNamespace",
    value: function hasLoadedNamespace(ns) {
      var _this6 = this;
      var options2 = arguments.length > 1 && arguments[1] !== undefined ? arguments[1] : {};
      if (!this.isInitialized) {
        this.logger.warn("hasLoadedNamespace: i18next was not initialized", this.languages);
        return false;
      }
      if (!this.languages || !this.languages.length) {
        this.logger.warn("hasLoadedNamespace: i18n.languages were undefined or empty", this.languages);
        return false;
      }
      var lng = this.languages[0];
      var fallbackLng = this.options ? this.options.fallbackLng : false;
      var lastLng = this.languages[this.languages.length - 1];
      if (lng.toLowerCase() === "cimode")
        return true;
      var loadNotPending = function loadNotPending(l, n2) {
        var loadState = _this6.services.backendConnector.state["".concat(l, "|").concat(n2)];
        return loadState === -1 || loadState === 2;
      };
      if (options2.precheck) {
        var preResult = options2.precheck(this, loadNotPending);
        if (preResult !== undefined)
          return preResult;
      }
      if (this.hasResourceBundle(lng, ns))
        return true;
      if (!this.services.backendConnector.backend)
        return true;
      if (loadNotPending(lng, ns) && (!fallbackLng || loadNotPending(lastLng, ns)))
        return true;
      return false;
    }
  }, {
    key: "loadNamespaces",
    value: function loadNamespaces(ns, callback) {
      var _this7 = this;
      var deferred = defer();
      if (!this.options.ns) {
        callback && callback();
        return Promise.resolve();
      }
      if (typeof ns === "string")
        ns = [ns];
      ns.forEach(function(n2) {
        if (_this7.options.ns.indexOf(n2) < 0)
          _this7.options.ns.push(n2);
      });
      this.loadResources(function(err) {
        deferred.resolve();
        if (callback)
          callback(err);
      });
      return deferred;
    }
  }, {
    key: "loadLanguages",
    value: function loadLanguages(lngs, callback) {
      var deferred = defer();
      if (typeof lngs === "string")
        lngs = [lngs];
      var preloaded = this.options.preload || [];
      var newLngs = lngs.filter(function(lng) {
        return preloaded.indexOf(lng) < 0;
      });
      if (!newLngs.length) {
        if (callback)
          callback();
        return Promise.resolve();
      }
      this.options.preload = preloaded.concat(newLngs);
      this.loadResources(function(err) {
        deferred.resolve();
        if (callback)
          callback(err);
      });
      return deferred;
    }
  }, {
    key: "dir",
    value: function dir(lng) {
      if (!lng)
        lng = this.languages && this.languages.length > 0 ? this.languages[0] : this.language;
      if (!lng)
        return "rtl";
      var rtlLngs = ["ar", "shu", "sqr", "ssh", "xaa", "yhd", "yud", "aao", "abh", "abv", "acm", "acq", "acw", "acx", "acy", "adf", "ads", "aeb", "aec", "afb", "ajp", "apc", "apd", "arb", "arq", "ars", "ary", "arz", "auz", "avl", "ayh", "ayl", "ayn", "ayp", "bbz", "pga", "he", "iw", "ps", "pbt", "pbu", "pst", "prp", "prd", "ug", "ur", "ydd", "yds", "yih", "ji", "yi", "hbo", "men", "xmn", "fa", "jpr", "peo", "pes", "prs", "dv", "sam"];
      return rtlLngs.indexOf(this.services.languageUtils.getLanguagePartFromCode(lng)) >= 0 ? "rtl" : "ltr";
    }
  }, {
    key: "createInstance",
    value: function createInstance() {
      var options2 = arguments.length > 0 && arguments[0] !== undefined ? arguments[0] : {};
      var callback = arguments.length > 1 ? arguments[1] : undefined;
      return new I18n2(options2, callback);
    }
  }, {
    key: "cloneInstance",
    value: function cloneInstance() {
      var _this8 = this;
      var options2 = arguments.length > 0 && arguments[0] !== undefined ? arguments[0] : {};
      var callback = arguments.length > 1 && arguments[1] !== undefined ? arguments[1] : noop;
      var mergedOptions = _objectSpread({}, this.options, options2, {
        isClone: true
      });
      var clone2 = new I18n2(mergedOptions);
      var membersToCopy = ["store", "services", "language"];
      membersToCopy.forEach(function(m) {
        clone2[m] = _this8[m];
      });
      clone2.services = _objectSpread({}, this.services);
      clone2.services.utils = {
        hasLoadedNamespace: clone2.hasLoadedNamespace.bind(clone2)
      };
      clone2.translator = new Translator(clone2.services, clone2.options);
      clone2.translator.on("*", function(event) {
        for (var _len4 = arguments.length, args = new Array(_len4 > 1 ? _len4 - 1 : 0), _key4 = 1;_key4 < _len4; _key4++) {
          args[_key4 - 1] = arguments[_key4];
        }
        clone2.emit.apply(clone2, [event].concat(args));
      });
      clone2.init(mergedOptions, callback);
      clone2.translator.options = clone2.options;
      clone2.translator.backendConnector.services.utils = {
        hasLoadedNamespace: clone2.hasLoadedNamespace.bind(clone2)
      };
      return clone2;
    }
  }]);
  return I18n2;
}(EventEmitter);
var i18next = new I18n;
var i18next_default = i18next;

// node_modules/i18next-browser-languagedetector/dist/esm/i18nextBrowserLanguageDetector.js
var arr = [];
var each = arr.forEach;
var slice = arr.slice;
function defaults(obj) {
  each.call(slice.call(arguments, 1), function(source) {
    if (source) {
      for (var prop in source) {
        if (obj[prop] === undefined)
          obj[prop] = source[prop];
      }
    }
  });
  return obj;
}
var cookie = {
  create: function create(name, value, minutes, domain) {
    var cookieOptions = arguments.length > 4 && arguments[4] !== undefined ? arguments[4] : {
      path: "/"
    };
    var expires;
    if (minutes) {
      var date = new Date;
      date.setTime(date.getTime() + minutes * 60 * 1000);
      expires = "; expires=" + date.toUTCString();
    } else
      expires = "";
    domain = domain ? "domain=" + domain + ";" : "";
    cookieOptions = Object.keys(cookieOptions).reduce(function(acc, key) {
      return acc + ";" + key.replace(/([A-Z])/g, function($1) {
        return "-" + $1.toLowerCase();
      }) + "=" + cookieOptions[key];
    }, "");
    document.cookie = name + "=" + encodeURIComponent(value) + expires + ";" + domain + cookieOptions;
  },
  read: function read(name) {
    var nameEQ = name + "=";
    var ca = document.cookie.split(";");
    for (var i = 0;i < ca.length; i++) {
      var c = ca[i];
      while (c.charAt(0) === " ") {
        c = c.substring(1, c.length);
      }
      if (c.indexOf(nameEQ) === 0)
        return c.substring(nameEQ.length, c.length);
    }
    return null;
  },
  remove: function remove2(name) {
    this.create(name, "", -1);
  }
};
var cookie$1 = {
  name: "cookie",
  lookup: function lookup(options2) {
    var found;
    if (options2.lookupCookie && typeof document !== "undefined") {
      var c = cookie.read(options2.lookupCookie);
      if (c)
        found = c;
    }
    return found;
  },
  cacheUserLanguage: function cacheUserLanguage(lng, options2) {
    if (options2.lookupCookie && typeof document !== "undefined") {
      cookie.create(options2.lookupCookie, lng, options2.cookieMinutes, options2.cookieDomain, options2.cookieOptions);
    }
  }
};
var querystring = {
  name: "querystring",
  lookup: function lookup2(options2) {
    var found;
    if (typeof window !== "undefined") {
      var query = window.location.search.substring(1);
      var params = query.split("&");
      for (var i = 0;i < params.length; i++) {
        var pos = params[i].indexOf("=");
        if (pos > 0) {
          var key = params[i].substring(0, pos);
          if (key === options2.lookupQuerystring) {
            found = params[i].substring(pos + 1);
          }
        }
      }
    }
    return found;
  }
};
var hasLocalStorageSupport;
try {
  hasLocalStorageSupport = window !== "undefined" && window.localStorage !== null;
  testKey = "i18next.translate.boo";
  window.localStorage.setItem(testKey, "foo");
  window.localStorage.removeItem(testKey);
} catch (e2) {
  hasLocalStorageSupport = false;
}
var testKey;
var localStorage2 = {
  name: "localStorage",
  lookup: function lookup3(options2) {
    var found;
    if (options2.lookupLocalStorage && hasLocalStorageSupport) {
      var lng = window.localStorage.getItem(options2.lookupLocalStorage);
      if (lng)
        found = lng;
    }
    return found;
  },
  cacheUserLanguage: function cacheUserLanguage2(lng, options2) {
    if (options2.lookupLocalStorage && hasLocalStorageSupport) {
      window.localStorage.setItem(options2.lookupLocalStorage, lng);
    }
  }
};
var hasSessionStorageSupport;
try {
  hasSessionStorageSupport = window !== "undefined" && window.sessionStorage !== null;
  testKey$1 = "i18next.translate.boo";
  window.sessionStorage.setItem(testKey$1, "foo");
  window.sessionStorage.removeItem(testKey$1);
} catch (e2) {
  hasSessionStorageSupport = false;
}
var testKey$1;
var sessionStorage = {
  name: "sessionStorage",
  lookup: function lookup4(options2) {
    var found;
    if (options2.lookupsessionStorage && hasSessionStorageSupport) {
      var lng = window.sessionStorage.getItem(options2.lookupsessionStorage);
      if (lng)
        found = lng;
    }
    return found;
  },
  cacheUserLanguage: function cacheUserLanguage3(lng, options2) {
    if (options2.lookupsessionStorage && hasSessionStorageSupport) {
      window.sessionStorage.setItem(options2.lookupsessionStorage, lng);
    }
  }
};
var navigator$1 = {
  name: "navigator",
  lookup: function lookup5(options2) {
    var found = [];
    if (typeof navigator !== "undefined") {
      if (navigator.languages) {
        for (var i = 0;i < navigator.languages.length; i++) {
          found.push(navigator.languages[i]);
        }
      }
      if (navigator.userLanguage) {
        found.push(navigator.userLanguage);
      }
      if (navigator.language) {
        found.push(navigator.language);
      }
    }
    return found.length > 0 ? found : undefined;
  }
};
var htmlTag = {
  name: "htmlTag",
  lookup: function lookup6(options2) {
    var found;
    var htmlTag2 = options2.htmlTag || (typeof document !== "undefined" ? document.documentElement : null);
    if (htmlTag2 && typeof htmlTag2.getAttribute === "function") {
      found = htmlTag2.getAttribute("lang");
    }
    return found;
  }
};
var path = {
  name: "path",
  lookup: function lookup7(options2) {
    var found;
    if (typeof window !== "undefined") {
      var language = window.location.pathname.match(/\/([a-zA-Z-]*)/g);
      if (language instanceof Array) {
        if (typeof options2.lookupFromPathIndex === "number") {
          if (typeof language[options2.lookupFromPathIndex] !== "string") {
            return;
          }
          found = language[options2.lookupFromPathIndex].replace("/", "");
        } else {
          found = language[0].replace("/", "");
        }
      }
    }
    return found;
  }
};
var subdomain = {
  name: "subdomain",
  lookup: function lookup8(options2) {
    var found;
    if (typeof window !== "undefined") {
      var language = window.location.href.match(/(?:http[s]*\:\/\/)*(.*?)\.(?=[^\/]*\..{2,5})/gi);
      if (language instanceof Array) {
        if (typeof options2.lookupFromSubdomainIndex === "number") {
          found = language[options2.lookupFromSubdomainIndex].replace("http://", "").replace("https://", "").replace(".", "");
        } else {
          found = language[0].replace("http://", "").replace("https://", "").replace(".", "");
        }
      }
    }
    return found;
  }
};
function getDefaults() {
  return {
    order: ["querystring", "cookie", "localStorage", "sessionStorage", "navigator", "htmlTag"],
    lookupQuerystring: "lng",
    lookupCookie: "i18next",
    lookupLocalStorage: "i18nextLng",
    caches: ["localStorage"],
    excludeCacheFor: ["cimode"],
    checkWhitelist: true,
    checkForSimilarInWhitelist: false
  };
}
var Browser = /* @__PURE__ */ function() {
  function Browser2(services) {
    var options2 = arguments.length > 1 && arguments[1] !== undefined ? arguments[1] : {};
    _classCallCheck(this, Browser2);
    this.type = "languageDetector";
    this.detectors = {};
    this.init(services, options2);
  }
  _createClass(Browser2, [{
    key: "init",
    value: function init(services) {
      var options2 = arguments.length > 1 && arguments[1] !== undefined ? arguments[1] : {};
      var i18nOptions = arguments.length > 2 && arguments[2] !== undefined ? arguments[2] : {};
      this.services = services;
      this.options = defaults(options2, this.options || {}, getDefaults());
      if (this.options.checkForSimilarInWhitelist)
        this.options.checkWhitelist = true;
      if (this.options.lookupFromUrlIndex)
        this.options.lookupFromPathIndex = this.options.lookupFromUrlIndex;
      this.i18nOptions = i18nOptions;
      this.addDetector(cookie$1);
      this.addDetector(querystring);
      this.addDetector(localStorage2);
      this.addDetector(sessionStorage);
      this.addDetector(navigator$1);
      this.addDetector(htmlTag);
      this.addDetector(path);
      this.addDetector(subdomain);
    }
  }, {
    key: "addDetector",
    value: function addDetector(detector) {
      this.detectors[detector.name] = detector;
    }
  }, {
    key: "detect",
    value: function detect(detectionOrder) {
      var _this = this;
      if (!detectionOrder)
        detectionOrder = this.options.order;
      var detected = [];
      detectionOrder.forEach(function(detectorName) {
        if (_this.detectors[detectorName]) {
          var lookup9 = _this.detectors[detectorName].lookup(_this.options);
          if (lookup9 && typeof lookup9 === "string")
            lookup9 = [lookup9];
          if (lookup9)
            detected = detected.concat(lookup9);
        }
      });
      var found;
      detected.forEach(function(lng) {
        if (found)
          return;
        var cleanedLng = _this.services.languageUtils.formatLanguageCode(lng);
        if (!_this.options.checkWhitelist || _this.services.languageUtils.isWhitelisted(cleanedLng))
          found = cleanedLng;
        if (!found && _this.options.checkForSimilarInWhitelist) {
          found = _this.getSimilarInWhitelist(cleanedLng);
        }
      });
      if (!found) {
        var fallbacks = this.i18nOptions.fallbackLng;
        if (typeof fallbacks === "string")
          fallbacks = [fallbacks];
        if (!fallbacks)
          fallbacks = [];
        if (Object.prototype.toString.apply(fallbacks) === "[object Array]") {
          found = fallbacks[0];
        } else {
          found = fallbacks[0] || fallbacks["default"] && fallbacks["default"][0];
        }
      }
      return found;
    }
  }, {
    key: "cacheUserLanguage",
    value: function cacheUserLanguage(lng, caches) {
      var _this2 = this;
      if (!caches)
        caches = this.options.caches;
      if (!caches)
        return;
      if (this.options.excludeCacheFor && this.options.excludeCacheFor.indexOf(lng) > -1)
        return;
      caches.forEach(function(cacheName) {
        if (_this2.detectors[cacheName])
          _this2.detectors[cacheName].cacheUserLanguage(lng, _this2.options);
      });
    }
  }, {
    key: "getSimilarInWhitelist",
    value: function getSimilarInWhitelist(cleanedLng) {
      var _this3 = this;
      if (!this.i18nOptions.whitelist)
        return;
      if (cleanedLng.includes("-")) {
        var prefix = cleanedLng.split("-")[0];
        var cleanedPrefix = this.services.languageUtils.formatLanguageCode(prefix);
        if (this.services.languageUtils.isWhitelisted(cleanedPrefix))
          return cleanedPrefix;
        cleanedLng = cleanedPrefix;
      }
      var similar = this.i18nOptions.whitelist.find(function(whitelistLng) {
        var cleanedWhitelistLng = _this3.services.languageUtils.formatLanguageCode(whitelistLng);
        if (cleanedWhitelistLng.startsWith(cleanedLng))
          return cleanedWhitelistLng;
      });
      if (similar)
        return similar;
    }
  }]);
  return Browser2;
}();
Browser.type = "languageDetector";
var i18nextBrowserLanguageDetector_default = Browser;

// node_modules/p5/dist/core/internationalization.js
var fes = {
  autoplay: `The media that tried to play (with '{{src}}') wasn't allowed to by this browser, most likely due to the browser's autoplay policy.

+ More info: {{url}}`,
  checkUserDefinedFns: "It seems that you may have accidentally written {{name}} instead of {{actualName}}. Please correct it if it's not intentional.",
  fileLoadError: {
    bytes: "It looks like there was a problem loading your file. {{suggestion}}",
    font: "It looks like there was a problem loading your font. {{suggestion}}",
    gif: "There was some trouble loading your GIF. Make sure that your GIF is using 87a or 89a encoding.",
    image: "It looks like there was a problem loading your image. {{suggestion}}",
    json: "It looks like there was a problem loading your JSON file. {{suggestion}}",
    large: "If your large file isn't fetched successfully, we recommend splitting the file into smaller segments and fetching those.",
    strings: "It looks like there was a problem loading your text file. {{suggestion}}",
    suggestion: `Try checking if the file path ({{filePath}}) is correct, hosting the file online, or running a local server.

+ More info: {{url}}`,
    table: "It looks like there was a problem loading your table file. {{suggestion}}",
    xml: "It looks like there was a problem loading your XML file. {{suggestion}}"
  },
  friendlyParamError: {
    type_EMPTY_VAR: `{{location}} {{func}}() was expecting {{formatType}} for the {{position}} parameter, received an empty variable instead. If not intentional, this is often a problem with scope.

+ More info: {{url}}`,
    type_TOO_FEW_ARGUMENTS: "{{location}} {{func}}() was expecting at least {{minParams}} arguments, but received only {{argCount}}.",
    type_TOO_MANY_ARGUMENTS: "{{location}} {{func}}() was expecting no more than {{maxParams}} arguments, but received {{argCount}}.",
    type_WRONG_TYPE: "{{location}} {{func}}() was expecting {{formatType}} for the {{position}} parameter, received {{argType}} instead."
  },
  globalErrors: {
    reference: {
      cannotAccess: `
{{location}} "{{symbol}}" is used before declaration. Make sure you have declared the variable before using it.

+ More info: {{url}}`,
      notDefined: `
{{location}} "{{symbol}}" is not defined in the current scope. If you have defined it in your code, you should check its scope, spelling, and letter-casing (JavaScript is case-sensitive).

+ More info: {{url}}`
    },
    stackSubseq: `[{{location}}] 
	 Called from line {{line}} in {{func}}()
`,
    stackTop: `[{{location}}] 
	 Error at line {{line}} in {{func}}()
`,
    syntax: {
      badReturnOrYield: `
Syntax Error - return lies outside of a function. Make sure youre not missing any brackets, so that return lies inside a function.

+ More info: {{url}}`,
      invalidToken: `
Syntax Error - Found a symbol that JavaScript doesn't recognize or didn't expect at it's place.

+ More info: {{url}}`,
      missingInitializer: `
Syntax Error - A const variable is declared but not initialized. In JavaScript, an initializer for a const is required. A value must be specified in the same statement in which the variable is declared. Check the line number in the error and assign the const variable a value.

+ More info: {{url}}`,
      redeclaredVariable: `
Syntax Error - "{{symbol}}" is being redeclared. JavaScript doesn't allow declaring a variable more than once. Check the line number in error for redeclaration of the variable.

+ More info: {{url}}`,
      unexpectedToken: `
Syntax Error - Symbol present at a place that wasn't expected.
Usually this is due to a typo. Check the line number in the error for anything missing/extra.

+ More info: {{url}}`
    },
    type: {
      constAssign: `
{{location}} A const variable is being re-assigned. In javascript, re-assigning a value to a constant is not allowed. If you want to re-assign new values to a variable, make sure it is declared as var or let.

+ More info: {{url}}`,
      notfunc: `
{{location}} "{{symbol}}" could not be called as a function.
Check the spelling, letter-casing (JavaScript is case-sensitive) and its type.

+ More info: {{url}}`,
      notfuncObj: `
{{location}} "{{symbol}}" could not be called as a function.
Verify whether "{{obj}}" has "{{symbol}}" in it and check the spelling, letter-casing (JavaScript is case-sensitive) and its type.

+ More info: {{url}}`,
      readFromNull: `
{{location}} The property of null can't be read. In javascript the value null indicates that an object has no value.

+ More info: {{url}}`,
      readFromUndefined: `
{{location}} Cannot read property of undefined. Check the line number in error and make sure the variable which is being operated is not undefined.

 + More info: {{url}}`
    }
  },
  libraryError: '{{location}} An error with message "{{error}}" occurred inside the p5js library when {{func}} was called. If not stated otherwise, it might be an issue with the arguments passed to {{func}}.',
  location: "[{{file}}, line {{line}}]",
  misspelling: '{{location}} It seems that you may have accidentally written "{{name}}" instead of "{{actualName}}". Please correct it to {{actualName}} if you wish to use the {{type}} from p5.js.',
  misspelling_plural: `{{location}} It seems that you may have accidentally written "{{name}}".
You may have meant one of the following: 
{{suggestions}}`,
  misusedTopLevel: `Did you just try to use p5.js's {{symbolName}} {{symbolType}}? If so, you may want to move it into your sketch's setup() function.

+ More info: {{url}}`,
  preloadDisabled: "The preload() function has been removed in p5.js 2.0. Please load assets in setup() using async / await keywords or callbacks instead. See https://github.com/processing/p5.js-compatibility for more information about 2.0 and compatibility, or https://dev.to/limzykenneth/asynchronous-p5js-20-458f for more information about promises and async/await.",
  positions: {
    p_1: "first",
    p_10: "tenth",
    p_11: "eleventh",
    p_12: "twelfth",
    p_2: "second",
    p_3: "third",
    p_4: "fourth",
    p_5: "fifth",
    p_6: "sixth",
    p_7: "seventh",
    p_8: "eighth",
    p_9: "ninth"
  },
  pre: `
\uD83C\uDF38 p5.js says: {{message}}`,
  sketchReaderErrors: {
    reservedConst: `you have used a p5.js reserved variable "{{symbol}}" make sure you change the variable name to something else.

+ More info: {{url}}`,
    reservedFunc: `you have used a p5.js reserved function "{{symbol}}" make sure you change the function name to something else.

+ More info: {{url}}`
  },
  welcome: "Welcome! This is your friendly debugger. To turn me off, switch to using p5.min.js.",
  wrongPreload: '{{location}} An error with message "{{error}}" occurred inside the p5js library when "{{func}}" was called. If not stated otherwise, it might be due to "{{func}}" being called from preload. Nothing besides load calls (loadImage, loadJSON, loadFont, loadStrings, etc.) should be inside the preload function.'
};
var en = {
  fes
};
var fallbackResources = {
  en: {
    translation: en
  }
};
var languages = [
  "en",
  "es",
  "ko",
  "zh",
  "hi",
  "ja"
];
if (typeof IS_MINIFIED === "undefined") {
  if (typeof P5_DEV_BUILD !== "undefined") {
    let completeResources = (init_dev(), __toCommonJS(exports_dev));
    for (const language of Object.keys(completeResources)) {
      const parts = language.split("_");
      const lng = parts.slice(0, parts.length - 1).join("-");
      const ns = parts[parts.length - 1];
      fallbackResources[lng] = fallbackResources[lng] || {};
      fallbackResources[lng][ns] = completeResources[language];
    }
  }
}

class FetchResources {
  constructor(services, options2) {
    this.init(services, options2);
  }
  fetchWithTimeout(url, options2, timeout = 2000) {
    return Promise.race([
      fetch(url, options2),
      new Promise((_23, reject) => setTimeout(() => reject(new Error("timeout")), timeout))
    ]);
  }
  init(services, options2 = {}) {
    this.services = services;
    this.options = options2;
  }
  read(language, namespace, callback) {
    const loadPath = this.options.loadPath;
    if (language === this.options.fallback) {
      callback(null, fallbackResources[language][namespace]);
    } else if (languages.includes(language)) {
      const url = this.services.interpolator.interpolate(loadPath, {
        lng: language,
        ns: namespace
      });
      this.loadUrl(url, callback);
    } else {
      callback("Not found", false);
    }
  }
  loadUrl(url, callback) {
    this.fetchWithTimeout(url).then((response) => {
      const ok = response.ok;
      if (!ok) {
        throw new Error(`failed loading ${url}`);
      }
      return response.json();
    }, () => {
      throw new Error(`failed loading ${url}`);
    }).then((data) => {
      return callback(null, data);
    }).catch(callback);
  }
}
FetchResources.type = "backend";
var translator = (key, values) => {
  console.debug("p5.js translator called before translations were loaded");
  i18next_default.t(key, values);
};
var initialize = () => {
  let i18init = i18next_default.use(i18nextBrowserLanguageDetector_default).use(FetchResources).init({
    fallbackLng: "en",
    nestingPrefix: "$tr(",
    nestingSuffix: ")",
    defaultNS: "translation",
    returnEmptyString: false,
    interpolation: {
      escapeValue: false
    },
    detection: {
      checkWhitelist: false,
      order: ["querystring", "navigator", "htmlTag", "path", "subdomain"],
      caches: []
    },
    backend: {
      fallback: "en",
      loadPath: `https://cdn.jsdelivr.net/npm/p5@${VERSION.replace(/^(\d+\.\d+)\.\d+.*$/, "$1")}/translations/{{lng}}/{{ns}}.json`
    },
    partialBundledLanguages: true,
    resources: fallbackResources
  }).then((translateFn) => {
    translator = translateFn;
  }, (e2) => console.debug(`Translations failed to load (${e2})`));
  return i18init;
};

// node_modules/p5/dist/core/friendly_errors/browser_errors.js
var strings = {
  ReferenceError: [
    {
      msg: "{{}} is not defined",
      type: "NOTDEFINED",
      browser: "all"
    },
    {
      msg: "Can't find variable: {{}}",
      type: "NOTDEFINED",
      browser: "Safari"
    },
    {
      msg: "Cannot access '{{.}}' before initialization",
      type: "CANNOTACCESS",
      browser: "Chrome"
    },
    {
      msg: "can't access lexical declaration '{{.}}' before initialization",
      type: "CANNOTACCESS",
      browser: "Firefox"
    }
  ],
  SyntaxError: [
    {
      msg: "illegal character",
      type: "INVALIDTOKEN",
      browser: "Firefox"
    },
    {
      msg: "Invalid character",
      type: "INVALIDTOKEN",
      browser: "Safari"
    },
    {
      msg: "Invalid or unexpected token",
      type: "INVALIDTOKEN",
      browser: "Chrome"
    },
    {
      msg: "Unexpected token '{{.}}'",
      type: "UNEXPECTEDTOKEN",
      browser: "Chrome"
    },
    {
      msg: "expected {{.}}, got '{{.}}'",
      type: "UNEXPECTEDTOKEN",
      browser: "Chrome"
    },
    {
      msg: "Identifier '{{.}}' has already been declared",
      type: "REDECLAREDVARIABLE",
      browser: "Chrome"
    },
    {
      msg: "redeclaration of {} {{.}}",
      type: "REDECLAREDVARIABLE",
      browser: "Firefox"
    },
    {
      msg: "Missing initializer in const declaration",
      type: "MISSINGINITIALIZER",
      browser: "Chrome"
    },
    {
      msg: "missing = in const declaration",
      type: "MISSINGINITIALIZER",
      browser: "Firefox"
    },
    {
      msg: "Illegal return statement",
      type: "BADRETURNORYIELD",
      browser: "Chrome"
    },
    {
      msg: "return not in function",
      type: "BADRETURNORYIELD",
      browser: "Firefox"
    }
  ],
  TypeError: [
    {
      msg: "{{.}} is not a function",
      type: "NOTFUNC",
      browser: "all"
    },
    {
      msg: "Cannot read {{.}} null",
      type: "READNULL",
      browser: "Chrome"
    },
    {
      msg: "{{.}} is null",
      type: "READNULL",
      browser: "Firefox"
    },
    {
      msg: "Cannot read {{.}} undefined",
      type: "READUDEFINED",
      browser: "Chrome"
    },
    {
      msg: "{{.}} is undefined",
      type: "READUDEFINED",
      browser: "Firefox"
    },
    {
      msg: "Assignment to constant variable",
      type: "CONSTASSIGN",
      browser: "Chrome"
    },
    {
      msg: "invalid assignment to const '{{.}}'",
      type: "CONSTASSIGN",
      browser: "Firefox"
    }
  ]
};

// node_modules/p5/dist/core/friendly_errors/fes_core.js
function fesCore(p53, fn2) {
  const typeColors = ["#2D7BB6", "#EE9900", "#4DB200", "#C83C00"];
  let misusedAtTopLevelCode = null;
  let defineMisusedAtTopLevelCode = null;
  const EDIT_DIST_THRESHOLD = 2;

  class FESError extends Error {
  }
  if (typeof IS_MINIFIED !== "undefined") {
    p53._friendlyError = p53._checkForUserDefinedFunctions = p53._fesErrorMonitor = () => {};
  } else {
    const class2type = {};
    const toString = class2type.toString;
    const names = [
      "Boolean",
      "Number",
      "String",
      "Function",
      "Array",
      "Date",
      "RegExp",
      "Object",
      "Error"
    ];
    for (let n2 = 0;n2 < names.length; n2++) {
      class2type[`[object ${names[n2]}]`] = names[n2].toLowerCase();
    }
    const getType = (obj) => {
      if (obj == null) {
        return `${obj}`;
      }
      return typeof obj === "object" || typeof obj === "function" ? class2type[toString.call(obj)] || "object" : typeof obj;
    };
    const entryPoints = [
      "setup",
      "draw",
      "deviceMoved",
      "deviceTurned",
      "deviceShaken",
      "doubleClicked",
      "mousePressed",
      "mouseReleased",
      "mouseMoved",
      "mouseDragged",
      "mouseClicked",
      "mouseWheel",
      "touchStarted",
      "touchMoved",
      "touchEnded",
      "keyPressed",
      "keyReleased",
      "keyTyped",
      "windowResized"
    ];
    const mapToReference = (message, func) => {
      let msgWithReference = "";
      if (func == null || func.substring(0, 4) === "load") {
        msgWithReference = message;
      } else {
        const methodParts = func.split(".");
        const referenceSection = methodParts.length > 1 ? `${methodParts[0]}.${methodParts[1]}` : "p5";
        const funcName = methodParts.length === 1 ? func : methodParts.slice(2).join("/");
        funcName.startsWith("p5.") ? msgWithReference = `${message} (https://p5js.org/reference/${referenceSection}.${funcName})` : msgWithReference = `${message} (https://p5js.org/reference/${referenceSection}/${funcName})`;
      }
      return msgWithReference;
    };
    p53._report = (message, func, color3) => {
      const log2 = p53._fesLogger == null ? console.log.bind(console) : p53._fesLogger;
      if (getType(color3) === "undefined") {
        color3 = "#B40033";
      } else if (getType(color3) === "number") {
        color3 = typeColors[color3];
      }
      message = mapToReference(message, func);
      const prefixedMsg = translator("fes.pre", { message });
      {
        log2(prefixedMsg);
      }
    };
    p53._error = (context, message, func) => {
      p53._report(message, func);
      context.hitCriticalError = true;
      throw new FESError("Stopping sketch to prevent more errors");
    };
    p53._friendlyError = function(message, func, color3) {
      if (p53.disableFriendlyErrors)
        return;
      p53._report(message, func, color3);
    };
    p53._friendlyAutoplayError = function(src) {
      const message = translator("fes.autoplay", {
        src,
        url: "https://developer.mozilla.org/docs/Web/Media/Autoplay_guide"
      });
      console.log(translator("fes.pre", { message }));
    };
    const computeEditDistance = (w1, w2) => {
      const l1 = w1.length, l2 = w2.length;
      if (l1 === 0)
        return w2;
      if (l2 === 0)
        return w1;
      let prev = [];
      let cur = [];
      for (let j = 0;j < l2 + 1; j++) {
        cur[j] = j;
      }
      prev = cur;
      for (let i = 1;i < l1 + 1; i++) {
        cur = [];
        for (let j = 0;j < l2 + 1; j++) {
          if (j === 0) {
            cur[j] = i;
          } else {
            let a1 = w1[i - 1], a2 = w2[j - 1];
            let temp = 999999;
            let cost = a1.toLowerCase() === a2.toLowerCase() ? 0 : 1;
            temp = temp > cost + prev[j - 1] ? cost + prev[j - 1] : temp;
            temp = temp > 1 + cur[j - 1] ? 1 + cur[j - 1] : temp;
            temp = temp > 1 + prev[j] ? 1 + prev[j] : temp;
            cur[j] = temp;
          }
        }
        prev = cur;
      }
      return cur[l2];
    };
    p53.isPreloadSupported = function() {
      return false;
    };
    const checkForUserDefinedFunctions = (context) => {
      if (p53.disableFriendlyErrors)
        return;
      const instanceMode = context instanceof p53;
      context = instanceMode ? context : window;
      const fnNames = entryPoints;
      if (context.preload && !p53.isPreloadSupported()) {
        p53._error(context, translator("fes.preloadDisabled"));
      }
      const fxns = {};
      fnNames.forEach((symbol) => {
        fxns[symbol.toLowerCase()] = symbol;
      });
      for (const prop of Object.keys(context)) {
        const lowercase = prop.toLowerCase();
        if (fxns.hasOwnProperty(lowercase) && !context[fxns[lowercase]] && typeof context[prop] === "function") {
          const msg = translator("fes.checkUserDefinedFns", {
            name: prop,
            actualName: fxns[lowercase]
          });
          p53._friendlyError(msg, fxns[lowercase]);
        }
      }
    };
    const handleMisspelling = (errSym, error2) => {
      if (!misusedAtTopLevelCode) {
        defineMisusedAtTopLevelCode();
      }
      const distanceMap = {};
      let min = 999999;
      misusedAtTopLevelCode.forEach((symbol) => {
        let dist = computeEditDistance(errSym, symbol.name);
        if (distanceMap[dist])
          distanceMap[dist].push(symbol);
        else
          distanceMap[dist] = [symbol];
        if (dist < min)
          min = dist;
      });
      if (min > Math.min(EDIT_DIST_THRESHOLD, errSym.length))
        return false;
      const matchedSymbols = distanceMap[min].filter((symbol) => symbol.name !== errSym);
      if (matchedSymbols.length !== 0) {
        const parsed = p53._getErrorStackParser().parse(error2);
        let locationObj;
        if (parsed && parsed[0] && parsed[0].fileName && parsed[0].lineNumber && parsed[0].columnNumber) {
          locationObj = {
            location: `${parsed[0].fileName}:${parsed[0].lineNumber}:${parsed[0].columnNumber}`,
            file: parsed[0].fileName.split("/").slice(-1),
            line: parsed[0].lineNumber
          };
        }
        let msg;
        if (matchedSymbols.length === 1) {
          msg = translator("fes.misspelling", {
            name: errSym,
            actualName: matchedSymbols[0].name,
            type: matchedSymbols[0].type,
            location: locationObj ? translator("fes.location", locationObj) : "",
            count: matchedSymbols.length
          });
        } else {
          const suggestions = matchedSymbols.map((symbol) => {
            const message = " " + symbol.name + (symbol.type === "function" ? "()" : "");
            return mapToReference(message, symbol.name);
          }).join(`
`);
          msg = translator("fes.misspelling", {
            name: errSym,
            suggestions,
            location: locationObj ? translator("fes.location", locationObj) : "",
            count: matchedSymbols.length
          });
        }
        p53._friendlyError(msg, matchedSymbols.length === 1 ? matchedSymbols[0].name : undefined);
        return true;
      }
      return false;
    };
    const printFriendlyStack = (friendlyStack) => {
      const log2 = p53._fesLogger && typeof p53._fesLogger === "function" ? p53._fesLogger : console.log.bind(console);
      if (friendlyStack.length > 1) {
        let stacktraceMsg = "";
        friendlyStack.forEach((frame, idx) => {
          const location2 = `${frame.fileName}:${frame.lineNumber}:${frame.columnNumber}`;
          let frameMsg, translationObj = {
            func: frame.functionName,
            line: frame.lineNumber,
            location: location2,
            file: frame.fileName.split("/").slice(-1)
          };
          if (idx === 0) {
            frameMsg = translator("fes.globalErrors.stackTop", translationObj);
          } else {
            frameMsg = translator("fes.globalErrors.stackSubseq", translationObj);
          }
          stacktraceMsg += frameMsg;
        });
        log2(stacktraceMsg);
      }
    };
    const processStack = (error2, stacktrace) => {
      if (!stacktrace)
        return [false, null];
      stacktrace.forEach((frame) => {
        frame.functionName = frame.functionName || "";
      });
      let isInternal = false;
      let p5FileName, friendlyStack, currentEntryPoint;
      try {
        throw new Error;
      } catch (testError) {
        const testStacktrace = p53._getErrorStackParser().parse(testError);
        p5FileName = testStacktrace[0].fileName;
      }
      for (let i = stacktrace.length - 1;i >= 0; i--) {
        let splitted = stacktrace[i].functionName.split(".");
        if (entryPoints.includes(splitted[splitted.length - 1])) {
          friendlyStack = stacktrace.slice(0, i + 1);
          currentEntryPoint = splitted[splitted.length - 1];
          if (stacktrace[0].fileName === p5FileName) {
            isInternal = true;
            break;
          }
          break;
        }
      }
      if (!friendlyStack)
        friendlyStack = stacktrace;
      if (isInternal) {
        friendlyStack = friendlyStack.map((frame, index) => {
          frame.frameIndex = index;
          return frame;
        }).filter((frame) => frame.fileName !== p5FileName);
        if (friendlyStack.length === 0)
          return [true, null];
        const func = stacktrace[friendlyStack[0].frameIndex - 1].functionName.split(".").slice(-1)[0];
        let locationObj;
        if (friendlyStack[0].fileName && friendlyStack[0].lineNumber && friendlyStack[0].columnNumber) {
          locationObj = {
            location: `${friendlyStack[0].fileName}:${friendlyStack[0].lineNumber}:${friendlyStack[0].columnNumber}`,
            file: friendlyStack[0].fileName.split("/").slice(-1),
            line: friendlyStack[0].lineNumber
          };
          if (p53._fesLogCache[locationObj.location])
            return [true, null];
        }
        if (currentEntryPoint === "preload" && fn2._preloadMethods[func] == null) {
          p53._friendlyError(translator("fes.wrongPreload", {
            func,
            location: locationObj ? translator("fes.location", locationObj) : "",
            error: error2.message
          }), "preload");
        } else {
          p53._friendlyError(translator("fes.libraryError", {
            func,
            location: locationObj ? translator("fes.location", locationObj) : "",
            error: error2.message
          }), func);
        }
        if (friendlyStack && friendlyStack.length) {
          printFriendlyStack(friendlyStack);
        }
      }
      return [isInternal, friendlyStack];
    };
    const fesErrorMonitor = (e2) => {
      if (p53.disableFriendlyErrors)
        return;
      if (e2 && (e2 instanceof FESError || e2.reason instanceof FESError))
        return;
      let error2;
      if (e2 instanceof Error) {
        error2 = e2;
      } else if (e2 instanceof ErrorEvent) {
        error2 = e2.error;
      } else if (e2 instanceof PromiseRejectionEvent) {
        error2 = e2.reason;
        if (!(error2 instanceof Error))
          return;
      }
      if (!error2)
        return;
      let stacktrace = p53._getErrorStackParser().parse(error2);
      let [isInternal, friendlyStack] = processStack(error2, stacktrace);
      if (isInternal) {
        return;
      }
      const errList = strings[error2.name];
      if (!errList)
        return;
      let matchedError;
      for (const obj of errList) {
        let string = obj.msg;
        string = string.replace(new RegExp("{{}}", "g"), "([a-zA-Z0-9_]+)");
        string = string.replace(new RegExp("{{.}}", "g"), "(.+)");
        string = string.replace(new RegExp("{}", "g"), "(?:[a-zA-Z0-9_]+)");
        let matched = error2.message.match(string);
        if (matched) {
          matchedError = Object.assign({}, obj);
          matchedError.match = matched;
          break;
        }
      }
      if (!matchedError)
        return;
      let locationObj;
      if (stacktrace && stacktrace[0].fileName && stacktrace[0].lineNumber && stacktrace[0].columnNumber) {
        locationObj = {
          location: `${stacktrace[0].fileName}:${stacktrace[0].lineNumber}:${stacktrace[0].columnNumber}`,
          file: stacktrace[0].fileName.split("/").slice(-1),
          line: friendlyStack[0].lineNumber
        };
      }
      switch (error2.name) {
        case "SyntaxError": {
          switch (matchedError.type) {
            case "INVALIDTOKEN": {
              let url = "https://developer.mozilla.org/docs/Web/JavaScript/Reference/Errors/Illegal_character#What_went_wrong";
              p53._friendlyError(translator("fes.globalErrors.syntax.invalidToken", {
                url
              }));
              break;
            }
            case "UNEXPECTEDTOKEN": {
              let url = "https://developer.mozilla.org/docs/Web/JavaScript/Reference/Errors/Unexpected_token#What_went_wrong";
              p53._friendlyError(translator("fes.globalErrors.syntax.unexpectedToken", {
                url
              }));
              break;
            }
            case "REDECLAREDVARIABLE": {
              let errSym = matchedError.match[1];
              let url = "https://developer.mozilla.org/en-US/docs/Web/JavaScript/Reference/Errors/Redeclared_parameter#what_went_wrong";
              p53._friendlyError(translator("fes.globalErrors.syntax.redeclaredVariable", {
                symbol: errSym,
                url
              }));
              break;
            }
            case "MISSINGINITIALIZER": {
              let url = "https://developer.mozilla.org/en-US/docs/Web/JavaScript/Reference/Errors/Missing_initializer_in_const#what_went_wrong";
              p53._friendlyError(translator("fes.globalErrors.syntax.missingInitializer", {
                url
              }));
              break;
            }
            case "BADRETURNORYIELD": {
              let url = "https://developer.mozilla.org/en-US/docs/Web/JavaScript/Reference/Errors/Bad_return_or_yield#what_went_wrong";
              p53._friendlyError(translator("fes.globalErrors.syntax.badReturnOrYield", {
                url
              }));
              break;
            }
          }
          break;
        }
        case "ReferenceError": {
          switch (matchedError.type) {
            case "NOTDEFINED": {
              let errSym = matchedError.match[1];
              if (errSym && handleMisspelling(errSym, error2)) {
                break;
              }
              let url = "https://p5js.org/examples/data-variable-scope.html";
              p53._friendlyError(translator("fes.globalErrors.reference.notDefined", {
                url,
                symbol: errSym,
                location: locationObj ? translator("fes.location", locationObj) : ""
              }));
              if (friendlyStack)
                printFriendlyStack(friendlyStack);
              break;
            }
            case "CANNOTACCESS": {
              let errSym = matchedError.match[1];
              let url = "https://developer.mozilla.org/en-US/docs/Web/JavaScript/Reference/Errors/Cant_access_lexical_declaration_before_init#what_went_wrong";
              p53._friendlyError(translator("fes.globalErrors.reference.cannotAccess", {
                url,
                symbol: errSym,
                location: locationObj ? translator("fes.location", locationObj) : ""
              }));
              if (friendlyStack)
                printFriendlyStack(friendlyStack);
              break;
            }
          }
          break;
        }
        case "TypeError": {
          switch (matchedError.type) {
            case "NOTFUNC": {
              let errSym = matchedError.match[1];
              let splitSym = errSym.split(".");
              let url = "https://developer.mozilla.org/docs/Web/JavaScript/Reference/Errors/Not_a_function#What_went_wrong";
              let translationObj = {
                url,
                symbol: splitSym[splitSym.length - 1],
                obj: splitSym.slice(0, splitSym.length - 1).join("."),
                location: locationObj ? translator("fes.location", locationObj) : ""
              };
              if (splitSym.length > 1) {
                p53._friendlyError(translator("fes.globalErrors.type.notfuncObj", translationObj));
              } else {
                p53._friendlyError(translator("fes.globalErrors.type.notfunc", translationObj));
              }
              if (friendlyStack)
                printFriendlyStack(friendlyStack);
              break;
            }
            case "READNULL": {
              let errSym = matchedError.match[1];
              let url = "https://developer.mozilla.org/en-US/docs/Web/JavaScript/Reference/Errors/Cant_access_property#what_went_wrong";
              p53._friendlyError(translator("fes.globalErrors.type.readFromNull", {
                url,
                symbol: errSym,
                location: locationObj ? translator("fes.location", locationObj) : ""
              }));
              if (friendlyStack)
                printFriendlyStack(friendlyStack);
              break;
            }
            case "READUDEFINED": {
              let errSym = matchedError.match[1];
              let url = "https://developer.mozilla.org/en-US/docs/Web/JavaScript/Reference/Errors/Cant_access_property#what_went_wrong";
              p53._friendlyError(translator("fes.globalErrors.type.readFromUndefined", {
                url,
                symbol: errSym,
                location: locationObj ? translator("fes.location", locationObj) : ""
              }));
              if (friendlyStack)
                printFriendlyStack(friendlyStack);
              break;
            }
            case "CONSTASSIGN": {
              let url = "https://developer.mozilla.org/en-US/docs/Web/JavaScript/Reference/Errors/Invalid_const_assignment#what_went_wrong";
              p53._friendlyError(translator("fes.globalErrors.type.constAssign", {
                url,
                location: locationObj ? translator("fes.location", locationObj) : ""
              }));
              if (friendlyStack)
                printFriendlyStack(friendlyStack);
              break;
            }
          }
        }
      }
    };
    p53._fesErrorMonitor = fesErrorMonitor;
    p53._checkForUserDefinedFunctions = checkForUserDefinedFunctions;
    p53._fesLogger = null;
    p53._fesLogCache = {};
    window.addEventListener("load", checkForUserDefinedFunctions, false);
    window.addEventListener("error", p53._fesErrorMonitor, false);
    window.addEventListener("unhandledrejection", p53._fesErrorMonitor, false);
  }
  misusedAtTopLevelCode = null;
  const FAQ_URL = "https://github.com/processing/p5.js/wiki/p5.js-overview#why-cant-i-assign-variables-using-p5-functions-and-variables-before-setup";
  defineMisusedAtTopLevelCode = () => {
    const uniqueNamesFound = {};
    const getSymbols = (obj) => Object.getOwnPropertyNames(obj).filter((name) => {
      if (name[0] === "_") {
        return false;
      }
      if (name in uniqueNamesFound) {
        return false;
      }
      uniqueNamesFound[name] = true;
      return true;
    }).map((name) => {
      let type2;
      if (typeof obj[name] === "function") {
        type2 = "function";
      } else if (name === name.toUpperCase()) {
        type2 = "constant";
      } else {
        type2 = "variable";
      }
      return { name, type: type2 };
    });
    misusedAtTopLevelCode = [].concat(getSymbols(fn2), getSymbols(constants));
    misusedAtTopLevelCode.sort((a, b2) => b2.name.length - a.name.length);
  };
  const helpForMisusedAtTopLevelCode = (e2, log2) => {
    if (!log2) {
      log2 = console.log.bind(console);
    }
    if (!misusedAtTopLevelCode) {
      defineMisusedAtTopLevelCode();
    }
    misusedAtTopLevelCode.some((symbol) => {
      if (e2.message && e2.message.match(`\\W?${symbol.name}\\W`) !== null) {
        const symbolName = symbol.type === "function" ? `${symbol.name}()` : symbol.name;
        if (typeof IS_MINIFIED !== "undefined") {
          log2(`Did you just try to use p5.js's ${symbolName} ${symbol.type}? If so, you may want to move it into your sketch's setup() function.

For more details, see: ${FAQ_URL}`);
        } else {
          log2(translator("fes.misusedTopLevel", {
            symbolName,
            symbolType: symbol.type,
            url: FAQ_URL
          }));
        }
        return true;
      }
    });
  };
  fn2._helpForMisusedAtTopLevelCode = helpForMisusedAtTopLevelCode;
  if (document.readyState !== "complete") {
    window.addEventListener("error", helpForMisusedAtTopLevelCode, false);
    window.addEventListener("load", () => {
      window.removeEventListener("error", helpForMisusedAtTopLevelCode, false);
    });
  }
}
if (typeof p5 !== "undefined") {
  fesCore(p5, p5.prototype);
}

// node_modules/p5/dist/core/friendly_errors/stacktrace.js
function ErrorStackParser() {
  let FIREFOX_SAFARI_STACK_REGEXP = /(^|@)\S+:\d+/;
  let CHROME_IE_STACK_REGEXP = /^\s*at .*(\S+:\d+|\(native\))/m;
  let SAFARI_NATIVE_CODE_REGEXP = /^(eval@)?(\[native code])?$/;
  return {
    parse: function ErrorStackParser$$parse(error2) {
      if (typeof error2.stacktrace !== "undefined" || typeof error2["opera#sourceloc"] !== "undefined") {
        return this.parseOpera(error2);
      } else if (error2.stack && error2.stack.match(CHROME_IE_STACK_REGEXP)) {
        return this.parseV8OrIE(error2);
      } else if (error2.stack) {
        return this.parseFFOrSafari(error2);
      } else
        ;
    },
    extractLocation: function ErrorStackParser$$extractLocation(urlLike) {
      if (urlLike.indexOf(":") === -1) {
        return [urlLike];
      }
      let regExp = /(.+?)(?::(\d+))?(?::(\d+))?$/;
      let parts = regExp.exec(urlLike.replace(/[()]/g, ""));
      return [parts[1], parts[2] || undefined, parts[3] || undefined];
    },
    parseV8OrIE: function ErrorStackParser$$parseV8OrIE(error2) {
      let filtered = error2.stack.split(`
`).filter(function(line) {
        return !!line.match(CHROME_IE_STACK_REGEXP);
      }, this);
      return filtered.map(function(line) {
        if (line.indexOf("(eval ") > -1) {
          line = line.replace(/eval code/g, "eval").replace(/(\(eval at [^()]*)|(\),.*$)/g, "");
        }
        let sanitizedLine = line.replace(/^\s+/, "").replace(/\(eval code/g, "(");
        let location2 = sanitizedLine.match(/ (\((.+):(\d+):(\d+)\)$)/);
        sanitizedLine = location2 ? sanitizedLine.replace(location2[0], "") : sanitizedLine;
        let tokens = sanitizedLine.split(/\s+/).slice(1);
        let locationParts = this.extractLocation(location2 ? location2[1] : tokens.pop());
        let functionName = tokens.join(" ") || undefined;
        let fileName = ["eval", "<anonymous>"].indexOf(locationParts[0]) > -1 ? undefined : locationParts[0];
        return {
          functionName,
          fileName,
          lineNumber: locationParts[1],
          columnNumber: locationParts[2],
          source: line
        };
      }, this);
    },
    parseFFOrSafari: function ErrorStackParser$$parseFFOrSafari(error2) {
      let filtered = error2.stack.split(`
`).filter(function(line) {
        return !line.match(SAFARI_NATIVE_CODE_REGEXP);
      }, this);
      return filtered.map(function(line) {
        if (line.indexOf(" > eval") > -1) {
          line = line.replace(/ line (\d+)(?: > eval line \d+)* > eval:\d+:\d+/g, ":$1");
        }
        if (line.indexOf("@") === -1 && line.indexOf(":") === -1) {
          return {
            functionName: line
          };
        } else {
          let functionNameRegex = /((.*".+"[^@]*)?[^@]*)(?:@)/;
          let matches = line.match(functionNameRegex);
          let functionName = matches && matches[1] ? matches[1] : undefined;
          let locationParts = this.extractLocation(line.replace(functionNameRegex, ""));
          return {
            functionName,
            fileName: locationParts[0],
            lineNumber: locationParts[1],
            columnNumber: locationParts[2],
            source: line
          };
        }
      }, this);
    },
    parseOpera: function ErrorStackParser$$parseOpera(e2) {
      if (!e2.stacktrace || e2.message.indexOf(`
`) > -1 && e2.message.split(`
`).length > e2.stacktrace.split(`
`).length) {
        return this.parseOpera9(e2);
      } else if (!e2.stack) {
        return this.parseOpera10(e2);
      } else {
        return this.parseOpera11(e2);
      }
    },
    parseOpera9: function ErrorStackParser$$parseOpera9(e2) {
      let lineRE = /Line (\d+).*script (?:in )?(\S+)/i;
      let lines = e2.message.split(`
`);
      let result = [];
      for (let i = 2, len = lines.length;i < len; i += 2) {
        let match = lineRE.exec(lines[i]);
        if (match) {
          result.push({
            fileName: match[2],
            lineNumber: match[1],
            source: lines[i]
          });
        }
      }
      return result;
    },
    parseOpera10: function ErrorStackParser$$parseOpera10(e2) {
      let lineRE = /Line (\d+).*script (?:in )?(\S+)(?:: In function (\S+))?$/i;
      let lines = e2.stacktrace.split(`
`);
      let result = [];
      for (let i = 0, len = lines.length;i < len; i += 2) {
        let match = lineRE.exec(lines[i]);
        if (match) {
          result.push({
            functionName: match[3] || undefined,
            fileName: match[2],
            lineNumber: match[1],
            source: lines[i]
          });
        }
      }
      return result;
    },
    parseOpera11: function ErrorStackParser$$parseOpera11(error2) {
      let filtered = error2.stack.split(`
`).filter(function(line) {
        return !!line.match(FIREFOX_SAFARI_STACK_REGEXP) && !line.match(/^Error created at/);
      }, this);
      return filtered.map(function(line) {
        let tokens = line.split("@");
        let locationParts = this.extractLocation(tokens.pop());
        let functionCall = tokens.shift() || "";
        let functionName = functionCall.replace(/<anonymous function(: (\w+))?>/, "$2").replace(/\([^)]*\)/g, "") || undefined;
        let argsRaw;
        if (functionCall.match(/\(([^)]*)\)/)) {
          argsRaw = functionCall.replace(/^[^(]+\(([^)]*)\)$/, "$1");
        }
        let args = argsRaw === undefined || argsRaw === "[arguments not available]" ? undefined : argsRaw.split(",");
        return {
          functionName,
          args,
          fileName: locationParts[0],
          lineNumber: locationParts[1],
          columnNumber: locationParts[2],
          source: line
        };
      }, this);
    }
  };
}
function stacktrace(p53, fn2) {
  p53._getErrorStackParser = function getErrorStackParser() {
    return new ErrorStackParser;
  };
}
if (typeof p5 !== "undefined") {
  stacktrace(p5, p5.prototype);
}

// node_modules/zod/v4/classic/external.js
var exports_external = {};
__export(exports_external, {
  xid: () => xid2,
  void: () => _void2,
  uuidv7: () => uuidv7,
  uuidv6: () => uuidv6,
  uuidv4: () => uuidv4,
  uuid: () => uuid2,
  url: () => url,
  uppercase: () => _uppercase,
  unknown: () => unknown,
  union: () => union,
  undefined: () => _undefined3,
  ulid: () => ulid2,
  uint64: () => uint64,
  uint32: () => uint32,
  tuple: () => tuple,
  trim: () => _trim,
  treeifyError: () => treeifyError,
  transform: () => transform2,
  toUpperCase: () => _toUpperCase,
  toLowerCase: () => _toLowerCase,
  toJSONSchema: () => toJSONSchema,
  templateLiteral: () => templateLiteral,
  symbol: () => symbol,
  superRefine: () => superRefine,
  success: () => success,
  stringbool: () => stringbool,
  stringFormat: () => stringFormat,
  string: () => string2,
  strictObject: () => strictObject,
  startsWith: () => _startsWith,
  size: () => _size,
  setErrorMap: () => setErrorMap,
  set: () => set2,
  safeParseAsync: () => safeParseAsync2,
  safeParse: () => safeParse2,
  registry: () => registry,
  regexes: () => exports_regexes,
  regex: () => _regex,
  refine: () => refine,
  record: () => record,
  readonly: () => readonly,
  property: () => _property,
  promise: () => promise,
  prettifyError: () => prettifyError,
  preprocess: () => preprocess,
  prefault: () => prefault,
  positive: () => _positive,
  pipe: () => pipe,
  partialRecord: () => partialRecord,
  parseAsync: () => parseAsync2,
  parse: () => parse5,
  overwrite: () => _overwrite,
  optional: () => optional,
  object: () => object,
  number: () => number2,
  nullish: () => nullish2,
  nullable: () => nullable,
  null: () => _null3,
  normalize: () => _normalize,
  nonpositive: () => _nonpositive,
  nonoptional: () => nonoptional,
  nonnegative: () => _nonnegative,
  never: () => never,
  negative: () => _negative,
  nativeEnum: () => nativeEnum,
  nanoid: () => nanoid2,
  nan: () => nan,
  multipleOf: () => _multipleOf,
  minSize: () => _minSize,
  minLength: () => _minLength,
  mime: () => _mime,
  maxSize: () => _maxSize,
  maxLength: () => _maxLength,
  map: () => map2,
  lte: () => _lte,
  lt: () => _lt,
  lowercase: () => _lowercase,
  looseObject: () => looseObject,
  locales: () => exports_locales,
  literal: () => literal,
  length: () => _length,
  lazy: () => lazy,
  ksuid: () => ksuid2,
  keyof: () => keyof,
  jwt: () => jwt,
  json: () => json,
  iso: () => exports_iso,
  ipv6: () => ipv62,
  ipv4: () => ipv42,
  intersection: () => intersection,
  int64: () => int64,
  int32: () => int32,
  int: () => int,
  instanceof: () => _instanceof,
  includes: () => _includes,
  guid: () => guid2,
  gte: () => _gte,
  gt: () => _gt,
  globalRegistry: () => globalRegistry,
  getErrorMap: () => getErrorMap,
  function: () => _function,
  formatError: () => formatError,
  float64: () => float64,
  float32: () => float32,
  flattenError: () => flattenError,
  file: () => file2,
  enum: () => _enum2,
  endsWith: () => _endsWith,
  emoji: () => emoji2,
  email: () => email2,
  e164: () => e1642,
  discriminatedUnion: () => discriminatedUnion,
  date: () => date3,
  custom: () => custom,
  cuid2: () => cuid22,
  cuid: () => cuid3,
  core: () => exports_core2,
  config: () => config,
  coerce: () => exports_coerce,
  clone: () => clone2,
  cidrv6: () => cidrv62,
  cidrv4: () => cidrv42,
  check: () => check,
  catch: () => _catch2,
  boolean: () => boolean2,
  bigint: () => bigint2,
  base64url: () => base64url2,
  base64: () => base642,
  array: () => array,
  any: () => any,
  _default: () => _default2,
  _ZodString: () => _ZodString,
  ZodXID: () => ZodXID,
  ZodVoid: () => ZodVoid,
  ZodUnknown: () => ZodUnknown,
  ZodUnion: () => ZodUnion,
  ZodUndefined: () => ZodUndefined,
  ZodUUID: () => ZodUUID,
  ZodURL: () => ZodURL,
  ZodULID: () => ZodULID,
  ZodType: () => ZodType,
  ZodTuple: () => ZodTuple,
  ZodTransform: () => ZodTransform,
  ZodTemplateLiteral: () => ZodTemplateLiteral,
  ZodSymbol: () => ZodSymbol,
  ZodSuccess: () => ZodSuccess,
  ZodStringFormat: () => ZodStringFormat,
  ZodString: () => ZodString,
  ZodSet: () => ZodSet,
  ZodRecord: () => ZodRecord,
  ZodRealError: () => ZodRealError,
  ZodReadonly: () => ZodReadonly,
  ZodPromise: () => ZodPromise,
  ZodPrefault: () => ZodPrefault,
  ZodPipe: () => ZodPipe,
  ZodOptional: () => ZodOptional,
  ZodObject: () => ZodObject,
  ZodNumberFormat: () => ZodNumberFormat,
  ZodNumber: () => ZodNumber,
  ZodNullable: () => ZodNullable,
  ZodNull: () => ZodNull,
  ZodNonOptional: () => ZodNonOptional,
  ZodNever: () => ZodNever,
  ZodNanoID: () => ZodNanoID,
  ZodNaN: () => ZodNaN,
  ZodMap: () => ZodMap,
  ZodLiteral: () => ZodLiteral,
  ZodLazy: () => ZodLazy,
  ZodKSUID: () => ZodKSUID,
  ZodJWT: () => ZodJWT,
  ZodIssueCode: () => ZodIssueCode,
  ZodIntersection: () => ZodIntersection,
  ZodISOTime: () => ZodISOTime,
  ZodISODuration: () => ZodISODuration,
  ZodISODateTime: () => ZodISODateTime,
  ZodISODate: () => ZodISODate,
  ZodIPv6: () => ZodIPv6,
  ZodIPv4: () => ZodIPv4,
  ZodGUID: () => ZodGUID,
  ZodFile: () => ZodFile,
  ZodError: () => ZodError,
  ZodEnum: () => ZodEnum,
  ZodEmoji: () => ZodEmoji,
  ZodEmail: () => ZodEmail,
  ZodE164: () => ZodE164,
  ZodDiscriminatedUnion: () => ZodDiscriminatedUnion,
  ZodDefault: () => ZodDefault,
  ZodDate: () => ZodDate,
  ZodCustomStringFormat: () => ZodCustomStringFormat,
  ZodCustom: () => ZodCustom,
  ZodCatch: () => ZodCatch,
  ZodCUID2: () => ZodCUID2,
  ZodCUID: () => ZodCUID,
  ZodCIDRv6: () => ZodCIDRv6,
  ZodCIDRv4: () => ZodCIDRv4,
  ZodBoolean: () => ZodBoolean,
  ZodBigIntFormat: () => ZodBigIntFormat,
  ZodBigInt: () => ZodBigInt,
  ZodBase64URL: () => ZodBase64URL,
  ZodBase64: () => ZodBase64,
  ZodArray: () => ZodArray,
  ZodAny: () => ZodAny,
  TimePrecision: () => TimePrecision,
  NEVER: () => NEVER,
  $output: () => $output,
  $input: () => $input,
  $brand: () => $brand
});

// node_modules/zod/v4/core/index.js
var exports_core2 = {};
__export(exports_core2, {
  version: () => version,
  util: () => exports_util2,
  treeifyError: () => treeifyError,
  toJSONSchema: () => toJSONSchema,
  toDotPath: () => toDotPath,
  safeParseAsync: () => safeParseAsync,
  safeParse: () => safeParse,
  registry: () => registry,
  regexes: () => exports_regexes,
  prettifyError: () => prettifyError,
  parseAsync: () => parseAsync,
  parse: () => parse3,
  locales: () => exports_locales,
  isValidJWT: () => isValidJWT,
  isValidBase64URL: () => isValidBase64URL,
  isValidBase64: () => isValidBase64,
  globalRegistry: () => globalRegistry,
  globalConfig: () => globalConfig,
  function: () => _function,
  formatError: () => formatError,
  flattenError: () => flattenError,
  config: () => config,
  clone: () => clone2,
  _xid: () => _xid,
  _void: () => _void,
  _uuidv7: () => _uuidv7,
  _uuidv6: () => _uuidv6,
  _uuidv4: () => _uuidv4,
  _uuid: () => _uuid,
  _url: () => _url,
  _uppercase: () => _uppercase,
  _unknown: () => _unknown,
  _union: () => _union,
  _undefined: () => _undefined2,
  _ulid: () => _ulid,
  _uint64: () => _uint64,
  _uint32: () => _uint32,
  _tuple: () => _tuple,
  _trim: () => _trim,
  _transform: () => _transform,
  _toUpperCase: () => _toUpperCase,
  _toLowerCase: () => _toLowerCase,
  _templateLiteral: () => _templateLiteral,
  _symbol: () => _symbol,
  _success: () => _success,
  _stringbool: () => _stringbool,
  _stringFormat: () => _stringFormat,
  _string: () => _string,
  _startsWith: () => _startsWith,
  _size: () => _size,
  _set: () => _set,
  _safeParseAsync: () => _safeParseAsync,
  _safeParse: () => _safeParse,
  _regex: () => _regex,
  _refine: () => _refine,
  _record: () => _record,
  _readonly: () => _readonly,
  _property: () => _property,
  _promise: () => _promise,
  _positive: () => _positive,
  _pipe: () => _pipe,
  _parseAsync: () => _parseAsync,
  _parse: () => _parse,
  _overwrite: () => _overwrite,
  _optional: () => _optional,
  _number: () => _number,
  _nullable: () => _nullable,
  _null: () => _null2,
  _normalize: () => _normalize,
  _nonpositive: () => _nonpositive,
  _nonoptional: () => _nonoptional,
  _nonnegative: () => _nonnegative,
  _never: () => _never,
  _negative: () => _negative,
  _nativeEnum: () => _nativeEnum,
  _nanoid: () => _nanoid,
  _nan: () => _nan,
  _multipleOf: () => _multipleOf,
  _minSize: () => _minSize,
  _minLength: () => _minLength,
  _min: () => _gte,
  _mime: () => _mime,
  _maxSize: () => _maxSize,
  _maxLength: () => _maxLength,
  _max: () => _lte,
  _map: () => _map,
  _lte: () => _lte,
  _lt: () => _lt,
  _lowercase: () => _lowercase,
  _literal: () => _literal,
  _length: () => _length,
  _lazy: () => _lazy,
  _ksuid: () => _ksuid,
  _jwt: () => _jwt,
  _isoTime: () => _isoTime,
  _isoDuration: () => _isoDuration,
  _isoDateTime: () => _isoDateTime,
  _isoDate: () => _isoDate,
  _ipv6: () => _ipv6,
  _ipv4: () => _ipv4,
  _intersection: () => _intersection,
  _int64: () => _int64,
  _int32: () => _int32,
  _int: () => _int,
  _includes: () => _includes,
  _guid: () => _guid,
  _gte: () => _gte,
  _gt: () => _gt,
  _float64: () => _float64,
  _float32: () => _float32,
  _file: () => _file,
  _enum: () => _enum,
  _endsWith: () => _endsWith,
  _emoji: () => _emoji2,
  _email: () => _email,
  _e164: () => _e164,
  _discriminatedUnion: () => _discriminatedUnion,
  _default: () => _default,
  _date: () => _date,
  _custom: () => _custom,
  _cuid2: () => _cuid2,
  _cuid: () => _cuid,
  _coercedString: () => _coercedString,
  _coercedNumber: () => _coercedNumber,
  _coercedDate: () => _coercedDate,
  _coercedBoolean: () => _coercedBoolean,
  _coercedBigint: () => _coercedBigint,
  _cidrv6: () => _cidrv6,
  _cidrv4: () => _cidrv4,
  _catch: () => _catch,
  _boolean: () => _boolean,
  _bigint: () => _bigint,
  _base64url: () => _base64url,
  _base64: () => _base64,
  _array: () => _array,
  _any: () => _any,
  TimePrecision: () => TimePrecision,
  NEVER: () => NEVER,
  JSONSchemaGenerator: () => JSONSchemaGenerator,
  JSONSchema: () => exports_json_schema,
  Doc: () => Doc,
  $output: () => $output,
  $input: () => $input,
  $constructor: () => $constructor,
  $brand: () => $brand,
  $ZodXID: () => $ZodXID,
  $ZodVoid: () => $ZodVoid,
  $ZodUnknown: () => $ZodUnknown,
  $ZodUnion: () => $ZodUnion,
  $ZodUndefined: () => $ZodUndefined,
  $ZodUUID: () => $ZodUUID,
  $ZodURL: () => $ZodURL,
  $ZodULID: () => $ZodULID,
  $ZodType: () => $ZodType,
  $ZodTuple: () => $ZodTuple,
  $ZodTransform: () => $ZodTransform,
  $ZodTemplateLiteral: () => $ZodTemplateLiteral,
  $ZodSymbol: () => $ZodSymbol,
  $ZodSuccess: () => $ZodSuccess,
  $ZodStringFormat: () => $ZodStringFormat,
  $ZodString: () => $ZodString,
  $ZodSet: () => $ZodSet,
  $ZodRegistry: () => $ZodRegistry,
  $ZodRecord: () => $ZodRecord,
  $ZodRealError: () => $ZodRealError,
  $ZodReadonly: () => $ZodReadonly,
  $ZodPromise: () => $ZodPromise,
  $ZodPrefault: () => $ZodPrefault,
  $ZodPipe: () => $ZodPipe,
  $ZodOptional: () => $ZodOptional,
  $ZodObject: () => $ZodObject,
  $ZodNumberFormat: () => $ZodNumberFormat,
  $ZodNumber: () => $ZodNumber,
  $ZodNullable: () => $ZodNullable,
  $ZodNull: () => $ZodNull,
  $ZodNonOptional: () => $ZodNonOptional,
  $ZodNever: () => $ZodNever,
  $ZodNanoID: () => $ZodNanoID,
  $ZodNaN: () => $ZodNaN,
  $ZodMap: () => $ZodMap,
  $ZodLiteral: () => $ZodLiteral,
  $ZodLazy: () => $ZodLazy,
  $ZodKSUID: () => $ZodKSUID,
  $ZodJWT: () => $ZodJWT,
  $ZodIntersection: () => $ZodIntersection,
  $ZodISOTime: () => $ZodISOTime,
  $ZodISODuration: () => $ZodISODuration,
  $ZodISODateTime: () => $ZodISODateTime,
  $ZodISODate: () => $ZodISODate,
  $ZodIPv6: () => $ZodIPv6,
  $ZodIPv4: () => $ZodIPv4,
  $ZodGUID: () => $ZodGUID,
  $ZodFunction: () => $ZodFunction,
  $ZodFile: () => $ZodFile,
  $ZodError: () => $ZodError,
  $ZodEnum: () => $ZodEnum,
  $ZodEmoji: () => $ZodEmoji,
  $ZodEmail: () => $ZodEmail,
  $ZodE164: () => $ZodE164,
  $ZodDiscriminatedUnion: () => $ZodDiscriminatedUnion,
  $ZodDefault: () => $ZodDefault,
  $ZodDate: () => $ZodDate,
  $ZodCustomStringFormat: () => $ZodCustomStringFormat,
  $ZodCustom: () => $ZodCustom,
  $ZodCheckUpperCase: () => $ZodCheckUpperCase,
  $ZodCheckStringFormat: () => $ZodCheckStringFormat,
  $ZodCheckStartsWith: () => $ZodCheckStartsWith,
  $ZodCheckSizeEquals: () => $ZodCheckSizeEquals,
  $ZodCheckRegex: () => $ZodCheckRegex,
  $ZodCheckProperty: () => $ZodCheckProperty,
  $ZodCheckOverwrite: () => $ZodCheckOverwrite,
  $ZodCheckNumberFormat: () => $ZodCheckNumberFormat,
  $ZodCheckMultipleOf: () => $ZodCheckMultipleOf,
  $ZodCheckMinSize: () => $ZodCheckMinSize,
  $ZodCheckMinLength: () => $ZodCheckMinLength,
  $ZodCheckMimeType: () => $ZodCheckMimeType,
  $ZodCheckMaxSize: () => $ZodCheckMaxSize,
  $ZodCheckMaxLength: () => $ZodCheckMaxLength,
  $ZodCheckLowerCase: () => $ZodCheckLowerCase,
  $ZodCheckLessThan: () => $ZodCheckLessThan,
  $ZodCheckLengthEquals: () => $ZodCheckLengthEquals,
  $ZodCheckIncludes: () => $ZodCheckIncludes,
  $ZodCheckGreaterThan: () => $ZodCheckGreaterThan,
  $ZodCheckEndsWith: () => $ZodCheckEndsWith,
  $ZodCheckBigIntFormat: () => $ZodCheckBigIntFormat,
  $ZodCheck: () => $ZodCheck,
  $ZodCatch: () => $ZodCatch,
  $ZodCUID2: () => $ZodCUID2,
  $ZodCUID: () => $ZodCUID,
  $ZodCIDRv6: () => $ZodCIDRv6,
  $ZodCIDRv4: () => $ZodCIDRv4,
  $ZodBoolean: () => $ZodBoolean,
  $ZodBigIntFormat: () => $ZodBigIntFormat,
  $ZodBigInt: () => $ZodBigInt,
  $ZodBase64URL: () => $ZodBase64URL,
  $ZodBase64: () => $ZodBase64,
  $ZodAsyncError: () => $ZodAsyncError,
  $ZodArray: () => $ZodArray,
  $ZodAny: () => $ZodAny
});

// node_modules/zod/v4/core/core.js
var NEVER = Object.freeze({
  status: "aborted"
});
function $constructor(name, initializer, params) {
  function init(inst, def) {
    var _a;
    Object.defineProperty(inst, "_zod", {
      value: inst._zod ?? {},
      enumerable: false
    });
    (_a = inst._zod).traits ?? (_a.traits = new Set);
    inst._zod.traits.add(name);
    initializer(inst, def);
    for (const k in _23.prototype) {
      if (!(k in inst))
        Object.defineProperty(inst, k, { value: _23.prototype[k].bind(inst) });
    }
    inst._zod.constr = _23;
    inst._zod.def = def;
  }
  const Parent = params?.Parent ?? Object;

  class Definition extends Parent {
  }
  Object.defineProperty(Definition, "name", { value: name });
  function _23(def) {
    var _a;
    const inst = params?.Parent ? new Definition : this;
    init(inst, def);
    (_a = inst._zod).deferred ?? (_a.deferred = []);
    for (const fn2 of inst._zod.deferred) {
      fn2();
    }
    return inst;
  }
  Object.defineProperty(_23, "init", { value: init });
  Object.defineProperty(_23, Symbol.hasInstance, {
    value: (inst) => {
      if (params?.Parent && inst instanceof params.Parent)
        return true;
      return inst?._zod?.traits?.has(name);
    }
  });
  Object.defineProperty(_23, "name", { value: name });
  return _23;
}
var $brand = Symbol("zod_brand");

class $ZodAsyncError extends Error {
  constructor() {
    super(`Encountered Promise during synchronous parse. Use .parseAsync() instead.`);
  }
}
var globalConfig = {};
function config(newConfig) {
  if (newConfig)
    Object.assign(globalConfig, newConfig);
  return globalConfig;
}
// node_modules/zod/v4/core/util.js
var exports_util2 = {};
__export(exports_util2, {
  unwrapMessage: () => unwrapMessage,
  stringifyPrimitive: () => stringifyPrimitive,
  required: () => required,
  randomString: () => randomString,
  propertyKeyTypes: () => propertyKeyTypes,
  promiseAllObject: () => promiseAllObject,
  primitiveTypes: () => primitiveTypes,
  prefixIssues: () => prefixIssues,
  pick: () => pick,
  partial: () => partial,
  optionalKeys: () => optionalKeys,
  omit: () => omit,
  numKeys: () => numKeys,
  nullish: () => nullish,
  normalizeParams: () => normalizeParams,
  merge: () => merge,
  jsonStringifyReplacer: () => jsonStringifyReplacer,
  joinValues: () => joinValues,
  issue: () => issue,
  isPlainObject: () => isPlainObject,
  isObject: () => isObject,
  getSizableOrigin: () => getSizableOrigin,
  getParsedType: () => getParsedType,
  getLengthableOrigin: () => getLengthableOrigin,
  getEnumValues: () => getEnumValues,
  getElementAtPath: () => getElementAtPath,
  floatSafeRemainder: () => floatSafeRemainder,
  finalizeIssue: () => finalizeIssue,
  extend: () => extend,
  escapeRegex: () => escapeRegex,
  esc: () => esc,
  defineLazy: () => defineLazy,
  createTransparentProxy: () => createTransparentProxy,
  clone: () => clone2,
  cleanRegex: () => cleanRegex,
  cleanEnum: () => cleanEnum,
  captureStackTrace: () => captureStackTrace,
  cached: () => cached,
  assignProp: () => assignProp,
  assertNotEqual: () => assertNotEqual,
  assertNever: () => assertNever,
  assertIs: () => assertIs,
  assertEqual: () => assertEqual,
  assert: () => assert,
  allowsEval: () => allowsEval,
  aborted: () => aborted,
  NUMBER_FORMAT_RANGES: () => NUMBER_FORMAT_RANGES,
  Class: () => Class,
  BIGINT_FORMAT_RANGES: () => BIGINT_FORMAT_RANGES
});
function assertEqual(val) {
  return val;
}
function assertNotEqual(val) {
  return val;
}
function assertIs(_arg) {}
function assertNever(_x) {
  throw new Error;
}
function assert(_23) {}
function getEnumValues(entries) {
  const numericValues = Object.values(entries).filter((v) => typeof v === "number");
  const values = Object.entries(entries).filter(([k, _23]) => numericValues.indexOf(+k) === -1).map(([_23, v]) => v);
  return values;
}
function joinValues(array, separator = "|") {
  return array.map((val) => stringifyPrimitive(val)).join(separator);
}
function jsonStringifyReplacer(_23, value) {
  if (typeof value === "bigint")
    return value.toString();
  return value;
}
function cached(getter) {
  const set2 = false;
  return {
    get value() {
      if (!set2) {
        const value = getter();
        Object.defineProperty(this, "value", { value });
        return value;
      }
      throw new Error("cached value already set");
    }
  };
}
function nullish(input) {
  return input === null || input === undefined;
}
function cleanRegex(source) {
  const start = source.startsWith("^") ? 1 : 0;
  const end = source.endsWith("$") ? source.length - 1 : source.length;
  return source.slice(start, end);
}
function floatSafeRemainder(val, step) {
  const valDecCount = (val.toString().split(".")[1] || "").length;
  const stepDecCount = (step.toString().split(".")[1] || "").length;
  const decCount = valDecCount > stepDecCount ? valDecCount : stepDecCount;
  const valInt = Number.parseInt(val.toFixed(decCount).replace(".", ""));
  const stepInt = Number.parseInt(step.toFixed(decCount).replace(".", ""));
  return valInt % stepInt / 10 ** decCount;
}
function defineLazy(object, key, getter) {
  const set2 = false;
  Object.defineProperty(object, key, {
    get() {
      if (!set2) {
        const value = getter();
        object[key] = value;
        return value;
      }
      throw new Error("cached value already set");
    },
    set(v) {
      Object.defineProperty(object, key, {
        value: v
      });
    },
    configurable: true
  });
}
function assignProp(target, prop, value) {
  Object.defineProperty(target, prop, {
    value,
    writable: true,
    enumerable: true,
    configurable: true
  });
}
function getElementAtPath(obj, path2) {
  if (!path2)
    return obj;
  return path2.reduce((acc, key) => acc?.[key], obj);
}
function promiseAllObject(promisesObj) {
  const keys = Object.keys(promisesObj);
  const promises = keys.map((key) => promisesObj[key]);
  return Promise.all(promises).then((results) => {
    const resolvedObj = {};
    for (let i = 0;i < keys.length; i++) {
      resolvedObj[keys[i]] = results[i];
    }
    return resolvedObj;
  });
}
function randomString(length = 10) {
  const chars = "abcdefghijklmnopqrstuvwxyz";
  let str = "";
  for (let i = 0;i < length; i++) {
    str += chars[Math.floor(Math.random() * chars.length)];
  }
  return str;
}
function esc(str) {
  return JSON.stringify(str);
}
var captureStackTrace = Error.captureStackTrace ? Error.captureStackTrace : (..._args) => {};
function isObject(data) {
  return typeof data === "object" && data !== null && !Array.isArray(data);
}
var allowsEval = cached(() => {
  if (typeof navigator !== "undefined" && navigator?.userAgent?.includes("Cloudflare")) {
    return false;
  }
  try {
    const F = Function;
    new F("");
    return true;
  } catch (_23) {
    return false;
  }
});
function isPlainObject(o) {
  if (isObject(o) === false)
    return false;
  const ctor = o.constructor;
  if (ctor === undefined)
    return true;
  const prot = ctor.prototype;
  if (isObject(prot) === false)
    return false;
  if (Object.prototype.hasOwnProperty.call(prot, "isPrototypeOf") === false) {
    return false;
  }
  return true;
}
function numKeys(data) {
  let keyCount = 0;
  for (const key in data) {
    if (Object.prototype.hasOwnProperty.call(data, key)) {
      keyCount++;
    }
  }
  return keyCount;
}
var getParsedType = (data) => {
  const t = typeof data;
  switch (t) {
    case "undefined":
      return "undefined";
    case "string":
      return "string";
    case "number":
      return Number.isNaN(data) ? "nan" : "number";
    case "boolean":
      return "boolean";
    case "function":
      return "function";
    case "bigint":
      return "bigint";
    case "symbol":
      return "symbol";
    case "object":
      if (Array.isArray(data)) {
        return "array";
      }
      if (data === null) {
        return "null";
      }
      if (data.then && typeof data.then === "function" && data.catch && typeof data.catch === "function") {
        return "promise";
      }
      if (typeof Map !== "undefined" && data instanceof Map) {
        return "map";
      }
      if (typeof Set !== "undefined" && data instanceof Set) {
        return "set";
      }
      if (typeof Date !== "undefined" && data instanceof Date) {
        return "date";
      }
      if (typeof File !== "undefined" && data instanceof File) {
        return "file";
      }
      return "object";
    default:
      throw new Error(`Unknown data type: ${t}`);
  }
};
var propertyKeyTypes = new Set(["string", "number", "symbol"]);
var primitiveTypes = new Set(["string", "number", "bigint", "boolean", "symbol", "undefined"]);
function escapeRegex(str) {
  return str.replace(/[.*+?^${}()|[\]\\]/g, "\\$&");
}
function clone2(inst, def, params) {
  const cl = new inst._zod.constr(def ?? inst._zod.def);
  if (!def || params?.parent)
    cl._zod.parent = inst;
  return cl;
}
function normalizeParams(_params) {
  const params = _params;
  if (!params)
    return {};
  if (typeof params === "string")
    return { error: () => params };
  if (params?.message !== undefined) {
    if (params?.error !== undefined)
      throw new Error("Cannot specify both `message` and `error` params");
    params.error = params.message;
  }
  delete params.message;
  if (typeof params.error === "string")
    return { ...params, error: () => params.error };
  return params;
}
function createTransparentProxy(getter) {
  let target;
  return new Proxy({}, {
    get(_23, prop, receiver) {
      target ?? (target = getter());
      return Reflect.get(target, prop, receiver);
    },
    set(_23, prop, value, receiver) {
      target ?? (target = getter());
      return Reflect.set(target, prop, value, receiver);
    },
    has(_23, prop) {
      target ?? (target = getter());
      return Reflect.has(target, prop);
    },
    deleteProperty(_23, prop) {
      target ?? (target = getter());
      return Reflect.deleteProperty(target, prop);
    },
    ownKeys(_23) {
      target ?? (target = getter());
      return Reflect.ownKeys(target);
    },
    getOwnPropertyDescriptor(_23, prop) {
      target ?? (target = getter());
      return Reflect.getOwnPropertyDescriptor(target, prop);
    },
    defineProperty(_23, prop, descriptor) {
      target ?? (target = getter());
      return Reflect.defineProperty(target, prop, descriptor);
    }
  });
}
function stringifyPrimitive(value) {
  if (typeof value === "bigint")
    return value.toString() + "n";
  if (typeof value === "string")
    return `"${value}"`;
  return `${value}`;
}
function optionalKeys(shape2) {
  return Object.keys(shape2).filter((k) => {
    return shape2[k]._zod.optin === "optional" && shape2[k]._zod.optout === "optional";
  });
}
var NUMBER_FORMAT_RANGES = {
  safeint: [Number.MIN_SAFE_INTEGER, Number.MAX_SAFE_INTEGER],
  int32: [-2147483648, 2147483647],
  uint32: [0, 4294967295],
  float32: [-340282346638528860000000000000000000000, 340282346638528860000000000000000000000],
  float64: [-Number.MAX_VALUE, Number.MAX_VALUE]
};
var BIGINT_FORMAT_RANGES = {
  int64: [/* @__PURE__ */ BigInt("-9223372036854775808"), /* @__PURE__ */ BigInt("9223372036854775807")],
  uint64: [/* @__PURE__ */ BigInt(0), /* @__PURE__ */ BigInt("18446744073709551615")]
};
function pick(schema, mask) {
  const newShape = {};
  const currDef = schema._zod.def;
  for (const key in mask) {
    if (!(key in currDef.shape)) {
      throw new Error(`Unrecognized key: "${key}"`);
    }
    if (!mask[key])
      continue;
    newShape[key] = currDef.shape[key];
  }
  return clone2(schema, {
    ...schema._zod.def,
    shape: newShape,
    checks: []
  });
}
function omit(schema, mask) {
  const newShape = { ...schema._zod.def.shape };
  const currDef = schema._zod.def;
  for (const key in mask) {
    if (!(key in currDef.shape)) {
      throw new Error(`Unrecognized key: "${key}"`);
    }
    if (!mask[key])
      continue;
    delete newShape[key];
  }
  return clone2(schema, {
    ...schema._zod.def,
    shape: newShape,
    checks: []
  });
}
function extend(schema, shape2) {
  if (!isPlainObject(shape2)) {
    throw new Error("Invalid input to extend: expected a plain object");
  }
  const def = {
    ...schema._zod.def,
    get shape() {
      const _shape = { ...schema._zod.def.shape, ...shape2 };
      assignProp(this, "shape", _shape);
      return _shape;
    },
    checks: []
  };
  return clone2(schema, def);
}
function merge(a, b2) {
  return clone2(a, {
    ...a._zod.def,
    get shape() {
      const _shape = { ...a._zod.def.shape, ...b2._zod.def.shape };
      assignProp(this, "shape", _shape);
      return _shape;
    },
    catchall: b2._zod.def.catchall,
    checks: []
  });
}
function partial(Class, schema, mask) {
  const oldShape = schema._zod.def.shape;
  const shape2 = { ...oldShape };
  if (mask) {
    for (const key in mask) {
      if (!(key in oldShape)) {
        throw new Error(`Unrecognized key: "${key}"`);
      }
      if (!mask[key])
        continue;
      shape2[key] = Class ? new Class({
        type: "optional",
        innerType: oldShape[key]
      }) : oldShape[key];
    }
  } else {
    for (const key in oldShape) {
      shape2[key] = Class ? new Class({
        type: "optional",
        innerType: oldShape[key]
      }) : oldShape[key];
    }
  }
  return clone2(schema, {
    ...schema._zod.def,
    shape: shape2,
    checks: []
  });
}
function required(Class, schema, mask) {
  const oldShape = schema._zod.def.shape;
  const shape2 = { ...oldShape };
  if (mask) {
    for (const key in mask) {
      if (!(key in shape2)) {
        throw new Error(`Unrecognized key: "${key}"`);
      }
      if (!mask[key])
        continue;
      shape2[key] = new Class({
        type: "nonoptional",
        innerType: oldShape[key]
      });
    }
  } else {
    for (const key in oldShape) {
      shape2[key] = new Class({
        type: "nonoptional",
        innerType: oldShape[key]
      });
    }
  }
  return clone2(schema, {
    ...schema._zod.def,
    shape: shape2,
    checks: []
  });
}
function aborted(x, startIndex = 0) {
  for (let i = startIndex;i < x.issues.length; i++) {
    if (x.issues[i]?.continue !== true)
      return true;
  }
  return false;
}
function prefixIssues(path2, issues) {
  return issues.map((iss) => {
    var _a;
    (_a = iss).path ?? (_a.path = []);
    iss.path.unshift(path2);
    return iss;
  });
}
function unwrapMessage(message) {
  return typeof message === "string" ? message : message?.message;
}
function finalizeIssue(iss, ctx, config2) {
  const full = { ...iss, path: iss.path ?? [] };
  if (!iss.message) {
    const message = unwrapMessage(iss.inst?._zod.def?.error?.(iss)) ?? unwrapMessage(ctx?.error?.(iss)) ?? unwrapMessage(config2.customError?.(iss)) ?? unwrapMessage(config2.localeError?.(iss)) ?? "Invalid input";
    full.message = message;
  }
  delete full.inst;
  delete full.continue;
  if (!ctx?.reportInput) {
    delete full.input;
  }
  return full;
}
function getSizableOrigin(input) {
  if (input instanceof Set)
    return "set";
  if (input instanceof Map)
    return "map";
  if (input instanceof File)
    return "file";
  return "unknown";
}
function getLengthableOrigin(input) {
  if (Array.isArray(input))
    return "array";
  if (typeof input === "string")
    return "string";
  return "unknown";
}
function issue(...args) {
  const [iss, input, inst] = args;
  if (typeof iss === "string") {
    return {
      message: iss,
      code: "custom",
      input,
      inst
    };
  }
  return { ...iss };
}
function cleanEnum(obj) {
  return Object.entries(obj).filter(([k, _23]) => {
    return Number.isNaN(Number.parseInt(k, 10));
  }).map((el) => el[1]);
}

class Class {
  constructor(..._args) {}
}

// node_modules/zod/v4/core/errors.js
var initializer = (inst, def) => {
  inst.name = "$ZodError";
  Object.defineProperty(inst, "_zod", {
    value: inst._zod,
    enumerable: false
  });
  Object.defineProperty(inst, "issues", {
    value: def,
    enumerable: false
  });
  Object.defineProperty(inst, "message", {
    get() {
      return JSON.stringify(def, jsonStringifyReplacer, 2);
    },
    enumerable: true
  });
  Object.defineProperty(inst, "toString", {
    value: () => inst.message,
    enumerable: false
  });
};
var $ZodError = $constructor("$ZodError", initializer);
var $ZodRealError = $constructor("$ZodError", initializer, { Parent: Error });
function flattenError(error2, mapper = (issue2) => issue2.message) {
  const fieldErrors = {};
  const formErrors = [];
  for (const sub of error2.issues) {
    if (sub.path.length > 0) {
      fieldErrors[sub.path[0]] = fieldErrors[sub.path[0]] || [];
      fieldErrors[sub.path[0]].push(mapper(sub));
    } else {
      formErrors.push(mapper(sub));
    }
  }
  return { formErrors, fieldErrors };
}
function formatError(error2, _mapper) {
  const mapper = _mapper || function(issue2) {
    return issue2.message;
  };
  const fieldErrors = { _errors: [] };
  const processError = (error3) => {
    for (const issue2 of error3.issues) {
      if (issue2.code === "invalid_union" && issue2.errors.length) {
        issue2.errors.map((issues) => processError({ issues }));
      } else if (issue2.code === "invalid_key") {
        processError({ issues: issue2.issues });
      } else if (issue2.code === "invalid_element") {
        processError({ issues: issue2.issues });
      } else if (issue2.path.length === 0) {
        fieldErrors._errors.push(mapper(issue2));
      } else {
        let curr = fieldErrors;
        let i = 0;
        while (i < issue2.path.length) {
          const el = issue2.path[i];
          const terminal = i === issue2.path.length - 1;
          if (!terminal) {
            curr[el] = curr[el] || { _errors: [] };
          } else {
            curr[el] = curr[el] || { _errors: [] };
            curr[el]._errors.push(mapper(issue2));
          }
          curr = curr[el];
          i++;
        }
      }
    }
  };
  processError(error2);
  return fieldErrors;
}
function treeifyError(error2, _mapper) {
  const mapper = _mapper || function(issue2) {
    return issue2.message;
  };
  const result = { errors: [] };
  const processError = (error3, path2 = []) => {
    var _a, _b;
    for (const issue2 of error3.issues) {
      if (issue2.code === "invalid_union" && issue2.errors.length) {
        issue2.errors.map((issues) => processError({ issues }, issue2.path));
      } else if (issue2.code === "invalid_key") {
        processError({ issues: issue2.issues }, issue2.path);
      } else if (issue2.code === "invalid_element") {
        processError({ issues: issue2.issues }, issue2.path);
      } else {
        const fullpath = [...path2, ...issue2.path];
        if (fullpath.length === 0) {
          result.errors.push(mapper(issue2));
          continue;
        }
        let curr = result;
        let i = 0;
        while (i < fullpath.length) {
          const el = fullpath[i];
          const terminal = i === fullpath.length - 1;
          if (typeof el === "string") {
            curr.properties ?? (curr.properties = {});
            (_a = curr.properties)[el] ?? (_a[el] = { errors: [] });
            curr = curr.properties[el];
          } else {
            curr.items ?? (curr.items = []);
            (_b = curr.items)[el] ?? (_b[el] = { errors: [] });
            curr = curr.items[el];
          }
          if (terminal) {
            curr.errors.push(mapper(issue2));
          }
          i++;
        }
      }
    }
  };
  processError(error2);
  return result;
}
function toDotPath(path2) {
  const segs = [];
  for (const seg of path2) {
    if (typeof seg === "number")
      segs.push(`[${seg}]`);
    else if (typeof seg === "symbol")
      segs.push(`[${JSON.stringify(String(seg))}]`);
    else if (/[^\w$]/.test(seg))
      segs.push(`[${JSON.stringify(seg)}]`);
    else {
      if (segs.length)
        segs.push(".");
      segs.push(seg);
    }
  }
  return segs.join("");
}
function prettifyError(error2) {
  const lines = [];
  const issues = [...error2.issues].sort((a, b2) => a.path.length - b2.path.length);
  for (const issue2 of issues) {
    lines.push(` ${issue2.message}`);
    if (issue2.path?.length)
      lines.push(`   at ${toDotPath(issue2.path)}`);
  }
  return lines.join(`
`);
}

// node_modules/zod/v4/core/parse.js
var _parse = (_Err) => (schema, value, _ctx, _params) => {
  const ctx = _ctx ? Object.assign(_ctx, { async: false }) : { async: false };
  const result = schema._zod.run({ value, issues: [] }, ctx);
  if (result instanceof Promise) {
    throw new $ZodAsyncError;
  }
  if (result.issues.length) {
    const e2 = new (_params?.Err ?? _Err)(result.issues.map((iss) => finalizeIssue(iss, ctx, config())));
    captureStackTrace(e2, _params?.callee);
    throw e2;
  }
  return result.value;
};
var parse3 = /* @__PURE__ */ _parse($ZodRealError);
var _parseAsync = (_Err) => async (schema, value, _ctx, params) => {
  const ctx = _ctx ? Object.assign(_ctx, { async: true }) : { async: true };
  let result = schema._zod.run({ value, issues: [] }, ctx);
  if (result instanceof Promise)
    result = await result;
  if (result.issues.length) {
    const e2 = new (params?.Err ?? _Err)(result.issues.map((iss) => finalizeIssue(iss, ctx, config())));
    captureStackTrace(e2, params?.callee);
    throw e2;
  }
  return result.value;
};
var parseAsync = /* @__PURE__ */ _parseAsync($ZodRealError);
var _safeParse = (_Err) => (schema, value, _ctx) => {
  const ctx = _ctx ? { ..._ctx, async: false } : { async: false };
  const result = schema._zod.run({ value, issues: [] }, ctx);
  if (result instanceof Promise) {
    throw new $ZodAsyncError;
  }
  return result.issues.length ? {
    success: false,
    error: new (_Err ?? $ZodError)(result.issues.map((iss) => finalizeIssue(iss, ctx, config())))
  } : { success: true, data: result.value };
};
var safeParse = /* @__PURE__ */ _safeParse($ZodRealError);
var _safeParseAsync = (_Err) => async (schema, value, _ctx) => {
  const ctx = _ctx ? Object.assign(_ctx, { async: true }) : { async: true };
  let result = schema._zod.run({ value, issues: [] }, ctx);
  if (result instanceof Promise)
    result = await result;
  return result.issues.length ? {
    success: false,
    error: new _Err(result.issues.map((iss) => finalizeIssue(iss, ctx, config())))
  } : { success: true, data: result.value };
};
var safeParseAsync = /* @__PURE__ */ _safeParseAsync($ZodRealError);
// node_modules/zod/v4/core/regexes.js
var exports_regexes = {};
__export(exports_regexes, {
  xid: () => xid,
  uuid7: () => uuid7,
  uuid6: () => uuid6,
  uuid4: () => uuid4,
  uuid: () => uuid,
  uppercase: () => uppercase,
  unicodeEmail: () => unicodeEmail,
  undefined: () => _undefined,
  ulid: () => ulid,
  time: () => time,
  string: () => string,
  rfc5322Email: () => rfc5322Email,
  number: () => number,
  null: () => _null,
  nanoid: () => nanoid,
  lowercase: () => lowercase,
  ksuid: () => ksuid,
  ipv6: () => ipv6,
  ipv4: () => ipv4,
  integer: () => integer,
  html5Email: () => html5Email,
  hostname: () => hostname,
  guid: () => guid,
  extendedDuration: () => extendedDuration,
  emoji: () => emoji,
  email: () => email,
  e164: () => e164,
  duration: () => duration,
  domain: () => domain,
  datetime: () => datetime,
  date: () => date,
  cuid2: () => cuid2,
  cuid: () => cuid,
  cidrv6: () => cidrv6,
  cidrv4: () => cidrv4,
  browserEmail: () => browserEmail,
  boolean: () => boolean,
  bigint: () => bigint,
  base64url: () => base64url,
  base64: () => base64,
  _emoji: () => _emoji
});
var cuid = /^[cC][^\s-]{8,}$/;
var cuid2 = /^[0-9a-z]+$/;
var ulid = /^[0-9A-HJKMNP-TV-Za-hjkmnp-tv-z]{26}$/;
var xid = /^[0-9a-vA-V]{20}$/;
var ksuid = /^[A-Za-z0-9]{27}$/;
var nanoid = /^[a-zA-Z0-9_-]{21}$/;
var duration = /^P(?:(\d+W)|(?!.*W)(?=\d|T\d)(\d+Y)?(\d+M)?(\d+D)?(T(?=\d)(\d+H)?(\d+M)?(\d+([.,]\d+)?S)?)?)$/;
var extendedDuration = /^[-+]?P(?!$)(?:(?:[-+]?\d+Y)|(?:[-+]?\d+[.,]\d+Y$))?(?:(?:[-+]?\d+M)|(?:[-+]?\d+[.,]\d+M$))?(?:(?:[-+]?\d+W)|(?:[-+]?\d+[.,]\d+W$))?(?:(?:[-+]?\d+D)|(?:[-+]?\d+[.,]\d+D$))?(?:T(?=[\d+-])(?:(?:[-+]?\d+H)|(?:[-+]?\d+[.,]\d+H$))?(?:(?:[-+]?\d+M)|(?:[-+]?\d+[.,]\d+M$))?(?:[-+]?\d+(?:[.,]\d+)?S)?)??$/;
var guid = /^([0-9a-fA-F]{8}-[0-9a-fA-F]{4}-[0-9a-fA-F]{4}-[0-9a-fA-F]{4}-[0-9a-fA-F]{12})$/;
var uuid = (version) => {
  if (!version)
    return /^([0-9a-fA-F]{8}-[0-9a-fA-F]{4}-[1-8][0-9a-fA-F]{3}-[89abAB][0-9a-fA-F]{3}-[0-9a-fA-F]{12}|00000000-0000-0000-0000-000000000000)$/;
  return new RegExp(`^([0-9a-fA-F]{8}-[0-9a-fA-F]{4}-${version}[0-9a-fA-F]{3}-[89abAB][0-9a-fA-F]{3}-[0-9a-fA-F]{12})$`);
};
var uuid4 = /* @__PURE__ */ uuid(4);
var uuid6 = /* @__PURE__ */ uuid(6);
var uuid7 = /* @__PURE__ */ uuid(7);
var email = /^(?!\.)(?!.*\.\.)([A-Za-z0-9_'+\-\.]*)[A-Za-z0-9_+-]@([A-Za-z0-9][A-Za-z0-9\-]*\.)+[A-Za-z]{2,}$/;
var html5Email = /^[a-zA-Z0-9.!#$%&'*+/=?^_`{|}~-]+@[a-zA-Z0-9](?:[a-zA-Z0-9-]{0,61}[a-zA-Z0-9])?(?:\.[a-zA-Z0-9](?:[a-zA-Z0-9-]{0,61}[a-zA-Z0-9])?)*$/;
var rfc5322Email = /^(([^<>()\[\]\\.,;:\s@"]+(\.[^<>()\[\]\\.,;:\s@"]+)*)|(".+"))@((\[[0-9]{1,3}\.[0-9]{1,3}\.[0-9]{1,3}\.[0-9]{1,3}])|(([a-zA-Z\-0-9]+\.)+[a-zA-Z]{2,}))$/;
var unicodeEmail = /^[^\s@"]{1,64}@[^\s@]{1,255}$/u;
var browserEmail = /^[a-zA-Z0-9.!#$%&'*+/=?^_`{|}~-]+@[a-zA-Z0-9](?:[a-zA-Z0-9-]{0,61}[a-zA-Z0-9])?(?:\.[a-zA-Z0-9](?:[a-zA-Z0-9-]{0,61}[a-zA-Z0-9])?)*$/;
var _emoji = `^(\\p{Extended_Pictographic}|\\p{Emoji_Component})+$`;
function emoji() {
  return new RegExp(_emoji, "u");
}
var ipv4 = /^(?:(?:25[0-5]|2[0-4][0-9]|1[0-9][0-9]|[1-9][0-9]|[0-9])\.){3}(?:25[0-5]|2[0-4][0-9]|1[0-9][0-9]|[1-9][0-9]|[0-9])$/;
var ipv6 = /^(([0-9a-fA-F]{1,4}:){7}[0-9a-fA-F]{1,4}|::|([0-9a-fA-F]{1,4})?::([0-9a-fA-F]{1,4}:?){0,6})$/;
var cidrv4 = /^((25[0-5]|2[0-4][0-9]|1[0-9][0-9]|[1-9][0-9]|[0-9])\.){3}(25[0-5]|2[0-4][0-9]|1[0-9][0-9]|[1-9][0-9]|[0-9])\/([0-9]|[1-2][0-9]|3[0-2])$/;
var cidrv6 = /^(([0-9a-fA-F]{1,4}:){7}[0-9a-fA-F]{1,4}|::|([0-9a-fA-F]{1,4})?::([0-9a-fA-F]{1,4}:?){0,6})\/(12[0-8]|1[01][0-9]|[1-9]?[0-9])$/;
var base64 = /^$|^(?:[0-9a-zA-Z+/]{4})*(?:(?:[0-9a-zA-Z+/]{2}==)|(?:[0-9a-zA-Z+/]{3}=))?$/;
var base64url = /^[A-Za-z0-9_-]*$/;
var hostname = /^([a-zA-Z0-9-]+\.)*[a-zA-Z0-9-]+$/;
var domain = /^([a-zA-Z0-9](?:[a-zA-Z0-9-]{0,61}[a-zA-Z0-9])?\.)+[a-zA-Z]{2,}$/;
var e164 = /^\+(?:[0-9]){6,14}[0-9]$/;
var dateSource = `(?:(?:\\d\\d[2468][048]|\\d\\d[13579][26]|\\d\\d0[48]|[02468][048]00|[13579][26]00)-02-29|\\d{4}-(?:(?:0[13578]|1[02])-(?:0[1-9]|[12]\\d|3[01])|(?:0[469]|11)-(?:0[1-9]|[12]\\d|30)|(?:02)-(?:0[1-9]|1\\d|2[0-8])))`;
var date = /* @__PURE__ */ new RegExp(`^${dateSource}$`);
function timeSource(args) {
  const hhmm = `(?:[01]\\d|2[0-3]):[0-5]\\d`;
  const regex = typeof args.precision === "number" ? args.precision === -1 ? `${hhmm}` : args.precision === 0 ? `${hhmm}:[0-5]\\d` : `${hhmm}:[0-5]\\d\\.\\d{${args.precision}}` : `${hhmm}(?::[0-5]\\d(?:\\.\\d+)?)?`;
  return regex;
}
function time(args) {
  return new RegExp(`^${timeSource(args)}$`);
}
function datetime(args) {
  const time2 = timeSource({ precision: args.precision });
  const opts = ["Z"];
  if (args.local)
    opts.push("");
  if (args.offset)
    opts.push(`([+-]\\d{2}:\\d{2})`);
  const timeRegex = `${time2}(?:${opts.join("|")})`;
  return new RegExp(`^${dateSource}T(?:${timeRegex})$`);
}
var string = (params) => {
  const regex = params ? `[\\s\\S]{${params?.minimum ?? 0},${params?.maximum ?? ""}}` : `[\\s\\S]*`;
  return new RegExp(`^${regex}$`);
};
var bigint = /^\d+n?$/;
var integer = /^\d+$/;
var number = /^-?\d+(?:\.\d+)?/i;
var boolean = /true|false/i;
var _null = /null/i;
var _undefined = /undefined/i;
var lowercase = /^[^A-Z]*$/;
var uppercase = /^[^a-z]*$/;

// node_modules/zod/v4/core/checks.js
var $ZodCheck = /* @__PURE__ */ $constructor("$ZodCheck", (inst, def) => {
  var _a;
  inst._zod ?? (inst._zod = {});
  inst._zod.def = def;
  (_a = inst._zod).onattach ?? (_a.onattach = []);
});
var numericOriginMap = {
  number: "number",
  bigint: "bigint",
  object: "date"
};
var $ZodCheckLessThan = /* @__PURE__ */ $constructor("$ZodCheckLessThan", (inst, def) => {
  $ZodCheck.init(inst, def);
  const origin = numericOriginMap[typeof def.value];
  inst._zod.onattach.push((inst2) => {
    const bag = inst2._zod.bag;
    const curr = (def.inclusive ? bag.maximum : bag.exclusiveMaximum) ?? Number.POSITIVE_INFINITY;
    if (def.value < curr) {
      if (def.inclusive)
        bag.maximum = def.value;
      else
        bag.exclusiveMaximum = def.value;
    }
  });
  inst._zod.check = (payload) => {
    if (def.inclusive ? payload.value <= def.value : payload.value < def.value) {
      return;
    }
    payload.issues.push({
      origin,
      code: "too_big",
      maximum: def.value,
      input: payload.value,
      inclusive: def.inclusive,
      inst,
      continue: !def.abort
    });
  };
});
var $ZodCheckGreaterThan = /* @__PURE__ */ $constructor("$ZodCheckGreaterThan", (inst, def) => {
  $ZodCheck.init(inst, def);
  const origin = numericOriginMap[typeof def.value];
  inst._zod.onattach.push((inst2) => {
    const bag = inst2._zod.bag;
    const curr = (def.inclusive ? bag.minimum : bag.exclusiveMinimum) ?? Number.NEGATIVE_INFINITY;
    if (def.value > curr) {
      if (def.inclusive)
        bag.minimum = def.value;
      else
        bag.exclusiveMinimum = def.value;
    }
  });
  inst._zod.check = (payload) => {
    if (def.inclusive ? payload.value >= def.value : payload.value > def.value) {
      return;
    }
    payload.issues.push({
      origin,
      code: "too_small",
      minimum: def.value,
      input: payload.value,
      inclusive: def.inclusive,
      inst,
      continue: !def.abort
    });
  };
});
var $ZodCheckMultipleOf = /* @__PURE__ */ $constructor("$ZodCheckMultipleOf", (inst, def) => {
  $ZodCheck.init(inst, def);
  inst._zod.onattach.push((inst2) => {
    var _a;
    (_a = inst2._zod.bag).multipleOf ?? (_a.multipleOf = def.value);
  });
  inst._zod.check = (payload) => {
    if (typeof payload.value !== typeof def.value)
      throw new Error("Cannot mix number and bigint in multiple_of check.");
    const isMultiple = typeof payload.value === "bigint" ? payload.value % def.value === BigInt(0) : floatSafeRemainder(payload.value, def.value) === 0;
    if (isMultiple)
      return;
    payload.issues.push({
      origin: typeof payload.value,
      code: "not_multiple_of",
      divisor: def.value,
      input: payload.value,
      inst,
      continue: !def.abort
    });
  };
});
var $ZodCheckNumberFormat = /* @__PURE__ */ $constructor("$ZodCheckNumberFormat", (inst, def) => {
  $ZodCheck.init(inst, def);
  def.format = def.format || "float64";
  const isInt = def.format?.includes("int");
  const origin = isInt ? "int" : "number";
  const [minimum, maximum] = NUMBER_FORMAT_RANGES[def.format];
  inst._zod.onattach.push((inst2) => {
    const bag = inst2._zod.bag;
    bag.format = def.format;
    bag.minimum = minimum;
    bag.maximum = maximum;
    if (isInt)
      bag.pattern = integer;
  });
  inst._zod.check = (payload) => {
    const input = payload.value;
    if (isInt) {
      if (!Number.isInteger(input)) {
        payload.issues.push({
          expected: origin,
          format: def.format,
          code: "invalid_type",
          input,
          inst
        });
        return;
      }
      if (!Number.isSafeInteger(input)) {
        if (input > 0) {
          payload.issues.push({
            input,
            code: "too_big",
            maximum: Number.MAX_SAFE_INTEGER,
            note: "Integers must be within the safe integer range.",
            inst,
            origin,
            continue: !def.abort
          });
        } else {
          payload.issues.push({
            input,
            code: "too_small",
            minimum: Number.MIN_SAFE_INTEGER,
            note: "Integers must be within the safe integer range.",
            inst,
            origin,
            continue: !def.abort
          });
        }
        return;
      }
    }
    if (input < minimum) {
      payload.issues.push({
        origin: "number",
        input,
        code: "too_small",
        minimum,
        inclusive: true,
        inst,
        continue: !def.abort
      });
    }
    if (input > maximum) {
      payload.issues.push({
        origin: "number",
        input,
        code: "too_big",
        maximum,
        inst
      });
    }
  };
});
var $ZodCheckBigIntFormat = /* @__PURE__ */ $constructor("$ZodCheckBigIntFormat", (inst, def) => {
  $ZodCheck.init(inst, def);
  const [minimum, maximum] = BIGINT_FORMAT_RANGES[def.format];
  inst._zod.onattach.push((inst2) => {
    const bag = inst2._zod.bag;
    bag.format = def.format;
    bag.minimum = minimum;
    bag.maximum = maximum;
  });
  inst._zod.check = (payload) => {
    const input = payload.value;
    if (input < minimum) {
      payload.issues.push({
        origin: "bigint",
        input,
        code: "too_small",
        minimum,
        inclusive: true,
        inst,
        continue: !def.abort
      });
    }
    if (input > maximum) {
      payload.issues.push({
        origin: "bigint",
        input,
        code: "too_big",
        maximum,
        inst
      });
    }
  };
});
var $ZodCheckMaxSize = /* @__PURE__ */ $constructor("$ZodCheckMaxSize", (inst, def) => {
  var _a;
  $ZodCheck.init(inst, def);
  (_a = inst._zod.def).when ?? (_a.when = (payload) => {
    const val = payload.value;
    return !nullish(val) && val.size !== undefined;
  });
  inst._zod.onattach.push((inst2) => {
    const curr = inst2._zod.bag.maximum ?? Number.POSITIVE_INFINITY;
    if (def.maximum < curr)
      inst2._zod.bag.maximum = def.maximum;
  });
  inst._zod.check = (payload) => {
    const input = payload.value;
    const size = input.size;
    if (size <= def.maximum)
      return;
    payload.issues.push({
      origin: getSizableOrigin(input),
      code: "too_big",
      maximum: def.maximum,
      input,
      inst,
      continue: !def.abort
    });
  };
});
var $ZodCheckMinSize = /* @__PURE__ */ $constructor("$ZodCheckMinSize", (inst, def) => {
  var _a;
  $ZodCheck.init(inst, def);
  (_a = inst._zod.def).when ?? (_a.when = (payload) => {
    const val = payload.value;
    return !nullish(val) && val.size !== undefined;
  });
  inst._zod.onattach.push((inst2) => {
    const curr = inst2._zod.bag.minimum ?? Number.NEGATIVE_INFINITY;
    if (def.minimum > curr)
      inst2._zod.bag.minimum = def.minimum;
  });
  inst._zod.check = (payload) => {
    const input = payload.value;
    const size = input.size;
    if (size >= def.minimum)
      return;
    payload.issues.push({
      origin: getSizableOrigin(input),
      code: "too_small",
      minimum: def.minimum,
      input,
      inst,
      continue: !def.abort
    });
  };
});
var $ZodCheckSizeEquals = /* @__PURE__ */ $constructor("$ZodCheckSizeEquals", (inst, def) => {
  var _a;
  $ZodCheck.init(inst, def);
  (_a = inst._zod.def).when ?? (_a.when = (payload) => {
    const val = payload.value;
    return !nullish(val) && val.size !== undefined;
  });
  inst._zod.onattach.push((inst2) => {
    const bag = inst2._zod.bag;
    bag.minimum = def.size;
    bag.maximum = def.size;
    bag.size = def.size;
  });
  inst._zod.check = (payload) => {
    const input = payload.value;
    const size = input.size;
    if (size === def.size)
      return;
    const tooBig = size > def.size;
    payload.issues.push({
      origin: getSizableOrigin(input),
      ...tooBig ? { code: "too_big", maximum: def.size } : { code: "too_small", minimum: def.size },
      inclusive: true,
      exact: true,
      input: payload.value,
      inst,
      continue: !def.abort
    });
  };
});
var $ZodCheckMaxLength = /* @__PURE__ */ $constructor("$ZodCheckMaxLength", (inst, def) => {
  var _a;
  $ZodCheck.init(inst, def);
  (_a = inst._zod.def).when ?? (_a.when = (payload) => {
    const val = payload.value;
    return !nullish(val) && val.length !== undefined;
  });
  inst._zod.onattach.push((inst2) => {
    const curr = inst2._zod.bag.maximum ?? Number.POSITIVE_INFINITY;
    if (def.maximum < curr)
      inst2._zod.bag.maximum = def.maximum;
  });
  inst._zod.check = (payload) => {
    const input = payload.value;
    const length = input.length;
    if (length <= def.maximum)
      return;
    const origin = getLengthableOrigin(input);
    payload.issues.push({
      origin,
      code: "too_big",
      maximum: def.maximum,
      inclusive: true,
      input,
      inst,
      continue: !def.abort
    });
  };
});
var $ZodCheckMinLength = /* @__PURE__ */ $constructor("$ZodCheckMinLength", (inst, def) => {
  var _a;
  $ZodCheck.init(inst, def);
  (_a = inst._zod.def).when ?? (_a.when = (payload) => {
    const val = payload.value;
    return !nullish(val) && val.length !== undefined;
  });
  inst._zod.onattach.push((inst2) => {
    const curr = inst2._zod.bag.minimum ?? Number.NEGATIVE_INFINITY;
    if (def.minimum > curr)
      inst2._zod.bag.minimum = def.minimum;
  });
  inst._zod.check = (payload) => {
    const input = payload.value;
    const length = input.length;
    if (length >= def.minimum)
      return;
    const origin = getLengthableOrigin(input);
    payload.issues.push({
      origin,
      code: "too_small",
      minimum: def.minimum,
      inclusive: true,
      input,
      inst,
      continue: !def.abort
    });
  };
});
var $ZodCheckLengthEquals = /* @__PURE__ */ $constructor("$ZodCheckLengthEquals", (inst, def) => {
  var _a;
  $ZodCheck.init(inst, def);
  (_a = inst._zod.def).when ?? (_a.when = (payload) => {
    const val = payload.value;
    return !nullish(val) && val.length !== undefined;
  });
  inst._zod.onattach.push((inst2) => {
    const bag = inst2._zod.bag;
    bag.minimum = def.length;
    bag.maximum = def.length;
    bag.length = def.length;
  });
  inst._zod.check = (payload) => {
    const input = payload.value;
    const length = input.length;
    if (length === def.length)
      return;
    const origin = getLengthableOrigin(input);
    const tooBig = length > def.length;
    payload.issues.push({
      origin,
      ...tooBig ? { code: "too_big", maximum: def.length } : { code: "too_small", minimum: def.length },
      inclusive: true,
      exact: true,
      input: payload.value,
      inst,
      continue: !def.abort
    });
  };
});
var $ZodCheckStringFormat = /* @__PURE__ */ $constructor("$ZodCheckStringFormat", (inst, def) => {
  var _a, _b;
  $ZodCheck.init(inst, def);
  inst._zod.onattach.push((inst2) => {
    const bag = inst2._zod.bag;
    bag.format = def.format;
    if (def.pattern) {
      bag.patterns ?? (bag.patterns = new Set);
      bag.patterns.add(def.pattern);
    }
  });
  if (def.pattern)
    (_a = inst._zod).check ?? (_a.check = (payload) => {
      def.pattern.lastIndex = 0;
      if (def.pattern.test(payload.value))
        return;
      payload.issues.push({
        origin: "string",
        code: "invalid_format",
        format: def.format,
        input: payload.value,
        ...def.pattern ? { pattern: def.pattern.toString() } : {},
        inst,
        continue: !def.abort
      });
    });
  else
    (_b = inst._zod).check ?? (_b.check = () => {});
});
var $ZodCheckRegex = /* @__PURE__ */ $constructor("$ZodCheckRegex", (inst, def) => {
  $ZodCheckStringFormat.init(inst, def);
  inst._zod.check = (payload) => {
    def.pattern.lastIndex = 0;
    if (def.pattern.test(payload.value))
      return;
    payload.issues.push({
      origin: "string",
      code: "invalid_format",
      format: "regex",
      input: payload.value,
      pattern: def.pattern.toString(),
      inst,
      continue: !def.abort
    });
  };
});
var $ZodCheckLowerCase = /* @__PURE__ */ $constructor("$ZodCheckLowerCase", (inst, def) => {
  def.pattern ?? (def.pattern = lowercase);
  $ZodCheckStringFormat.init(inst, def);
});
var $ZodCheckUpperCase = /* @__PURE__ */ $constructor("$ZodCheckUpperCase", (inst, def) => {
  def.pattern ?? (def.pattern = uppercase);
  $ZodCheckStringFormat.init(inst, def);
});
var $ZodCheckIncludes = /* @__PURE__ */ $constructor("$ZodCheckIncludes", (inst, def) => {
  $ZodCheck.init(inst, def);
  const escapedRegex = escapeRegex(def.includes);
  const pattern = new RegExp(typeof def.position === "number" ? `^.{${def.position}}${escapedRegex}` : escapedRegex);
  def.pattern = pattern;
  inst._zod.onattach.push((inst2) => {
    const bag = inst2._zod.bag;
    bag.patterns ?? (bag.patterns = new Set);
    bag.patterns.add(pattern);
  });
  inst._zod.check = (payload) => {
    if (payload.value.includes(def.includes, def.position))
      return;
    payload.issues.push({
      origin: "string",
      code: "invalid_format",
      format: "includes",
      includes: def.includes,
      input: payload.value,
      inst,
      continue: !def.abort
    });
  };
});
var $ZodCheckStartsWith = /* @__PURE__ */ $constructor("$ZodCheckStartsWith", (inst, def) => {
  $ZodCheck.init(inst, def);
  const pattern = new RegExp(`^${escapeRegex(def.prefix)}.*`);
  def.pattern ?? (def.pattern = pattern);
  inst._zod.onattach.push((inst2) => {
    const bag = inst2._zod.bag;
    bag.patterns ?? (bag.patterns = new Set);
    bag.patterns.add(pattern);
  });
  inst._zod.check = (payload) => {
    if (payload.value.startsWith(def.prefix))
      return;
    payload.issues.push({
      origin: "string",
      code: "invalid_format",
      format: "starts_with",
      prefix: def.prefix,
      input: payload.value,
      inst,
      continue: !def.abort
    });
  };
});
var $ZodCheckEndsWith = /* @__PURE__ */ $constructor("$ZodCheckEndsWith", (inst, def) => {
  $ZodCheck.init(inst, def);
  const pattern = new RegExp(`.*${escapeRegex(def.suffix)}$`);
  def.pattern ?? (def.pattern = pattern);
  inst._zod.onattach.push((inst2) => {
    const bag = inst2._zod.bag;
    bag.patterns ?? (bag.patterns = new Set);
    bag.patterns.add(pattern);
  });
  inst._zod.check = (payload) => {
    if (payload.value.endsWith(def.suffix))
      return;
    payload.issues.push({
      origin: "string",
      code: "invalid_format",
      format: "ends_with",
      suffix: def.suffix,
      input: payload.value,
      inst,
      continue: !def.abort
    });
  };
});
function handleCheckPropertyResult(result, payload, property) {
  if (result.issues.length) {
    payload.issues.push(...prefixIssues(property, result.issues));
  }
}
var $ZodCheckProperty = /* @__PURE__ */ $constructor("$ZodCheckProperty", (inst, def) => {
  $ZodCheck.init(inst, def);
  inst._zod.check = (payload) => {
    const result = def.schema._zod.run({
      value: payload.value[def.property],
      issues: []
    }, {});
    if (result instanceof Promise) {
      return result.then((result2) => handleCheckPropertyResult(result2, payload, def.property));
    }
    handleCheckPropertyResult(result, payload, def.property);
    return;
  };
});
var $ZodCheckMimeType = /* @__PURE__ */ $constructor("$ZodCheckMimeType", (inst, def) => {
  $ZodCheck.init(inst, def);
  const mimeSet = new Set(def.mime);
  inst._zod.onattach.push((inst2) => {
    inst2._zod.bag.mime = def.mime;
  });
  inst._zod.check = (payload) => {
    if (mimeSet.has(payload.value.type))
      return;
    payload.issues.push({
      code: "invalid_value",
      values: def.mime,
      input: payload.value.type,
      inst
    });
  };
});
var $ZodCheckOverwrite = /* @__PURE__ */ $constructor("$ZodCheckOverwrite", (inst, def) => {
  $ZodCheck.init(inst, def);
  inst._zod.check = (payload) => {
    payload.value = def.tx(payload.value);
  };
});

// node_modules/zod/v4/core/doc.js
class Doc {
  constructor(args = []) {
    this.content = [];
    this.indent = 0;
    if (this)
      this.args = args;
  }
  indented(fn2) {
    this.indent += 1;
    fn2(this);
    this.indent -= 1;
  }
  write(arg) {
    if (typeof arg === "function") {
      arg(this, { execution: "sync" });
      arg(this, { execution: "async" });
      return;
    }
    const content = arg;
    const lines = content.split(`
`).filter((x) => x);
    const minIndent = Math.min(...lines.map((x) => x.length - x.trimStart().length));
    const dedented = lines.map((x) => x.slice(minIndent)).map((x) => " ".repeat(this.indent * 2) + x);
    for (const line of dedented) {
      this.content.push(line);
    }
  }
  compile() {
    const F = Function;
    const args = this?.args;
    const content = this?.content ?? [``];
    const lines = [...content.map((x) => `  ${x}`)];
    return new F(...args, lines.join(`
`));
  }
}

// node_modules/zod/v4/core/versions.js
var version = {
  major: 4,
  minor: 0,
  patch: 0
};

// node_modules/zod/v4/core/schemas.js
var $ZodType = /* @__PURE__ */ $constructor("$ZodType", (inst, def) => {
  var _a;
  inst ?? (inst = {});
  inst._zod.def = def;
  inst._zod.bag = inst._zod.bag || {};
  inst._zod.version = version;
  const checks = [...inst._zod.def.checks ?? []];
  if (inst._zod.traits.has("$ZodCheck")) {
    checks.unshift(inst);
  }
  for (const ch of checks) {
    for (const fn2 of ch._zod.onattach) {
      fn2(inst);
    }
  }
  if (checks.length === 0) {
    (_a = inst._zod).deferred ?? (_a.deferred = []);
    inst._zod.deferred?.push(() => {
      inst._zod.run = inst._zod.parse;
    });
  } else {
    const runChecks = (payload, checks2, ctx) => {
      let isAborted = aborted(payload);
      let asyncResult;
      for (const ch of checks2) {
        if (ch._zod.def.when) {
          const shouldRun = ch._zod.def.when(payload);
          if (!shouldRun)
            continue;
        } else if (isAborted) {
          continue;
        }
        const currLen = payload.issues.length;
        const _23 = ch._zod.check(payload);
        if (_23 instanceof Promise && ctx?.async === false) {
          throw new $ZodAsyncError;
        }
        if (asyncResult || _23 instanceof Promise) {
          asyncResult = (asyncResult ?? Promise.resolve()).then(async () => {
            await _23;
            const nextLen = payload.issues.length;
            if (nextLen === currLen)
              return;
            if (!isAborted)
              isAborted = aborted(payload, currLen);
          });
        } else {
          const nextLen = payload.issues.length;
          if (nextLen === currLen)
            continue;
          if (!isAborted)
            isAborted = aborted(payload, currLen);
        }
      }
      if (asyncResult) {
        return asyncResult.then(() => {
          return payload;
        });
      }
      return payload;
    };
    inst._zod.run = (payload, ctx) => {
      const result = inst._zod.parse(payload, ctx);
      if (result instanceof Promise) {
        if (ctx.async === false)
          throw new $ZodAsyncError;
        return result.then((result2) => runChecks(result2, checks, ctx));
      }
      return runChecks(result, checks, ctx);
    };
  }
  inst["~standard"] = {
    validate: (value) => {
      try {
        const r = safeParse(inst, value);
        return r.success ? { value: r.data } : { issues: r.error?.issues };
      } catch (_23) {
        return safeParseAsync(inst, value).then((r) => r.success ? { value: r.data } : { issues: r.error?.issues });
      }
    },
    vendor: "zod",
    version: 1
  };
});
var $ZodString = /* @__PURE__ */ $constructor("$ZodString", (inst, def) => {
  $ZodType.init(inst, def);
  inst._zod.pattern = [...inst?._zod.bag?.patterns ?? []].pop() ?? string(inst._zod.bag);
  inst._zod.parse = (payload, _23) => {
    if (def.coerce)
      try {
        payload.value = String(payload.value);
      } catch (_24) {}
    if (typeof payload.value === "string")
      return payload;
    payload.issues.push({
      expected: "string",
      code: "invalid_type",
      input: payload.value,
      inst
    });
    return payload;
  };
});
var $ZodStringFormat = /* @__PURE__ */ $constructor("$ZodStringFormat", (inst, def) => {
  $ZodCheckStringFormat.init(inst, def);
  $ZodString.init(inst, def);
});
var $ZodGUID = /* @__PURE__ */ $constructor("$ZodGUID", (inst, def) => {
  def.pattern ?? (def.pattern = guid);
  $ZodStringFormat.init(inst, def);
});
var $ZodUUID = /* @__PURE__ */ $constructor("$ZodUUID", (inst, def) => {
  if (def.version) {
    const versionMap = {
      v1: 1,
      v2: 2,
      v3: 3,
      v4: 4,
      v5: 5,
      v6: 6,
      v7: 7,
      v8: 8
    };
    const v = versionMap[def.version];
    if (v === undefined)
      throw new Error(`Invalid UUID version: "${def.version}"`);
    def.pattern ?? (def.pattern = uuid(v));
  } else
    def.pattern ?? (def.pattern = uuid());
  $ZodStringFormat.init(inst, def);
});
var $ZodEmail = /* @__PURE__ */ $constructor("$ZodEmail", (inst, def) => {
  def.pattern ?? (def.pattern = email);
  $ZodStringFormat.init(inst, def);
});
var $ZodURL = /* @__PURE__ */ $constructor("$ZodURL", (inst, def) => {
  $ZodStringFormat.init(inst, def);
  inst._zod.check = (payload) => {
    try {
      const orig = payload.value;
      const url = new URL(orig);
      const href = url.href;
      if (def.hostname) {
        def.hostname.lastIndex = 0;
        if (!def.hostname.test(url.hostname)) {
          payload.issues.push({
            code: "invalid_format",
            format: "url",
            note: "Invalid hostname",
            pattern: hostname.source,
            input: payload.value,
            inst,
            continue: !def.abort
          });
        }
      }
      if (def.protocol) {
        def.protocol.lastIndex = 0;
        if (!def.protocol.test(url.protocol.endsWith(":") ? url.protocol.slice(0, -1) : url.protocol)) {
          payload.issues.push({
            code: "invalid_format",
            format: "url",
            note: "Invalid protocol",
            pattern: def.protocol.source,
            input: payload.value,
            inst,
            continue: !def.abort
          });
        }
      }
      if (!orig.endsWith("/") && href.endsWith("/")) {
        payload.value = href.slice(0, -1);
      } else {
        payload.value = href;
      }
      return;
    } catch (_23) {
      payload.issues.push({
        code: "invalid_format",
        format: "url",
        input: payload.value,
        inst,
        continue: !def.abort
      });
    }
  };
});
var $ZodEmoji = /* @__PURE__ */ $constructor("$ZodEmoji", (inst, def) => {
  def.pattern ?? (def.pattern = emoji());
  $ZodStringFormat.init(inst, def);
});
var $ZodNanoID = /* @__PURE__ */ $constructor("$ZodNanoID", (inst, def) => {
  def.pattern ?? (def.pattern = nanoid);
  $ZodStringFormat.init(inst, def);
});
var $ZodCUID = /* @__PURE__ */ $constructor("$ZodCUID", (inst, def) => {
  def.pattern ?? (def.pattern = cuid);
  $ZodStringFormat.init(inst, def);
});
var $ZodCUID2 = /* @__PURE__ */ $constructor("$ZodCUID2", (inst, def) => {
  def.pattern ?? (def.pattern = cuid2);
  $ZodStringFormat.init(inst, def);
});
var $ZodULID = /* @__PURE__ */ $constructor("$ZodULID", (inst, def) => {
  def.pattern ?? (def.pattern = ulid);
  $ZodStringFormat.init(inst, def);
});
var $ZodXID = /* @__PURE__ */ $constructor("$ZodXID", (inst, def) => {
  def.pattern ?? (def.pattern = xid);
  $ZodStringFormat.init(inst, def);
});
var $ZodKSUID = /* @__PURE__ */ $constructor("$ZodKSUID", (inst, def) => {
  def.pattern ?? (def.pattern = ksuid);
  $ZodStringFormat.init(inst, def);
});
var $ZodISODateTime = /* @__PURE__ */ $constructor("$ZodISODateTime", (inst, def) => {
  def.pattern ?? (def.pattern = datetime(def));
  $ZodStringFormat.init(inst, def);
});
var $ZodISODate = /* @__PURE__ */ $constructor("$ZodISODate", (inst, def) => {
  def.pattern ?? (def.pattern = date);
  $ZodStringFormat.init(inst, def);
});
var $ZodISOTime = /* @__PURE__ */ $constructor("$ZodISOTime", (inst, def) => {
  def.pattern ?? (def.pattern = time(def));
  $ZodStringFormat.init(inst, def);
});
var $ZodISODuration = /* @__PURE__ */ $constructor("$ZodISODuration", (inst, def) => {
  def.pattern ?? (def.pattern = duration);
  $ZodStringFormat.init(inst, def);
});
var $ZodIPv4 = /* @__PURE__ */ $constructor("$ZodIPv4", (inst, def) => {
  def.pattern ?? (def.pattern = ipv4);
  $ZodStringFormat.init(inst, def);
  inst._zod.onattach.push((inst2) => {
    const bag = inst2._zod.bag;
    bag.format = `ipv4`;
  });
});
var $ZodIPv6 = /* @__PURE__ */ $constructor("$ZodIPv6", (inst, def) => {
  def.pattern ?? (def.pattern = ipv6);
  $ZodStringFormat.init(inst, def);
  inst._zod.onattach.push((inst2) => {
    const bag = inst2._zod.bag;
    bag.format = `ipv6`;
  });
  inst._zod.check = (payload) => {
    try {
      new URL(`http://[${payload.value}]`);
    } catch {
      payload.issues.push({
        code: "invalid_format",
        format: "ipv6",
        input: payload.value,
        inst,
        continue: !def.abort
      });
    }
  };
});
var $ZodCIDRv4 = /* @__PURE__ */ $constructor("$ZodCIDRv4", (inst, def) => {
  def.pattern ?? (def.pattern = cidrv4);
  $ZodStringFormat.init(inst, def);
});
var $ZodCIDRv6 = /* @__PURE__ */ $constructor("$ZodCIDRv6", (inst, def) => {
  def.pattern ?? (def.pattern = cidrv6);
  $ZodStringFormat.init(inst, def);
  inst._zod.check = (payload) => {
    const [address, prefix] = payload.value.split("/");
    try {
      if (!prefix)
        throw new Error;
      const prefixNum = Number(prefix);
      if (`${prefixNum}` !== prefix)
        throw new Error;
      if (prefixNum < 0 || prefixNum > 128)
        throw new Error;
      new URL(`http://[${address}]`);
    } catch {
      payload.issues.push({
        code: "invalid_format",
        format: "cidrv6",
        input: payload.value,
        inst,
        continue: !def.abort
      });
    }
  };
});
function isValidBase64(data) {
  if (data === "")
    return true;
  if (data.length % 4 !== 0)
    return false;
  try {
    atob(data);
    return true;
  } catch {
    return false;
  }
}
var $ZodBase64 = /* @__PURE__ */ $constructor("$ZodBase64", (inst, def) => {
  def.pattern ?? (def.pattern = base64);
  $ZodStringFormat.init(inst, def);
  inst._zod.onattach.push((inst2) => {
    inst2._zod.bag.contentEncoding = "base64";
  });
  inst._zod.check = (payload) => {
    if (isValidBase64(payload.value))
      return;
    payload.issues.push({
      code: "invalid_format",
      format: "base64",
      input: payload.value,
      inst,
      continue: !def.abort
    });
  };
});
function isValidBase64URL(data) {
  if (!base64url.test(data))
    return false;
  const base642 = data.replace(/[-_]/g, (c) => c === "-" ? "+" : "/");
  const padded = base642.padEnd(Math.ceil(base642.length / 4) * 4, "=");
  return isValidBase64(padded);
}
var $ZodBase64URL = /* @__PURE__ */ $constructor("$ZodBase64URL", (inst, def) => {
  def.pattern ?? (def.pattern = base64url);
  $ZodStringFormat.init(inst, def);
  inst._zod.onattach.push((inst2) => {
    inst2._zod.bag.contentEncoding = "base64url";
  });
  inst._zod.check = (payload) => {
    if (isValidBase64URL(payload.value))
      return;
    payload.issues.push({
      code: "invalid_format",
      format: "base64url",
      input: payload.value,
      inst,
      continue: !def.abort
    });
  };
});
var $ZodE164 = /* @__PURE__ */ $constructor("$ZodE164", (inst, def) => {
  def.pattern ?? (def.pattern = e164);
  $ZodStringFormat.init(inst, def);
});
function isValidJWT(token, algorithm = null) {
  try {
    const tokensParts = token.split(".");
    if (tokensParts.length !== 3)
      return false;
    const [header] = tokensParts;
    if (!header)
      return false;
    const parsedHeader = JSON.parse(atob(header));
    if ("typ" in parsedHeader && parsedHeader?.typ !== "JWT")
      return false;
    if (!parsedHeader.alg)
      return false;
    if (algorithm && (!("alg" in parsedHeader) || parsedHeader.alg !== algorithm))
      return false;
    return true;
  } catch {
    return false;
  }
}
var $ZodJWT = /* @__PURE__ */ $constructor("$ZodJWT", (inst, def) => {
  $ZodStringFormat.init(inst, def);
  inst._zod.check = (payload) => {
    if (isValidJWT(payload.value, def.alg))
      return;
    payload.issues.push({
      code: "invalid_format",
      format: "jwt",
      input: payload.value,
      inst,
      continue: !def.abort
    });
  };
});
var $ZodCustomStringFormat = /* @__PURE__ */ $constructor("$ZodCustomStringFormat", (inst, def) => {
  $ZodStringFormat.init(inst, def);
  inst._zod.check = (payload) => {
    if (def.fn(payload.value))
      return;
    payload.issues.push({
      code: "invalid_format",
      format: def.format,
      input: payload.value,
      inst,
      continue: !def.abort
    });
  };
});
var $ZodNumber = /* @__PURE__ */ $constructor("$ZodNumber", (inst, def) => {
  $ZodType.init(inst, def);
  inst._zod.pattern = inst._zod.bag.pattern ?? number;
  inst._zod.parse = (payload, _ctx) => {
    if (def.coerce)
      try {
        payload.value = Number(payload.value);
      } catch (_23) {}
    const input = payload.value;
    if (typeof input === "number" && !Number.isNaN(input) && Number.isFinite(input)) {
      return payload;
    }
    const received = typeof input === "number" ? Number.isNaN(input) ? "NaN" : !Number.isFinite(input) ? "Infinity" : undefined : undefined;
    payload.issues.push({
      expected: "number",
      code: "invalid_type",
      input,
      inst,
      ...received ? { received } : {}
    });
    return payload;
  };
});
var $ZodNumberFormat = /* @__PURE__ */ $constructor("$ZodNumber", (inst, def) => {
  $ZodCheckNumberFormat.init(inst, def);
  $ZodNumber.init(inst, def);
});
var $ZodBoolean = /* @__PURE__ */ $constructor("$ZodBoolean", (inst, def) => {
  $ZodType.init(inst, def);
  inst._zod.pattern = boolean;
  inst._zod.parse = (payload, _ctx) => {
    if (def.coerce)
      try {
        payload.value = Boolean(payload.value);
      } catch (_23) {}
    const input = payload.value;
    if (typeof input === "boolean")
      return payload;
    payload.issues.push({
      expected: "boolean",
      code: "invalid_type",
      input,
      inst
    });
    return payload;
  };
});
var $ZodBigInt = /* @__PURE__ */ $constructor("$ZodBigInt", (inst, def) => {
  $ZodType.init(inst, def);
  inst._zod.pattern = bigint;
  inst._zod.parse = (payload, _ctx) => {
    if (def.coerce)
      try {
        payload.value = BigInt(payload.value);
      } catch (_23) {}
    if (typeof payload.value === "bigint")
      return payload;
    payload.issues.push({
      expected: "bigint",
      code: "invalid_type",
      input: payload.value,
      inst
    });
    return payload;
  };
});
var $ZodBigIntFormat = /* @__PURE__ */ $constructor("$ZodBigInt", (inst, def) => {
  $ZodCheckBigIntFormat.init(inst, def);
  $ZodBigInt.init(inst, def);
});
var $ZodSymbol = /* @__PURE__ */ $constructor("$ZodSymbol", (inst, def) => {
  $ZodType.init(inst, def);
  inst._zod.parse = (payload, _ctx) => {
    const input = payload.value;
    if (typeof input === "symbol")
      return payload;
    payload.issues.push({
      expected: "symbol",
      code: "invalid_type",
      input,
      inst
    });
    return payload;
  };
});
var $ZodUndefined = /* @__PURE__ */ $constructor("$ZodUndefined", (inst, def) => {
  $ZodType.init(inst, def);
  inst._zod.pattern = _undefined;
  inst._zod.values = new Set([undefined]);
  inst._zod.optin = "optional";
  inst._zod.optout = "optional";
  inst._zod.parse = (payload, _ctx) => {
    const input = payload.value;
    if (typeof input === "undefined")
      return payload;
    payload.issues.push({
      expected: "undefined",
      code: "invalid_type",
      input,
      inst
    });
    return payload;
  };
});
var $ZodNull = /* @__PURE__ */ $constructor("$ZodNull", (inst, def) => {
  $ZodType.init(inst, def);
  inst._zod.pattern = _null;
  inst._zod.values = new Set([null]);
  inst._zod.parse = (payload, _ctx) => {
    const input = payload.value;
    if (input === null)
      return payload;
    payload.issues.push({
      expected: "null",
      code: "invalid_type",
      input,
      inst
    });
    return payload;
  };
});
var $ZodAny = /* @__PURE__ */ $constructor("$ZodAny", (inst, def) => {
  $ZodType.init(inst, def);
  inst._zod.parse = (payload) => payload;
});
var $ZodUnknown = /* @__PURE__ */ $constructor("$ZodUnknown", (inst, def) => {
  $ZodType.init(inst, def);
  inst._zod.parse = (payload) => payload;
});
var $ZodNever = /* @__PURE__ */ $constructor("$ZodNever", (inst, def) => {
  $ZodType.init(inst, def);
  inst._zod.parse = (payload, _ctx) => {
    payload.issues.push({
      expected: "never",
      code: "invalid_type",
      input: payload.value,
      inst
    });
    return payload;
  };
});
var $ZodVoid = /* @__PURE__ */ $constructor("$ZodVoid", (inst, def) => {
  $ZodType.init(inst, def);
  inst._zod.parse = (payload, _ctx) => {
    const input = payload.value;
    if (typeof input === "undefined")
      return payload;
    payload.issues.push({
      expected: "void",
      code: "invalid_type",
      input,
      inst
    });
    return payload;
  };
});
var $ZodDate = /* @__PURE__ */ $constructor("$ZodDate", (inst, def) => {
  $ZodType.init(inst, def);
  inst._zod.parse = (payload, _ctx) => {
    if (def.coerce) {
      try {
        payload.value = new Date(payload.value);
      } catch (_err) {}
    }
    const input = payload.value;
    const isDate = input instanceof Date;
    const isValidDate = isDate && !Number.isNaN(input.getTime());
    if (isValidDate)
      return payload;
    payload.issues.push({
      expected: "date",
      code: "invalid_type",
      input,
      ...isDate ? { received: "Invalid Date" } : {},
      inst
    });
    return payload;
  };
});
function handleArrayResult(result, final, index) {
  if (result.issues.length) {
    final.issues.push(...prefixIssues(index, result.issues));
  }
  final.value[index] = result.value;
}
var $ZodArray = /* @__PURE__ */ $constructor("$ZodArray", (inst, def) => {
  $ZodType.init(inst, def);
  inst._zod.parse = (payload, ctx) => {
    const input = payload.value;
    if (!Array.isArray(input)) {
      payload.issues.push({
        expected: "array",
        code: "invalid_type",
        input,
        inst
      });
      return payload;
    }
    payload.value = Array(input.length);
    const proms = [];
    for (let i = 0;i < input.length; i++) {
      const item = input[i];
      const result = def.element._zod.run({
        value: item,
        issues: []
      }, ctx);
      if (result instanceof Promise) {
        proms.push(result.then((result2) => handleArrayResult(result2, payload, i)));
      } else {
        handleArrayResult(result, payload, i);
      }
    }
    if (proms.length) {
      return Promise.all(proms).then(() => payload);
    }
    return payload;
  };
});
function handleObjectResult(result, final, key) {
  if (result.issues.length) {
    final.issues.push(...prefixIssues(key, result.issues));
  }
  final.value[key] = result.value;
}
function handleOptionalObjectResult(result, final, key, input) {
  if (result.issues.length) {
    if (input[key] === undefined) {
      if (key in input) {
        final.value[key] = undefined;
      } else {
        final.value[key] = result.value;
      }
    } else {
      final.issues.push(...prefixIssues(key, result.issues));
    }
  } else if (result.value === undefined) {
    if (key in input)
      final.value[key] = undefined;
  } else {
    final.value[key] = result.value;
  }
}
var $ZodObject = /* @__PURE__ */ $constructor("$ZodObject", (inst, def) => {
  $ZodType.init(inst, def);
  const _normalized = cached(() => {
    const keys = Object.keys(def.shape);
    for (const k of keys) {
      if (!(def.shape[k] instanceof $ZodType)) {
        throw new Error(`Invalid element at key "${k}": expected a Zod schema`);
      }
    }
    const okeys = optionalKeys(def.shape);
    return {
      shape: def.shape,
      keys,
      keySet: new Set(keys),
      numKeys: keys.length,
      optionalKeys: new Set(okeys)
    };
  });
  defineLazy(inst._zod, "propValues", () => {
    const shape2 = def.shape;
    const propValues = {};
    for (const key in shape2) {
      const field = shape2[key]._zod;
      if (field.values) {
        propValues[key] ?? (propValues[key] = new Set);
        for (const v of field.values)
          propValues[key].add(v);
      }
    }
    return propValues;
  });
  const generateFastpass = (shape2) => {
    const doc = new Doc(["shape", "payload", "ctx"]);
    const normalized = _normalized.value;
    const parseStr = (key) => {
      const k = esc(key);
      return `shape[${k}]._zod.run({ value: input[${k}], issues: [] }, ctx)`;
    };
    doc.write(`const input = payload.value;`);
    const ids = Object.create(null);
    let counter = 0;
    for (const key of normalized.keys) {
      ids[key] = `key_${counter++}`;
    }
    doc.write(`const newResult = {}`);
    for (const key of normalized.keys) {
      if (normalized.optionalKeys.has(key)) {
        const id = ids[key];
        doc.write(`const ${id} = ${parseStr(key)};`);
        const k = esc(key);
        doc.write(`
        if (${id}.issues.length) {
          if (input[${k}] === undefined) {
            if (${k} in input) {
              newResult[${k}] = undefined;
            }
          } else {
            payload.issues = payload.issues.concat(
              ${id}.issues.map((iss) => ({
                ...iss,
                path: iss.path ? [${k}, ...iss.path] : [${k}],
              }))
            );
          }
        } else if (${id}.value === undefined) {
          if (${k} in input) newResult[${k}] = undefined;
        } else {
          newResult[${k}] = ${id}.value;
        }
        `);
      } else {
        const id = ids[key];
        doc.write(`const ${id} = ${parseStr(key)};`);
        doc.write(`
          if (${id}.issues.length) payload.issues = payload.issues.concat(${id}.issues.map(iss => ({
            ...iss,
            path: iss.path ? [${esc(key)}, ...iss.path] : [${esc(key)}]
          })));`);
        doc.write(`newResult[${esc(key)}] = ${id}.value`);
      }
    }
    doc.write(`payload.value = newResult;`);
    doc.write(`return payload;`);
    const fn2 = doc.compile();
    return (payload, ctx) => fn2(shape2, payload, ctx);
  };
  let fastpass;
  const isObject2 = isObject;
  const jit = !globalConfig.jitless;
  const allowsEval2 = allowsEval;
  const fastEnabled = jit && allowsEval2.value;
  const catchall = def.catchall;
  let value;
  inst._zod.parse = (payload, ctx) => {
    value ?? (value = _normalized.value);
    const input = payload.value;
    if (!isObject2(input)) {
      payload.issues.push({
        expected: "object",
        code: "invalid_type",
        input,
        inst
      });
      return payload;
    }
    const proms = [];
    if (jit && fastEnabled && ctx?.async === false && ctx.jitless !== true) {
      if (!fastpass)
        fastpass = generateFastpass(def.shape);
      payload = fastpass(payload, ctx);
    } else {
      payload.value = {};
      const shape2 = value.shape;
      for (const key of value.keys) {
        const el = shape2[key];
        const r = el._zod.run({ value: input[key], issues: [] }, ctx);
        const isOptional = el._zod.optin === "optional" && el._zod.optout === "optional";
        if (r instanceof Promise) {
          proms.push(r.then((r2) => isOptional ? handleOptionalObjectResult(r2, payload, key, input) : handleObjectResult(r2, payload, key)));
        } else if (isOptional) {
          handleOptionalObjectResult(r, payload, key, input);
        } else {
          handleObjectResult(r, payload, key);
        }
      }
    }
    if (!catchall) {
      return proms.length ? Promise.all(proms).then(() => payload) : payload;
    }
    const unrecognized = [];
    const keySet = value.keySet;
    const _catchall = catchall._zod;
    const t = _catchall.def.type;
    for (const key of Object.keys(input)) {
      if (keySet.has(key))
        continue;
      if (t === "never") {
        unrecognized.push(key);
        continue;
      }
      const r = _catchall.run({ value: input[key], issues: [] }, ctx);
      if (r instanceof Promise) {
        proms.push(r.then((r2) => handleObjectResult(r2, payload, key)));
      } else {
        handleObjectResult(r, payload, key);
      }
    }
    if (unrecognized.length) {
      payload.issues.push({
        code: "unrecognized_keys",
        keys: unrecognized,
        input,
        inst
      });
    }
    if (!proms.length)
      return payload;
    return Promise.all(proms).then(() => {
      return payload;
    });
  };
});
function handleUnionResults(results, final, inst, ctx) {
  for (const result of results) {
    if (result.issues.length === 0) {
      final.value = result.value;
      return final;
    }
  }
  final.issues.push({
    code: "invalid_union",
    input: final.value,
    inst,
    errors: results.map((result) => result.issues.map((iss) => finalizeIssue(iss, ctx, config())))
  });
  return final;
}
var $ZodUnion = /* @__PURE__ */ $constructor("$ZodUnion", (inst, def) => {
  $ZodType.init(inst, def);
  defineLazy(inst._zod, "optin", () => def.options.some((o) => o._zod.optin === "optional") ? "optional" : undefined);
  defineLazy(inst._zod, "optout", () => def.options.some((o) => o._zod.optout === "optional") ? "optional" : undefined);
  defineLazy(inst._zod, "values", () => {
    if (def.options.every((o) => o._zod.values)) {
      return new Set(def.options.flatMap((option) => Array.from(option._zod.values)));
    }
    return;
  });
  defineLazy(inst._zod, "pattern", () => {
    if (def.options.every((o) => o._zod.pattern)) {
      const patterns = def.options.map((o) => o._zod.pattern);
      return new RegExp(`^(${patterns.map((p2) => cleanRegex(p2.source)).join("|")})$`);
    }
    return;
  });
  inst._zod.parse = (payload, ctx) => {
    let async = false;
    const results = [];
    for (const option of def.options) {
      const result = option._zod.run({
        value: payload.value,
        issues: []
      }, ctx);
      if (result instanceof Promise) {
        results.push(result);
        async = true;
      } else {
        if (result.issues.length === 0)
          return result;
        results.push(result);
      }
    }
    if (!async)
      return handleUnionResults(results, payload, inst, ctx);
    return Promise.all(results).then((results2) => {
      return handleUnionResults(results2, payload, inst, ctx);
    });
  };
});
var $ZodDiscriminatedUnion = /* @__PURE__ */ $constructor("$ZodDiscriminatedUnion", (inst, def) => {
  $ZodUnion.init(inst, def);
  const _super = inst._zod.parse;
  defineLazy(inst._zod, "propValues", () => {
    const propValues = {};
    for (const option of def.options) {
      const pv = option._zod.propValues;
      if (!pv || Object.keys(pv).length === 0)
        throw new Error(`Invalid discriminated union option at index "${def.options.indexOf(option)}"`);
      for (const [k, v] of Object.entries(pv)) {
        if (!propValues[k])
          propValues[k] = new Set;
        for (const val of v) {
          propValues[k].add(val);
        }
      }
    }
    return propValues;
  });
  const disc = cached(() => {
    const opts = def.options;
    const map2 = new Map;
    for (const o of opts) {
      const values = o._zod.propValues[def.discriminator];
      if (!values || values.size === 0)
        throw new Error(`Invalid discriminated union option at index "${def.options.indexOf(o)}"`);
      for (const v of values) {
        if (map2.has(v)) {
          throw new Error(`Duplicate discriminator value "${String(v)}"`);
        }
        map2.set(v, o);
      }
    }
    return map2;
  });
  inst._zod.parse = (payload, ctx) => {
    const input = payload.value;
    if (!isObject(input)) {
      payload.issues.push({
        code: "invalid_type",
        expected: "object",
        input,
        inst
      });
      return payload;
    }
    const opt = disc.value.get(input?.[def.discriminator]);
    if (opt) {
      return opt._zod.run(payload, ctx);
    }
    if (def.unionFallback) {
      return _super(payload, ctx);
    }
    payload.issues.push({
      code: "invalid_union",
      errors: [],
      note: "No matching discriminator",
      input,
      path: [def.discriminator],
      inst
    });
    return payload;
  };
});
var $ZodIntersection = /* @__PURE__ */ $constructor("$ZodIntersection", (inst, def) => {
  $ZodType.init(inst, def);
  inst._zod.parse = (payload, ctx) => {
    const input = payload.value;
    const left = def.left._zod.run({ value: input, issues: [] }, ctx);
    const right = def.right._zod.run({ value: input, issues: [] }, ctx);
    const async = left instanceof Promise || right instanceof Promise;
    if (async) {
      return Promise.all([left, right]).then(([left2, right2]) => {
        return handleIntersectionResults(payload, left2, right2);
      });
    }
    return handleIntersectionResults(payload, left, right);
  };
});
function mergeValues(a, b2) {
  if (a === b2) {
    return { valid: true, data: a };
  }
  if (a instanceof Date && b2 instanceof Date && +a === +b2) {
    return { valid: true, data: a };
  }
  if (isPlainObject(a) && isPlainObject(b2)) {
    const bKeys = Object.keys(b2);
    const sharedKeys = Object.keys(a).filter((key) => bKeys.indexOf(key) !== -1);
    const newObj = { ...a, ...b2 };
    for (const key of sharedKeys) {
      const sharedValue = mergeValues(a[key], b2[key]);
      if (!sharedValue.valid) {
        return {
          valid: false,
          mergeErrorPath: [key, ...sharedValue.mergeErrorPath]
        };
      }
      newObj[key] = sharedValue.data;
    }
    return { valid: true, data: newObj };
  }
  if (Array.isArray(a) && Array.isArray(b2)) {
    if (a.length !== b2.length) {
      return { valid: false, mergeErrorPath: [] };
    }
    const newArray = [];
    for (let index = 0;index < a.length; index++) {
      const itemA = a[index];
      const itemB = b2[index];
      const sharedValue = mergeValues(itemA, itemB);
      if (!sharedValue.valid) {
        return {
          valid: false,
          mergeErrorPath: [index, ...sharedValue.mergeErrorPath]
        };
      }
      newArray.push(sharedValue.data);
    }
    return { valid: true, data: newArray };
  }
  return { valid: false, mergeErrorPath: [] };
}
function handleIntersectionResults(result, left, right) {
  if (left.issues.length) {
    result.issues.push(...left.issues);
  }
  if (right.issues.length) {
    result.issues.push(...right.issues);
  }
  if (aborted(result))
    return result;
  const merged = mergeValues(left.value, right.value);
  if (!merged.valid) {
    throw new Error(`Unmergable intersection. Error path: ` + `${JSON.stringify(merged.mergeErrorPath)}`);
  }
  result.value = merged.data;
  return result;
}
var $ZodTuple = /* @__PURE__ */ $constructor("$ZodTuple", (inst, def) => {
  $ZodType.init(inst, def);
  const items = def.items;
  const optStart = items.length - [...items].reverse().findIndex((item) => item._zod.optin !== "optional");
  inst._zod.parse = (payload, ctx) => {
    const input = payload.value;
    if (!Array.isArray(input)) {
      payload.issues.push({
        input,
        inst,
        expected: "tuple",
        code: "invalid_type"
      });
      return payload;
    }
    payload.value = [];
    const proms = [];
    if (!def.rest) {
      const tooBig = input.length > items.length;
      const tooSmall = input.length < optStart - 1;
      if (tooBig || tooSmall) {
        payload.issues.push({
          input,
          inst,
          origin: "array",
          ...tooBig ? { code: "too_big", maximum: items.length } : { code: "too_small", minimum: items.length }
        });
        return payload;
      }
    }
    let i = -1;
    for (const item of items) {
      i++;
      if (i >= input.length) {
        if (i >= optStart)
          continue;
      }
      const result = item._zod.run({
        value: input[i],
        issues: []
      }, ctx);
      if (result instanceof Promise) {
        proms.push(result.then((result2) => handleTupleResult(result2, payload, i)));
      } else {
        handleTupleResult(result, payload, i);
      }
    }
    if (def.rest) {
      const rest = input.slice(items.length);
      for (const el of rest) {
        i++;
        const result = def.rest._zod.run({
          value: el,
          issues: []
        }, ctx);
        if (result instanceof Promise) {
          proms.push(result.then((result2) => handleTupleResult(result2, payload, i)));
        } else {
          handleTupleResult(result, payload, i);
        }
      }
    }
    if (proms.length)
      return Promise.all(proms).then(() => payload);
    return payload;
  };
});
function handleTupleResult(result, final, index) {
  if (result.issues.length) {
    final.issues.push(...prefixIssues(index, result.issues));
  }
  final.value[index] = result.value;
}
var $ZodRecord = /* @__PURE__ */ $constructor("$ZodRecord", (inst, def) => {
  $ZodType.init(inst, def);
  inst._zod.parse = (payload, ctx) => {
    const input = payload.value;
    if (!isPlainObject(input)) {
      payload.issues.push({
        expected: "record",
        code: "invalid_type",
        input,
        inst
      });
      return payload;
    }
    const proms = [];
    if (def.keyType._zod.values) {
      const values = def.keyType._zod.values;
      payload.value = {};
      for (const key of values) {
        if (typeof key === "string" || typeof key === "number" || typeof key === "symbol") {
          const result = def.valueType._zod.run({ value: input[key], issues: [] }, ctx);
          if (result instanceof Promise) {
            proms.push(result.then((result2) => {
              if (result2.issues.length) {
                payload.issues.push(...prefixIssues(key, result2.issues));
              }
              payload.value[key] = result2.value;
            }));
          } else {
            if (result.issues.length) {
              payload.issues.push(...prefixIssues(key, result.issues));
            }
            payload.value[key] = result.value;
          }
        }
      }
      let unrecognized;
      for (const key in input) {
        if (!values.has(key)) {
          unrecognized = unrecognized ?? [];
          unrecognized.push(key);
        }
      }
      if (unrecognized && unrecognized.length > 0) {
        payload.issues.push({
          code: "unrecognized_keys",
          input,
          inst,
          keys: unrecognized
        });
      }
    } else {
      payload.value = {};
      for (const key of Reflect.ownKeys(input)) {
        if (key === "__proto__")
          continue;
        const keyResult = def.keyType._zod.run({ value: key, issues: [] }, ctx);
        if (keyResult instanceof Promise) {
          throw new Error("Async schemas not supported in object keys currently");
        }
        if (keyResult.issues.length) {
          payload.issues.push({
            origin: "record",
            code: "invalid_key",
            issues: keyResult.issues.map((iss) => finalizeIssue(iss, ctx, config())),
            input: key,
            path: [key],
            inst
          });
          payload.value[keyResult.value] = keyResult.value;
          continue;
        }
        const result = def.valueType._zod.run({ value: input[key], issues: [] }, ctx);
        if (result instanceof Promise) {
          proms.push(result.then((result2) => {
            if (result2.issues.length) {
              payload.issues.push(...prefixIssues(key, result2.issues));
            }
            payload.value[keyResult.value] = result2.value;
          }));
        } else {
          if (result.issues.length) {
            payload.issues.push(...prefixIssues(key, result.issues));
          }
          payload.value[keyResult.value] = result.value;
        }
      }
    }
    if (proms.length) {
      return Promise.all(proms).then(() => payload);
    }
    return payload;
  };
});
var $ZodMap = /* @__PURE__ */ $constructor("$ZodMap", (inst, def) => {
  $ZodType.init(inst, def);
  inst._zod.parse = (payload, ctx) => {
    const input = payload.value;
    if (!(input instanceof Map)) {
      payload.issues.push({
        expected: "map",
        code: "invalid_type",
        input,
        inst
      });
      return payload;
    }
    const proms = [];
    payload.value = new Map;
    for (const [key, value] of input) {
      const keyResult = def.keyType._zod.run({ value: key, issues: [] }, ctx);
      const valueResult = def.valueType._zod.run({ value, issues: [] }, ctx);
      if (keyResult instanceof Promise || valueResult instanceof Promise) {
        proms.push(Promise.all([keyResult, valueResult]).then(([keyResult2, valueResult2]) => {
          handleMapResult(keyResult2, valueResult2, payload, key, input, inst, ctx);
        }));
      } else {
        handleMapResult(keyResult, valueResult, payload, key, input, inst, ctx);
      }
    }
    if (proms.length)
      return Promise.all(proms).then(() => payload);
    return payload;
  };
});
function handleMapResult(keyResult, valueResult, final, key, input, inst, ctx) {
  if (keyResult.issues.length) {
    if (propertyKeyTypes.has(typeof key)) {
      final.issues.push(...prefixIssues(key, keyResult.issues));
    } else {
      final.issues.push({
        origin: "map",
        code: "invalid_key",
        input,
        inst,
        issues: keyResult.issues.map((iss) => finalizeIssue(iss, ctx, config()))
      });
    }
  }
  if (valueResult.issues.length) {
    if (propertyKeyTypes.has(typeof key)) {
      final.issues.push(...prefixIssues(key, valueResult.issues));
    } else {
      final.issues.push({
        origin: "map",
        code: "invalid_element",
        input,
        inst,
        key,
        issues: valueResult.issues.map((iss) => finalizeIssue(iss, ctx, config()))
      });
    }
  }
  final.value.set(keyResult.value, valueResult.value);
}
var $ZodSet = /* @__PURE__ */ $constructor("$ZodSet", (inst, def) => {
  $ZodType.init(inst, def);
  inst._zod.parse = (payload, ctx) => {
    const input = payload.value;
    if (!(input instanceof Set)) {
      payload.issues.push({
        input,
        inst,
        expected: "set",
        code: "invalid_type"
      });
      return payload;
    }
    const proms = [];
    payload.value = new Set;
    for (const item of input) {
      const result = def.valueType._zod.run({ value: item, issues: [] }, ctx);
      if (result instanceof Promise) {
        proms.push(result.then((result2) => handleSetResult(result2, payload)));
      } else
        handleSetResult(result, payload);
    }
    if (proms.length)
      return Promise.all(proms).then(() => payload);
    return payload;
  };
});
function handleSetResult(result, final) {
  if (result.issues.length) {
    final.issues.push(...result.issues);
  }
  final.value.add(result.value);
}
var $ZodEnum = /* @__PURE__ */ $constructor("$ZodEnum", (inst, def) => {
  $ZodType.init(inst, def);
  const values = getEnumValues(def.entries);
  inst._zod.values = new Set(values);
  inst._zod.pattern = new RegExp(`^(${values.filter((k) => propertyKeyTypes.has(typeof k)).map((o) => typeof o === "string" ? escapeRegex(o) : o.toString()).join("|")})$`);
  inst._zod.parse = (payload, _ctx) => {
    const input = payload.value;
    if (inst._zod.values.has(input)) {
      return payload;
    }
    payload.issues.push({
      code: "invalid_value",
      values,
      input,
      inst
    });
    return payload;
  };
});
var $ZodLiteral = /* @__PURE__ */ $constructor("$ZodLiteral", (inst, def) => {
  $ZodType.init(inst, def);
  inst._zod.values = new Set(def.values);
  inst._zod.pattern = new RegExp(`^(${def.values.map((o) => typeof o === "string" ? escapeRegex(o) : o ? o.toString() : String(o)).join("|")})$`);
  inst._zod.parse = (payload, _ctx) => {
    const input = payload.value;
    if (inst._zod.values.has(input)) {
      return payload;
    }
    payload.issues.push({
      code: "invalid_value",
      values: def.values,
      input,
      inst
    });
    return payload;
  };
});
var $ZodFile = /* @__PURE__ */ $constructor("$ZodFile", (inst, def) => {
  $ZodType.init(inst, def);
  inst._zod.parse = (payload, _ctx) => {
    const input = payload.value;
    if (input instanceof File)
      return payload;
    payload.issues.push({
      expected: "file",
      code: "invalid_type",
      input,
      inst
    });
    return payload;
  };
});
var $ZodTransform = /* @__PURE__ */ $constructor("$ZodTransform", (inst, def) => {
  $ZodType.init(inst, def);
  inst._zod.parse = (payload, _ctx) => {
    const _out = def.transform(payload.value, payload);
    if (_ctx.async) {
      const output2 = _out instanceof Promise ? _out : Promise.resolve(_out);
      return output2.then((output3) => {
        payload.value = output3;
        return payload;
      });
    }
    if (_out instanceof Promise) {
      throw new $ZodAsyncError;
    }
    payload.value = _out;
    return payload;
  };
});
var $ZodOptional = /* @__PURE__ */ $constructor("$ZodOptional", (inst, def) => {
  $ZodType.init(inst, def);
  inst._zod.optin = "optional";
  inst._zod.optout = "optional";
  defineLazy(inst._zod, "values", () => {
    return def.innerType._zod.values ? new Set([...def.innerType._zod.values, undefined]) : undefined;
  });
  defineLazy(inst._zod, "pattern", () => {
    const pattern = def.innerType._zod.pattern;
    return pattern ? new RegExp(`^(${cleanRegex(pattern.source)})?$`) : undefined;
  });
  inst._zod.parse = (payload, ctx) => {
    if (def.innerType._zod.optin === "optional") {
      return def.innerType._zod.run(payload, ctx);
    }
    if (payload.value === undefined) {
      return payload;
    }
    return def.innerType._zod.run(payload, ctx);
  };
});
var $ZodNullable = /* @__PURE__ */ $constructor("$ZodNullable", (inst, def) => {
  $ZodType.init(inst, def);
  defineLazy(inst._zod, "optin", () => def.innerType._zod.optin);
  defineLazy(inst._zod, "optout", () => def.innerType._zod.optout);
  defineLazy(inst._zod, "pattern", () => {
    const pattern = def.innerType._zod.pattern;
    return pattern ? new RegExp(`^(${cleanRegex(pattern.source)}|null)$`) : undefined;
  });
  defineLazy(inst._zod, "values", () => {
    return def.innerType._zod.values ? new Set([...def.innerType._zod.values, null]) : undefined;
  });
  inst._zod.parse = (payload, ctx) => {
    if (payload.value === null)
      return payload;
    return def.innerType._zod.run(payload, ctx);
  };
});
var $ZodDefault = /* @__PURE__ */ $constructor("$ZodDefault", (inst, def) => {
  $ZodType.init(inst, def);
  inst._zod.optin = "optional";
  defineLazy(inst._zod, "values", () => def.innerType._zod.values);
  inst._zod.parse = (payload, ctx) => {
    if (payload.value === undefined) {
      payload.value = def.defaultValue;
      return payload;
    }
    const result = def.innerType._zod.run(payload, ctx);
    if (result instanceof Promise) {
      return result.then((result2) => handleDefaultResult(result2, def));
    }
    return handleDefaultResult(result, def);
  };
});
function handleDefaultResult(payload, def) {
  if (payload.value === undefined) {
    payload.value = def.defaultValue;
  }
  return payload;
}
var $ZodPrefault = /* @__PURE__ */ $constructor("$ZodPrefault", (inst, def) => {
  $ZodType.init(inst, def);
  inst._zod.optin = "optional";
  defineLazy(inst._zod, "values", () => def.innerType._zod.values);
  inst._zod.parse = (payload, ctx) => {
    if (payload.value === undefined) {
      payload.value = def.defaultValue;
    }
    return def.innerType._zod.run(payload, ctx);
  };
});
var $ZodNonOptional = /* @__PURE__ */ $constructor("$ZodNonOptional", (inst, def) => {
  $ZodType.init(inst, def);
  defineLazy(inst._zod, "values", () => {
    const v = def.innerType._zod.values;
    return v ? new Set([...v].filter((x) => x !== undefined)) : undefined;
  });
  inst._zod.parse = (payload, ctx) => {
    const result = def.innerType._zod.run(payload, ctx);
    if (result instanceof Promise) {
      return result.then((result2) => handleNonOptionalResult(result2, inst));
    }
    return handleNonOptionalResult(result, inst);
  };
});
function handleNonOptionalResult(payload, inst) {
  if (!payload.issues.length && payload.value === undefined) {
    payload.issues.push({
      code: "invalid_type",
      expected: "nonoptional",
      input: payload.value,
      inst
    });
  }
  return payload;
}
var $ZodSuccess = /* @__PURE__ */ $constructor("$ZodSuccess", (inst, def) => {
  $ZodType.init(inst, def);
  inst._zod.parse = (payload, ctx) => {
    const result = def.innerType._zod.run(payload, ctx);
    if (result instanceof Promise) {
      return result.then((result2) => {
        payload.value = result2.issues.length === 0;
        return payload;
      });
    }
    payload.value = result.issues.length === 0;
    return payload;
  };
});
var $ZodCatch = /* @__PURE__ */ $constructor("$ZodCatch", (inst, def) => {
  $ZodType.init(inst, def);
  inst._zod.optin = "optional";
  defineLazy(inst._zod, "optout", () => def.innerType._zod.optout);
  defineLazy(inst._zod, "values", () => def.innerType._zod.values);
  inst._zod.parse = (payload, ctx) => {
    const result = def.innerType._zod.run(payload, ctx);
    if (result instanceof Promise) {
      return result.then((result2) => {
        payload.value = result2.value;
        if (result2.issues.length) {
          payload.value = def.catchValue({
            ...payload,
            error: {
              issues: result2.issues.map((iss) => finalizeIssue(iss, ctx, config()))
            },
            input: payload.value
          });
          payload.issues = [];
        }
        return payload;
      });
    }
    payload.value = result.value;
    if (result.issues.length) {
      payload.value = def.catchValue({
        ...payload,
        error: {
          issues: result.issues.map((iss) => finalizeIssue(iss, ctx, config()))
        },
        input: payload.value
      });
      payload.issues = [];
    }
    return payload;
  };
});
var $ZodNaN = /* @__PURE__ */ $constructor("$ZodNaN", (inst, def) => {
  $ZodType.init(inst, def);
  inst._zod.parse = (payload, _ctx) => {
    if (typeof payload.value !== "number" || !Number.isNaN(payload.value)) {
      payload.issues.push({
        input: payload.value,
        inst,
        expected: "nan",
        code: "invalid_type"
      });
      return payload;
    }
    return payload;
  };
});
var $ZodPipe = /* @__PURE__ */ $constructor("$ZodPipe", (inst, def) => {
  $ZodType.init(inst, def);
  defineLazy(inst._zod, "values", () => def.in._zod.values);
  defineLazy(inst._zod, "optin", () => def.in._zod.optin);
  defineLazy(inst._zod, "optout", () => def.out._zod.optout);
  inst._zod.parse = (payload, ctx) => {
    const left = def.in._zod.run(payload, ctx);
    if (left instanceof Promise) {
      return left.then((left2) => handlePipeResult(left2, def, ctx));
    }
    return handlePipeResult(left, def, ctx);
  };
});
function handlePipeResult(left, def, ctx) {
  if (aborted(left)) {
    return left;
  }
  return def.out._zod.run({ value: left.value, issues: left.issues }, ctx);
}
var $ZodReadonly = /* @__PURE__ */ $constructor("$ZodReadonly", (inst, def) => {
  $ZodType.init(inst, def);
  defineLazy(inst._zod, "propValues", () => def.innerType._zod.propValues);
  defineLazy(inst._zod, "values", () => def.innerType._zod.values);
  defineLazy(inst._zod, "optin", () => def.innerType._zod.optin);
  defineLazy(inst._zod, "optout", () => def.innerType._zod.optout);
  inst._zod.parse = (payload, ctx) => {
    const result = def.innerType._zod.run(payload, ctx);
    if (result instanceof Promise) {
      return result.then(handleReadonlyResult);
    }
    return handleReadonlyResult(result);
  };
});
function handleReadonlyResult(payload) {
  payload.value = Object.freeze(payload.value);
  return payload;
}
var $ZodTemplateLiteral = /* @__PURE__ */ $constructor("$ZodTemplateLiteral", (inst, def) => {
  $ZodType.init(inst, def);
  const regexParts = [];
  for (const part of def.parts) {
    if (part instanceof $ZodType) {
      if (!part._zod.pattern) {
        throw new Error(`Invalid template literal part, no pattern found: ${[...part._zod.traits].shift()}`);
      }
      const source = part._zod.pattern instanceof RegExp ? part._zod.pattern.source : part._zod.pattern;
      if (!source)
        throw new Error(`Invalid template literal part: ${part._zod.traits}`);
      const start = source.startsWith("^") ? 1 : 0;
      const end = source.endsWith("$") ? source.length - 1 : source.length;
      regexParts.push(source.slice(start, end));
    } else if (part === null || primitiveTypes.has(typeof part)) {
      regexParts.push(escapeRegex(`${part}`));
    } else {
      throw new Error(`Invalid template literal part: ${part}`);
    }
  }
  inst._zod.pattern = new RegExp(`^${regexParts.join("")}$`);
  inst._zod.parse = (payload, _ctx) => {
    if (typeof payload.value !== "string") {
      payload.issues.push({
        input: payload.value,
        inst,
        expected: "template_literal",
        code: "invalid_type"
      });
      return payload;
    }
    inst._zod.pattern.lastIndex = 0;
    if (!inst._zod.pattern.test(payload.value)) {
      payload.issues.push({
        input: payload.value,
        inst,
        code: "invalid_format",
        format: "template_literal",
        pattern: inst._zod.pattern.source
      });
      return payload;
    }
    return payload;
  };
});
var $ZodPromise = /* @__PURE__ */ $constructor("$ZodPromise", (inst, def) => {
  $ZodType.init(inst, def);
  inst._zod.parse = (payload, ctx) => {
    return Promise.resolve(payload.value).then((inner) => def.innerType._zod.run({ value: inner, issues: [] }, ctx));
  };
});
var $ZodLazy = /* @__PURE__ */ $constructor("$ZodLazy", (inst, def) => {
  $ZodType.init(inst, def);
  defineLazy(inst._zod, "innerType", () => def.getter());
  defineLazy(inst._zod, "pattern", () => inst._zod.innerType._zod.pattern);
  defineLazy(inst._zod, "propValues", () => inst._zod.innerType._zod.propValues);
  defineLazy(inst._zod, "optin", () => inst._zod.innerType._zod.optin);
  defineLazy(inst._zod, "optout", () => inst._zod.innerType._zod.optout);
  inst._zod.parse = (payload, ctx) => {
    const inner = inst._zod.innerType;
    return inner._zod.run(payload, ctx);
  };
});
var $ZodCustom = /* @__PURE__ */ $constructor("$ZodCustom", (inst, def) => {
  $ZodCheck.init(inst, def);
  $ZodType.init(inst, def);
  inst._zod.parse = (payload, _23) => {
    return payload;
  };
  inst._zod.check = (payload) => {
    const input = payload.value;
    const r = def.fn(input);
    if (r instanceof Promise) {
      return r.then((r2) => handleRefineResult(r2, payload, input, inst));
    }
    handleRefineResult(r, payload, input, inst);
    return;
  };
});
function handleRefineResult(result, payload, input, inst) {
  if (!result) {
    const _iss = {
      code: "custom",
      input,
      inst,
      path: [...inst._zod.def.path ?? []],
      continue: !inst._zod.def.abort
    };
    if (inst._zod.def.params)
      _iss.params = inst._zod.def.params;
    payload.issues.push(issue(_iss));
  }
}
// node_modules/zod/v4/locales/index.js
var exports_locales = {};
__export(exports_locales, {
  zhTW: () => zh_TW_default,
  zhCN: () => zh_CN_default,
  vi: () => vi_default,
  ur: () => ur_default,
  ua: () => ua_default,
  tr: () => tr_default,
  th: () => th_default,
  ta: () => ta_default,
  sv: () => sv_default,
  sl: () => sl_default,
  ru: () => ru_default,
  pt: () => pt_default,
  ps: () => ps_default,
  pl: () => pl_default,
  ota: () => ota_default,
  no: () => no_default,
  nl: () => nl_default,
  ms: () => ms_default,
  mk: () => mk_default,
  ko: () => ko_default,
  kh: () => kh_default,
  ja: () => ja_default,
  it: () => it_default,
  id: () => id_default,
  hu: () => hu_default,
  he: () => he_default,
  frCA: () => fr_CA_default,
  fr: () => fr_default,
  fi: () => fi_default,
  fa: () => fa_default,
  es: () => es_default,
  eo: () => eo_default,
  en: () => en_default,
  de: () => de_default,
  cs: () => cs_default,
  ca: () => ca_default,
  be: () => be_default,
  az: () => az_default,
  ar: () => ar_default
});

// node_modules/zod/v4/locales/ar.js
var error2 = () => {
  const Sizable = {
    string: { unit: "", verb: " " },
    file: { unit: "", verb: " " },
    array: { unit: "", verb: " " },
    set: { unit: "", verb: " " }
  };
  function getSizing(origin) {
    return Sizable[origin] ?? null;
  }
  const parsedType = (data) => {
    const t = typeof data;
    switch (t) {
      case "number": {
        return Number.isNaN(data) ? "NaN" : "number";
      }
      case "object": {
        if (Array.isArray(data)) {
          return "array";
        }
        if (data === null) {
          return "null";
        }
        if (Object.getPrototypeOf(data) !== Object.prototype && data.constructor) {
          return data.constructor.name;
        }
      }
    }
    return t;
  };
  const Nouns = {
    regex: "",
    email: " ",
    url: "",
    emoji: "",
    uuid: "UUID",
    uuidv4: "UUIDv4",
    uuidv6: "UUIDv6",
    nanoid: "nanoid",
    guid: "GUID",
    cuid: "cuid",
    cuid2: "cuid2",
    ulid: "ULID",
    xid: "XID",
    ksuid: "KSUID",
    datetime: "   ISO",
    date: "  ISO",
    time: "  ISO",
    duration: "  ISO",
    ipv4: " IPv4",
    ipv6: " IPv6",
    cidrv4: "   IPv4",
    cidrv6: "   IPv6",
    base64: "  base64-encoded",
    base64url: "  base64url-encoded",
    json_string: "   JSON",
    e164: "   E.164",
    jwt: "JWT",
    template_literal: ""
  };
  return (issue2) => {
    switch (issue2.code) {
      case "invalid_type":
        return `  :   ${issue2.expected}    ${parsedType(issue2.input)}`;
      case "invalid_value":
        if (issue2.values.length === 1)
          return `  :   ${stringifyPrimitive(issue2.values[0])}`;
        return `  :     : ${joinValues(issue2.values, "|")}`;
      case "too_big": {
        const adj = issue2.inclusive ? "<=" : "<";
        const sizing = getSizing(issue2.origin);
        if (sizing)
          return `   :    ${issue2.origin ?? ""} ${adj} ${issue2.maximum.toString()} ${sizing.unit ?? ""}`;
        return `  :    ${issue2.origin ?? ""} ${adj} ${issue2.maximum.toString()}`;
      }
      case "too_small": {
        const adj = issue2.inclusive ? ">=" : ">";
        const sizing = getSizing(issue2.origin);
        if (sizing) {
          return `  :   ${issue2.origin}   ${adj} ${issue2.minimum.toString()} ${sizing.unit}`;
        }
        return `  :   ${issue2.origin}   ${adj} ${issue2.minimum.toString()}`;
      }
      case "invalid_format": {
        const _issue = issue2;
        if (_issue.format === "starts_with")
          return `  :     "${issue2.prefix}"`;
        if (_issue.format === "ends_with")
          return `  :     "${_issue.suffix}"`;
        if (_issue.format === "includes")
          return `  :    "${_issue.includes}"`;
        if (_issue.format === "regex")
          return `  :     ${_issue.pattern}`;
        return `${Nouns[_issue.format] ?? issue2.format}  `;
      }
      case "not_multiple_of":
        return `  :      ${issue2.divisor}`;
      case "unrecognized_keys":
        return `${issue2.keys.length > 1 ? "" : ""} ${issue2.keys.length > 1 ? "" : ""}: ${joinValues(issue2.keys, " ")}`;
      case "invalid_key":
        return `    ${issue2.origin}`;
      case "invalid_union":
        return "  ";
      case "invalid_element":
        return `    ${issue2.origin}`;
      default:
        return "  ";
    }
  };
};
function ar_default() {
  return {
    localeError: error2()
  };
}
// node_modules/zod/v4/locales/az.js
var error3 = () => {
  const Sizable = {
    string: { unit: "simvol", verb: "olmaldr" },
    file: { unit: "bayt", verb: "olmaldr" },
    array: { unit: "element", verb: "olmaldr" },
    set: { unit: "element", verb: "olmaldr" }
  };
  function getSizing(origin) {
    return Sizable[origin] ?? null;
  }
  const parsedType = (data) => {
    const t = typeof data;
    switch (t) {
      case "number": {
        return Number.isNaN(data) ? "NaN" : "number";
      }
      case "object": {
        if (Array.isArray(data)) {
          return "array";
        }
        if (data === null) {
          return "null";
        }
        if (Object.getPrototypeOf(data) !== Object.prototype && data.constructor) {
          return data.constructor.name;
        }
      }
    }
    return t;
  };
  const Nouns = {
    regex: "input",
    email: "email address",
    url: "URL",
    emoji: "emoji",
    uuid: "UUID",
    uuidv4: "UUIDv4",
    uuidv6: "UUIDv6",
    nanoid: "nanoid",
    guid: "GUID",
    cuid: "cuid",
    cuid2: "cuid2",
    ulid: "ULID",
    xid: "XID",
    ksuid: "KSUID",
    datetime: "ISO datetime",
    date: "ISO date",
    time: "ISO time",
    duration: "ISO duration",
    ipv4: "IPv4 address",
    ipv6: "IPv6 address",
    cidrv4: "IPv4 range",
    cidrv6: "IPv6 range",
    base64: "base64-encoded string",
    base64url: "base64url-encoded string",
    json_string: "JSON string",
    e164: "E.164 number",
    jwt: "JWT",
    template_literal: "input"
  };
  return (issue2) => {
    switch (issue2.code) {
      case "invalid_type":
        return `Yanl dyr: gzlniln ${issue2.expected}, daxil olan ${parsedType(issue2.input)}`;
      case "invalid_value":
        if (issue2.values.length === 1)
          return `Yanl dyr: gzlniln ${stringifyPrimitive(issue2.values[0])}`;
        return `Yanl seim: aadaklardan biri olmaldr: ${joinValues(issue2.values, "|")}`;
      case "too_big": {
        const adj = issue2.inclusive ? "<=" : "<";
        const sizing = getSizing(issue2.origin);
        if (sizing)
          return `ox byk: gzlniln ${issue2.origin ?? "dyr"} ${adj}${issue2.maximum.toString()} ${sizing.unit ?? "element"}`;
        return `ox byk: gzlniln ${issue2.origin ?? "dyr"} ${adj}${issue2.maximum.toString()}`;
      }
      case "too_small": {
        const adj = issue2.inclusive ? ">=" : ">";
        const sizing = getSizing(issue2.origin);
        if (sizing)
          return `ox kiik: gzlniln ${issue2.origin} ${adj}${issue2.minimum.toString()} ${sizing.unit}`;
        return `ox kiik: gzlniln ${issue2.origin} ${adj}${issue2.minimum.toString()}`;
      }
      case "invalid_format": {
        const _issue = issue2;
        if (_issue.format === "starts_with")
          return `Yanl mtn: "${_issue.prefix}" il balamaldr`;
        if (_issue.format === "ends_with")
          return `Yanl mtn: "${_issue.suffix}" il bitmlidir`;
        if (_issue.format === "includes")
          return `Yanl mtn: "${_issue.includes}" daxil olmaldr`;
        if (_issue.format === "regex")
          return `Yanl mtn: ${_issue.pattern} ablonuna uyun olmaldr`;
        return `Yanl ${Nouns[_issue.format] ?? issue2.format}`;
      }
      case "not_multiple_of":
        return `Yanl dd: ${issue2.divisor} il bln biln olmaldr`;
      case "unrecognized_keys":
        return `Tannmayan aar${issue2.keys.length > 1 ? "lar" : ""}: ${joinValues(issue2.keys, ", ")}`;
      case "invalid_key":
        return `${issue2.origin} daxilind yanl aar`;
      case "invalid_union":
        return "Yanl dyr";
      case "invalid_element":
        return `${issue2.origin} daxilind yanl dyr`;
      default:
        return `Yanl dyr`;
    }
  };
};
function az_default() {
  return {
    localeError: error3()
  };
}
// node_modules/zod/v4/locales/be.js
function getBelarusianPlural(count, one, few, many) {
  const absCount = Math.abs(count);
  const lastDigit = absCount % 10;
  const lastTwoDigits = absCount % 100;
  if (lastTwoDigits >= 11 && lastTwoDigits <= 19) {
    return many;
  }
  if (lastDigit === 1) {
    return one;
  }
  if (lastDigit >= 2 && lastDigit <= 4) {
    return few;
  }
  return many;
}
var error4 = () => {
  const Sizable = {
    string: {
      unit: {
        one: "",
        few: "",
        many: ""
      },
      verb: ""
    },
    array: {
      unit: {
        one: "",
        few: "",
        many: ""
      },
      verb: ""
    },
    set: {
      unit: {
        one: "",
        few: "",
        many: ""
      },
      verb: ""
    },
    file: {
      unit: {
        one: "",
        few: "",
        many: ""
      },
      verb: ""
    }
  };
  function getSizing(origin) {
    return Sizable[origin] ?? null;
  }
  const parsedType = (data) => {
    const t = typeof data;
    switch (t) {
      case "number": {
        return Number.isNaN(data) ? "NaN" : "";
      }
      case "object": {
        if (Array.isArray(data)) {
          return "";
        }
        if (data === null) {
          return "null";
        }
        if (Object.getPrototypeOf(data) !== Object.prototype && data.constructor) {
          return data.constructor.name;
        }
      }
    }
    return t;
  };
  const Nouns = {
    regex: "",
    email: "email ",
    url: "URL",
    emoji: "",
    uuid: "UUID",
    uuidv4: "UUIDv4",
    uuidv6: "UUIDv6",
    nanoid: "nanoid",
    guid: "GUID",
    cuid: "cuid",
    cuid2: "cuid2",
    ulid: "ULID",
    xid: "XID",
    ksuid: "KSUID",
    datetime: "ISO   ",
    date: "ISO ",
    time: "ISO ",
    duration: "ISO ",
    ipv4: "IPv4 ",
    ipv6: "IPv6 ",
    cidrv4: "IPv4 ",
    cidrv6: "IPv6 ",
    base64: "   base64",
    base64url: "   base64url",
    json_string: "JSON ",
    e164: " E.164",
    jwt: "JWT",
    template_literal: ""
  };
  return (issue2) => {
    switch (issue2.code) {
      case "invalid_type":
        return ` :  ${issue2.expected},  ${parsedType(issue2.input)}`;
      case "invalid_value":
        if (issue2.values.length === 1)
          return ` :  ${stringifyPrimitive(issue2.values[0])}`;
        return ` :    ${joinValues(issue2.values, "|")}`;
      case "too_big": {
        const adj = issue2.inclusive ? "<=" : "<";
        const sizing = getSizing(issue2.origin);
        if (sizing) {
          const maxValue = Number(issue2.maximum);
          const unit = getBelarusianPlural(maxValue, sizing.unit.one, sizing.unit.few, sizing.unit.many);
          return ` : ,  ${issue2.origin ?? ""}  ${sizing.verb} ${adj}${issue2.maximum.toString()} ${unit}`;
        }
        return ` : ,  ${issue2.origin ?? ""}   ${adj}${issue2.maximum.toString()}`;
      }
      case "too_small": {
        const adj = issue2.inclusive ? ">=" : ">";
        const sizing = getSizing(issue2.origin);
        if (sizing) {
          const minValue = Number(issue2.minimum);
          const unit = getBelarusianPlural(minValue, sizing.unit.one, sizing.unit.few, sizing.unit.many);
          return ` : ,  ${issue2.origin}  ${sizing.verb} ${adj}${issue2.minimum.toString()} ${unit}`;
        }
        return ` : ,  ${issue2.origin}   ${adj}${issue2.minimum.toString()}`;
      }
      case "invalid_format": {
        const _issue = issue2;
        if (_issue.format === "starts_with")
          return ` :    "${_issue.prefix}"`;
        if (_issue.format === "ends_with")
          return ` :    "${_issue.suffix}"`;
        if (_issue.format === "includes")
          return ` :   "${_issue.includes}"`;
        if (_issue.format === "regex")
          return ` :    ${_issue.pattern}`;
        return ` ${Nouns[_issue.format] ?? issue2.format}`;
      }
      case "not_multiple_of":
        return ` :    ${issue2.divisor}`;
      case "unrecognized_keys":
        return ` ${issue2.keys.length > 1 ? "" : ""}: ${joinValues(issue2.keys, ", ")}`;
      case "invalid_key":
        return `   ${issue2.origin}`;
      case "invalid_union":
        return " ";
      case "invalid_element":
        return `   ${issue2.origin}`;
      default:
        return ` `;
    }
  };
};
function be_default() {
  return {
    localeError: error4()
  };
}
// node_modules/zod/v4/locales/ca.js
var error5 = () => {
  const Sizable = {
    string: { unit: "carcters", verb: "contenir" },
    file: { unit: "bytes", verb: "contenir" },
    array: { unit: "elements", verb: "contenir" },
    set: { unit: "elements", verb: "contenir" }
  };
  function getSizing(origin) {
    return Sizable[origin] ?? null;
  }
  const parsedType = (data) => {
    const t = typeof data;
    switch (t) {
      case "number": {
        return Number.isNaN(data) ? "NaN" : "number";
      }
      case "object": {
        if (Array.isArray(data)) {
          return "array";
        }
        if (data === null) {
          return "null";
        }
        if (Object.getPrototypeOf(data) !== Object.prototype && data.constructor) {
          return data.constructor.name;
        }
      }
    }
    return t;
  };
  const Nouns = {
    regex: "entrada",
    email: "adrea electrnica",
    url: "URL",
    emoji: "emoji",
    uuid: "UUID",
    uuidv4: "UUIDv4",
    uuidv6: "UUIDv6",
    nanoid: "nanoid",
    guid: "GUID",
    cuid: "cuid",
    cuid2: "cuid2",
    ulid: "ULID",
    xid: "XID",
    ksuid: "KSUID",
    datetime: "data i hora ISO",
    date: "data ISO",
    time: "hora ISO",
    duration: "durada ISO",
    ipv4: "adrea IPv4",
    ipv6: "adrea IPv6",
    cidrv4: "rang IPv4",
    cidrv6: "rang IPv6",
    base64: "cadena codificada en base64",
    base64url: "cadena codificada en base64url",
    json_string: "cadena JSON",
    e164: "nmero E.164",
    jwt: "JWT",
    template_literal: "entrada"
  };
  return (issue2) => {
    switch (issue2.code) {
      case "invalid_type":
        return `Tipus invlid: s'esperava ${issue2.expected}, s'ha rebut ${parsedType(issue2.input)}`;
      case "invalid_value":
        if (issue2.values.length === 1)
          return `Valor invlid: s'esperava ${stringifyPrimitive(issue2.values[0])}`;
        return `Opci invlida: s'esperava una de ${joinValues(issue2.values, " o ")}`;
      case "too_big": {
        const adj = issue2.inclusive ? "com a mxim" : "menys de";
        const sizing = getSizing(issue2.origin);
        if (sizing)
          return `Massa gran: s'esperava que ${issue2.origin ?? "el valor"} contingus ${adj} ${issue2.maximum.toString()} ${sizing.unit ?? "elements"}`;
        return `Massa gran: s'esperava que ${issue2.origin ?? "el valor"} fos ${adj} ${issue2.maximum.toString()}`;
      }
      case "too_small": {
        const adj = issue2.inclusive ? "com a mnim" : "ms de";
        const sizing = getSizing(issue2.origin);
        if (sizing) {
          return `Massa petit: s'esperava que ${issue2.origin} contingus ${adj} ${issue2.minimum.toString()} ${sizing.unit}`;
        }
        return `Massa petit: s'esperava que ${issue2.origin} fos ${adj} ${issue2.minimum.toString()}`;
      }
      case "invalid_format": {
        const _issue = issue2;
        if (_issue.format === "starts_with") {
          return `Format invlid: ha de comenar amb "${_issue.prefix}"`;
        }
        if (_issue.format === "ends_with")
          return `Format invlid: ha d'acabar amb "${_issue.suffix}"`;
        if (_issue.format === "includes")
          return `Format invlid: ha d'incloure "${_issue.includes}"`;
        if (_issue.format === "regex")
          return `Format invlid: ha de coincidir amb el patr ${_issue.pattern}`;
        return `Format invlid per a ${Nouns[_issue.format] ?? issue2.format}`;
      }
      case "not_multiple_of":
        return `Nmero invlid: ha de ser mltiple de ${issue2.divisor}`;
      case "unrecognized_keys":
        return `Clau${issue2.keys.length > 1 ? "s" : ""} no reconeguda${issue2.keys.length > 1 ? "s" : ""}: ${joinValues(issue2.keys, ", ")}`;
      case "invalid_key":
        return `Clau invlida a ${issue2.origin}`;
      case "invalid_union":
        return "Entrada invlida";
      case "invalid_element":
        return `Element invlid a ${issue2.origin}`;
      default:
        return `Entrada invlida`;
    }
  };
};
function ca_default() {
  return {
    localeError: error5()
  };
}
// node_modules/zod/v4/locales/cs.js
var error6 = () => {
  const Sizable = {
    string: { unit: "znak", verb: "mt" },
    file: { unit: "bajt", verb: "mt" },
    array: { unit: "prvk", verb: "mt" },
    set: { unit: "prvk", verb: "mt" }
  };
  function getSizing(origin) {
    return Sizable[origin] ?? null;
  }
  const parsedType = (data) => {
    const t = typeof data;
    switch (t) {
      case "number": {
        return Number.isNaN(data) ? "NaN" : "slo";
      }
      case "string": {
        return "etzec";
      }
      case "boolean": {
        return "boolean";
      }
      case "bigint": {
        return "bigint";
      }
      case "function": {
        return "funkce";
      }
      case "symbol": {
        return "symbol";
      }
      case "undefined": {
        return "undefined";
      }
      case "object": {
        if (Array.isArray(data)) {
          return "pole";
        }
        if (data === null) {
          return "null";
        }
        if (Object.getPrototypeOf(data) !== Object.prototype && data.constructor) {
          return data.constructor.name;
        }
      }
    }
    return t;
  };
  const Nouns = {
    regex: "regulrn vraz",
    email: "e-mailov adresa",
    url: "URL",
    emoji: "emoji",
    uuid: "UUID",
    uuidv4: "UUIDv4",
    uuidv6: "UUIDv6",
    nanoid: "nanoid",
    guid: "GUID",
    cuid: "cuid",
    cuid2: "cuid2",
    ulid: "ULID",
    xid: "XID",
    ksuid: "KSUID",
    datetime: "datum a as ve formtu ISO",
    date: "datum ve formtu ISO",
    time: "as ve formtu ISO",
    duration: "doba trvn ISO",
    ipv4: "IPv4 adresa",
    ipv6: "IPv6 adresa",
    cidrv4: "rozsah IPv4",
    cidrv6: "rozsah IPv6",
    base64: "etzec zakdovan ve formtu base64",
    base64url: "etzec zakdovan ve formtu base64url",
    json_string: "etzec ve formtu JSON",
    e164: "slo E.164",
    jwt: "JWT",
    template_literal: "vstup"
  };
  return (issue2) => {
    switch (issue2.code) {
      case "invalid_type":
        return `Neplatn vstup: oekvno ${issue2.expected}, obdreno ${parsedType(issue2.input)}`;
      case "invalid_value":
        if (issue2.values.length === 1)
          return `Neplatn vstup: oekvno ${stringifyPrimitive(issue2.values[0])}`;
        return `Neplatn monost: oekvna jedna z hodnot ${joinValues(issue2.values, "|")}`;
      case "too_big": {
        const adj = issue2.inclusive ? "<=" : "<";
        const sizing = getSizing(issue2.origin);
        if (sizing) {
          return `Hodnota je pli velk: ${issue2.origin ?? "hodnota"} mus mt ${adj}${issue2.maximum.toString()} ${sizing.unit ?? "prvk"}`;
        }
        return `Hodnota je pli velk: ${issue2.origin ?? "hodnota"} mus bt ${adj}${issue2.maximum.toString()}`;
      }
      case "too_small": {
        const adj = issue2.inclusive ? ">=" : ">";
        const sizing = getSizing(issue2.origin);
        if (sizing) {
          return `Hodnota je pli mal: ${issue2.origin ?? "hodnota"} mus mt ${adj}${issue2.minimum.toString()} ${sizing.unit ?? "prvk"}`;
        }
        return `Hodnota je pli mal: ${issue2.origin ?? "hodnota"} mus bt ${adj}${issue2.minimum.toString()}`;
      }
      case "invalid_format": {
        const _issue = issue2;
        if (_issue.format === "starts_with")
          return `Neplatn etzec: mus zanat na "${_issue.prefix}"`;
        if (_issue.format === "ends_with")
          return `Neplatn etzec: mus konit na "${_issue.suffix}"`;
        if (_issue.format === "includes")
          return `Neplatn etzec: mus obsahovat "${_issue.includes}"`;
        if (_issue.format === "regex")
          return `Neplatn etzec: mus odpovdat vzoru ${_issue.pattern}`;
        return `Neplatn formt ${Nouns[_issue.format] ?? issue2.format}`;
      }
      case "not_multiple_of":
        return `Neplatn slo: mus bt nsobkem ${issue2.divisor}`;
      case "unrecognized_keys":
        return `Neznm kle: ${joinValues(issue2.keys, ", ")}`;
      case "invalid_key":
        return `Neplatn kl v ${issue2.origin}`;
      case "invalid_union":
        return "Neplatn vstup";
      case "invalid_element":
        return `Neplatn hodnota v ${issue2.origin}`;
      default:
        return `Neplatn vstup`;
    }
  };
};
function cs_default() {
  return {
    localeError: error6()
  };
}
// node_modules/zod/v4/locales/de.js
var error7 = () => {
  const Sizable = {
    string: { unit: "Zeichen", verb: "zu haben" },
    file: { unit: "Bytes", verb: "zu haben" },
    array: { unit: "Elemente", verb: "zu haben" },
    set: { unit: "Elemente", verb: "zu haben" }
  };
  function getSizing(origin) {
    return Sizable[origin] ?? null;
  }
  const parsedType = (data) => {
    const t = typeof data;
    switch (t) {
      case "number": {
        return Number.isNaN(data) ? "NaN" : "Zahl";
      }
      case "object": {
        if (Array.isArray(data)) {
          return "Array";
        }
        if (data === null) {
          return "null";
        }
        if (Object.getPrototypeOf(data) !== Object.prototype && data.constructor) {
          return data.constructor.name;
        }
      }
    }
    return t;
  };
  const Nouns = {
    regex: "Eingabe",
    email: "E-Mail-Adresse",
    url: "URL",
    emoji: "Emoji",
    uuid: "UUID",
    uuidv4: "UUIDv4",
    uuidv6: "UUIDv6",
    nanoid: "nanoid",
    guid: "GUID",
    cuid: "cuid",
    cuid2: "cuid2",
    ulid: "ULID",
    xid: "XID",
    ksuid: "KSUID",
    datetime: "ISO-Datum und -Uhrzeit",
    date: "ISO-Datum",
    time: "ISO-Uhrzeit",
    duration: "ISO-Dauer",
    ipv4: "IPv4-Adresse",
    ipv6: "IPv6-Adresse",
    cidrv4: "IPv4-Bereich",
    cidrv6: "IPv6-Bereich",
    base64: "Base64-codierter String",
    base64url: "Base64-URL-codierter String",
    json_string: "JSON-String",
    e164: "E.164-Nummer",
    jwt: "JWT",
    template_literal: "Eingabe"
  };
  return (issue2) => {
    switch (issue2.code) {
      case "invalid_type":
        return `Ungltige Eingabe: erwartet ${issue2.expected}, erhalten ${parsedType(issue2.input)}`;
      case "invalid_value":
        if (issue2.values.length === 1)
          return `Ungltige Eingabe: erwartet ${stringifyPrimitive(issue2.values[0])}`;
        return `Ungltige Option: erwartet eine von ${joinValues(issue2.values, "|")}`;
      case "too_big": {
        const adj = issue2.inclusive ? "<=" : "<";
        const sizing = getSizing(issue2.origin);
        if (sizing)
          return `Zu gro: erwartet, dass ${issue2.origin ?? "Wert"} ${adj}${issue2.maximum.toString()} ${sizing.unit ?? "Elemente"} hat`;
        return `Zu gro: erwartet, dass ${issue2.origin ?? "Wert"} ${adj}${issue2.maximum.toString()} ist`;
      }
      case "too_small": {
        const adj = issue2.inclusive ? ">=" : ">";
        const sizing = getSizing(issue2.origin);
        if (sizing) {
          return `Zu klein: erwartet, dass ${issue2.origin} ${adj}${issue2.minimum.toString()} ${sizing.unit} hat`;
        }
        return `Zu klein: erwartet, dass ${issue2.origin} ${adj}${issue2.minimum.toString()} ist`;
      }
      case "invalid_format": {
        const _issue = issue2;
        if (_issue.format === "starts_with")
          return `Ungltiger String: muss mit "${_issue.prefix}" beginnen`;
        if (_issue.format === "ends_with")
          return `Ungltiger String: muss mit "${_issue.suffix}" enden`;
        if (_issue.format === "includes")
          return `Ungltiger String: muss "${_issue.includes}" enthalten`;
        if (_issue.format === "regex")
          return `Ungltiger String: muss dem Muster ${_issue.pattern} entsprechen`;
        return `Ungltig: ${Nouns[_issue.format] ?? issue2.format}`;
      }
      case "not_multiple_of":
        return `Ungltige Zahl: muss ein Vielfaches von ${issue2.divisor} sein`;
      case "unrecognized_keys":
        return `${issue2.keys.length > 1 ? "Unbekannte Schlssel" : "Unbekannter Schlssel"}: ${joinValues(issue2.keys, ", ")}`;
      case "invalid_key":
        return `Ungltiger Schlssel in ${issue2.origin}`;
      case "invalid_union":
        return "Ungltige Eingabe";
      case "invalid_element":
        return `Ungltiger Wert in ${issue2.origin}`;
      default:
        return `Ungltige Eingabe`;
    }
  };
};
function de_default() {
  return {
    localeError: error7()
  };
}
// node_modules/zod/v4/locales/en.js
var parsedType = (data) => {
  const t = typeof data;
  switch (t) {
    case "number": {
      return Number.isNaN(data) ? "NaN" : "number";
    }
    case "object": {
      if (Array.isArray(data)) {
        return "array";
      }
      if (data === null) {
        return "null";
      }
      if (Object.getPrototypeOf(data) !== Object.prototype && data.constructor) {
        return data.constructor.name;
      }
    }
  }
  return t;
};
var error8 = () => {
  const Sizable = {
    string: { unit: "characters", verb: "to have" },
    file: { unit: "bytes", verb: "to have" },
    array: { unit: "items", verb: "to have" },
    set: { unit: "items", verb: "to have" }
  };
  function getSizing(origin) {
    return Sizable[origin] ?? null;
  }
  const Nouns = {
    regex: "input",
    email: "email address",
    url: "URL",
    emoji: "emoji",
    uuid: "UUID",
    uuidv4: "UUIDv4",
    uuidv6: "UUIDv6",
    nanoid: "nanoid",
    guid: "GUID",
    cuid: "cuid",
    cuid2: "cuid2",
    ulid: "ULID",
    xid: "XID",
    ksuid: "KSUID",
    datetime: "ISO datetime",
    date: "ISO date",
    time: "ISO time",
    duration: "ISO duration",
    ipv4: "IPv4 address",
    ipv6: "IPv6 address",
    cidrv4: "IPv4 range",
    cidrv6: "IPv6 range",
    base64: "base64-encoded string",
    base64url: "base64url-encoded string",
    json_string: "JSON string",
    e164: "E.164 number",
    jwt: "JWT",
    template_literal: "input"
  };
  return (issue2) => {
    switch (issue2.code) {
      case "invalid_type":
        return `Invalid input: expected ${issue2.expected}, received ${parsedType(issue2.input)}`;
      case "invalid_value":
        if (issue2.values.length === 1)
          return `Invalid input: expected ${stringifyPrimitive(issue2.values[0])}`;
        return `Invalid option: expected one of ${joinValues(issue2.values, "|")}`;
      case "too_big": {
        const adj = issue2.inclusive ? "<=" : "<";
        const sizing = getSizing(issue2.origin);
        if (sizing)
          return `Too big: expected ${issue2.origin ?? "value"} to have ${adj}${issue2.maximum.toString()} ${sizing.unit ?? "elements"}`;
        return `Too big: expected ${issue2.origin ?? "value"} to be ${adj}${issue2.maximum.toString()}`;
      }
      case "too_small": {
        const adj = issue2.inclusive ? ">=" : ">";
        const sizing = getSizing(issue2.origin);
        if (sizing) {
          return `Too small: expected ${issue2.origin} to have ${adj}${issue2.minimum.toString()} ${sizing.unit}`;
        }
        return `Too small: expected ${issue2.origin} to be ${adj}${issue2.minimum.toString()}`;
      }
      case "invalid_format": {
        const _issue = issue2;
        if (_issue.format === "starts_with") {
          return `Invalid string: must start with "${_issue.prefix}"`;
        }
        if (_issue.format === "ends_with")
          return `Invalid string: must end with "${_issue.suffix}"`;
        if (_issue.format === "includes")
          return `Invalid string: must include "${_issue.includes}"`;
        if (_issue.format === "regex")
          return `Invalid string: must match pattern ${_issue.pattern}`;
        return `Invalid ${Nouns[_issue.format] ?? issue2.format}`;
      }
      case "not_multiple_of":
        return `Invalid number: must be a multiple of ${issue2.divisor}`;
      case "unrecognized_keys":
        return `Unrecognized key${issue2.keys.length > 1 ? "s" : ""}: ${joinValues(issue2.keys, ", ")}`;
      case "invalid_key":
        return `Invalid key in ${issue2.origin}`;
      case "invalid_union":
        return "Invalid input";
      case "invalid_element":
        return `Invalid value in ${issue2.origin}`;
      default:
        return `Invalid input`;
    }
  };
};
function en_default() {
  return {
    localeError: error8()
  };
}
// node_modules/zod/v4/locales/eo.js
var parsedType2 = (data) => {
  const t = typeof data;
  switch (t) {
    case "number": {
      return Number.isNaN(data) ? "NaN" : "nombro";
    }
    case "object": {
      if (Array.isArray(data)) {
        return "tabelo";
      }
      if (data === null) {
        return "senvalora";
      }
      if (Object.getPrototypeOf(data) !== Object.prototype && data.constructor) {
        return data.constructor.name;
      }
    }
  }
  return t;
};
var error9 = () => {
  const Sizable = {
    string: { unit: "karaktrojn", verb: "havi" },
    file: { unit: "bajtojn", verb: "havi" },
    array: { unit: "elementojn", verb: "havi" },
    set: { unit: "elementojn", verb: "havi" }
  };
  function getSizing(origin) {
    return Sizable[origin] ?? null;
  }
  const Nouns = {
    regex: "enigo",
    email: "retadreso",
    url: "URL",
    emoji: "emoio",
    uuid: "UUID",
    uuidv4: "UUIDv4",
    uuidv6: "UUIDv6",
    nanoid: "nanoid",
    guid: "GUID",
    cuid: "cuid",
    cuid2: "cuid2",
    ulid: "ULID",
    xid: "XID",
    ksuid: "KSUID",
    datetime: "ISO-datotempo",
    date: "ISO-dato",
    time: "ISO-tempo",
    duration: "ISO-daro",
    ipv4: "IPv4-adreso",
    ipv6: "IPv6-adreso",
    cidrv4: "IPv4-rango",
    cidrv6: "IPv6-rango",
    base64: "64-ume kodita karaktraro",
    base64url: "URL-64-ume kodita karaktraro",
    json_string: "JSON-karaktraro",
    e164: "E.164-nombro",
    jwt: "JWT",
    template_literal: "enigo"
  };
  return (issue2) => {
    switch (issue2.code) {
      case "invalid_type":
        return `Nevalida enigo: atendiis ${issue2.expected}, riceviis ${parsedType2(issue2.input)}`;
      case "invalid_value":
        if (issue2.values.length === 1)
          return `Nevalida enigo: atendiis ${stringifyPrimitive(issue2.values[0])}`;
        return `Nevalida opcio: atendiis unu el ${joinValues(issue2.values, "|")}`;
      case "too_big": {
        const adj = issue2.inclusive ? "<=" : "<";
        const sizing = getSizing(issue2.origin);
        if (sizing)
          return `Tro granda: atendiis ke ${issue2.origin ?? "valoro"} havu ${adj}${issue2.maximum.toString()} ${sizing.unit ?? "elementojn"}`;
        return `Tro granda: atendiis ke ${issue2.origin ?? "valoro"} havu ${adj}${issue2.maximum.toString()}`;
      }
      case "too_small": {
        const adj = issue2.inclusive ? ">=" : ">";
        const sizing = getSizing(issue2.origin);
        if (sizing) {
          return `Tro malgranda: atendiis ke ${issue2.origin} havu ${adj}${issue2.minimum.toString()} ${sizing.unit}`;
        }
        return `Tro malgranda: atendiis ke ${issue2.origin} estu ${adj}${issue2.minimum.toString()}`;
      }
      case "invalid_format": {
        const _issue = issue2;
        if (_issue.format === "starts_with")
          return `Nevalida karaktraro: devas komencii per "${_issue.prefix}"`;
        if (_issue.format === "ends_with")
          return `Nevalida karaktraro: devas finii per "${_issue.suffix}"`;
        if (_issue.format === "includes")
          return `Nevalida karaktraro: devas inkluzivi "${_issue.includes}"`;
        if (_issue.format === "regex")
          return `Nevalida karaktraro: devas kongrui kun la modelo ${_issue.pattern}`;
        return `Nevalida ${Nouns[_issue.format] ?? issue2.format}`;
      }
      case "not_multiple_of":
        return `Nevalida nombro: devas esti oblo de ${issue2.divisor}`;
      case "unrecognized_keys":
        return `Nekonata${issue2.keys.length > 1 ? "j" : ""} losilo${issue2.keys.length > 1 ? "j" : ""}: ${joinValues(issue2.keys, ", ")}`;
      case "invalid_key":
        return `Nevalida losilo en ${issue2.origin}`;
      case "invalid_union":
        return "Nevalida enigo";
      case "invalid_element":
        return `Nevalida valoro en ${issue2.origin}`;
      default:
        return `Nevalida enigo`;
    }
  };
};
function eo_default() {
  return {
    localeError: error9()
  };
}
// node_modules/zod/v4/locales/es.js
var error10 = () => {
  const Sizable = {
    string: { unit: "caracteres", verb: "tener" },
    file: { unit: "bytes", verb: "tener" },
    array: { unit: "elementos", verb: "tener" },
    set: { unit: "elementos", verb: "tener" }
  };
  function getSizing(origin) {
    return Sizable[origin] ?? null;
  }
  const parsedType3 = (data) => {
    const t = typeof data;
    switch (t) {
      case "number": {
        return Number.isNaN(data) ? "NaN" : "nmero";
      }
      case "object": {
        if (Array.isArray(data)) {
          return "arreglo";
        }
        if (data === null) {
          return "nulo";
        }
        if (Object.getPrototypeOf(data) !== Object.prototype) {
          return data.constructor.name;
        }
      }
    }
    return t;
  };
  const Nouns = {
    regex: "entrada",
    email: "direccin de correo electrnico",
    url: "URL",
    emoji: "emoji",
    uuid: "UUID",
    uuidv4: "UUIDv4",
    uuidv6: "UUIDv6",
    nanoid: "nanoid",
    guid: "GUID",
    cuid: "cuid",
    cuid2: "cuid2",
    ulid: "ULID",
    xid: "XID",
    ksuid: "KSUID",
    datetime: "fecha y hora ISO",
    date: "fecha ISO",
    time: "hora ISO",
    duration: "duracin ISO",
    ipv4: "direccin IPv4",
    ipv6: "direccin IPv6",
    cidrv4: "rango IPv4",
    cidrv6: "rango IPv6",
    base64: "cadena codificada en base64",
    base64url: "URL codificada en base64",
    json_string: "cadena JSON",
    e164: "nmero E.164",
    jwt: "JWT",
    template_literal: "entrada"
  };
  return (issue2) => {
    switch (issue2.code) {
      case "invalid_type":
        return `Entrada invlida: se esperaba ${issue2.expected}, recibido ${parsedType3(issue2.input)}`;
      case "invalid_value":
        if (issue2.values.length === 1)
          return `Entrada invlida: se esperaba ${stringifyPrimitive(issue2.values[0])}`;
        return `Opcin invlida: se esperaba una de ${joinValues(issue2.values, "|")}`;
      case "too_big": {
        const adj = issue2.inclusive ? "<=" : "<";
        const sizing = getSizing(issue2.origin);
        if (sizing)
          return `Demasiado grande: se esperaba que ${issue2.origin ?? "valor"} tuviera ${adj}${issue2.maximum.toString()} ${sizing.unit ?? "elementos"}`;
        return `Demasiado grande: se esperaba que ${issue2.origin ?? "valor"} fuera ${adj}${issue2.maximum.toString()}`;
      }
      case "too_small": {
        const adj = issue2.inclusive ? ">=" : ">";
        const sizing = getSizing(issue2.origin);
        if (sizing) {
          return `Demasiado pequeo: se esperaba que ${issue2.origin} tuviera ${adj}${issue2.minimum.toString()} ${sizing.unit}`;
        }
        return `Demasiado pequeo: se esperaba que ${issue2.origin} fuera ${adj}${issue2.minimum.toString()}`;
      }
      case "invalid_format": {
        const _issue = issue2;
        if (_issue.format === "starts_with")
          return `Cadena invlida: debe comenzar con "${_issue.prefix}"`;
        if (_issue.format === "ends_with")
          return `Cadena invlida: debe terminar en "${_issue.suffix}"`;
        if (_issue.format === "includes")
          return `Cadena invlida: debe incluir "${_issue.includes}"`;
        if (_issue.format === "regex")
          return `Cadena invlida: debe coincidir con el patrn ${_issue.pattern}`;
        return `Invlido ${Nouns[_issue.format] ?? issue2.format}`;
      }
      case "not_multiple_of":
        return `Nmero invlido: debe ser mltiplo de ${issue2.divisor}`;
      case "unrecognized_keys":
        return `Llave${issue2.keys.length > 1 ? "s" : ""} desconocida${issue2.keys.length > 1 ? "s" : ""}: ${joinValues(issue2.keys, ", ")}`;
      case "invalid_key":
        return `Llave invlida en ${issue2.origin}`;
      case "invalid_union":
        return "Entrada invlida";
      case "invalid_element":
        return `Valor invlido en ${issue2.origin}`;
      default:
        return `Entrada invlida`;
    }
  };
};
function es_default() {
  return {
    localeError: error10()
  };
}
// node_modules/zod/v4/locales/fa.js
var error11 = () => {
  const Sizable = {
    string: { unit: "", verb: " " },
    file: { unit: "", verb: " " },
    array: { unit: "", verb: " " },
    set: { unit: "", verb: " " }
  };
  function getSizing(origin) {
    return Sizable[origin] ?? null;
  }
  const parsedType3 = (data) => {
    const t = typeof data;
    switch (t) {
      case "number": {
        return Number.isNaN(data) ? "NaN" : "";
      }
      case "object": {
        if (Array.isArray(data)) {
          return "";
        }
        if (data === null) {
          return "null";
        }
        if (Object.getPrototypeOf(data) !== Object.prototype && data.constructor) {
          return data.constructor.name;
        }
      }
    }
    return t;
  };
  const Nouns = {
    regex: "",
    email: " ",
    url: "URL",
    emoji: "",
    uuid: "UUID",
    uuidv4: "UUIDv4",
    uuidv6: "UUIDv6",
    nanoid: "nanoid",
    guid: "GUID",
    cuid: "cuid",
    cuid2: "cuid2",
    ulid: "ULID",
    xid: "XID",
    ksuid: "KSUID",
    datetime: "   ",
    date: " ",
    time: " ",
    duration: "  ",
    ipv4: "IPv4 ",
    ipv6: "IPv6 ",
    cidrv4: "IPv4 ",
    cidrv6: "IPv6 ",
    base64: "base64-encoded ",
    base64url: "base64url-encoded ",
    json_string: "JSON ",
    e164: "E.164 ",
    jwt: "JWT",
    template_literal: ""
  };
  return (issue2) => {
    switch (issue2.code) {
      case "invalid_type":
        return ` :  ${issue2.expected}  ${parsedType3(issue2.input)}  `;
      case "invalid_value":
        if (issue2.values.length === 1) {
          return ` :  ${stringifyPrimitive(issue2.values[0])} `;
        }
        return ` :    ${joinValues(issue2.values, "|")} `;
      case "too_big": {
        const adj = issue2.inclusive ? "<=" : "<";
        const sizing = getSizing(issue2.origin);
        if (sizing) {
          return ` : ${issue2.origin ?? ""}  ${adj}${issue2.maximum.toString()} ${sizing.unit ?? ""} `;
        }
        return ` : ${issue2.origin ?? ""}  ${adj}${issue2.maximum.toString()} `;
      }
      case "too_small": {
        const adj = issue2.inclusive ? ">=" : ">";
        const sizing = getSizing(issue2.origin);
        if (sizing) {
          return ` : ${issue2.origin}  ${adj}${issue2.minimum.toString()} ${sizing.unit} `;
        }
        return ` : ${issue2.origin}  ${adj}${issue2.minimum.toString()} `;
      }
      case "invalid_format": {
        const _issue = issue2;
        if (_issue.format === "starts_with") {
          return ` :   "${_issue.prefix}"  `;
        }
        if (_issue.format === "ends_with") {
          return ` :   "${_issue.suffix}"  `;
        }
        if (_issue.format === "includes") {
          return ` :   "${_issue.includes}" `;
        }
        if (_issue.format === "regex") {
          return ` :    ${_issue.pattern}   `;
        }
        return `${Nouns[_issue.format] ?? issue2.format} `;
      }
      case "not_multiple_of":
        return ` :   ${issue2.divisor} `;
      case "unrecognized_keys":
        return `${issue2.keys.length > 1 ? "" : ""} : ${joinValues(issue2.keys, ", ")}`;
      case "invalid_key":
        return `   ${issue2.origin}`;
      case "invalid_union":
        return ` `;
      case "invalid_element":
        return `   ${issue2.origin}`;
      default:
        return ` `;
    }
  };
};
function fa_default() {
  return {
    localeError: error11()
  };
}
// node_modules/zod/v4/locales/fi.js
var error12 = () => {
  const Sizable = {
    string: { unit: "merkki", subject: "merkkijonon" },
    file: { unit: "tavua", subject: "tiedoston" },
    array: { unit: "alkiota", subject: "listan" },
    set: { unit: "alkiota", subject: "joukon" },
    number: { unit: "", subject: "luvun" },
    bigint: { unit: "", subject: "suuren kokonaisluvun" },
    int: { unit: "", subject: "kokonaisluvun" },
    date: { unit: "", subject: "pivmrn" }
  };
  function getSizing(origin) {
    return Sizable[origin] ?? null;
  }
  const parsedType3 = (data) => {
    const t = typeof data;
    switch (t) {
      case "number": {
        return Number.isNaN(data) ? "NaN" : "number";
      }
      case "object": {
        if (Array.isArray(data)) {
          return "array";
        }
        if (data === null) {
          return "null";
        }
        if (Object.getPrototypeOf(data) !== Object.prototype && data.constructor) {
          return data.constructor.name;
        }
      }
    }
    return t;
  };
  const Nouns = {
    regex: "snnllinen lauseke",
    email: "shkpostiosoite",
    url: "URL-osoite",
    emoji: "emoji",
    uuid: "UUID",
    uuidv4: "UUIDv4",
    uuidv6: "UUIDv6",
    nanoid: "nanoid",
    guid: "GUID",
    cuid: "cuid",
    cuid2: "cuid2",
    ulid: "ULID",
    xid: "XID",
    ksuid: "KSUID",
    datetime: "ISO-aikaleima",
    date: "ISO-pivmr",
    time: "ISO-aika",
    duration: "ISO-kesto",
    ipv4: "IPv4-osoite",
    ipv6: "IPv6-osoite",
    cidrv4: "IPv4-alue",
    cidrv6: "IPv6-alue",
    base64: "base64-koodattu merkkijono",
    base64url: "base64url-koodattu merkkijono",
    json_string: "JSON-merkkijono",
    e164: "E.164-luku",
    jwt: "JWT",
    template_literal: "templaattimerkkijono"
  };
  return (issue2) => {
    switch (issue2.code) {
      case "invalid_type":
        return `Virheellinen tyyppi: odotettiin ${issue2.expected}, oli ${parsedType3(issue2.input)}`;
      case "invalid_value":
        if (issue2.values.length === 1)
          return `Virheellinen syte: tytyy olla ${stringifyPrimitive(issue2.values[0])}`;
        return `Virheellinen valinta: tytyy olla yksi seuraavista: ${joinValues(issue2.values, "|")}`;
      case "too_big": {
        const adj = issue2.inclusive ? "<=" : "<";
        const sizing = getSizing(issue2.origin);
        if (sizing) {
          return `Liian suuri: ${sizing.subject} tytyy olla ${adj}${issue2.maximum.toString()} ${sizing.unit}`.trim();
        }
        return `Liian suuri: arvon tytyy olla ${adj}${issue2.maximum.toString()}`;
      }
      case "too_small": {
        const adj = issue2.inclusive ? ">=" : ">";
        const sizing = getSizing(issue2.origin);
        if (sizing) {
          return `Liian pieni: ${sizing.subject} tytyy olla ${adj}${issue2.minimum.toString()} ${sizing.unit}`.trim();
        }
        return `Liian pieni: arvon tytyy olla ${adj}${issue2.minimum.toString()}`;
      }
      case "invalid_format": {
        const _issue = issue2;
        if (_issue.format === "starts_with")
          return `Virheellinen syte: tytyy alkaa "${_issue.prefix}"`;
        if (_issue.format === "ends_with")
          return `Virheellinen syte: tytyy loppua "${_issue.suffix}"`;
        if (_issue.format === "includes")
          return `Virheellinen syte: tytyy sislt "${_issue.includes}"`;
        if (_issue.format === "regex") {
          return `Virheellinen syte: tytyy vastata snnllist lauseketta ${_issue.pattern}`;
        }
        return `Virheellinen ${Nouns[_issue.format] ?? issue2.format}`;
      }
      case "not_multiple_of":
        return `Virheellinen luku: tytyy olla luvun ${issue2.divisor} monikerta`;
      case "unrecognized_keys":
        return `${issue2.keys.length > 1 ? "Tuntemattomat avaimet" : "Tuntematon avain"}: ${joinValues(issue2.keys, ", ")}`;
      case "invalid_key":
        return "Virheellinen avain tietueessa";
      case "invalid_union":
        return "Virheellinen unioni";
      case "invalid_element":
        return "Virheellinen arvo joukossa";
      default:
        return `Virheellinen syte`;
    }
  };
};
function fi_default() {
  return {
    localeError: error12()
  };
}
// node_modules/zod/v4/locales/fr.js
var error13 = () => {
  const Sizable = {
    string: { unit: "caractres", verb: "avoir" },
    file: { unit: "octets", verb: "avoir" },
    array: { unit: "lments", verb: "avoir" },
    set: { unit: "lments", verb: "avoir" }
  };
  function getSizing(origin) {
    return Sizable[origin] ?? null;
  }
  const parsedType3 = (data) => {
    const t = typeof data;
    switch (t) {
      case "number": {
        return Number.isNaN(data) ? "NaN" : "nombre";
      }
      case "object": {
        if (Array.isArray(data)) {
          return "tableau";
        }
        if (data === null) {
          return "null";
        }
        if (Object.getPrototypeOf(data) !== Object.prototype && data.constructor) {
          return data.constructor.name;
        }
      }
    }
    return t;
  };
  const Nouns = {
    regex: "entre",
    email: "adresse e-mail",
    url: "URL",
    emoji: "emoji",
    uuid: "UUID",
    uuidv4: "UUIDv4",
    uuidv6: "UUIDv6",
    nanoid: "nanoid",
    guid: "GUID",
    cuid: "cuid",
    cuid2: "cuid2",
    ulid: "ULID",
    xid: "XID",
    ksuid: "KSUID",
    datetime: "date et heure ISO",
    date: "date ISO",
    time: "heure ISO",
    duration: "dure ISO",
    ipv4: "adresse IPv4",
    ipv6: "adresse IPv6",
    cidrv4: "plage IPv4",
    cidrv6: "plage IPv6",
    base64: "chane encode en base64",
    base64url: "chane encode en base64url",
    json_string: "chane JSON",
    e164: "numro E.164",
    jwt: "JWT",
    template_literal: "entre"
  };
  return (issue2) => {
    switch (issue2.code) {
      case "invalid_type":
        return `Entre invalide : ${issue2.expected} attendu, ${parsedType3(issue2.input)} reu`;
      case "invalid_value":
        if (issue2.values.length === 1)
          return `Entre invalide : ${stringifyPrimitive(issue2.values[0])} attendu`;
        return `Option invalide : une valeur parmi ${joinValues(issue2.values, "|")} attendue`;
      case "too_big": {
        const adj = issue2.inclusive ? "<=" : "<";
        const sizing = getSizing(issue2.origin);
        if (sizing)
          return `Trop grand : ${issue2.origin ?? "valeur"} doit ${sizing.verb} ${adj}${issue2.maximum.toString()} ${sizing.unit ?? "lment(s)"}`;
        return `Trop grand : ${issue2.origin ?? "valeur"} doit tre ${adj}${issue2.maximum.toString()}`;
      }
      case "too_small": {
        const adj = issue2.inclusive ? ">=" : ">";
        const sizing = getSizing(issue2.origin);
        if (sizing) {
          return `Trop petit : ${issue2.origin} doit ${sizing.verb} ${adj}${issue2.minimum.toString()} ${sizing.unit}`;
        }
        return `Trop petit : ${issue2.origin} doit tre ${adj}${issue2.minimum.toString()}`;
      }
      case "invalid_format": {
        const _issue = issue2;
        if (_issue.format === "starts_with")
          return `Chane invalide : doit commencer par "${_issue.prefix}"`;
        if (_issue.format === "ends_with")
          return `Chane invalide : doit se terminer par "${_issue.suffix}"`;
        if (_issue.format === "includes")
          return `Chane invalide : doit inclure "${_issue.includes}"`;
        if (_issue.format === "regex")
          return `Chane invalide : doit correspondre au modle ${_issue.pattern}`;
        return `${Nouns[_issue.format] ?? issue2.format} invalide`;
      }
      case "not_multiple_of":
        return `Nombre invalide : doit tre un multiple de ${issue2.divisor}`;
      case "unrecognized_keys":
        return `Cl${issue2.keys.length > 1 ? "s" : ""} non reconnue${issue2.keys.length > 1 ? "s" : ""} : ${joinValues(issue2.keys, ", ")}`;
      case "invalid_key":
        return `Cl invalide dans ${issue2.origin}`;
      case "invalid_union":
        return "Entre invalide";
      case "invalid_element":
        return `Valeur invalide dans ${issue2.origin}`;
      default:
        return `Entre invalide`;
    }
  };
};
function fr_default() {
  return {
    localeError: error13()
  };
}
// node_modules/zod/v4/locales/fr-CA.js
var error14 = () => {
  const Sizable = {
    string: { unit: "caractres", verb: "avoir" },
    file: { unit: "octets", verb: "avoir" },
    array: { unit: "lments", verb: "avoir" },
    set: { unit: "lments", verb: "avoir" }
  };
  function getSizing(origin) {
    return Sizable[origin] ?? null;
  }
  const parsedType3 = (data) => {
    const t = typeof data;
    switch (t) {
      case "number": {
        return Number.isNaN(data) ? "NaN" : "number";
      }
      case "object": {
        if (Array.isArray(data)) {
          return "array";
        }
        if (data === null) {
          return "null";
        }
        if (Object.getPrototypeOf(data) !== Object.prototype && data.constructor) {
          return data.constructor.name;
        }
      }
    }
    return t;
  };
  const Nouns = {
    regex: "entre",
    email: "adresse courriel",
    url: "URL",
    emoji: "emoji",
    uuid: "UUID",
    uuidv4: "UUIDv4",
    uuidv6: "UUIDv6",
    nanoid: "nanoid",
    guid: "GUID",
    cuid: "cuid",
    cuid2: "cuid2",
    ulid: "ULID",
    xid: "XID",
    ksuid: "KSUID",
    datetime: "date-heure ISO",
    date: "date ISO",
    time: "heure ISO",
    duration: "dure ISO",
    ipv4: "adresse IPv4",
    ipv6: "adresse IPv6",
    cidrv4: "plage IPv4",
    cidrv6: "plage IPv6",
    base64: "chane encode en base64",
    base64url: "chane encode en base64url",
    json_string: "chane JSON",
    e164: "numro E.164",
    jwt: "JWT",
    template_literal: "entre"
  };
  return (issue2) => {
    switch (issue2.code) {
      case "invalid_type":
        return `Entre invalide : attendu ${issue2.expected}, reu ${parsedType3(issue2.input)}`;
      case "invalid_value":
        if (issue2.values.length === 1)
          return `Entre invalide : attendu ${stringifyPrimitive(issue2.values[0])}`;
        return `Option invalide : attendu l'une des valeurs suivantes ${joinValues(issue2.values, "|")}`;
      case "too_big": {
        const adj = issue2.inclusive ? "" : "<";
        const sizing = getSizing(issue2.origin);
        if (sizing)
          return `Trop grand : attendu que ${issue2.origin ?? "la valeur"} ait ${adj}${issue2.maximum.toString()} ${sizing.unit}`;
        return `Trop grand : attendu que ${issue2.origin ?? "la valeur"} soit ${adj}${issue2.maximum.toString()}`;
      }
      case "too_small": {
        const adj = issue2.inclusive ? "" : ">";
        const sizing = getSizing(issue2.origin);
        if (sizing) {
          return `Trop petit : attendu que ${issue2.origin} ait ${adj}${issue2.minimum.toString()} ${sizing.unit}`;
        }
        return `Trop petit : attendu que ${issue2.origin} soit ${adj}${issue2.minimum.toString()}`;
      }
      case "invalid_format": {
        const _issue = issue2;
        if (_issue.format === "starts_with") {
          return `Chane invalide : doit commencer par "${_issue.prefix}"`;
        }
        if (_issue.format === "ends_with")
          return `Chane invalide : doit se terminer par "${_issue.suffix}"`;
        if (_issue.format === "includes")
          return `Chane invalide : doit inclure "${_issue.includes}"`;
        if (_issue.format === "regex")
          return `Chane invalide : doit correspondre au motif ${_issue.pattern}`;
        return `${Nouns[_issue.format] ?? issue2.format} invalide`;
      }
      case "not_multiple_of":
        return `Nombre invalide : doit tre un multiple de ${issue2.divisor}`;
      case "unrecognized_keys":
        return `Cl${issue2.keys.length > 1 ? "s" : ""} non reconnue${issue2.keys.length > 1 ? "s" : ""} : ${joinValues(issue2.keys, ", ")}`;
      case "invalid_key":
        return `Cl invalide dans ${issue2.origin}`;
      case "invalid_union":
        return "Entre invalide";
      case "invalid_element":
        return `Valeur invalide dans ${issue2.origin}`;
      default:
        return `Entre invalide`;
    }
  };
};
function fr_CA_default() {
  return {
    localeError: error14()
  };
}
// node_modules/zod/v4/locales/he.js
var error15 = () => {
  const Sizable = {
    string: { unit: "", verb: "" },
    file: { unit: "", verb: "" },
    array: { unit: "", verb: "" },
    set: { unit: "", verb: "" }
  };
  function getSizing(origin) {
    return Sizable[origin] ?? null;
  }
  const parsedType3 = (data) => {
    const t = typeof data;
    switch (t) {
      case "number": {
        return Number.isNaN(data) ? "NaN" : "number";
      }
      case "object": {
        if (Array.isArray(data)) {
          return "array";
        }
        if (data === null) {
          return "null";
        }
        if (Object.getPrototypeOf(data) !== Object.prototype && data.constructor) {
          return data.constructor.name;
        }
      }
    }
    return t;
  };
  const Nouns = {
    regex: "",
    email: " ",
    url: " ",
    emoji: "'",
    uuid: "UUID",
    uuidv4: "UUIDv4",
    uuidv6: "UUIDv6",
    nanoid: "nanoid",
    guid: "GUID",
    cuid: "cuid",
    cuid2: "cuid2",
    ulid: "ULID",
    xid: "XID",
    ksuid: "KSUID",
    datetime: "  ISO",
    date: " ISO",
    time: " ISO",
    duration: "  ISO",
    ipv4: " IPv4",
    ipv6: " IPv6",
    cidrv4: " IPv4",
    cidrv6: " IPv6",
    base64: "  64",
    base64url: "  64  ",
    json_string: " JSON",
    e164: " E.164",
    jwt: "JWT",
    template_literal: ""
  };
  return (issue2) => {
    switch (issue2.code) {
      case "invalid_type":
        return `  :  ${issue2.expected},  ${parsedType3(issue2.input)}`;
      case "invalid_value":
        if (issue2.values.length === 1)
          return `  :  ${stringifyPrimitive(issue2.values[0])}`;
        return `  :     ${joinValues(issue2.values, "|")}`;
      case "too_big": {
        const adj = issue2.inclusive ? "<=" : "<";
        const sizing = getSizing(issue2.origin);
        if (sizing)
          return ` : ${issue2.origin ?? "value"}   ${adj}${issue2.maximum.toString()} ${sizing.unit ?? "elements"}`;
        return ` : ${issue2.origin ?? "value"}   ${adj}${issue2.maximum.toString()}`;
      }
      case "too_small": {
        const adj = issue2.inclusive ? ">=" : ">";
        const sizing = getSizing(issue2.origin);
        if (sizing) {
          return ` : ${issue2.origin}   ${adj}${issue2.minimum.toString()} ${sizing.unit}`;
        }
        return ` : ${issue2.origin}   ${adj}${issue2.minimum.toString()}`;
      }
      case "invalid_format": {
        const _issue = issue2;
        if (_issue.format === "starts_with")
          return `  :   "${_issue.prefix}"`;
        if (_issue.format === "ends_with")
          return `  :    "${_issue.suffix}"`;
        if (_issue.format === "includes")
          return `  :   "${_issue.includes}"`;
        if (_issue.format === "regex")
          return `  :    ${_issue.pattern}`;
        return `${Nouns[_issue.format] ?? issue2.format}  `;
      }
      case "not_multiple_of":
        return `  :     ${issue2.divisor}`;
      case "unrecognized_keys":
        return `${issue2.keys.length > 1 ? "" : ""}  ${issue2.keys.length > 1 ? "" : ""}: ${joinValues(issue2.keys, ", ")}`;
      case "invalid_key":
        return `   ${issue2.origin}`;
      case "invalid_union":
        return "  ";
      case "invalid_element":
        return `   ${issue2.origin}`;
      default:
        return `  `;
    }
  };
};
function he_default() {
  return {
    localeError: error15()
  };
}
// node_modules/zod/v4/locales/hu.js
var error16 = () => {
  const Sizable = {
    string: { unit: "karakter", verb: "legyen" },
    file: { unit: "byte", verb: "legyen" },
    array: { unit: "elem", verb: "legyen" },
    set: { unit: "elem", verb: "legyen" }
  };
  function getSizing(origin) {
    return Sizable[origin] ?? null;
  }
  const parsedType3 = (data) => {
    const t = typeof data;
    switch (t) {
      case "number": {
        return Number.isNaN(data) ? "NaN" : "szm";
      }
      case "object": {
        if (Array.isArray(data)) {
          return "tmb";
        }
        if (data === null) {
          return "null";
        }
        if (Object.getPrototypeOf(data) !== Object.prototype && data.constructor) {
          return data.constructor.name;
        }
      }
    }
    return t;
  };
  const Nouns = {
    regex: "bemenet",
    email: "email cm",
    url: "URL",
    emoji: "emoji",
    uuid: "UUID",
    uuidv4: "UUIDv4",
    uuidv6: "UUIDv6",
    nanoid: "nanoid",
    guid: "GUID",
    cuid: "cuid",
    cuid2: "cuid2",
    ulid: "ULID",
    xid: "XID",
    ksuid: "KSUID",
    datetime: "ISO idblyeg",
    date: "ISO dtum",
    time: "ISO id",
    duration: "ISO idintervallum",
    ipv4: "IPv4 cm",
    ipv6: "IPv6 cm",
    cidrv4: "IPv4 tartomny",
    cidrv6: "IPv6 tartomny",
    base64: "base64-kdolt string",
    base64url: "base64url-kdolt string",
    json_string: "JSON string",
    e164: "E.164 szm",
    jwt: "JWT",
    template_literal: "bemenet"
  };
  return (issue2) => {
    switch (issue2.code) {
      case "invalid_type":
        return `rvnytelen bemenet: a vrt rtk ${issue2.expected}, a kapott rtk ${parsedType3(issue2.input)}`;
      case "invalid_value":
        if (issue2.values.length === 1)
          return `rvnytelen bemenet: a vrt rtk ${stringifyPrimitive(issue2.values[0])}`;
        return `rvnytelen opci: valamelyik rtk vrt ${joinValues(issue2.values, "|")}`;
      case "too_big": {
        const adj = issue2.inclusive ? "<=" : "<";
        const sizing = getSizing(issue2.origin);
        if (sizing)
          return `Tl nagy: ${issue2.origin ?? "rtk"} mrete tl nagy ${adj}${issue2.maximum.toString()} ${sizing.unit ?? "elem"}`;
        return `Tl nagy: a bemeneti rtk ${issue2.origin ?? "rtk"} tl nagy: ${adj}${issue2.maximum.toString()}`;
      }
      case "too_small": {
        const adj = issue2.inclusive ? ">=" : ">";
        const sizing = getSizing(issue2.origin);
        if (sizing) {
          return `Tl kicsi: a bemeneti rtk ${issue2.origin} mrete tl kicsi ${adj}${issue2.minimum.toString()} ${sizing.unit}`;
        }
        return `Tl kicsi: a bemeneti rtk ${issue2.origin} tl kicsi ${adj}${issue2.minimum.toString()}`;
      }
      case "invalid_format": {
        const _issue = issue2;
        if (_issue.format === "starts_with")
          return `rvnytelen string: "${_issue.prefix}" rtkkel kell kezddnie`;
        if (_issue.format === "ends_with")
          return `rvnytelen string: "${_issue.suffix}" rtkkel kell vgzdnie`;
        if (_issue.format === "includes")
          return `rvnytelen string: "${_issue.includes}" rtket kell tartalmaznia`;
        if (_issue.format === "regex")
          return `rvnytelen string: ${_issue.pattern} mintnak kell megfelelnie`;
        return `rvnytelen ${Nouns[_issue.format] ?? issue2.format}`;
      }
      case "not_multiple_of":
        return `rvnytelen szm: ${issue2.divisor} tbbszrsnek kell lennie`;
      case "unrecognized_keys":
        return `Ismeretlen kulcs${issue2.keys.length > 1 ? "s" : ""}: ${joinValues(issue2.keys, ", ")}`;
      case "invalid_key":
        return `rvnytelen kulcs ${issue2.origin}`;
      case "invalid_union":
        return "rvnytelen bemenet";
      case "invalid_element":
        return `rvnytelen rtk: ${issue2.origin}`;
      default:
        return `rvnytelen bemenet`;
    }
  };
};
function hu_default() {
  return {
    localeError: error16()
  };
}
// node_modules/zod/v4/locales/id.js
var error17 = () => {
  const Sizable = {
    string: { unit: "karakter", verb: "memiliki" },
    file: { unit: "byte", verb: "memiliki" },
    array: { unit: "item", verb: "memiliki" },
    set: { unit: "item", verb: "memiliki" }
  };
  function getSizing(origin) {
    return Sizable[origin] ?? null;
  }
  const parsedType3 = (data) => {
    const t = typeof data;
    switch (t) {
      case "number": {
        return Number.isNaN(data) ? "NaN" : "number";
      }
      case "object": {
        if (Array.isArray(data)) {
          return "array";
        }
        if (data === null) {
          return "null";
        }
        if (Object.getPrototypeOf(data) !== Object.prototype && data.constructor) {
          return data.constructor.name;
        }
      }
    }
    return t;
  };
  const Nouns = {
    regex: "input",
    email: "alamat email",
    url: "URL",
    emoji: "emoji",
    uuid: "UUID",
    uuidv4: "UUIDv4",
    uuidv6: "UUIDv6",
    nanoid: "nanoid",
    guid: "GUID",
    cuid: "cuid",
    cuid2: "cuid2",
    ulid: "ULID",
    xid: "XID",
    ksuid: "KSUID",
    datetime: "tanggal dan waktu format ISO",
    date: "tanggal format ISO",
    time: "jam format ISO",
    duration: "durasi format ISO",
    ipv4: "alamat IPv4",
    ipv6: "alamat IPv6",
    cidrv4: "rentang alamat IPv4",
    cidrv6: "rentang alamat IPv6",
    base64: "string dengan enkode base64",
    base64url: "string dengan enkode base64url",
    json_string: "string JSON",
    e164: "angka E.164",
    jwt: "JWT",
    template_literal: "input"
  };
  return (issue2) => {
    switch (issue2.code) {
      case "invalid_type":
        return `Input tidak valid: diharapkan ${issue2.expected}, diterima ${parsedType3(issue2.input)}`;
      case "invalid_value":
        if (issue2.values.length === 1)
          return `Input tidak valid: diharapkan ${stringifyPrimitive(issue2.values[0])}`;
        return `Pilihan tidak valid: diharapkan salah satu dari ${joinValues(issue2.values, "|")}`;
      case "too_big": {
        const adj = issue2.inclusive ? "<=" : "<";
        const sizing = getSizing(issue2.origin);
        if (sizing)
          return `Terlalu besar: diharapkan ${issue2.origin ?? "value"} memiliki ${adj}${issue2.maximum.toString()} ${sizing.unit ?? "elemen"}`;
        return `Terlalu besar: diharapkan ${issue2.origin ?? "value"} menjadi ${adj}${issue2.maximum.toString()}`;
      }
      case "too_small": {
        const adj = issue2.inclusive ? ">=" : ">";
        const sizing = getSizing(issue2.origin);
        if (sizing) {
          return `Terlalu kecil: diharapkan ${issue2.origin} memiliki ${adj}${issue2.minimum.toString()} ${sizing.unit}`;
        }
        return `Terlalu kecil: diharapkan ${issue2.origin} menjadi ${adj}${issue2.minimum.toString()}`;
      }
      case "invalid_format": {
        const _issue = issue2;
        if (_issue.format === "starts_with")
          return `String tidak valid: harus dimulai dengan "${_issue.prefix}"`;
        if (_issue.format === "ends_with")
          return `String tidak valid: harus berakhir dengan "${_issue.suffix}"`;
        if (_issue.format === "includes")
          return `String tidak valid: harus menyertakan "${_issue.includes}"`;
        if (_issue.format === "regex")
          return `String tidak valid: harus sesuai pola ${_issue.pattern}`;
        return `${Nouns[_issue.format] ?? issue2.format} tidak valid`;
      }
      case "not_multiple_of":
        return `Angka tidak valid: harus kelipatan dari ${issue2.divisor}`;
      case "unrecognized_keys":
        return `Kunci tidak dikenali ${issue2.keys.length > 1 ? "s" : ""}: ${joinValues(issue2.keys, ", ")}`;
      case "invalid_key":
        return `Kunci tidak valid di ${issue2.origin}`;
      case "invalid_union":
        return "Input tidak valid";
      case "invalid_element":
        return `Nilai tidak valid di ${issue2.origin}`;
      default:
        return `Input tidak valid`;
    }
  };
};
function id_default() {
  return {
    localeError: error17()
  };
}
// node_modules/zod/v4/locales/it.js
var error18 = () => {
  const Sizable = {
    string: { unit: "caratteri", verb: "avere" },
    file: { unit: "byte", verb: "avere" },
    array: { unit: "elementi", verb: "avere" },
    set: { unit: "elementi", verb: "avere" }
  };
  function getSizing(origin) {
    return Sizable[origin] ?? null;
  }
  const parsedType3 = (data) => {
    const t = typeof data;
    switch (t) {
      case "number": {
        return Number.isNaN(data) ? "NaN" : "numero";
      }
      case "object": {
        if (Array.isArray(data)) {
          return "vettore";
        }
        if (data === null) {
          return "null";
        }
        if (Object.getPrototypeOf(data) !== Object.prototype && data.constructor) {
          return data.constructor.name;
        }
      }
    }
    return t;
  };
  const Nouns = {
    regex: "input",
    email: "indirizzo email",
    url: "URL",
    emoji: "emoji",
    uuid: "UUID",
    uuidv4: "UUIDv4",
    uuidv6: "UUIDv6",
    nanoid: "nanoid",
    guid: "GUID",
    cuid: "cuid",
    cuid2: "cuid2",
    ulid: "ULID",
    xid: "XID",
    ksuid: "KSUID",
    datetime: "data e ora ISO",
    date: "data ISO",
    time: "ora ISO",
    duration: "durata ISO",
    ipv4: "indirizzo IPv4",
    ipv6: "indirizzo IPv6",
    cidrv4: "intervallo IPv4",
    cidrv6: "intervallo IPv6",
    base64: "stringa codificata in base64",
    base64url: "URL codificata in base64",
    json_string: "stringa JSON",
    e164: "numero E.164",
    jwt: "JWT",
    template_literal: "input"
  };
  return (issue2) => {
    switch (issue2.code) {
      case "invalid_type":
        return `Input non valido: atteso ${issue2.expected}, ricevuto ${parsedType3(issue2.input)}`;
      case "invalid_value":
        if (issue2.values.length === 1)
          return `Input non valido: atteso ${stringifyPrimitive(issue2.values[0])}`;
        return `Opzione non valida: atteso uno tra ${joinValues(issue2.values, "|")}`;
      case "too_big": {
        const adj = issue2.inclusive ? "<=" : "<";
        const sizing = getSizing(issue2.origin);
        if (sizing)
          return `Troppo grande: ${issue2.origin ?? "valore"} deve avere ${adj}${issue2.maximum.toString()} ${sizing.unit ?? "elementi"}`;
        return `Troppo grande: ${issue2.origin ?? "valore"} deve essere ${adj}${issue2.maximum.toString()}`;
      }
      case "too_small": {
        const adj = issue2.inclusive ? ">=" : ">";
        const sizing = getSizing(issue2.origin);
        if (sizing) {
          return `Troppo piccolo: ${issue2.origin} deve avere ${adj}${issue2.minimum.toString()} ${sizing.unit}`;
        }
        return `Troppo piccolo: ${issue2.origin} deve essere ${adj}${issue2.minimum.toString()}`;
      }
      case "invalid_format": {
        const _issue = issue2;
        if (_issue.format === "starts_with")
          return `Stringa non valida: deve iniziare con "${_issue.prefix}"`;
        if (_issue.format === "ends_with")
          return `Stringa non valida: deve terminare con "${_issue.suffix}"`;
        if (_issue.format === "includes")
          return `Stringa non valida: deve includere "${_issue.includes}"`;
        if (_issue.format === "regex")
          return `Stringa non valida: deve corrispondere al pattern ${_issue.pattern}`;
        return `Invalid ${Nouns[_issue.format] ?? issue2.format}`;
      }
      case "not_multiple_of":
        return `Numero non valido: deve essere un multiplo di ${issue2.divisor}`;
      case "unrecognized_keys":
        return `Chiav${issue2.keys.length > 1 ? "i" : "e"} non riconosciut${issue2.keys.length > 1 ? "e" : "a"}: ${joinValues(issue2.keys, ", ")}`;
      case "invalid_key":
        return `Chiave non valida in ${issue2.origin}`;
      case "invalid_union":
        return "Input non valido";
      case "invalid_element":
        return `Valore non valido in ${issue2.origin}`;
      default:
        return `Input non valido`;
    }
  };
};
function it_default() {
  return {
    localeError: error18()
  };
}
// node_modules/zod/v4/locales/ja.js
var error19 = () => {
  const Sizable = {
    string: { unit: "", verb: "" },
    file: { unit: "", verb: "" },
    array: { unit: "", verb: "" },
    set: { unit: "", verb: "" }
  };
  function getSizing(origin) {
    return Sizable[origin] ?? null;
  }
  const parsedType3 = (data) => {
    const t = typeof data;
    switch (t) {
      case "number": {
        return Number.isNaN(data) ? "NaN" : "";
      }
      case "object": {
        if (Array.isArray(data)) {
          return "";
        }
        if (data === null) {
          return "null";
        }
        if (Object.getPrototypeOf(data) !== Object.prototype && data.constructor) {
          return data.constructor.name;
        }
      }
    }
    return t;
  };
  const Nouns = {
    regex: "",
    email: "",
    url: "URL",
    emoji: "",
    uuid: "UUID",
    uuidv4: "UUIDv4",
    uuidv6: "UUIDv6",
    nanoid: "nanoid",
    guid: "GUID",
    cuid: "cuid",
    cuid2: "cuid2",
    ulid: "ULID",
    xid: "XID",
    ksuid: "KSUID",
    datetime: "ISO",
    date: "ISO",
    time: "ISO",
    duration: "ISO",
    ipv4: "IPv4",
    ipv6: "IPv6",
    cidrv4: "IPv4",
    cidrv6: "IPv6",
    base64: "base64",
    base64url: "base64url",
    json_string: "JSON",
    e164: "E.164",
    jwt: "JWT",
    template_literal: ""
  };
  return (issue2) => {
    switch (issue2.code) {
      case "invalid_type":
        return `: ${issue2.expected}${parsedType3(issue2.input)}`;
      case "invalid_value":
        if (issue2.values.length === 1)
          return `: ${stringifyPrimitive(issue2.values[0])}`;
        return `: ${joinValues(issue2.values, "")}`;
      case "too_big": {
        const adj = issue2.inclusive ? "" : "";
        const sizing = getSizing(issue2.origin);
        if (sizing)
          return `: ${issue2.origin ?? ""}${issue2.maximum.toString()}${sizing.unit ?? ""}${adj}`;
        return `: ${issue2.origin ?? ""}${issue2.maximum.toString()}${adj}`;
      }
      case "too_small": {
        const adj = issue2.inclusive ? "" : "";
        const sizing = getSizing(issue2.origin);
        if (sizing)
          return `: ${issue2.origin}${issue2.minimum.toString()}${sizing.unit}${adj}`;
        return `: ${issue2.origin}${issue2.minimum.toString()}${adj}`;
      }
      case "invalid_format": {
        const _issue = issue2;
        if (_issue.format === "starts_with")
          return `: "${_issue.prefix}"`;
        if (_issue.format === "ends_with")
          return `: "${_issue.suffix}"`;
        if (_issue.format === "includes")
          return `: "${_issue.includes}"`;
        if (_issue.format === "regex")
          return `: ${_issue.pattern}`;
        return `${Nouns[_issue.format] ?? issue2.format}`;
      }
      case "not_multiple_of":
        return `: ${issue2.divisor}`;
      case "unrecognized_keys":
        return `${issue2.keys.length > 1 ? "" : ""}: ${joinValues(issue2.keys, "")}`;
      case "invalid_key":
        return `${issue2.origin}`;
      case "invalid_union":
        return "";
      case "invalid_element":
        return `${issue2.origin}`;
      default:
        return ``;
    }
  };
};
function ja_default() {
  return {
    localeError: error19()
  };
}
// node_modules/zod/v4/locales/kh.js
var error20 = () => {
  const Sizable = {
    string: { unit: "", verb: "" },
    file: { unit: "", verb: "" },
    array: { unit: "", verb: "" },
    set: { unit: "", verb: "" }
  };
  function getSizing(origin) {
    return Sizable[origin] ?? null;
  }
  const parsedType3 = (data) => {
    const t = typeof data;
    switch (t) {
      case "number": {
        return Number.isNaN(data) ? " (NaN)" : "";
      }
      case "object": {
        if (Array.isArray(data)) {
          return " (Array)";
        }
        if (data === null) {
          return " (null)";
        }
        if (Object.getPrototypeOf(data) !== Object.prototype && data.constructor) {
          return data.constructor.name;
        }
      }
    }
    return t;
  };
  const Nouns = {
    regex: "",
    email: "",
    url: "URL",
    emoji: "",
    uuid: "UUID",
    uuidv4: "UUIDv4",
    uuidv6: "UUIDv6",
    nanoid: "nanoid",
    guid: "GUID",
    cuid: "cuid",
    cuid2: "cuid2",
    ulid: "ULID",
    xid: "XID",
    ksuid: "KSUID",
    datetime: "  ISO",
    date: " ISO",
    time: " ISO",
    duration: " ISO",
    ipv4: " IPv4",
    ipv6: " IPv6",
    cidrv4: " IPv4",
    cidrv6: " IPv6",
    base64: " base64",
    base64url: " base64url",
    json_string: " JSON",
    e164: " E.164",
    jwt: "JWT",
    template_literal: ""
  };
  return (issue2) => {
    switch (issue2.code) {
      case "invalid_type":
        return `  ${issue2.expected}  ${parsedType3(issue2.input)}`;
      case "invalid_value":
        if (issue2.values.length === 1)
          return `  ${stringifyPrimitive(issue2.values[0])}`;
        return `  ${joinValues(issue2.values, "|")}`;
      case "too_big": {
        const adj = issue2.inclusive ? "<=" : "<";
        const sizing = getSizing(issue2.origin);
        if (sizing)
          return `  ${issue2.origin ?? ""} ${adj} ${issue2.maximum.toString()} ${sizing.unit ?? ""}`;
        return `  ${issue2.origin ?? ""} ${adj} ${issue2.maximum.toString()}`;
      }
      case "too_small": {
        const adj = issue2.inclusive ? ">=" : ">";
        const sizing = getSizing(issue2.origin);
        if (sizing) {
          return `  ${issue2.origin} ${adj} ${issue2.minimum.toString()} ${sizing.unit}`;
        }
        return `  ${issue2.origin} ${adj} ${issue2.minimum.toString()}`;
      }
      case "invalid_format": {
        const _issue = issue2;
        if (_issue.format === "starts_with") {
          return `  "${_issue.prefix}"`;
        }
        if (_issue.format === "ends_with")
          return `  "${_issue.suffix}"`;
        if (_issue.format === "includes")
          return `  "${_issue.includes}"`;
        if (_issue.format === "regex")
          return `  ${_issue.pattern}`;
        return ` ${Nouns[_issue.format] ?? issue2.format}`;
      }
      case "not_multiple_of":
        return `  ${issue2.divisor}`;
      case "unrecognized_keys":
        return ` ${joinValues(issue2.keys, ", ")}`;
      case "invalid_key":
        return ` ${issue2.origin}`;
      case "invalid_union":
        return ``;
      case "invalid_element":
        return ` ${issue2.origin}`;
      default:
        return ``;
    }
  };
};
function kh_default() {
  return {
    localeError: error20()
  };
}
// node_modules/zod/v4/locales/ko.js
var error21 = () => {
  const Sizable = {
    string: { unit: "", verb: "to have" },
    file: { unit: "", verb: "to have" },
    array: { unit: "", verb: "to have" },
    set: { unit: "", verb: "to have" }
  };
  function getSizing(origin) {
    return Sizable[origin] ?? null;
  }
  const parsedType3 = (data) => {
    const t = typeof data;
    switch (t) {
      case "number": {
        return Number.isNaN(data) ? "NaN" : "number";
      }
      case "object": {
        if (Array.isArray(data)) {
          return "array";
        }
        if (data === null) {
          return "null";
        }
        if (Object.getPrototypeOf(data) !== Object.prototype && data.constructor) {
          return data.constructor.name;
        }
      }
    }
    return t;
  };
  const Nouns = {
    regex: "",
    email: " ",
    url: "URL",
    emoji: "",
    uuid: "UUID",
    uuidv4: "UUIDv4",
    uuidv6: "UUIDv6",
    nanoid: "nanoid",
    guid: "GUID",
    cuid: "cuid",
    cuid2: "cuid2",
    ulid: "ULID",
    xid: "XID",
    ksuid: "KSUID",
    datetime: "ISO ",
    date: "ISO ",
    time: "ISO ",
    duration: "ISO ",
    ipv4: "IPv4 ",
    ipv6: "IPv6 ",
    cidrv4: "IPv4 ",
    cidrv6: "IPv6 ",
    base64: "base64  ",
    base64url: "base64url  ",
    json_string: "JSON ",
    e164: "E.164 ",
    jwt: "JWT",
    template_literal: ""
  };
  return (issue2) => {
    switch (issue2.code) {
      case "invalid_type":
        return ` :   ${issue2.expected},   ${parsedType3(issue2.input)}`;
      case "invalid_value":
        if (issue2.values.length === 1)
          return ` :  ${stringifyPrimitive(issue2.values[0])}  `;
        return ` : ${joinValues(issue2.values, " ")}   `;
      case "too_big": {
        const adj = issue2.inclusive ? "" : "";
        const suffix = adj === "" ? " " : " ";
        const sizing = getSizing(issue2.origin);
        const unit = sizing?.unit ?? "";
        if (sizing)
          return `${issue2.origin ?? ""}  : ${issue2.maximum.toString()}${unit} ${adj}${suffix}`;
        return `${issue2.origin ?? ""}  : ${issue2.maximum.toString()} ${adj}${suffix}`;
      }
      case "too_small": {
        const adj = issue2.inclusive ? "" : "";
        const suffix = adj === "" ? " " : " ";
        const sizing = getSizing(issue2.origin);
        const unit = sizing?.unit ?? "";
        if (sizing) {
          return `${issue2.origin ?? ""}  : ${issue2.minimum.toString()}${unit} ${adj}${suffix}`;
        }
        return `${issue2.origin ?? ""}  : ${issue2.minimum.toString()} ${adj}${suffix}`;
      }
      case "invalid_format": {
        const _issue = issue2;
        if (_issue.format === "starts_with") {
          return ` : "${_issue.prefix}"()  `;
        }
        if (_issue.format === "ends_with")
          return ` : "${_issue.suffix}"()  `;
        if (_issue.format === "includes")
          return ` : "${_issue.includes}"()  `;
        if (_issue.format === "regex")
          return ` :  ${_issue.pattern}   `;
        return ` ${Nouns[_issue.format] ?? issue2.format}`;
      }
      case "not_multiple_of":
        return ` : ${issue2.divisor}  `;
      case "unrecognized_keys":
        return `   : ${joinValues(issue2.keys, ", ")}`;
      case "invalid_key":
        return ` : ${issue2.origin}`;
      case "invalid_union":
        return ` `;
      case "invalid_element":
        return ` : ${issue2.origin}`;
      default:
        return ` `;
    }
  };
};
function ko_default() {
  return {
    localeError: error21()
  };
}
// node_modules/zod/v4/locales/mk.js
var error22 = () => {
  const Sizable = {
    string: { unit: "", verb: " " },
    file: { unit: "", verb: " " },
    array: { unit: "", verb: " " },
    set: { unit: "", verb: " " }
  };
  function getSizing(origin) {
    return Sizable[origin] ?? null;
  }
  const parsedType3 = (data) => {
    const t = typeof data;
    switch (t) {
      case "number": {
        return Number.isNaN(data) ? "NaN" : "";
      }
      case "object": {
        if (Array.isArray(data)) {
          return "";
        }
        if (data === null) {
          return "null";
        }
        if (Object.getPrototypeOf(data) !== Object.prototype && data.constructor) {
          return data.constructor.name;
        }
      }
    }
    return t;
  };
  const Nouns = {
    regex: "",
    email: "  -",
    url: "URL",
    emoji: "",
    uuid: "UUID",
    uuidv4: "UUIDv4",
    uuidv6: "UUIDv6",
    nanoid: "nanoid",
    guid: "GUID",
    cuid: "cuid",
    cuid2: "cuid2",
    ulid: "ULID",
    xid: "XID",
    ksuid: "KSUID",
    datetime: "ISO   ",
    date: "ISO ",
    time: "ISO ",
    duration: "ISO ",
    ipv4: "IPv4 ",
    ipv6: "IPv6 ",
    cidrv4: "IPv4 ",
    cidrv6: "IPv6 ",
    base64: "base64- ",
    base64url: "base64url- ",
    json_string: "JSON ",
    e164: "E.164 ",
    jwt: "JWT",
    template_literal: ""
  };
  return (issue2) => {
    switch (issue2.code) {
      case "invalid_type":
        return ` :   ${issue2.expected},  ${parsedType3(issue2.input)}`;
      case "invalid_value":
        if (issue2.values.length === 1)
          return `Invalid input: expected ${stringifyPrimitive(issue2.values[0])}`;
        return ` :    ${joinValues(issue2.values, "|")}`;
      case "too_big": {
        const adj = issue2.inclusive ? "<=" : "<";
        const sizing = getSizing(issue2.origin);
        if (sizing)
          return ` :   ${issue2.origin ?? ""}   ${adj}${issue2.maximum.toString()} ${sizing.unit ?? ""}`;
        return ` :   ${issue2.origin ?? ""}   ${adj}${issue2.maximum.toString()}`;
      }
      case "too_small": {
        const adj = issue2.inclusive ? ">=" : ">";
        const sizing = getSizing(issue2.origin);
        if (sizing) {
          return ` :   ${issue2.origin}   ${adj}${issue2.minimum.toString()} ${sizing.unit}`;
        }
        return ` :   ${issue2.origin}   ${adj}${issue2.minimum.toString()}`;
      }
      case "invalid_format": {
        const _issue = issue2;
        if (_issue.format === "starts_with") {
          return ` :     "${_issue.prefix}"`;
        }
        if (_issue.format === "ends_with")
          return ` :     "${_issue.suffix}"`;
        if (_issue.format === "includes")
          return ` :    "${_issue.includes}"`;
        if (_issue.format === "regex")
          return ` :      ${_issue.pattern}`;
        return `Invalid ${Nouns[_issue.format] ?? issue2.format}`;
      }
      case "not_multiple_of":
        return ` :      ${issue2.divisor}`;
      case "unrecognized_keys":
        return `${issue2.keys.length > 1 ? " " : " "}: ${joinValues(issue2.keys, ", ")}`;
      case "invalid_key":
        return `   ${issue2.origin}`;
      case "invalid_union":
        return " ";
      case "invalid_element":
        return `   ${issue2.origin}`;
      default:
        return ` `;
    }
  };
};
function mk_default() {
  return {
    localeError: error22()
  };
}
// node_modules/zod/v4/locales/ms.js
var error23 = () => {
  const Sizable = {
    string: { unit: "aksara", verb: "mempunyai" },
    file: { unit: "bait", verb: "mempunyai" },
    array: { unit: "elemen", verb: "mempunyai" },
    set: { unit: "elemen", verb: "mempunyai" }
  };
  function getSizing(origin) {
    return Sizable[origin] ?? null;
  }
  const parsedType3 = (data) => {
    const t = typeof data;
    switch (t) {
      case "number": {
        return Number.isNaN(data) ? "NaN" : "nombor";
      }
      case "object": {
        if (Array.isArray(data)) {
          return "array";
        }
        if (data === null) {
          return "null";
        }
        if (Object.getPrototypeOf(data) !== Object.prototype && data.constructor) {
          return data.constructor.name;
        }
      }
    }
    return t;
  };
  const Nouns = {
    regex: "input",
    email: "alamat e-mel",
    url: "URL",
    emoji: "emoji",
    uuid: "UUID",
    uuidv4: "UUIDv4",
    uuidv6: "UUIDv6",
    nanoid: "nanoid",
    guid: "GUID",
    cuid: "cuid",
    cuid2: "cuid2",
    ulid: "ULID",
    xid: "XID",
    ksuid: "KSUID",
    datetime: "tarikh masa ISO",
    date: "tarikh ISO",
    time: "masa ISO",
    duration: "tempoh ISO",
    ipv4: "alamat IPv4",
    ipv6: "alamat IPv6",
    cidrv4: "julat IPv4",
    cidrv6: "julat IPv6",
    base64: "string dikodkan base64",
    base64url: "string dikodkan base64url",
    json_string: "string JSON",
    e164: "nombor E.164",
    jwt: "JWT",
    template_literal: "input"
  };
  return (issue2) => {
    switch (issue2.code) {
      case "invalid_type":
        return `Input tidak sah: dijangka ${issue2.expected}, diterima ${parsedType3(issue2.input)}`;
      case "invalid_value":
        if (issue2.values.length === 1)
          return `Input tidak sah: dijangka ${stringifyPrimitive(issue2.values[0])}`;
        return `Pilihan tidak sah: dijangka salah satu daripada ${joinValues(issue2.values, "|")}`;
      case "too_big": {
        const adj = issue2.inclusive ? "<=" : "<";
        const sizing = getSizing(issue2.origin);
        if (sizing)
          return `Terlalu besar: dijangka ${issue2.origin ?? "nilai"} ${sizing.verb} ${adj}${issue2.maximum.toString()} ${sizing.unit ?? "elemen"}`;
        return `Terlalu besar: dijangka ${issue2.origin ?? "nilai"} adalah ${adj}${issue2.maximum.toString()}`;
      }
      case "too_small": {
        const adj = issue2.inclusive ? ">=" : ">";
        const sizing = getSizing(issue2.origin);
        if (sizing) {
          return `Terlalu kecil: dijangka ${issue2.origin} ${sizing.verb} ${adj}${issue2.minimum.toString()} ${sizing.unit}`;
        }
        return `Terlalu kecil: dijangka ${issue2.origin} adalah ${adj}${issue2.minimum.toString()}`;
      }
      case "invalid_format": {
        const _issue = issue2;
        if (_issue.format === "starts_with")
          return `String tidak sah: mesti bermula dengan "${_issue.prefix}"`;
        if (_issue.format === "ends_with")
          return `String tidak sah: mesti berakhir dengan "${_issue.suffix}"`;
        if (_issue.format === "includes")
          return `String tidak sah: mesti mengandungi "${_issue.includes}"`;
        if (_issue.format === "regex")
          return `String tidak sah: mesti sepadan dengan corak ${_issue.pattern}`;
        return `${Nouns[_issue.format] ?? issue2.format} tidak sah`;
      }
      case "not_multiple_of":
        return `Nombor tidak sah: perlu gandaan ${issue2.divisor}`;
      case "unrecognized_keys":
        return `Kunci tidak dikenali: ${joinValues(issue2.keys, ", ")}`;
      case "invalid_key":
        return `Kunci tidak sah dalam ${issue2.origin}`;
      case "invalid_union":
        return "Input tidak sah";
      case "invalid_element":
        return `Nilai tidak sah dalam ${issue2.origin}`;
      default:
        return `Input tidak sah`;
    }
  };
};
function ms_default() {
  return {
    localeError: error23()
  };
}
// node_modules/zod/v4/locales/nl.js
var error24 = () => {
  const Sizable = {
    string: { unit: "tekens" },
    file: { unit: "bytes" },
    array: { unit: "elementen" },
    set: { unit: "elementen" }
  };
  function getSizing(origin) {
    return Sizable[origin] ?? null;
  }
  const parsedType3 = (data) => {
    const t = typeof data;
    switch (t) {
      case "number": {
        return Number.isNaN(data) ? "NaN" : "getal";
      }
      case "object": {
        if (Array.isArray(data)) {
          return "array";
        }
        if (data === null) {
          return "null";
        }
        if (Object.getPrototypeOf(data) !== Object.prototype && data.constructor) {
          return data.constructor.name;
        }
      }
    }
    return t;
  };
  const Nouns = {
    regex: "invoer",
    email: "emailadres",
    url: "URL",
    emoji: "emoji",
    uuid: "UUID",
    uuidv4: "UUIDv4",
    uuidv6: "UUIDv6",
    nanoid: "nanoid",
    guid: "GUID",
    cuid: "cuid",
    cuid2: "cuid2",
    ulid: "ULID",
    xid: "XID",
    ksuid: "KSUID",
    datetime: "ISO datum en tijd",
    date: "ISO datum",
    time: "ISO tijd",
    duration: "ISO duur",
    ipv4: "IPv4-adres",
    ipv6: "IPv6-adres",
    cidrv4: "IPv4-bereik",
    cidrv6: "IPv6-bereik",
    base64: "base64-gecodeerde tekst",
    base64url: "base64 URL-gecodeerde tekst",
    json_string: "JSON string",
    e164: "E.164-nummer",
    jwt: "JWT",
    template_literal: "invoer"
  };
  return (issue2) => {
    switch (issue2.code) {
      case "invalid_type":
        return `Ongeldige invoer: verwacht ${issue2.expected}, ontving ${parsedType3(issue2.input)}`;
      case "invalid_value":
        if (issue2.values.length === 1)
          return `Ongeldige invoer: verwacht ${stringifyPrimitive(issue2.values[0])}`;
        return `Ongeldige optie: verwacht n van ${joinValues(issue2.values, "|")}`;
      case "too_big": {
        const adj = issue2.inclusive ? "<=" : "<";
        const sizing = getSizing(issue2.origin);
        if (sizing)
          return `Te lang: verwacht dat ${issue2.origin ?? "waarde"} ${adj}${issue2.maximum.toString()} ${sizing.unit ?? "elementen"} bevat`;
        return `Te lang: verwacht dat ${issue2.origin ?? "waarde"} ${adj}${issue2.maximum.toString()} is`;
      }
      case "too_small": {
        const adj = issue2.inclusive ? ">=" : ">";
        const sizing = getSizing(issue2.origin);
        if (sizing) {
          return `Te kort: verwacht dat ${issue2.origin} ${adj}${issue2.minimum.toString()} ${sizing.unit} bevat`;
        }
        return `Te kort: verwacht dat ${issue2.origin} ${adj}${issue2.minimum.toString()} is`;
      }
      case "invalid_format": {
        const _issue = issue2;
        if (_issue.format === "starts_with") {
          return `Ongeldige tekst: moet met "${_issue.prefix}" beginnen`;
        }
        if (_issue.format === "ends_with")
          return `Ongeldige tekst: moet op "${_issue.suffix}" eindigen`;
        if (_issue.format === "includes")
          return `Ongeldige tekst: moet "${_issue.includes}" bevatten`;
        if (_issue.format === "regex")
          return `Ongeldige tekst: moet overeenkomen met patroon ${_issue.pattern}`;
        return `Ongeldig: ${Nouns[_issue.format] ?? issue2.format}`;
      }
      case "not_multiple_of":
        return `Ongeldig getal: moet een veelvoud van ${issue2.divisor} zijn`;
      case "unrecognized_keys":
        return `Onbekende key${issue2.keys.length > 1 ? "s" : ""}: ${joinValues(issue2.keys, ", ")}`;
      case "invalid_key":
        return `Ongeldige key in ${issue2.origin}`;
      case "invalid_union":
        return "Ongeldige invoer";
      case "invalid_element":
        return `Ongeldige waarde in ${issue2.origin}`;
      default:
        return `Ongeldige invoer`;
    }
  };
};
function nl_default() {
  return {
    localeError: error24()
  };
}
// node_modules/zod/v4/locales/no.js
var error25 = () => {
  const Sizable = {
    string: { unit: "tegn", verb: " ha" },
    file: { unit: "bytes", verb: " ha" },
    array: { unit: "elementer", verb: " inneholde" },
    set: { unit: "elementer", verb: " inneholde" }
  };
  function getSizing(origin) {
    return Sizable[origin] ?? null;
  }
  const parsedType3 = (data) => {
    const t = typeof data;
    switch (t) {
      case "number": {
        return Number.isNaN(data) ? "NaN" : "tall";
      }
      case "object": {
        if (Array.isArray(data)) {
          return "liste";
        }
        if (data === null) {
          return "null";
        }
        if (Object.getPrototypeOf(data) !== Object.prototype && data.constructor) {
          return data.constructor.name;
        }
      }
    }
    return t;
  };
  const Nouns = {
    regex: "input",
    email: "e-postadresse",
    url: "URL",
    emoji: "emoji",
    uuid: "UUID",
    uuidv4: "UUIDv4",
    uuidv6: "UUIDv6",
    nanoid: "nanoid",
    guid: "GUID",
    cuid: "cuid",
    cuid2: "cuid2",
    ulid: "ULID",
    xid: "XID",
    ksuid: "KSUID",
    datetime: "ISO dato- og klokkeslett",
    date: "ISO-dato",
    time: "ISO-klokkeslett",
    duration: "ISO-varighet",
    ipv4: "IPv4-omrde",
    ipv6: "IPv6-omrde",
    cidrv4: "IPv4-spekter",
    cidrv6: "IPv6-spekter",
    base64: "base64-enkodet streng",
    base64url: "base64url-enkodet streng",
    json_string: "JSON-streng",
    e164: "E.164-nummer",
    jwt: "JWT",
    template_literal: "input"
  };
  return (issue2) => {
    switch (issue2.code) {
      case "invalid_type":
        return `Ugyldig input: forventet ${issue2.expected}, fikk ${parsedType3(issue2.input)}`;
      case "invalid_value":
        if (issue2.values.length === 1)
          return `Ugyldig verdi: forventet ${stringifyPrimitive(issue2.values[0])}`;
        return `Ugyldig valg: forventet en av ${joinValues(issue2.values, "|")}`;
      case "too_big": {
        const adj = issue2.inclusive ? "<=" : "<";
        const sizing = getSizing(issue2.origin);
        if (sizing)
          return `For stor(t): forventet ${issue2.origin ?? "value"} til  ha ${adj}${issue2.maximum.toString()} ${sizing.unit ?? "elementer"}`;
        return `For stor(t): forventet ${issue2.origin ?? "value"} til  ha ${adj}${issue2.maximum.toString()}`;
      }
      case "too_small": {
        const adj = issue2.inclusive ? ">=" : ">";
        const sizing = getSizing(issue2.origin);
        if (sizing) {
          return `For lite(n): forventet ${issue2.origin} til  ha ${adj}${issue2.minimum.toString()} ${sizing.unit}`;
        }
        return `For lite(n): forventet ${issue2.origin} til  ha ${adj}${issue2.minimum.toString()}`;
      }
      case "invalid_format": {
        const _issue = issue2;
        if (_issue.format === "starts_with")
          return `Ugyldig streng: m starte med "${_issue.prefix}"`;
        if (_issue.format === "ends_with")
          return `Ugyldig streng: m ende med "${_issue.suffix}"`;
        if (_issue.format === "includes")
          return `Ugyldig streng: m inneholde "${_issue.includes}"`;
        if (_issue.format === "regex")
          return `Ugyldig streng: m matche mnsteret ${_issue.pattern}`;
        return `Ugyldig ${Nouns[_issue.format] ?? issue2.format}`;
      }
      case "not_multiple_of":
        return `Ugyldig tall: m vre et multiplum av ${issue2.divisor}`;
      case "unrecognized_keys":
        return `${issue2.keys.length > 1 ? "Ukjente nkler" : "Ukjent nkkel"}: ${joinValues(issue2.keys, ", ")}`;
      case "invalid_key":
        return `Ugyldig nkkel i ${issue2.origin}`;
      case "invalid_union":
        return "Ugyldig input";
      case "invalid_element":
        return `Ugyldig verdi i ${issue2.origin}`;
      default:
        return `Ugyldig input`;
    }
  };
};
function no_default() {
  return {
    localeError: error25()
  };
}
// node_modules/zod/v4/locales/ota.js
var error26 = () => {
  const Sizable = {
    string: { unit: "harf", verb: "olmaldr" },
    file: { unit: "bayt", verb: "olmaldr" },
    array: { unit: "unsur", verb: "olmaldr" },
    set: { unit: "unsur", verb: "olmaldr" }
  };
  function getSizing(origin) {
    return Sizable[origin] ?? null;
  }
  const parsedType3 = (data) => {
    const t = typeof data;
    switch (t) {
      case "number": {
        return Number.isNaN(data) ? "NaN" : "numara";
      }
      case "object": {
        if (Array.isArray(data)) {
          return "saf";
        }
        if (data === null) {
          return "gayb";
        }
        if (Object.getPrototypeOf(data) !== Object.prototype && data.constructor) {
          return data.constructor.name;
        }
      }
    }
    return t;
  };
  const Nouns = {
    regex: "giren",
    email: "epostagh",
    url: "URL",
    emoji: "emoji",
    uuid: "UUID",
    uuidv4: "UUIDv4",
    uuidv6: "UUIDv6",
    nanoid: "nanoid",
    guid: "GUID",
    cuid: "cuid",
    cuid2: "cuid2",
    ulid: "ULID",
    xid: "XID",
    ksuid: "KSUID",
    datetime: "ISO hengm",
    date: "ISO tarihi",
    time: "ISO zaman",
    duration: "ISO mddeti",
    ipv4: "IPv4 nin",
    ipv6: "IPv6 nin",
    cidrv4: "IPv4 menzili",
    cidrv6: "IPv6 menzili",
    base64: "base64-ifreli metin",
    base64url: "base64url-ifreli metin",
    json_string: "JSON metin",
    e164: "E.164 says",
    jwt: "JWT",
    template_literal: "giren"
  };
  return (issue2) => {
    switch (issue2.code) {
      case "invalid_type":
        return `Fsit giren: umulan ${issue2.expected}, alnan ${parsedType3(issue2.input)}`;
      case "invalid_value":
        if (issue2.values.length === 1)
          return `Fsit giren: umulan ${stringifyPrimitive(issue2.values[0])}`;
        return `Fsit tercih: mteberler ${joinValues(issue2.values, "|")}`;
      case "too_big": {
        const adj = issue2.inclusive ? "<=" : "<";
        const sizing = getSizing(issue2.origin);
        if (sizing)
          return `Fazla byk: ${issue2.origin ?? "value"}, ${adj}${issue2.maximum.toString()} ${sizing.unit ?? "elements"} sahip olmalyd.`;
        return `Fazla byk: ${issue2.origin ?? "value"}, ${adj}${issue2.maximum.toString()} olmalyd.`;
      }
      case "too_small": {
        const adj = issue2.inclusive ? ">=" : ">";
        const sizing = getSizing(issue2.origin);
        if (sizing) {
          return `Fazla kk: ${issue2.origin}, ${adj}${issue2.minimum.toString()} ${sizing.unit} sahip olmalyd.`;
        }
        return `Fazla kk: ${issue2.origin}, ${adj}${issue2.minimum.toString()} olmalyd.`;
      }
      case "invalid_format": {
        const _issue = issue2;
        if (_issue.format === "starts_with")
          return `Fsit metin: "${_issue.prefix}" ile balamal.`;
        if (_issue.format === "ends_with")
          return `Fsit metin: "${_issue.suffix}" ile bitmeli.`;
        if (_issue.format === "includes")
          return `Fsit metin: "${_issue.includes}" ihtiv etmeli.`;
        if (_issue.format === "regex")
          return `Fsit metin: ${_issue.pattern} nakna uymal.`;
        return `Fsit ${Nouns[_issue.format] ?? issue2.format}`;
      }
      case "not_multiple_of":
        return `Fsit say: ${issue2.divisor} kat olmalyd.`;
      case "unrecognized_keys":
        return `Tannmayan anahtar ${issue2.keys.length > 1 ? "s" : ""}: ${joinValues(issue2.keys, ", ")}`;
      case "invalid_key":
        return `${issue2.origin} iin tannmayan anahtar var.`;
      case "invalid_union":
        return "Giren tannamad.";
      case "invalid_element":
        return `${issue2.origin} iin tannmayan kymet var.`;
      default:
        return `Kymet tannamad.`;
    }
  };
};
function ota_default() {
  return {
    localeError: error26()
  };
}
// node_modules/zod/v4/locales/ps.js
var error27 = () => {
  const Sizable = {
    string: { unit: "", verb: "" },
    file: { unit: "", verb: "" },
    array: { unit: "", verb: "" },
    set: { unit: "", verb: "" }
  };
  function getSizing(origin) {
    return Sizable[origin] ?? null;
  }
  const parsedType3 = (data) => {
    const t = typeof data;
    switch (t) {
      case "number": {
        return Number.isNaN(data) ? "NaN" : "";
      }
      case "object": {
        if (Array.isArray(data)) {
          return "";
        }
        if (data === null) {
          return "null";
        }
        if (Object.getPrototypeOf(data) !== Object.prototype && data.constructor) {
          return data.constructor.name;
        }
      }
    }
    return t;
  };
  const Nouns = {
    regex: "",
    email: "",
    url: "  ",
    emoji: "",
    uuid: "UUID",
    uuidv4: "UUIDv4",
    uuidv6: "UUIDv6",
    nanoid: "nanoid",
    guid: "GUID",
    cuid: "cuid",
    cuid2: "cuid2",
    ulid: "ULID",
    xid: "XID",
    ksuid: "KSUID",
    datetime: "  ",
    date: "",
    time: "",
    duration: "",
    ipv4: " IPv4 ",
    ipv6: " IPv6 ",
    cidrv4: " IPv4 ",
    cidrv6: " IPv6 ",
    base64: "base64-encoded ",
    base64url: "base64url-encoded ",
    json_string: "JSON ",
    e164: " E.164 ",
    jwt: "JWT",
    template_literal: ""
  };
  return (issue2) => {
    switch (issue2.code) {
      case "invalid_type":
        return ` :  ${issue2.expected} ,  ${parsedType3(issue2.input)}  `;
      case "invalid_value":
        if (issue2.values.length === 1) {
          return ` :  ${stringifyPrimitive(issue2.values[0])} `;
        }
        return ` :    ${joinValues(issue2.values, "|")}  `;
      case "too_big": {
        const adj = issue2.inclusive ? "<=" : "<";
        const sizing = getSizing(issue2.origin);
        if (sizing) {
          return ` : ${issue2.origin ?? ""}  ${adj}${issue2.maximum.toString()} ${sizing.unit ?? ""} `;
        }
        return ` : ${issue2.origin ?? ""}  ${adj}${issue2.maximum.toString()} `;
      }
      case "too_small": {
        const adj = issue2.inclusive ? ">=" : ">";
        const sizing = getSizing(issue2.origin);
        if (sizing) {
          return ` : ${issue2.origin}  ${adj}${issue2.minimum.toString()} ${sizing.unit} `;
        }
        return ` : ${issue2.origin}  ${adj}${issue2.minimum.toString()} `;
      }
      case "invalid_format": {
        const _issue = issue2;
        if (_issue.format === "starts_with") {
          return ` :   "${_issue.prefix}"   `;
        }
        if (_issue.format === "ends_with") {
          return ` :   "${_issue.suffix}"    `;
        }
        if (_issue.format === "includes") {
          return ` :  "${_issue.includes}" `;
        }
        if (_issue.format === "regex") {
          return ` :   ${_issue.pattern}   `;
        }
        return `${Nouns[_issue.format] ?? issue2.format}  `;
      }
      case "not_multiple_of":
        return ` :   ${issue2.divisor}  `;
      case "unrecognized_keys":
        return ` ${issue2.keys.length > 1 ? "" : ""}: ${joinValues(issue2.keys, ", ")}`;
      case "invalid_key":
        return `   ${issue2.origin} `;
      case "invalid_union":
        return ` `;
      case "invalid_element":
        return `   ${issue2.origin} `;
      default:
        return ` `;
    }
  };
};
function ps_default() {
  return {
    localeError: error27()
  };
}
// node_modules/zod/v4/locales/pl.js
var error28 = () => {
  const Sizable = {
    string: { unit: "znakw", verb: "mie" },
    file: { unit: "bajtw", verb: "mie" },
    array: { unit: "elementw", verb: "mie" },
    set: { unit: "elementw", verb: "mie" }
  };
  function getSizing(origin) {
    return Sizable[origin] ?? null;
  }
  const parsedType3 = (data) => {
    const t = typeof data;
    switch (t) {
      case "number": {
        return Number.isNaN(data) ? "NaN" : "liczba";
      }
      case "object": {
        if (Array.isArray(data)) {
          return "tablica";
        }
        if (data === null) {
          return "null";
        }
        if (Object.getPrototypeOf(data) !== Object.prototype && data.constructor) {
          return data.constructor.name;
        }
      }
    }
    return t;
  };
  const Nouns = {
    regex: "wyraenie",
    email: "adres email",
    url: "URL",
    emoji: "emoji",
    uuid: "UUID",
    uuidv4: "UUIDv4",
    uuidv6: "UUIDv6",
    nanoid: "nanoid",
    guid: "GUID",
    cuid: "cuid",
    cuid2: "cuid2",
    ulid: "ULID",
    xid: "XID",
    ksuid: "KSUID",
    datetime: "data i godzina w formacie ISO",
    date: "data w formacie ISO",
    time: "godzina w formacie ISO",
    duration: "czas trwania ISO",
    ipv4: "adres IPv4",
    ipv6: "adres IPv6",
    cidrv4: "zakres IPv4",
    cidrv6: "zakres IPv6",
    base64: "cig znakw zakodowany w formacie base64",
    base64url: "cig znakw zakodowany w formacie base64url",
    json_string: "cig znakw w formacie JSON",
    e164: "liczba E.164",
    jwt: "JWT",
    template_literal: "wejcie"
  };
  return (issue2) => {
    switch (issue2.code) {
      case "invalid_type":
        return `Nieprawidowe dane wejciowe: oczekiwano ${issue2.expected}, otrzymano ${parsedType3(issue2.input)}`;
      case "invalid_value":
        if (issue2.values.length === 1)
          return `Nieprawidowe dane wejciowe: oczekiwano ${stringifyPrimitive(issue2.values[0])}`;
        return `Nieprawidowa opcja: oczekiwano jednej z wartoci ${joinValues(issue2.values, "|")}`;
      case "too_big": {
        const adj = issue2.inclusive ? "<=" : "<";
        const sizing = getSizing(issue2.origin);
        if (sizing) {
          return `Za dua warto: oczekiwano, e ${issue2.origin ?? "warto"} bdzie mie ${adj}${issue2.maximum.toString()} ${sizing.unit ?? "elementw"}`;
        }
        return `Zbyt du(y/a/e): oczekiwano, e ${issue2.origin ?? "warto"} bdzie wynosi ${adj}${issue2.maximum.toString()}`;
      }
      case "too_small": {
        const adj = issue2.inclusive ? ">=" : ">";
        const sizing = getSizing(issue2.origin);
        if (sizing) {
          return `Za maa warto: oczekiwano, e ${issue2.origin ?? "warto"} bdzie mie ${adj}${issue2.minimum.toString()} ${sizing.unit ?? "elementw"}`;
        }
        return `Zbyt ma(y/a/e): oczekiwano, e ${issue2.origin ?? "warto"} bdzie wynosi ${adj}${issue2.minimum.toString()}`;
      }
      case "invalid_format": {
        const _issue = issue2;
        if (_issue.format === "starts_with")
          return `Nieprawidowy cig znakw: musi zaczyna si od "${_issue.prefix}"`;
        if (_issue.format === "ends_with")
          return `Nieprawidowy cig znakw: musi koczy si na "${_issue.suffix}"`;
        if (_issue.format === "includes")
          return `Nieprawidowy cig znakw: musi zawiera "${_issue.includes}"`;
        if (_issue.format === "regex")
          return `Nieprawidowy cig znakw: musi odpowiada wzorcowi ${_issue.pattern}`;
        return `Nieprawidow(y/a/e) ${Nouns[_issue.format] ?? issue2.format}`;
      }
      case "not_multiple_of":
        return `Nieprawidowa liczba: musi by wielokrotnoci ${issue2.divisor}`;
      case "unrecognized_keys":
        return `Nierozpoznane klucze${issue2.keys.length > 1 ? "s" : ""}: ${joinValues(issue2.keys, ", ")}`;
      case "invalid_key":
        return `Nieprawidowy klucz w ${issue2.origin}`;
      case "invalid_union":
        return "Nieprawidowe dane wejciowe";
      case "invalid_element":
        return `Nieprawidowa warto w ${issue2.origin}`;
      default:
        return `Nieprawidowe dane wejciowe`;
    }
  };
};
function pl_default() {
  return {
    localeError: error28()
  };
}
// node_modules/zod/v4/locales/pt.js
var error29 = () => {
  const Sizable = {
    string: { unit: "caracteres", verb: "ter" },
    file: { unit: "bytes", verb: "ter" },
    array: { unit: "itens", verb: "ter" },
    set: { unit: "itens", verb: "ter" }
  };
  function getSizing(origin) {
    return Sizable[origin] ?? null;
  }
  const parsedType3 = (data) => {
    const t = typeof data;
    switch (t) {
      case "number": {
        return Number.isNaN(data) ? "NaN" : "nmero";
      }
      case "object": {
        if (Array.isArray(data)) {
          return "array";
        }
        if (data === null) {
          return "nulo";
        }
        if (Object.getPrototypeOf(data) !== Object.prototype && data.constructor) {
          return data.constructor.name;
        }
      }
    }
    return t;
  };
  const Nouns = {
    regex: "padro",
    email: "endereo de e-mail",
    url: "URL",
    emoji: "emoji",
    uuid: "UUID",
    uuidv4: "UUIDv4",
    uuidv6: "UUIDv6",
    nanoid: "nanoid",
    guid: "GUID",
    cuid: "cuid",
    cuid2: "cuid2",
    ulid: "ULID",
    xid: "XID",
    ksuid: "KSUID",
    datetime: "data e hora ISO",
    date: "data ISO",
    time: "hora ISO",
    duration: "durao ISO",
    ipv4: "endereo IPv4",
    ipv6: "endereo IPv6",
    cidrv4: "faixa de IPv4",
    cidrv6: "faixa de IPv6",
    base64: "texto codificado em base64",
    base64url: "URL codificada em base64",
    json_string: "texto JSON",
    e164: "nmero E.164",
    jwt: "JWT",
    template_literal: "entrada"
  };
  return (issue2) => {
    switch (issue2.code) {
      case "invalid_type":
        return `Tipo invlido: esperado ${issue2.expected}, recebido ${parsedType3(issue2.input)}`;
      case "invalid_value":
        if (issue2.values.length === 1)
          return `Entrada invlida: esperado ${stringifyPrimitive(issue2.values[0])}`;
        return `Opo invlida: esperada uma das ${joinValues(issue2.values, "|")}`;
      case "too_big": {
        const adj = issue2.inclusive ? "<=" : "<";
        const sizing = getSizing(issue2.origin);
        if (sizing)
          return `Muito grande: esperado que ${issue2.origin ?? "valor"} tivesse ${adj}${issue2.maximum.toString()} ${sizing.unit ?? "elementos"}`;
        return `Muito grande: esperado que ${issue2.origin ?? "valor"} fosse ${adj}${issue2.maximum.toString()}`;
      }
      case "too_small": {
        const adj = issue2.inclusive ? ">=" : ">";
        const sizing = getSizing(issue2.origin);
        if (sizing) {
          return `Muito pequeno: esperado que ${issue2.origin} tivesse ${adj}${issue2.minimum.toString()} ${sizing.unit}`;
        }
        return `Muito pequeno: esperado que ${issue2.origin} fosse ${adj}${issue2.minimum.toString()}`;
      }
      case "invalid_format": {
        const _issue = issue2;
        if (_issue.format === "starts_with")
          return `Texto invlido: deve comear com "${_issue.prefix}"`;
        if (_issue.format === "ends_with")
          return `Texto invlido: deve terminar com "${_issue.suffix}"`;
        if (_issue.format === "includes")
          return `Texto invlido: deve incluir "${_issue.includes}"`;
        if (_issue.format === "regex")
          return `Texto invlido: deve corresponder ao padro ${_issue.pattern}`;
        return `${Nouns[_issue.format] ?? issue2.format} invlido`;
      }
      case "not_multiple_of":
        return `Nmero invlido: deve ser mltiplo de ${issue2.divisor}`;
      case "unrecognized_keys":
        return `Chave${issue2.keys.length > 1 ? "s" : ""} desconhecida${issue2.keys.length > 1 ? "s" : ""}: ${joinValues(issue2.keys, ", ")}`;
      case "invalid_key":
        return `Chave invlida em ${issue2.origin}`;
      case "invalid_union":
        return "Entrada invlida";
      case "invalid_element":
        return `Valor invlido em ${issue2.origin}`;
      default:
        return `Campo invlido`;
    }
  };
};
function pt_default() {
  return {
    localeError: error29()
  };
}
// node_modules/zod/v4/locales/ru.js
function getRussianPlural(count, one, few, many) {
  const absCount = Math.abs(count);
  const lastDigit = absCount % 10;
  const lastTwoDigits = absCount % 100;
  if (lastTwoDigits >= 11 && lastTwoDigits <= 19) {
    return many;
  }
  if (lastDigit === 1) {
    return one;
  }
  if (lastDigit >= 2 && lastDigit <= 4) {
    return few;
  }
  return many;
}
var error30 = () => {
  const Sizable = {
    string: {
      unit: {
        one: "",
        few: "",
        many: ""
      },
      verb: ""
    },
    file: {
      unit: {
        one: "",
        few: "",
        many: ""
      },
      verb: ""
    },
    array: {
      unit: {
        one: "",
        few: "",
        many: ""
      },
      verb: ""
    },
    set: {
      unit: {
        one: "",
        few: "",
        many: ""
      },
      verb: ""
    }
  };
  function getSizing(origin) {
    return Sizable[origin] ?? null;
  }
  const parsedType3 = (data) => {
    const t = typeof data;
    switch (t) {
      case "number": {
        return Number.isNaN(data) ? "NaN" : "";
      }
      case "object": {
        if (Array.isArray(data)) {
          return "";
        }
        if (data === null) {
          return "null";
        }
        if (Object.getPrototypeOf(data) !== Object.prototype && data.constructor) {
          return data.constructor.name;
        }
      }
    }
    return t;
  };
  const Nouns = {
    regex: "",
    email: "email ",
    url: "URL",
    emoji: "",
    uuid: "UUID",
    uuidv4: "UUIDv4",
    uuidv6: "UUIDv6",
    nanoid: "nanoid",
    guid: "GUID",
    cuid: "cuid",
    cuid2: "cuid2",
    ulid: "ULID",
    xid: "XID",
    ksuid: "KSUID",
    datetime: "ISO   ",
    date: "ISO ",
    time: "ISO ",
    duration: "ISO ",
    ipv4: "IPv4 ",
    ipv6: "IPv6 ",
    cidrv4: "IPv4 ",
    cidrv6: "IPv6 ",
    base64: "   base64",
    base64url: "   base64url",
    json_string: "JSON ",
    e164: " E.164",
    jwt: "JWT",
    template_literal: ""
  };
  return (issue2) => {
    switch (issue2.code) {
      case "invalid_type":
        return ` :  ${issue2.expected},  ${parsedType3(issue2.input)}`;
      case "invalid_value":
        if (issue2.values.length === 1)
          return ` :  ${stringifyPrimitive(issue2.values[0])}`;
        return ` :    ${joinValues(issue2.values, "|")}`;
      case "too_big": {
        const adj = issue2.inclusive ? "<=" : "<";
        const sizing = getSizing(issue2.origin);
        if (sizing) {
          const maxValue = Number(issue2.maximum);
          const unit = getRussianPlural(maxValue, sizing.unit.one, sizing.unit.few, sizing.unit.many);
          return `  : ,  ${issue2.origin ?? ""}   ${adj}${issue2.maximum.toString()} ${unit}`;
        }
        return `  : ,  ${issue2.origin ?? ""}  ${adj}${issue2.maximum.toString()}`;
      }
      case "too_small": {
        const adj = issue2.inclusive ? ">=" : ">";
        const sizing = getSizing(issue2.origin);
        if (sizing) {
          const minValue = Number(issue2.minimum);
          const unit = getRussianPlural(minValue, sizing.unit.one, sizing.unit.few, sizing.unit.many);
          return `  : ,  ${issue2.origin}   ${adj}${issue2.minimum.toString()} ${unit}`;
        }
        return `  : ,  ${issue2.origin}  ${adj}${issue2.minimum.toString()}`;
      }
      case "invalid_format": {
        const _issue = issue2;
        if (_issue.format === "starts_with")
          return ` :    "${_issue.prefix}"`;
        if (_issue.format === "ends_with")
          return ` :    "${_issue.suffix}"`;
        if (_issue.format === "includes")
          return ` :   "${_issue.includes}"`;
        if (_issue.format === "regex")
          return ` :    ${_issue.pattern}`;
        return ` ${Nouns[_issue.format] ?? issue2.format}`;
      }
      case "not_multiple_of":
        return ` :    ${issue2.divisor}`;
      case "unrecognized_keys":
        return `${issue2.keys.length > 1 ? "" : ""} ${issue2.keys.length > 1 ? "" : ""}: ${joinValues(issue2.keys, ", ")}`;
      case "invalid_key":
        return `   ${issue2.origin}`;
      case "invalid_union":
        return "  ";
      case "invalid_element":
        return `   ${issue2.origin}`;
      default:
        return `  `;
    }
  };
};
function ru_default() {
  return {
    localeError: error30()
  };
}
// node_modules/zod/v4/locales/sl.js
var error31 = () => {
  const Sizable = {
    string: { unit: "znakov", verb: "imeti" },
    file: { unit: "bajtov", verb: "imeti" },
    array: { unit: "elementov", verb: "imeti" },
    set: { unit: "elementov", verb: "imeti" }
  };
  function getSizing(origin) {
    return Sizable[origin] ?? null;
  }
  const parsedType3 = (data) => {
    const t = typeof data;
    switch (t) {
      case "number": {
        return Number.isNaN(data) ? "NaN" : "tevilo";
      }
      case "object": {
        if (Array.isArray(data)) {
          return "tabela";
        }
        if (data === null) {
          return "null";
        }
        if (Object.getPrototypeOf(data) !== Object.prototype && data.constructor) {
          return data.constructor.name;
        }
      }
    }
    return t;
  };
  const Nouns = {
    regex: "vnos",
    email: "e-potni naslov",
    url: "URL",
    emoji: "emoji",
    uuid: "UUID",
    uuidv4: "UUIDv4",
    uuidv6: "UUIDv6",
    nanoid: "nanoid",
    guid: "GUID",
    cuid: "cuid",
    cuid2: "cuid2",
    ulid: "ULID",
    xid: "XID",
    ksuid: "KSUID",
    datetime: "ISO datum in as",
    date: "ISO datum",
    time: "ISO as",
    duration: "ISO trajanje",
    ipv4: "IPv4 naslov",
    ipv6: "IPv6 naslov",
    cidrv4: "obseg IPv4",
    cidrv6: "obseg IPv6",
    base64: "base64 kodiran niz",
    base64url: "base64url kodiran niz",
    json_string: "JSON niz",
    e164: "E.164 tevilka",
    jwt: "JWT",
    template_literal: "vnos"
  };
  return (issue2) => {
    switch (issue2.code) {
      case "invalid_type":
        return `Neveljaven vnos: priakovano ${issue2.expected}, prejeto ${parsedType3(issue2.input)}`;
      case "invalid_value":
        if (issue2.values.length === 1)
          return `Neveljaven vnos: priakovano ${stringifyPrimitive(issue2.values[0])}`;
        return `Neveljavna monost: priakovano eno izmed ${joinValues(issue2.values, "|")}`;
      case "too_big": {
        const adj = issue2.inclusive ? "<=" : "<";
        const sizing = getSizing(issue2.origin);
        if (sizing)
          return `Preveliko: priakovano, da bo ${issue2.origin ?? "vrednost"} imelo ${adj}${issue2.maximum.toString()} ${sizing.unit ?? "elementov"}`;
        return `Preveliko: priakovano, da bo ${issue2.origin ?? "vrednost"} ${adj}${issue2.maximum.toString()}`;
      }
      case "too_small": {
        const adj = issue2.inclusive ? ">=" : ">";
        const sizing = getSizing(issue2.origin);
        if (sizing) {
          return `Premajhno: priakovano, da bo ${issue2.origin} imelo ${adj}${issue2.minimum.toString()} ${sizing.unit}`;
        }
        return `Premajhno: priakovano, da bo ${issue2.origin} ${adj}${issue2.minimum.toString()}`;
      }
      case "invalid_format": {
        const _issue = issue2;
        if (_issue.format === "starts_with") {
          return `Neveljaven niz: mora se zaeti z "${_issue.prefix}"`;
        }
        if (_issue.format === "ends_with")
          return `Neveljaven niz: mora se konati z "${_issue.suffix}"`;
        if (_issue.format === "includes")
          return `Neveljaven niz: mora vsebovati "${_issue.includes}"`;
        if (_issue.format === "regex")
          return `Neveljaven niz: mora ustrezati vzorcu ${_issue.pattern}`;
        return `Neveljaven ${Nouns[_issue.format] ?? issue2.format}`;
      }
      case "not_multiple_of":
        return `Neveljavno tevilo: mora biti vekratnik ${issue2.divisor}`;
      case "unrecognized_keys":
        return `Neprepoznan${issue2.keys.length > 1 ? "i kljui" : " klju"}: ${joinValues(issue2.keys, ", ")}`;
      case "invalid_key":
        return `Neveljaven klju v ${issue2.origin}`;
      case "invalid_union":
        return "Neveljaven vnos";
      case "invalid_element":
        return `Neveljavna vrednost v ${issue2.origin}`;
      default:
        return "Neveljaven vnos";
    }
  };
};
function sl_default() {
  return {
    localeError: error31()
  };
}
// node_modules/zod/v4/locales/sv.js
var error32 = () => {
  const Sizable = {
    string: { unit: "tecken", verb: "att ha" },
    file: { unit: "bytes", verb: "att ha" },
    array: { unit: "objekt", verb: "att innehlla" },
    set: { unit: "objekt", verb: "att innehlla" }
  };
  function getSizing(origin) {
    return Sizable[origin] ?? null;
  }
  const parsedType3 = (data) => {
    const t = typeof data;
    switch (t) {
      case "number": {
        return Number.isNaN(data) ? "NaN" : "antal";
      }
      case "object": {
        if (Array.isArray(data)) {
          return "lista";
        }
        if (data === null) {
          return "null";
        }
        if (Object.getPrototypeOf(data) !== Object.prototype && data.constructor) {
          return data.constructor.name;
        }
      }
    }
    return t;
  };
  const Nouns = {
    regex: "reguljrt uttryck",
    email: "e-postadress",
    url: "URL",
    emoji: "emoji",
    uuid: "UUID",
    uuidv4: "UUIDv4",
    uuidv6: "UUIDv6",
    nanoid: "nanoid",
    guid: "GUID",
    cuid: "cuid",
    cuid2: "cuid2",
    ulid: "ULID",
    xid: "XID",
    ksuid: "KSUID",
    datetime: "ISO-datum och tid",
    date: "ISO-datum",
    time: "ISO-tid",
    duration: "ISO-varaktighet",
    ipv4: "IPv4-intervall",
    ipv6: "IPv6-intervall",
    cidrv4: "IPv4-spektrum",
    cidrv6: "IPv6-spektrum",
    base64: "base64-kodad strng",
    base64url: "base64url-kodad strng",
    json_string: "JSON-strng",
    e164: "E.164-nummer",
    jwt: "JWT",
    template_literal: "mall-literal"
  };
  return (issue2) => {
    switch (issue2.code) {
      case "invalid_type":
        return `Ogiltig inmatning: frvntat ${issue2.expected}, fick ${parsedType3(issue2.input)}`;
      case "invalid_value":
        if (issue2.values.length === 1)
          return `Ogiltig inmatning: frvntat ${stringifyPrimitive(issue2.values[0])}`;
        return `Ogiltigt val: frvntade en av ${joinValues(issue2.values, "|")}`;
      case "too_big": {
        const adj = issue2.inclusive ? "<=" : "<";
        const sizing = getSizing(issue2.origin);
        if (sizing) {
          return `Fr stor(t): frvntade ${issue2.origin ?? "vrdet"} att ha ${adj}${issue2.maximum.toString()} ${sizing.unit ?? "element"}`;
        }
        return `Fr stor(t): frvntat ${issue2.origin ?? "vrdet"} att ha ${adj}${issue2.maximum.toString()}`;
      }
      case "too_small": {
        const adj = issue2.inclusive ? ">=" : ">";
        const sizing = getSizing(issue2.origin);
        if (sizing) {
          return `Fr lite(t): frvntade ${issue2.origin ?? "vrdet"} att ha ${adj}${issue2.minimum.toString()} ${sizing.unit}`;
        }
        return `Fr lite(t): frvntade ${issue2.origin ?? "vrdet"} att ha ${adj}${issue2.minimum.toString()}`;
      }
      case "invalid_format": {
        const _issue = issue2;
        if (_issue.format === "starts_with") {
          return `Ogiltig strng: mste brja med "${_issue.prefix}"`;
        }
        if (_issue.format === "ends_with")
          return `Ogiltig strng: mste sluta med "${_issue.suffix}"`;
        if (_issue.format === "includes")
          return `Ogiltig strng: mste innehlla "${_issue.includes}"`;
        if (_issue.format === "regex")
          return `Ogiltig strng: mste matcha mnstret "${_issue.pattern}"`;
        return `Ogiltig(t) ${Nouns[_issue.format] ?? issue2.format}`;
      }
      case "not_multiple_of":
        return `Ogiltigt tal: mste vara en multipel av ${issue2.divisor}`;
      case "unrecognized_keys":
        return `${issue2.keys.length > 1 ? "Oknda nycklar" : "Oknd nyckel"}: ${joinValues(issue2.keys, ", ")}`;
      case "invalid_key":
        return `Ogiltig nyckel i ${issue2.origin ?? "vrdet"}`;
      case "invalid_union":
        return "Ogiltig input";
      case "invalid_element":
        return `Ogiltigt vrde i ${issue2.origin ?? "vrdet"}`;
      default:
        return `Ogiltig input`;
    }
  };
};
function sv_default() {
  return {
    localeError: error32()
  };
}
// node_modules/zod/v4/locales/ta.js
var error33 = () => {
  const Sizable = {
    string: { unit: "", verb: " " },
    file: { unit: "", verb: " " },
    array: { unit: "", verb: " " },
    set: { unit: "", verb: " " }
  };
  function getSizing(origin) {
    return Sizable[origin] ?? null;
  }
  const parsedType3 = (data) => {
    const t = typeof data;
    switch (t) {
      case "number": {
        return Number.isNaN(data) ? " " : "";
      }
      case "object": {
        if (Array.isArray(data)) {
          return "";
        }
        if (data === null) {
          return "";
        }
        if (Object.getPrototypeOf(data) !== Object.prototype && data.constructor) {
          return data.constructor.name;
        }
      }
    }
    return t;
  };
  const Nouns = {
    regex: "",
    email: " ",
    url: "URL",
    emoji: "emoji",
    uuid: "UUID",
    uuidv4: "UUIDv4",
    uuidv6: "UUIDv6",
    nanoid: "nanoid",
    guid: "GUID",
    cuid: "cuid",
    cuid2: "cuid2",
    ulid: "ULID",
    xid: "XID",
    ksuid: "KSUID",
    datetime: "ISO  ",
    date: "ISO ",
    time: "ISO ",
    duration: "ISO  ",
    ipv4: "IPv4 ",
    ipv6: "IPv6 ",
    cidrv4: "IPv4 ",
    cidrv6: "IPv6 ",
    base64: "base64-encoded ",
    base64url: "base64url-encoded ",
    json_string: "JSON ",
    e164: "E.164 ",
    jwt: "JWT",
    template_literal: "input"
  };
  return (issue2) => {
    switch (issue2.code) {
      case "invalid_type":
        return ` :  ${issue2.expected},  ${parsedType3(issue2.input)}`;
      case "invalid_value":
        if (issue2.values.length === 1)
          return ` :  ${stringifyPrimitive(issue2.values[0])}`;
        return ` :  ${joinValues(issue2.values, "|")}  `;
      case "too_big": {
        const adj = issue2.inclusive ? "<=" : "<";
        const sizing = getSizing(issue2.origin);
        if (sizing) {
          return ` :  ${issue2.origin ?? ""} ${adj}${issue2.maximum.toString()} ${sizing.unit ?? ""}   `;
        }
        return ` :  ${issue2.origin ?? ""} ${adj}${issue2.maximum.toString()}   `;
      }
      case "too_small": {
        const adj = issue2.inclusive ? ">=" : ">";
        const sizing = getSizing(issue2.origin);
        if (sizing) {
          return ` :  ${issue2.origin} ${adj}${issue2.minimum.toString()} ${sizing.unit}   `;
        }
        return ` :  ${issue2.origin} ${adj}${issue2.minimum.toString()}   `;
      }
      case "invalid_format": {
        const _issue = issue2;
        if (_issue.format === "starts_with")
          return ` : "${_issue.prefix}"   `;
        if (_issue.format === "ends_with")
          return ` : "${_issue.suffix}"   `;
        if (_issue.format === "includes")
          return ` : "${_issue.includes}"   `;
        if (_issue.format === "regex")
          return ` : ${_issue.pattern}   `;
        return ` ${Nouns[_issue.format] ?? issue2.format}`;
      }
      case "not_multiple_of":
        return ` : ${issue2.divisor}    `;
      case "unrecognized_keys":
        return `  ${issue2.keys.length > 1 ? "" : ""}: ${joinValues(issue2.keys, ", ")}`;
      case "invalid_key":
        return `${issue2.origin}   `;
      case "invalid_union":
        return " ";
      case "invalid_element":
        return `${issue2.origin}   `;
      default:
        return ` `;
    }
  };
};
function ta_default() {
  return {
    localeError: error33()
  };
}
// node_modules/zod/v4/locales/th.js
var error34 = () => {
  const Sizable = {
    string: { unit: "", verb: "" },
    file: { unit: "", verb: "" },
    array: { unit: "", verb: "" },
    set: { unit: "", verb: "" }
  };
  function getSizing(origin) {
    return Sizable[origin] ?? null;
  }
  const parsedType3 = (data) => {
    const t = typeof data;
    switch (t) {
      case "number": {
        return Number.isNaN(data) ? " (NaN)" : "";
      }
      case "object": {
        if (Array.isArray(data)) {
          return " (Array)";
        }
        if (data === null) {
          return " (null)";
        }
        if (Object.getPrototypeOf(data) !== Object.prototype && data.constructor) {
          return data.constructor.name;
        }
      }
    }
    return t;
  };
  const Nouns = {
    regex: "",
    email: "",
    url: "URL",
    emoji: "",
    uuid: "UUID",
    uuidv4: "UUIDv4",
    uuidv6: "UUIDv6",
    nanoid: "nanoid",
    guid: "GUID",
    cuid: "cuid",
    cuid2: "cuid2",
    ulid: "ULID",
    xid: "XID",
    ksuid: "KSUID",
    datetime: " ISO",
    date: " ISO",
    time: " ISO",
    duration: " ISO",
    ipv4: " IPv4",
    ipv6: " IPv6",
    cidrv4: " IP  IPv4",
    cidrv6: " IP  IPv6",
    base64: " Base64",
    base64url: " Base64  URL",
    json_string: " JSON",
    e164: " (E.164)",
    jwt: " JWT",
    template_literal: ""
  };
  return (issue2) => {
    switch (issue2.code) {
      case "invalid_type":
        return `:  ${issue2.expected}  ${parsedType3(issue2.input)}`;
      case "invalid_value":
        if (issue2.values.length === 1)
          return `:  ${stringifyPrimitive(issue2.values[0])}`;
        return `:  ${joinValues(issue2.values, "|")}`;
      case "too_big": {
        const adj = issue2.inclusive ? "" : "";
        const sizing = getSizing(issue2.origin);
        if (sizing)
          return `: ${issue2.origin ?? ""} ${adj} ${issue2.maximum.toString()} ${sizing.unit ?? ""}`;
        return `: ${issue2.origin ?? ""} ${adj} ${issue2.maximum.toString()}`;
      }
      case "too_small": {
        const adj = issue2.inclusive ? "" : "";
        const sizing = getSizing(issue2.origin);
        if (sizing) {
          return `: ${issue2.origin} ${adj} ${issue2.minimum.toString()} ${sizing.unit}`;
        }
        return `: ${issue2.origin} ${adj} ${issue2.minimum.toString()}`;
      }
      case "invalid_format": {
        const _issue = issue2;
        if (_issue.format === "starts_with") {
          return `:  "${_issue.prefix}"`;
        }
        if (_issue.format === "ends_with")
          return `:  "${_issue.suffix}"`;
        if (_issue.format === "includes")
          return `:  "${_issue.includes}" `;
        if (_issue.format === "regex")
          return `:  ${_issue.pattern}`;
        return `: ${Nouns[_issue.format] ?? issue2.format}`;
      }
      case "not_multiple_of":
        return `:  ${issue2.divisor} `;
      case "unrecognized_keys":
        return `: ${joinValues(issue2.keys, ", ")}`;
      case "invalid_key":
        return ` ${issue2.origin}`;
      case "invalid_union":
        return ": ";
      case "invalid_element":
        return ` ${issue2.origin}`;
      default:
        return ``;
    }
  };
};
function th_default() {
  return {
    localeError: error34()
  };
}
// node_modules/zod/v4/locales/tr.js
var parsedType3 = (data) => {
  const t = typeof data;
  switch (t) {
    case "number": {
      return Number.isNaN(data) ? "NaN" : "number";
    }
    case "object": {
      if (Array.isArray(data)) {
        return "array";
      }
      if (data === null) {
        return "null";
      }
      if (Object.getPrototypeOf(data) !== Object.prototype && data.constructor) {
        return data.constructor.name;
      }
    }
  }
  return t;
};
var error35 = () => {
  const Sizable = {
    string: { unit: "karakter", verb: "olmal" },
    file: { unit: "bayt", verb: "olmal" },
    array: { unit: "e", verb: "olmal" },
    set: { unit: "e", verb: "olmal" }
  };
  function getSizing(origin) {
    return Sizable[origin] ?? null;
  }
  const Nouns = {
    regex: "girdi",
    email: "e-posta adresi",
    url: "URL",
    emoji: "emoji",
    uuid: "UUID",
    uuidv4: "UUIDv4",
    uuidv6: "UUIDv6",
    nanoid: "nanoid",
    guid: "GUID",
    cuid: "cuid",
    cuid2: "cuid2",
    ulid: "ULID",
    xid: "XID",
    ksuid: "KSUID",
    datetime: "ISO tarih ve saat",
    date: "ISO tarih",
    time: "ISO saat",
    duration: "ISO sre",
    ipv4: "IPv4 adresi",
    ipv6: "IPv6 adresi",
    cidrv4: "IPv4 aral",
    cidrv6: "IPv6 aral",
    base64: "base64 ile ifrelenmi metin",
    base64url: "base64url ile ifrelenmi metin",
    json_string: "JSON dizesi",
    e164: "E.164 says",
    jwt: "JWT",
    template_literal: "ablon dizesi"
  };
  return (issue2) => {
    switch (issue2.code) {
      case "invalid_type":
        return `Geersiz deer: beklenen ${issue2.expected}, alnan ${parsedType3(issue2.input)}`;
      case "invalid_value":
        if (issue2.values.length === 1)
          return `Geersiz deer: beklenen ${stringifyPrimitive(issue2.values[0])}`;
        return `Geersiz seenek: aadakilerden biri olmal: ${joinValues(issue2.values, "|")}`;
      case "too_big": {
        const adj = issue2.inclusive ? "<=" : "<";
        const sizing = getSizing(issue2.origin);
        if (sizing)
          return `ok byk: beklenen ${issue2.origin ?? "deer"} ${adj}${issue2.maximum.toString()} ${sizing.unit ?? "e"}`;
        return `ok byk: beklenen ${issue2.origin ?? "deer"} ${adj}${issue2.maximum.toString()}`;
      }
      case "too_small": {
        const adj = issue2.inclusive ? ">=" : ">";
        const sizing = getSizing(issue2.origin);
        if (sizing)
          return `ok kk: beklenen ${issue2.origin} ${adj}${issue2.minimum.toString()} ${sizing.unit}`;
        return `ok kk: beklenen ${issue2.origin} ${adj}${issue2.minimum.toString()}`;
      }
      case "invalid_format": {
        const _issue = issue2;
        if (_issue.format === "starts_with")
          return `Geersiz metin: "${_issue.prefix}" ile balamal`;
        if (_issue.format === "ends_with")
          return `Geersiz metin: "${_issue.suffix}" ile bitmeli`;
        if (_issue.format === "includes")
          return `Geersiz metin: "${_issue.includes}" iermeli`;
        if (_issue.format === "regex")
          return `Geersiz metin: ${_issue.pattern} desenine uymal`;
        return `Geersiz ${Nouns[_issue.format] ?? issue2.format}`;
      }
      case "not_multiple_of":
        return `Geersiz say: ${issue2.divisor} ile tam blnebilmeli`;
      case "unrecognized_keys":
        return `Tannmayan anahtar${issue2.keys.length > 1 ? "lar" : ""}: ${joinValues(issue2.keys, ", ")}`;
      case "invalid_key":
        return `${issue2.origin} iinde geersiz anahtar`;
      case "invalid_union":
        return "Geersiz deer";
      case "invalid_element":
        return `${issue2.origin} iinde geersiz deer`;
      default:
        return `Geersiz deer`;
    }
  };
};
function tr_default() {
  return {
    localeError: error35()
  };
}
// node_modules/zod/v4/locales/ua.js
var error36 = () => {
  const Sizable = {
    string: { unit: "", verb: "" },
    file: { unit: "", verb: "" },
    array: { unit: "", verb: "" },
    set: { unit: "", verb: "" }
  };
  function getSizing(origin) {
    return Sizable[origin] ?? null;
  }
  const parsedType4 = (data) => {
    const t = typeof data;
    switch (t) {
      case "number": {
        return Number.isNaN(data) ? "NaN" : "";
      }
      case "object": {
        if (Array.isArray(data)) {
          return "";
        }
        if (data === null) {
          return "null";
        }
        if (Object.getPrototypeOf(data) !== Object.prototype && data.constructor) {
          return data.constructor.name;
        }
      }
    }
    return t;
  };
  const Nouns = {
    regex: " ",
    email: "  ",
    url: "URL",
    emoji: "",
    uuid: "UUID",
    uuidv4: "UUIDv4",
    uuidv6: "UUIDv6",
    nanoid: "nanoid",
    guid: "GUID",
    cuid: "cuid",
    cuid2: "cuid2",
    ulid: "ULID",
    xid: "XID",
    ksuid: "KSUID",
    datetime: "   ISO",
    date: " ISO",
    time: " ISO",
    duration: " ISO",
    ipv4: " IPv4",
    ipv6: " IPv6",
    cidrv4: " IPv4",
    cidrv6: " IPv6",
    base64: "   base64",
    base64url: "   base64url",
    json_string: " JSON",
    e164: " E.164",
    jwt: "JWT",
    template_literal: " "
  };
  return (issue2) => {
    switch (issue2.code) {
      case "invalid_type":
        return `  :  ${issue2.expected},  ${parsedType4(issue2.input)}`;
      case "invalid_value":
        if (issue2.values.length === 1)
          return `  :  ${stringifyPrimitive(issue2.values[0])}`;
        return ` :    ${joinValues(issue2.values, "|")}`;
      case "too_big": {
        const adj = issue2.inclusive ? "<=" : "<";
        const sizing = getSizing(issue2.origin);
        if (sizing)
          return ` : ,  ${issue2.origin ?? ""} ${sizing.verb} ${adj}${issue2.maximum.toString()} ${sizing.unit ?? ""}`;
        return ` : ,  ${issue2.origin ?? ""}  ${adj}${issue2.maximum.toString()}`;
      }
      case "too_small": {
        const adj = issue2.inclusive ? ">=" : ">";
        const sizing = getSizing(issue2.origin);
        if (sizing) {
          return ` : ,  ${issue2.origin} ${sizing.verb} ${adj}${issue2.minimum.toString()} ${sizing.unit}`;
        }
        return ` : ,  ${issue2.origin}  ${adj}${issue2.minimum.toString()}`;
      }
      case "invalid_format": {
        const _issue = issue2;
        if (_issue.format === "starts_with")
          return ` :    "${_issue.prefix}"`;
        if (_issue.format === "ends_with")
          return ` :    "${_issue.suffix}"`;
        if (_issue.format === "includes")
          return ` :   "${_issue.includes}"`;
        if (_issue.format === "regex")
          return ` :    ${_issue.pattern}`;
        return ` ${Nouns[_issue.format] ?? issue2.format}`;
      }
      case "not_multiple_of":
        return ` :    ${issue2.divisor}`;
      case "unrecognized_keys":
        return ` ${issue2.keys.length > 1 ? "" : ""}: ${joinValues(issue2.keys, ", ")}`;
      case "invalid_key":
        return `   ${issue2.origin}`;
      case "invalid_union":
        return "  ";
      case "invalid_element":
        return `   ${issue2.origin}`;
      default:
        return `  `;
    }
  };
};
function ua_default() {
  return {
    localeError: error36()
  };
}
// node_modules/zod/v4/locales/ur.js
var error37 = () => {
  const Sizable = {
    string: { unit: "", verb: "" },
    file: { unit: "", verb: "" },
    array: { unit: "", verb: "" },
    set: { unit: "", verb: "" }
  };
  function getSizing(origin) {
    return Sizable[origin] ?? null;
  }
  const parsedType4 = (data) => {
    const t = typeof data;
    switch (t) {
      case "number": {
        return Number.isNaN(data) ? "NaN" : "";
      }
      case "object": {
        if (Array.isArray(data)) {
          return "";
        }
        if (data === null) {
          return "";
        }
        if (Object.getPrototypeOf(data) !== Object.prototype && data.constructor) {
          return data.constructor.name;
        }
      }
    }
    return t;
  };
  const Nouns = {
    regex: " ",
    email: "  ",
    url: "  ",
    emoji: "",
    uuid: "   ",
    uuidv4: "     4",
    uuidv6: "     6",
    nanoid: "  ",
    guid: "   ",
    cuid: "   ",
    cuid2: "    2",
    ulid: "   ",
    xid: "  ",
    ksuid: "    ",
    datetime: "    ",
    date: "   ",
    time: "   ",
    duration: "   ",
    ipv4: "   4 ",
    ipv6: "   6 ",
    cidrv4: "   4 ",
    cidrv6: "   6 ",
    base64: " 64   ",
    base64url: " 64      ",
    json_string: "    ",
    e164: " 164 ",
    jwt: "  ",
    template_literal: " "
  };
  return (issue2) => {
    switch (issue2.code) {
      case "invalid_type":
        return `  : ${issue2.expected}   ${parsedType4(issue2.input)}  `;
      case "invalid_value":
        if (issue2.values.length === 1)
          return `  : ${stringifyPrimitive(issue2.values[0])}  `;
        return ` : ${joinValues(issue2.values, "|")}     `;
      case "too_big": {
        const adj = issue2.inclusive ? "<=" : "<";
        const sizing = getSizing(issue2.origin);
        if (sizing)
          return ` : ${issue2.origin ?? ""}  ${adj}${issue2.maximum.toString()} ${sizing.unit ?? ""}   `;
        return ` : ${issue2.origin ?? ""}  ${adj}${issue2.maximum.toString()}   `;
      }
      case "too_small": {
        const adj = issue2.inclusive ? ">=" : ">";
        const sizing = getSizing(issue2.origin);
        if (sizing) {
          return ` : ${issue2.origin}  ${adj}${issue2.minimum.toString()} ${sizing.unit}   `;
        }
        return ` : ${issue2.origin}  ${adj}${issue2.minimum.toString()}   `;
      }
      case "invalid_format": {
        const _issue = issue2;
        if (_issue.format === "starts_with") {
          return ` : "${_issue.prefix}"    `;
        }
        if (_issue.format === "ends_with")
          return ` : "${_issue.suffix}"    `;
        if (_issue.format === "includes")
          return ` : "${_issue.includes}"   `;
        if (_issue.format === "regex")
          return ` :  ${_issue.pattern}    `;
        return ` ${Nouns[_issue.format] ?? issue2.format}`;
      }
      case "not_multiple_of":
        return ` : ${issue2.divisor}    `;
      case "unrecognized_keys":
        return `   ${issue2.keys.length > 1 ? "" : ""}: ${joinValues(issue2.keys, " ")}`;
      case "invalid_key":
        return `${issue2.origin}   `;
      case "invalid_union":
        return "  ";
      case "invalid_element":
        return `${issue2.origin}   `;
      default:
        return `  `;
    }
  };
};
function ur_default() {
  return {
    localeError: error37()
  };
}
// node_modules/zod/v4/locales/vi.js
var error38 = () => {
  const Sizable = {
    string: { unit: "k t", verb: "c" },
    file: { unit: "byte", verb: "c" },
    array: { unit: "phn t", verb: "c" },
    set: { unit: "phn t", verb: "c" }
  };
  function getSizing(origin) {
    return Sizable[origin] ?? null;
  }
  const parsedType4 = (data) => {
    const t = typeof data;
    switch (t) {
      case "number": {
        return Number.isNaN(data) ? "NaN" : "s";
      }
      case "object": {
        if (Array.isArray(data)) {
          return "mng";
        }
        if (data === null) {
          return "null";
        }
        if (Object.getPrototypeOf(data) !== Object.prototype && data.constructor) {
          return data.constructor.name;
        }
      }
    }
    return t;
  };
  const Nouns = {
    regex: "u vo",
    email: "a ch email",
    url: "URL",
    emoji: "emoji",
    uuid: "UUID",
    uuidv4: "UUIDv4",
    uuidv6: "UUIDv6",
    nanoid: "nanoid",
    guid: "GUID",
    cuid: "cuid",
    cuid2: "cuid2",
    ulid: "ULID",
    xid: "XID",
    ksuid: "KSUID",
    datetime: "ngy gi ISO",
    date: "ngy ISO",
    time: "gi ISO",
    duration: "khong thi gian ISO",
    ipv4: "a ch IPv4",
    ipv6: "a ch IPv6",
    cidrv4: "di IPv4",
    cidrv6: "di IPv6",
    base64: "chui m ha base64",
    base64url: "chui m ha base64url",
    json_string: "chui JSON",
    e164: "s E.164",
    jwt: "JWT",
    template_literal: "u vo"
  };
  return (issue2) => {
    switch (issue2.code) {
      case "invalid_type":
        return `u vo khng hp l: mong i ${issue2.expected}, nhn c ${parsedType4(issue2.input)}`;
      case "invalid_value":
        if (issue2.values.length === 1)
          return `u vo khng hp l: mong i ${stringifyPrimitive(issue2.values[0])}`;
        return `Ty chn khng hp l: mong i mt trong cc gi tr ${joinValues(issue2.values, "|")}`;
      case "too_big": {
        const adj = issue2.inclusive ? "<=" : "<";
        const sizing = getSizing(issue2.origin);
        if (sizing)
          return `Qu ln: mong i ${issue2.origin ?? "gi tr"} ${sizing.verb} ${adj}${issue2.maximum.toString()} ${sizing.unit ?? "phn t"}`;
        return `Qu ln: mong i ${issue2.origin ?? "gi tr"} ${adj}${issue2.maximum.toString()}`;
      }
      case "too_small": {
        const adj = issue2.inclusive ? ">=" : ">";
        const sizing = getSizing(issue2.origin);
        if (sizing) {
          return `Qu nh: mong i ${issue2.origin} ${sizing.verb} ${adj}${issue2.minimum.toString()} ${sizing.unit}`;
        }
        return `Qu nh: mong i ${issue2.origin} ${adj}${issue2.minimum.toString()}`;
      }
      case "invalid_format": {
        const _issue = issue2;
        if (_issue.format === "starts_with")
          return `Chui khng hp l: phi bt u bng "${_issue.prefix}"`;
        if (_issue.format === "ends_with")
          return `Chui khng hp l: phi kt thc bng "${_issue.suffix}"`;
        if (_issue.format === "includes")
          return `Chui khng hp l: phi bao gm "${_issue.includes}"`;
        if (_issue.format === "regex")
          return `Chui khng hp l: phi khp vi mu ${_issue.pattern}`;
        return `${Nouns[_issue.format] ?? issue2.format} khng hp l`;
      }
      case "not_multiple_of":
        return `S khng hp l: phi l bi s ca ${issue2.divisor}`;
      case "unrecognized_keys":
        return `Kha khng c nhn dng: ${joinValues(issue2.keys, ", ")}`;
      case "invalid_key":
        return `Kha khng hp l trong ${issue2.origin}`;
      case "invalid_union":
        return "u vo khng hp l";
      case "invalid_element":
        return `Gi tr khng hp l trong ${issue2.origin}`;
      default:
        return `u vo khng hp l`;
    }
  };
};
function vi_default() {
  return {
    localeError: error38()
  };
}
// node_modules/zod/v4/locales/zh-CN.js
var error39 = () => {
  const Sizable = {
    string: { unit: "", verb: "" },
    file: { unit: "", verb: "" },
    array: { unit: "", verb: "" },
    set: { unit: "", verb: "" }
  };
  function getSizing(origin) {
    return Sizable[origin] ?? null;
  }
  const parsedType4 = (data) => {
    const t = typeof data;
    switch (t) {
      case "number": {
        return Number.isNaN(data) ? "(NaN)" : "";
      }
      case "object": {
        if (Array.isArray(data)) {
          return "";
        }
        if (data === null) {
          return "(null)";
        }
        if (Object.getPrototypeOf(data) !== Object.prototype && data.constructor) {
          return data.constructor.name;
        }
      }
    }
    return t;
  };
  const Nouns = {
    regex: "",
    email: "",
    url: "URL",
    emoji: "",
    uuid: "UUID",
    uuidv4: "UUIDv4",
    uuidv6: "UUIDv6",
    nanoid: "nanoid",
    guid: "GUID",
    cuid: "cuid",
    cuid2: "cuid2",
    ulid: "ULID",
    xid: "XID",
    ksuid: "KSUID",
    datetime: "ISO",
    date: "ISO",
    time: "ISO",
    duration: "ISO",
    ipv4: "IPv4",
    ipv6: "IPv6",
    cidrv4: "IPv4",
    cidrv6: "IPv6",
    base64: "base64",
    base64url: "base64url",
    json_string: "JSON",
    e164: "E.164",
    jwt: "JWT",
    template_literal: ""
  };
  return (issue2) => {
    switch (issue2.code) {
      case "invalid_type":
        return ` ${issue2.expected} ${parsedType4(issue2.input)}`;
      case "invalid_value":
        if (issue2.values.length === 1)
          return ` ${stringifyPrimitive(issue2.values[0])}`;
        return ` ${joinValues(issue2.values, "|")}`;
      case "too_big": {
        const adj = issue2.inclusive ? "<=" : "<";
        const sizing = getSizing(issue2.origin);
        if (sizing)
          return ` ${issue2.origin ?? ""} ${adj}${issue2.maximum.toString()} ${sizing.unit ?? ""}`;
        return ` ${issue2.origin ?? ""} ${adj}${issue2.maximum.toString()}`;
      }
      case "too_small": {
        const adj = issue2.inclusive ? ">=" : ">";
        const sizing = getSizing(issue2.origin);
        if (sizing) {
          return ` ${issue2.origin} ${adj}${issue2.minimum.toString()} ${sizing.unit}`;
        }
        return ` ${issue2.origin} ${adj}${issue2.minimum.toString()}`;
      }
      case "invalid_format": {
        const _issue = issue2;
        if (_issue.format === "starts_with")
          return ` "${_issue.prefix}" `;
        if (_issue.format === "ends_with")
          return ` "${_issue.suffix}" `;
        if (_issue.format === "includes")
          return ` "${_issue.includes}"`;
        if (_issue.format === "regex")
          return ` ${_issue.pattern}`;
        return `${Nouns[_issue.format] ?? issue2.format}`;
      }
      case "not_multiple_of":
        return ` ${issue2.divisor} `;
      case "unrecognized_keys":
        return `(key): ${joinValues(issue2.keys, ", ")}`;
      case "invalid_key":
        return `${issue2.origin} (key)`;
      case "invalid_union":
        return "";
      case "invalid_element":
        return `${issue2.origin} (value)`;
      default:
        return ``;
    }
  };
};
function zh_CN_default() {
  return {
    localeError: error39()
  };
}
// node_modules/zod/v4/locales/zh-TW.js
var error40 = () => {
  const Sizable = {
    string: { unit: "", verb: "" },
    file: { unit: "", verb: "" },
    array: { unit: "", verb: "" },
    set: { unit: "", verb: "" }
  };
  function getSizing(origin) {
    return Sizable[origin] ?? null;
  }
  const parsedType4 = (data) => {
    const t = typeof data;
    switch (t) {
      case "number": {
        return Number.isNaN(data) ? "NaN" : "number";
      }
      case "object": {
        if (Array.isArray(data)) {
          return "array";
        }
        if (data === null) {
          return "null";
        }
        if (Object.getPrototypeOf(data) !== Object.prototype && data.constructor) {
          return data.constructor.name;
        }
      }
    }
    return t;
  };
  const Nouns = {
    regex: "",
    email: "",
    url: "URL",
    emoji: "emoji",
    uuid: "UUID",
    uuidv4: "UUIDv4",
    uuidv6: "UUIDv6",
    nanoid: "nanoid",
    guid: "GUID",
    cuid: "cuid",
    cuid2: "cuid2",
    ulid: "ULID",
    xid: "XID",
    ksuid: "KSUID",
    datetime: "ISO ",
    date: "ISO ",
    time: "ISO ",
    duration: "ISO ",
    ipv4: "IPv4 ",
    ipv6: "IPv6 ",
    cidrv4: "IPv4 ",
    cidrv6: "IPv6 ",
    base64: "base64 ",
    base64url: "base64url ",
    json_string: "JSON ",
    e164: "E.164 ",
    jwt: "JWT",
    template_literal: ""
  };
  return (issue2) => {
    switch (issue2.code) {
      case "invalid_type":
        return ` ${issue2.expected} ${parsedType4(issue2.input)}`;
      case "invalid_value":
        if (issue2.values.length === 1)
          return ` ${stringifyPrimitive(issue2.values[0])}`;
        return ` ${joinValues(issue2.values, "|")}`;
      case "too_big": {
        const adj = issue2.inclusive ? "<=" : "<";
        const sizing = getSizing(issue2.origin);
        if (sizing)
          return ` ${issue2.origin ?? ""}  ${adj}${issue2.maximum.toString()} ${sizing.unit ?? ""}`;
        return ` ${issue2.origin ?? ""}  ${adj}${issue2.maximum.toString()}`;
      }
      case "too_small": {
        const adj = issue2.inclusive ? ">=" : ">";
        const sizing = getSizing(issue2.origin);
        if (sizing) {
          return ` ${issue2.origin}  ${adj}${issue2.minimum.toString()} ${sizing.unit}`;
        }
        return ` ${issue2.origin}  ${adj}${issue2.minimum.toString()}`;
      }
      case "invalid_format": {
        const _issue = issue2;
        if (_issue.format === "starts_with") {
          return ` "${_issue.prefix}" `;
        }
        if (_issue.format === "ends_with")
          return ` "${_issue.suffix}" `;
        if (_issue.format === "includes")
          return ` "${_issue.includes}"`;
        if (_issue.format === "regex")
          return ` ${_issue.pattern}`;
        return ` ${Nouns[_issue.format] ?? issue2.format}`;
      }
      case "not_multiple_of":
        return ` ${issue2.divisor} `;
      case "unrecognized_keys":
        return `${issue2.keys.length > 1 ? "" : ""}${joinValues(issue2.keys, "")}`;
      case "invalid_key":
        return `${issue2.origin} `;
      case "invalid_union":
        return "";
      case "invalid_element":
        return `${issue2.origin} `;
      default:
        return ``;
    }
  };
};
function zh_TW_default() {
  return {
    localeError: error40()
  };
}
// node_modules/zod/v4/core/registries.js
var $output = Symbol("ZodOutput");
var $input = Symbol("ZodInput");

class $ZodRegistry {
  constructor() {
    this._map = new Map;
    this._idmap = new Map;
  }
  add(schema, ..._meta) {
    const meta = _meta[0];
    this._map.set(schema, meta);
    if (meta && typeof meta === "object" && "id" in meta) {
      if (this._idmap.has(meta.id)) {
        throw new Error(`ID ${meta.id} already exists in the registry`);
      }
      this._idmap.set(meta.id, schema);
    }
    return this;
  }
  clear() {
    this._map = new Map;
    this._idmap = new Map;
    return this;
  }
  remove(schema) {
    const meta = this._map.get(schema);
    if (meta && typeof meta === "object" && "id" in meta) {
      this._idmap.delete(meta.id);
    }
    this._map.delete(schema);
    return this;
  }
  get(schema) {
    const p2 = schema._zod.parent;
    if (p2) {
      const pm = { ...this.get(p2) ?? {} };
      delete pm.id;
      return { ...pm, ...this._map.get(schema) };
    }
    return this._map.get(schema);
  }
  has(schema) {
    return this._map.has(schema);
  }
}
function registry() {
  return new $ZodRegistry;
}
var globalRegistry = /* @__PURE__ */ registry();
// node_modules/zod/v4/core/api.js
function _string(Class2, params) {
  return new Class2({
    type: "string",
    ...normalizeParams(params)
  });
}
function _coercedString(Class2, params) {
  return new Class2({
    type: "string",
    coerce: true,
    ...normalizeParams(params)
  });
}
function _email(Class2, params) {
  return new Class2({
    type: "string",
    format: "email",
    check: "string_format",
    abort: false,
    ...normalizeParams(params)
  });
}
function _guid(Class2, params) {
  return new Class2({
    type: "string",
    format: "guid",
    check: "string_format",
    abort: false,
    ...normalizeParams(params)
  });
}
function _uuid(Class2, params) {
  return new Class2({
    type: "string",
    format: "uuid",
    check: "string_format",
    abort: false,
    ...normalizeParams(params)
  });
}
function _uuidv4(Class2, params) {
  return new Class2({
    type: "string",
    format: "uuid",
    check: "string_format",
    abort: false,
    version: "v4",
    ...normalizeParams(params)
  });
}
function _uuidv6(Class2, params) {
  return new Class2({
    type: "string",
    format: "uuid",
    check: "string_format",
    abort: false,
    version: "v6",
    ...normalizeParams(params)
  });
}
function _uuidv7(Class2, params) {
  return new Class2({
    type: "string",
    format: "uuid",
    check: "string_format",
    abort: false,
    version: "v7",
    ...normalizeParams(params)
  });
}
function _url(Class2, params) {
  return new Class2({
    type: "string",
    format: "url",
    check: "string_format",
    abort: false,
    ...normalizeParams(params)
  });
}
function _emoji2(Class2, params) {
  return new Class2({
    type: "string",
    format: "emoji",
    check: "string_format",
    abort: false,
    ...normalizeParams(params)
  });
}
function _nanoid(Class2, params) {
  return new Class2({
    type: "string",
    format: "nanoid",
    check: "string_format",
    abort: false,
    ...normalizeParams(params)
  });
}
function _cuid(Class2, params) {
  return new Class2({
    type: "string",
    format: "cuid",
    check: "string_format",
    abort: false,
    ...normalizeParams(params)
  });
}
function _cuid2(Class2, params) {
  return new Class2({
    type: "string",
    format: "cuid2",
    check: "string_format",
    abort: false,
    ...normalizeParams(params)
  });
}
function _ulid(Class2, params) {
  return new Class2({
    type: "string",
    format: "ulid",
    check: "string_format",
    abort: false,
    ...normalizeParams(params)
  });
}
function _xid(Class2, params) {
  return new Class2({
    type: "string",
    format: "xid",
    check: "string_format",
    abort: false,
    ...normalizeParams(params)
  });
}
function _ksuid(Class2, params) {
  return new Class2({
    type: "string",
    format: "ksuid",
    check: "string_format",
    abort: false,
    ...normalizeParams(params)
  });
}
function _ipv4(Class2, params) {
  return new Class2({
    type: "string",
    format: "ipv4",
    check: "string_format",
    abort: false,
    ...normalizeParams(params)
  });
}
function _ipv6(Class2, params) {
  return new Class2({
    type: "string",
    format: "ipv6",
    check: "string_format",
    abort: false,
    ...normalizeParams(params)
  });
}
function _cidrv4(Class2, params) {
  return new Class2({
    type: "string",
    format: "cidrv4",
    check: "string_format",
    abort: false,
    ...normalizeParams(params)
  });
}
function _cidrv6(Class2, params) {
  return new Class2({
    type: "string",
    format: "cidrv6",
    check: "string_format",
    abort: false,
    ...normalizeParams(params)
  });
}
function _base64(Class2, params) {
  return new Class2({
    type: "string",
    format: "base64",
    check: "string_format",
    abort: false,
    ...normalizeParams(params)
  });
}
function _base64url(Class2, params) {
  return new Class2({
    type: "string",
    format: "base64url",
    check: "string_format",
    abort: false,
    ...normalizeParams(params)
  });
}
function _e164(Class2, params) {
  return new Class2({
    type: "string",
    format: "e164",
    check: "string_format",
    abort: false,
    ...normalizeParams(params)
  });
}
function _jwt(Class2, params) {
  return new Class2({
    type: "string",
    format: "jwt",
    check: "string_format",
    abort: false,
    ...normalizeParams(params)
  });
}
var TimePrecision = {
  Any: null,
  Minute: -1,
  Second: 0,
  Millisecond: 3,
  Microsecond: 6
};
function _isoDateTime(Class2, params) {
  return new Class2({
    type: "string",
    format: "datetime",
    check: "string_format",
    offset: false,
    local: false,
    precision: null,
    ...normalizeParams(params)
  });
}
function _isoDate(Class2, params) {
  return new Class2({
    type: "string",
    format: "date",
    check: "string_format",
    ...normalizeParams(params)
  });
}
function _isoTime(Class2, params) {
  return new Class2({
    type: "string",
    format: "time",
    check: "string_format",
    precision: null,
    ...normalizeParams(params)
  });
}
function _isoDuration(Class2, params) {
  return new Class2({
    type: "string",
    format: "duration",
    check: "string_format",
    ...normalizeParams(params)
  });
}
function _number(Class2, params) {
  return new Class2({
    type: "number",
    checks: [],
    ...normalizeParams(params)
  });
}
function _coercedNumber(Class2, params) {
  return new Class2({
    type: "number",
    coerce: true,
    checks: [],
    ...normalizeParams(params)
  });
}
function _int(Class2, params) {
  return new Class2({
    type: "number",
    check: "number_format",
    abort: false,
    format: "safeint",
    ...normalizeParams(params)
  });
}
function _float32(Class2, params) {
  return new Class2({
    type: "number",
    check: "number_format",
    abort: false,
    format: "float32",
    ...normalizeParams(params)
  });
}
function _float64(Class2, params) {
  return new Class2({
    type: "number",
    check: "number_format",
    abort: false,
    format: "float64",
    ...normalizeParams(params)
  });
}
function _int32(Class2, params) {
  return new Class2({
    type: "number",
    check: "number_format",
    abort: false,
    format: "int32",
    ...normalizeParams(params)
  });
}
function _uint32(Class2, params) {
  return new Class2({
    type: "number",
    check: "number_format",
    abort: false,
    format: "uint32",
    ...normalizeParams(params)
  });
}
function _boolean(Class2, params) {
  return new Class2({
    type: "boolean",
    ...normalizeParams(params)
  });
}
function _coercedBoolean(Class2, params) {
  return new Class2({
    type: "boolean",
    coerce: true,
    ...normalizeParams(params)
  });
}
function _bigint(Class2, params) {
  return new Class2({
    type: "bigint",
    ...normalizeParams(params)
  });
}
function _coercedBigint(Class2, params) {
  return new Class2({
    type: "bigint",
    coerce: true,
    ...normalizeParams(params)
  });
}
function _int64(Class2, params) {
  return new Class2({
    type: "bigint",
    check: "bigint_format",
    abort: false,
    format: "int64",
    ...normalizeParams(params)
  });
}
function _uint64(Class2, params) {
  return new Class2({
    type: "bigint",
    check: "bigint_format",
    abort: false,
    format: "uint64",
    ...normalizeParams(params)
  });
}
function _symbol(Class2, params) {
  return new Class2({
    type: "symbol",
    ...normalizeParams(params)
  });
}
function _undefined2(Class2, params) {
  return new Class2({
    type: "undefined",
    ...normalizeParams(params)
  });
}
function _null2(Class2, params) {
  return new Class2({
    type: "null",
    ...normalizeParams(params)
  });
}
function _any(Class2) {
  return new Class2({
    type: "any"
  });
}
function _unknown(Class2) {
  return new Class2({
    type: "unknown"
  });
}
function _never(Class2, params) {
  return new Class2({
    type: "never",
    ...normalizeParams(params)
  });
}
function _void(Class2, params) {
  return new Class2({
    type: "void",
    ...normalizeParams(params)
  });
}
function _date(Class2, params) {
  return new Class2({
    type: "date",
    ...normalizeParams(params)
  });
}
function _coercedDate(Class2, params) {
  return new Class2({
    type: "date",
    coerce: true,
    ...normalizeParams(params)
  });
}
function _nan(Class2, params) {
  return new Class2({
    type: "nan",
    ...normalizeParams(params)
  });
}
function _lt(value, params) {
  return new $ZodCheckLessThan({
    check: "less_than",
    ...normalizeParams(params),
    value,
    inclusive: false
  });
}
function _lte(value, params) {
  return new $ZodCheckLessThan({
    check: "less_than",
    ...normalizeParams(params),
    value,
    inclusive: true
  });
}
function _gt(value, params) {
  return new $ZodCheckGreaterThan({
    check: "greater_than",
    ...normalizeParams(params),
    value,
    inclusive: false
  });
}
function _gte(value, params) {
  return new $ZodCheckGreaterThan({
    check: "greater_than",
    ...normalizeParams(params),
    value,
    inclusive: true
  });
}
function _positive(params) {
  return _gt(0, params);
}
function _negative(params) {
  return _lt(0, params);
}
function _nonpositive(params) {
  return _lte(0, params);
}
function _nonnegative(params) {
  return _gte(0, params);
}
function _multipleOf(value, params) {
  return new $ZodCheckMultipleOf({
    check: "multiple_of",
    ...normalizeParams(params),
    value
  });
}
function _maxSize(maximum, params) {
  return new $ZodCheckMaxSize({
    check: "max_size",
    ...normalizeParams(params),
    maximum
  });
}
function _minSize(minimum, params) {
  return new $ZodCheckMinSize({
    check: "min_size",
    ...normalizeParams(params),
    minimum
  });
}
function _size(size, params) {
  return new $ZodCheckSizeEquals({
    check: "size_equals",
    ...normalizeParams(params),
    size
  });
}
function _maxLength(maximum, params) {
  const ch = new $ZodCheckMaxLength({
    check: "max_length",
    ...normalizeParams(params),
    maximum
  });
  return ch;
}
function _minLength(minimum, params) {
  return new $ZodCheckMinLength({
    check: "min_length",
    ...normalizeParams(params),
    minimum
  });
}
function _length(length, params) {
  return new $ZodCheckLengthEquals({
    check: "length_equals",
    ...normalizeParams(params),
    length
  });
}
function _regex(pattern, params) {
  return new $ZodCheckRegex({
    check: "string_format",
    format: "regex",
    ...normalizeParams(params),
    pattern
  });
}
function _lowercase(params) {
  return new $ZodCheckLowerCase({
    check: "string_format",
    format: "lowercase",
    ...normalizeParams(params)
  });
}
function _uppercase(params) {
  return new $ZodCheckUpperCase({
    check: "string_format",
    format: "uppercase",
    ...normalizeParams(params)
  });
}
function _includes(includes, params) {
  return new $ZodCheckIncludes({
    check: "string_format",
    format: "includes",
    ...normalizeParams(params),
    includes
  });
}
function _startsWith(prefix, params) {
  return new $ZodCheckStartsWith({
    check: "string_format",
    format: "starts_with",
    ...normalizeParams(params),
    prefix
  });
}
function _endsWith(suffix, params) {
  return new $ZodCheckEndsWith({
    check: "string_format",
    format: "ends_with",
    ...normalizeParams(params),
    suffix
  });
}
function _property(property, schema, params) {
  return new $ZodCheckProperty({
    check: "property",
    property,
    schema,
    ...normalizeParams(params)
  });
}
function _mime(types, params) {
  return new $ZodCheckMimeType({
    check: "mime_type",
    mime: types,
    ...normalizeParams(params)
  });
}
function _overwrite(tx) {
  return new $ZodCheckOverwrite({
    check: "overwrite",
    tx
  });
}
function _normalize(form) {
  return _overwrite((input) => input.normalize(form));
}
function _trim() {
  return _overwrite((input) => input.trim());
}
function _toLowerCase() {
  return _overwrite((input) => input.toLowerCase());
}
function _toUpperCase() {
  return _overwrite((input) => input.toUpperCase());
}
function _array(Class2, element2, params) {
  return new Class2({
    type: "array",
    element: element2,
    ...normalizeParams(params)
  });
}
function _union(Class2, options2, params) {
  return new Class2({
    type: "union",
    options: options2,
    ...normalizeParams(params)
  });
}
function _discriminatedUnion(Class2, discriminator, options2, params) {
  return new Class2({
    type: "union",
    options: options2,
    discriminator,
    ...normalizeParams(params)
  });
}
function _intersection(Class2, left, right) {
  return new Class2({
    type: "intersection",
    left,
    right
  });
}
function _tuple(Class2, items, _paramsOrRest, _params) {
  const hasRest = _paramsOrRest instanceof $ZodType;
  const params = hasRest ? _params : _paramsOrRest;
  const rest = hasRest ? _paramsOrRest : null;
  return new Class2({
    type: "tuple",
    items,
    rest,
    ...normalizeParams(params)
  });
}
function _record(Class2, keyType, valueType, params) {
  return new Class2({
    type: "record",
    keyType,
    valueType,
    ...normalizeParams(params)
  });
}
function _map(Class2, keyType, valueType, params) {
  return new Class2({
    type: "map",
    keyType,
    valueType,
    ...normalizeParams(params)
  });
}
function _set(Class2, valueType, params) {
  return new Class2({
    type: "set",
    valueType,
    ...normalizeParams(params)
  });
}
function _enum(Class2, values, params) {
  const entries = Array.isArray(values) ? Object.fromEntries(values.map((v) => [v, v])) : values;
  return new Class2({
    type: "enum",
    entries,
    ...normalizeParams(params)
  });
}
function _nativeEnum(Class2, entries, params) {
  return new Class2({
    type: "enum",
    entries,
    ...normalizeParams(params)
  });
}
function _literal(Class2, value, params) {
  return new Class2({
    type: "literal",
    values: Array.isArray(value) ? value : [value],
    ...normalizeParams(params)
  });
}
function _file(Class2, params) {
  return new Class2({
    type: "file",
    ...normalizeParams(params)
  });
}
function _transform(Class2, fn2) {
  return new Class2({
    type: "transform",
    transform: fn2
  });
}
function _optional(Class2, innerType) {
  return new Class2({
    type: "optional",
    innerType
  });
}
function _nullable(Class2, innerType) {
  return new Class2({
    type: "nullable",
    innerType
  });
}
function _default(Class2, innerType, defaultValue) {
  return new Class2({
    type: "default",
    innerType,
    get defaultValue() {
      return typeof defaultValue === "function" ? defaultValue() : defaultValue;
    }
  });
}
function _nonoptional(Class2, innerType, params) {
  return new Class2({
    type: "nonoptional",
    innerType,
    ...normalizeParams(params)
  });
}
function _success(Class2, innerType) {
  return new Class2({
    type: "success",
    innerType
  });
}
function _catch(Class2, innerType, catchValue) {
  return new Class2({
    type: "catch",
    innerType,
    catchValue: typeof catchValue === "function" ? catchValue : () => catchValue
  });
}
function _pipe(Class2, in_, out) {
  return new Class2({
    type: "pipe",
    in: in_,
    out
  });
}
function _readonly(Class2, innerType) {
  return new Class2({
    type: "readonly",
    innerType
  });
}
function _templateLiteral(Class2, parts, params) {
  return new Class2({
    type: "template_literal",
    parts,
    ...normalizeParams(params)
  });
}
function _lazy(Class2, getter) {
  return new Class2({
    type: "lazy",
    getter
  });
}
function _promise(Class2, innerType) {
  return new Class2({
    type: "promise",
    innerType
  });
}
function _custom(Class2, fn2, _params) {
  const norm = normalizeParams(_params);
  norm.abort ?? (norm.abort = true);
  const schema = new Class2({
    type: "custom",
    check: "custom",
    fn: fn2,
    ...norm
  });
  return schema;
}
function _refine(Class2, fn2, _params) {
  const schema = new Class2({
    type: "custom",
    check: "custom",
    fn: fn2,
    ...normalizeParams(_params)
  });
  return schema;
}
function _stringbool(Classes, _params) {
  const params = normalizeParams(_params);
  let truthyArray = params.truthy ?? ["true", "1", "yes", "on", "y", "enabled"];
  let falsyArray = params.falsy ?? ["false", "0", "no", "off", "n", "disabled"];
  if (params.case !== "sensitive") {
    truthyArray = truthyArray.map((v) => typeof v === "string" ? v.toLowerCase() : v);
    falsyArray = falsyArray.map((v) => typeof v === "string" ? v.toLowerCase() : v);
  }
  const truthySet = new Set(truthyArray);
  const falsySet = new Set(falsyArray);
  const _Pipe = Classes.Pipe ?? $ZodPipe;
  const _Boolean = Classes.Boolean ?? $ZodBoolean;
  const _String = Classes.String ?? $ZodString;
  const _Transform = Classes.Transform ?? $ZodTransform;
  const tx = new _Transform({
    type: "transform",
    transform: (input, payload) => {
      let data = input;
      if (params.case !== "sensitive")
        data = data.toLowerCase();
      if (truthySet.has(data)) {
        return true;
      } else if (falsySet.has(data)) {
        return false;
      } else {
        payload.issues.push({
          code: "invalid_value",
          expected: "stringbool",
          values: [...truthySet, ...falsySet],
          input: payload.value,
          inst: tx
        });
        return {};
      }
    },
    error: params.error
  });
  const innerPipe = new _Pipe({
    type: "pipe",
    in: new _String({ type: "string", error: params.error }),
    out: tx,
    error: params.error
  });
  const outerPipe = new _Pipe({
    type: "pipe",
    in: innerPipe,
    out: new _Boolean({
      type: "boolean",
      error: params.error
    }),
    error: params.error
  });
  return outerPipe;
}
function _stringFormat(Class2, format, fnOrRegex, _params = {}) {
  const params = normalizeParams(_params);
  const def = {
    ...normalizeParams(_params),
    check: "string_format",
    type: "string",
    format,
    fn: typeof fnOrRegex === "function" ? fnOrRegex : (val) => fnOrRegex.test(val),
    ...params
  };
  if (fnOrRegex instanceof RegExp) {
    def.pattern = fnOrRegex;
  }
  const inst = new Class2(def);
  return inst;
}

// node_modules/zod/v4/core/function.js
class $ZodFunction {
  constructor(def) {
    this._def = def;
    this.def = def;
  }
  implement(func) {
    if (typeof func !== "function") {
      throw new Error("implement() must be called with a function");
    }
    const impl = (...args) => {
      const parsedArgs = this._def.input ? parse3(this._def.input, args, undefined, { callee: impl }) : args;
      if (!Array.isArray(parsedArgs)) {
        throw new Error("Invalid arguments schema: not an array or tuple schema.");
      }
      const output2 = func(...parsedArgs);
      return this._def.output ? parse3(this._def.output, output2, undefined, { callee: impl }) : output2;
    };
    return impl;
  }
  implementAsync(func) {
    if (typeof func !== "function") {
      throw new Error("implement() must be called with a function");
    }
    const impl = async (...args) => {
      const parsedArgs = this._def.input ? await parseAsync(this._def.input, args, undefined, { callee: impl }) : args;
      if (!Array.isArray(parsedArgs)) {
        throw new Error("Invalid arguments schema: not an array or tuple schema.");
      }
      const output2 = await func(...parsedArgs);
      return this._def.output ? parseAsync(this._def.output, output2, undefined, { callee: impl }) : output2;
    };
    return impl;
  }
  input(...args) {
    const F = this.constructor;
    if (Array.isArray(args[0])) {
      return new F({
        type: "function",
        input: new $ZodTuple({
          type: "tuple",
          items: args[0],
          rest: args[1]
        }),
        output: this._def.output
      });
    }
    return new F({
      type: "function",
      input: args[0],
      output: this._def.output
    });
  }
  output(output2) {
    const F = this.constructor;
    return new F({
      type: "function",
      input: this._def.input,
      output: output2
    });
  }
}
function _function(params) {
  return new $ZodFunction({
    type: "function",
    input: Array.isArray(params?.input) ? _tuple($ZodTuple, params?.input) : params?.input ?? _array($ZodArray, _unknown($ZodUnknown)),
    output: params?.output ?? _unknown($ZodUnknown)
  });
}
// node_modules/zod/v4/core/to-json-schema.js
class JSONSchemaGenerator {
  constructor(params) {
    this.counter = 0;
    this.metadataRegistry = params?.metadata ?? globalRegistry;
    this.target = params?.target ?? "draft-2020-12";
    this.unrepresentable = params?.unrepresentable ?? "throw";
    this.override = params?.override ?? (() => {});
    this.io = params?.io ?? "output";
    this.seen = new Map;
  }
  process(schema, _params = { path: [], schemaPath: [] }) {
    var _a;
    const def = schema._zod.def;
    const formatMap = {
      guid: "uuid",
      url: "uri",
      datetime: "date-time",
      json_string: "json-string",
      regex: ""
    };
    const seen = this.seen.get(schema);
    if (seen) {
      seen.count++;
      const isCycle = _params.schemaPath.includes(schema);
      if (isCycle) {
        seen.cycle = _params.path;
      }
      return seen.schema;
    }
    const result = { schema: {}, count: 1, cycle: undefined, path: _params.path };
    this.seen.set(schema, result);
    const overrideSchema = schema._zod.toJSONSchema?.();
    if (overrideSchema) {
      result.schema = overrideSchema;
    } else {
      const params = {
        ..._params,
        schemaPath: [..._params.schemaPath, schema],
        path: _params.path
      };
      const parent = schema._zod.parent;
      if (parent) {
        result.ref = parent;
        this.process(parent, params);
        this.seen.get(parent).isParent = true;
      } else {
        const _json = result.schema;
        switch (def.type) {
          case "string": {
            const json = _json;
            json.type = "string";
            const { minimum, maximum, format, patterns, contentEncoding } = schema._zod.bag;
            if (typeof minimum === "number")
              json.minLength = minimum;
            if (typeof maximum === "number")
              json.maxLength = maximum;
            if (format) {
              json.format = formatMap[format] ?? format;
              if (json.format === "")
                delete json.format;
            }
            if (contentEncoding)
              json.contentEncoding = contentEncoding;
            if (patterns && patterns.size > 0) {
              const regexes = [...patterns];
              if (regexes.length === 1)
                json.pattern = regexes[0].source;
              else if (regexes.length > 1) {
                result.schema.allOf = [
                  ...regexes.map((regex) => ({
                    ...this.target === "draft-7" ? { type: "string" } : {},
                    pattern: regex.source
                  }))
                ];
              }
            }
            break;
          }
          case "number": {
            const json = _json;
            const { minimum, maximum, format, multipleOf, exclusiveMaximum, exclusiveMinimum } = schema._zod.bag;
            if (typeof format === "string" && format.includes("int"))
              json.type = "integer";
            else
              json.type = "number";
            if (typeof exclusiveMinimum === "number")
              json.exclusiveMinimum = exclusiveMinimum;
            if (typeof minimum === "number") {
              json.minimum = minimum;
              if (typeof exclusiveMinimum === "number") {
                if (exclusiveMinimum >= minimum)
                  delete json.minimum;
                else
                  delete json.exclusiveMinimum;
              }
            }
            if (typeof exclusiveMaximum === "number")
              json.exclusiveMaximum = exclusiveMaximum;
            if (typeof maximum === "number") {
              json.maximum = maximum;
              if (typeof exclusiveMaximum === "number") {
                if (exclusiveMaximum <= maximum)
                  delete json.maximum;
                else
                  delete json.exclusiveMaximum;
              }
            }
            if (typeof multipleOf === "number")
              json.multipleOf = multipleOf;
            break;
          }
          case "boolean": {
            const json = _json;
            json.type = "boolean";
            break;
          }
          case "bigint": {
            if (this.unrepresentable === "throw") {
              throw new Error("BigInt cannot be represented in JSON Schema");
            }
            break;
          }
          case "symbol": {
            if (this.unrepresentable === "throw") {
              throw new Error("Symbols cannot be represented in JSON Schema");
            }
            break;
          }
          case "null": {
            _json.type = "null";
            break;
          }
          case "any": {
            break;
          }
          case "unknown": {
            break;
          }
          case "undefined": {
            if (this.unrepresentable === "throw") {
              throw new Error("Undefined cannot be represented in JSON Schema");
            }
            break;
          }
          case "void": {
            if (this.unrepresentable === "throw") {
              throw new Error("Void cannot be represented in JSON Schema");
            }
            break;
          }
          case "never": {
            _json.not = {};
            break;
          }
          case "date": {
            if (this.unrepresentable === "throw") {
              throw new Error("Date cannot be represented in JSON Schema");
            }
            break;
          }
          case "array": {
            const json = _json;
            const { minimum, maximum } = schema._zod.bag;
            if (typeof minimum === "number")
              json.minItems = minimum;
            if (typeof maximum === "number")
              json.maxItems = maximum;
            json.type = "array";
            json.items = this.process(def.element, { ...params, path: [...params.path, "items"] });
            break;
          }
          case "object": {
            const json = _json;
            json.type = "object";
            json.properties = {};
            const shape2 = def.shape;
            for (const key in shape2) {
              json.properties[key] = this.process(shape2[key], {
                ...params,
                path: [...params.path, "properties", key]
              });
            }
            const allKeys = new Set(Object.keys(shape2));
            const requiredKeys = new Set([...allKeys].filter((key) => {
              const v = def.shape[key]._zod;
              if (this.io === "input") {
                return v.optin === undefined;
              } else {
                return v.optout === undefined;
              }
            }));
            if (requiredKeys.size > 0) {
              json.required = Array.from(requiredKeys);
            }
            if (def.catchall?._zod.def.type === "never") {
              json.additionalProperties = false;
            } else if (!def.catchall) {
              if (this.io === "output")
                json.additionalProperties = false;
            } else if (def.catchall) {
              json.additionalProperties = this.process(def.catchall, {
                ...params,
                path: [...params.path, "additionalProperties"]
              });
            }
            break;
          }
          case "union": {
            const json = _json;
            json.anyOf = def.options.map((x, i) => this.process(x, {
              ...params,
              path: [...params.path, "anyOf", i]
            }));
            break;
          }
          case "intersection": {
            const json = _json;
            const a = this.process(def.left, {
              ...params,
              path: [...params.path, "allOf", 0]
            });
            const b2 = this.process(def.right, {
              ...params,
              path: [...params.path, "allOf", 1]
            });
            const isSimpleIntersection = (val) => ("allOf" in val) && Object.keys(val).length === 1;
            const allOf = [
              ...isSimpleIntersection(a) ? a.allOf : [a],
              ...isSimpleIntersection(b2) ? b2.allOf : [b2]
            ];
            json.allOf = allOf;
            break;
          }
          case "tuple": {
            const json = _json;
            json.type = "array";
            const prefixItems = def.items.map((x, i) => this.process(x, { ...params, path: [...params.path, "prefixItems", i] }));
            if (this.target === "draft-2020-12") {
              json.prefixItems = prefixItems;
            } else {
              json.items = prefixItems;
            }
            if (def.rest) {
              const rest = this.process(def.rest, {
                ...params,
                path: [...params.path, "items"]
              });
              if (this.target === "draft-2020-12") {
                json.items = rest;
              } else {
                json.additionalItems = rest;
              }
            }
            if (def.rest) {
              json.items = this.process(def.rest, {
                ...params,
                path: [...params.path, "items"]
              });
            }
            const { minimum, maximum } = schema._zod.bag;
            if (typeof minimum === "number")
              json.minItems = minimum;
            if (typeof maximum === "number")
              json.maxItems = maximum;
            break;
          }
          case "record": {
            const json = _json;
            json.type = "object";
            json.propertyNames = this.process(def.keyType, { ...params, path: [...params.path, "propertyNames"] });
            json.additionalProperties = this.process(def.valueType, {
              ...params,
              path: [...params.path, "additionalProperties"]
            });
            break;
          }
          case "map": {
            if (this.unrepresentable === "throw") {
              throw new Error("Map cannot be represented in JSON Schema");
            }
            break;
          }
          case "set": {
            if (this.unrepresentable === "throw") {
              throw new Error("Set cannot be represented in JSON Schema");
            }
            break;
          }
          case "enum": {
            const json = _json;
            const values = getEnumValues(def.entries);
            if (values.every((v) => typeof v === "number"))
              json.type = "number";
            if (values.every((v) => typeof v === "string"))
              json.type = "string";
            json.enum = values;
            break;
          }
          case "literal": {
            const json = _json;
            const vals = [];
            for (const val of def.values) {
              if (val === undefined) {
                if (this.unrepresentable === "throw") {
                  throw new Error("Literal `undefined` cannot be represented in JSON Schema");
                } else {}
              } else if (typeof val === "bigint") {
                if (this.unrepresentable === "throw") {
                  throw new Error("BigInt literals cannot be represented in JSON Schema");
                } else {
                  vals.push(Number(val));
                }
              } else {
                vals.push(val);
              }
            }
            if (vals.length === 0) {} else if (vals.length === 1) {
              const val = vals[0];
              json.type = val === null ? "null" : typeof val;
              json.const = val;
            } else {
              if (vals.every((v) => typeof v === "number"))
                json.type = "number";
              if (vals.every((v) => typeof v === "string"))
                json.type = "string";
              if (vals.every((v) => typeof v === "boolean"))
                json.type = "string";
              if (vals.every((v) => v === null))
                json.type = "null";
              json.enum = vals;
            }
            break;
          }
          case "file": {
            const json = _json;
            const file2 = {
              type: "string",
              format: "binary",
              contentEncoding: "binary"
            };
            const { minimum, maximum, mime } = schema._zod.bag;
            if (minimum !== undefined)
              file2.minLength = minimum;
            if (maximum !== undefined)
              file2.maxLength = maximum;
            if (mime) {
              if (mime.length === 1) {
                file2.contentMediaType = mime[0];
                Object.assign(json, file2);
              } else {
                json.anyOf = mime.map((m) => {
                  const mFile = { ...file2, contentMediaType: m };
                  return mFile;
                });
              }
            } else {
              Object.assign(json, file2);
            }
            break;
          }
          case "transform": {
            if (this.unrepresentable === "throw") {
              throw new Error("Transforms cannot be represented in JSON Schema");
            }
            break;
          }
          case "nullable": {
            const inner = this.process(def.innerType, params);
            _json.anyOf = [inner, { type: "null" }];
            break;
          }
          case "nonoptional": {
            this.process(def.innerType, params);
            result.ref = def.innerType;
            break;
          }
          case "success": {
            const json = _json;
            json.type = "boolean";
            break;
          }
          case "default": {
            this.process(def.innerType, params);
            result.ref = def.innerType;
            _json.default = JSON.parse(JSON.stringify(def.defaultValue));
            break;
          }
          case "prefault": {
            this.process(def.innerType, params);
            result.ref = def.innerType;
            if (this.io === "input")
              _json._prefault = JSON.parse(JSON.stringify(def.defaultValue));
            break;
          }
          case "catch": {
            this.process(def.innerType, params);
            result.ref = def.innerType;
            let catchValue;
            try {
              catchValue = def.catchValue(undefined);
            } catch {
              throw new Error("Dynamic catch values are not supported in JSON Schema");
            }
            _json.default = catchValue;
            break;
          }
          case "nan": {
            if (this.unrepresentable === "throw") {
              throw new Error("NaN cannot be represented in JSON Schema");
            }
            break;
          }
          case "template_literal": {
            const json = _json;
            const pattern = schema._zod.pattern;
            if (!pattern)
              throw new Error("Pattern not found in template literal");
            json.type = "string";
            json.pattern = pattern.source;
            break;
          }
          case "pipe": {
            const innerType = this.io === "input" ? def.in._zod.def.type === "transform" ? def.out : def.in : def.out;
            this.process(innerType, params);
            result.ref = innerType;
            break;
          }
          case "readonly": {
            this.process(def.innerType, params);
            result.ref = def.innerType;
            _json.readOnly = true;
            break;
          }
          case "promise": {
            this.process(def.innerType, params);
            result.ref = def.innerType;
            break;
          }
          case "optional": {
            this.process(def.innerType, params);
            result.ref = def.innerType;
            break;
          }
          case "lazy": {
            const innerType = schema._zod.innerType;
            this.process(innerType, params);
            result.ref = innerType;
            break;
          }
          case "custom": {
            if (this.unrepresentable === "throw") {
              throw new Error("Custom types cannot be represented in JSON Schema");
            }
            break;
          }
          default: {}
        }
      }
    }
    const meta = this.metadataRegistry.get(schema);
    if (meta)
      Object.assign(result.schema, meta);
    if (this.io === "input" && isTransforming(schema)) {
      delete result.schema.examples;
      delete result.schema.default;
    }
    if (this.io === "input" && result.schema._prefault)
      (_a = result.schema).default ?? (_a.default = result.schema._prefault);
    delete result.schema._prefault;
    const _result = this.seen.get(schema);
    return _result.schema;
  }
  emit(schema, _params) {
    const params = {
      cycles: _params?.cycles ?? "ref",
      reused: _params?.reused ?? "inline",
      external: _params?.external ?? undefined
    };
    const root = this.seen.get(schema);
    if (!root)
      throw new Error("Unprocessed schema. This is a bug in Zod.");
    const makeURI = (entry) => {
      const defsSegment = this.target === "draft-2020-12" ? "$defs" : "definitions";
      if (params.external) {
        const externalId = params.external.registry.get(entry[0])?.id;
        const uriGenerator = params.external.uri ?? ((id2) => id2);
        if (externalId) {
          return { ref: uriGenerator(externalId) };
        }
        const id = entry[1].defId ?? entry[1].schema.id ?? `schema${this.counter++}`;
        entry[1].defId = id;
        return { defId: id, ref: `${uriGenerator("__shared")}#/${defsSegment}/${id}` };
      }
      if (entry[1] === root) {
        return { ref: "#" };
      }
      const uriPrefix = `#`;
      const defUriPrefix = `${uriPrefix}/${defsSegment}/`;
      const defId = entry[1].schema.id ?? `__schema${this.counter++}`;
      return { defId, ref: defUriPrefix + defId };
    };
    const extractToDef = (entry) => {
      if (entry[1].schema.$ref) {
        return;
      }
      const seen = entry[1];
      const { ref, defId } = makeURI(entry);
      seen.def = { ...seen.schema };
      if (defId)
        seen.defId = defId;
      const schema2 = seen.schema;
      for (const key in schema2) {
        delete schema2[key];
      }
      schema2.$ref = ref;
    };
    if (params.cycles === "throw") {
      for (const entry of this.seen.entries()) {
        const seen = entry[1];
        if (seen.cycle) {
          throw new Error("Cycle detected: " + `#/${seen.cycle?.join("/")}/<root>` + '\n\nSet the `cycles` parameter to `"ref"` to resolve cyclical schemas with defs.');
        }
      }
    }
    for (const entry of this.seen.entries()) {
      const seen = entry[1];
      if (schema === entry[0]) {
        extractToDef(entry);
        continue;
      }
      if (params.external) {
        const ext = params.external.registry.get(entry[0])?.id;
        if (schema !== entry[0] && ext) {
          extractToDef(entry);
          continue;
        }
      }
      const id = this.metadataRegistry.get(entry[0])?.id;
      if (id) {
        extractToDef(entry);
        continue;
      }
      if (seen.cycle) {
        extractToDef(entry);
        continue;
      }
      if (seen.count > 1) {
        if (params.reused === "ref") {
          extractToDef(entry);
          continue;
        }
      }
    }
    const flattenRef = (zodSchema, params2) => {
      const seen = this.seen.get(zodSchema);
      const schema2 = seen.def ?? seen.schema;
      const _cached = { ...schema2 };
      if (seen.ref === null) {
        return;
      }
      const ref = seen.ref;
      seen.ref = null;
      if (ref) {
        flattenRef(ref, params2);
        const refSchema = this.seen.get(ref).schema;
        if (refSchema.$ref && params2.target === "draft-7") {
          schema2.allOf = schema2.allOf ?? [];
          schema2.allOf.push(refSchema);
        } else {
          Object.assign(schema2, refSchema);
          Object.assign(schema2, _cached);
        }
      }
      if (!seen.isParent)
        this.override({
          zodSchema,
          jsonSchema: schema2,
          path: seen.path ?? []
        });
    };
    for (const entry of [...this.seen.entries()].reverse()) {
      flattenRef(entry[0], { target: this.target });
    }
    const result = {};
    if (this.target === "draft-2020-12") {
      result.$schema = "https://json-schema.org/draft/2020-12/schema";
    } else if (this.target === "draft-7") {
      result.$schema = "http://json-schema.org/draft-07/schema#";
    } else {
      console.warn(`Invalid target: ${this.target}`);
    }
    if (params.external?.uri) {
      const id = params.external.registry.get(schema)?.id;
      if (!id)
        throw new Error("Schema is missing an `id` property");
      result.$id = params.external.uri(id);
    }
    Object.assign(result, root.def);
    const defs = params.external?.defs ?? {};
    for (const entry of this.seen.entries()) {
      const seen = entry[1];
      if (seen.def && seen.defId) {
        defs[seen.defId] = seen.def;
      }
    }
    if (params.external) {} else {
      if (Object.keys(defs).length > 0) {
        if (this.target === "draft-2020-12") {
          result.$defs = defs;
        } else {
          result.definitions = defs;
        }
      }
    }
    try {
      return JSON.parse(JSON.stringify(result));
    } catch (_err) {
      throw new Error("Error converting schema to JSON.");
    }
  }
}
function toJSONSchema(input, _params) {
  if (input instanceof $ZodRegistry) {
    const gen2 = new JSONSchemaGenerator(_params);
    const defs = {};
    for (const entry of input._idmap.entries()) {
      const [_23, schema] = entry;
      gen2.process(schema);
    }
    const schemas = {};
    const external = {
      registry: input,
      uri: _params?.uri,
      defs
    };
    for (const entry of input._idmap.entries()) {
      const [key, schema] = entry;
      schemas[key] = gen2.emit(schema, {
        ..._params,
        external
      });
    }
    if (Object.keys(defs).length > 0) {
      const defsSegment = gen2.target === "draft-2020-12" ? "$defs" : "definitions";
      schemas.__shared = {
        [defsSegment]: defs
      };
    }
    return { schemas };
  }
  const gen = new JSONSchemaGenerator(_params);
  gen.process(input);
  return gen.emit(input, _params);
}
function isTransforming(_schema, _ctx) {
  const ctx = _ctx ?? { seen: new Set };
  if (ctx.seen.has(_schema))
    return false;
  ctx.seen.add(_schema);
  const schema = _schema;
  const def = schema._zod.def;
  switch (def.type) {
    case "string":
    case "number":
    case "bigint":
    case "boolean":
    case "date":
    case "symbol":
    case "undefined":
    case "null":
    case "any":
    case "unknown":
    case "never":
    case "void":
    case "literal":
    case "enum":
    case "nan":
    case "file":
    case "template_literal":
      return false;
    case "array": {
      return isTransforming(def.element, ctx);
    }
    case "object": {
      for (const key in def.shape) {
        if (isTransforming(def.shape[key], ctx))
          return true;
      }
      return false;
    }
    case "union": {
      for (const option of def.options) {
        if (isTransforming(option, ctx))
          return true;
      }
      return false;
    }
    case "intersection": {
      return isTransforming(def.left, ctx) || isTransforming(def.right, ctx);
    }
    case "tuple": {
      for (const item of def.items) {
        if (isTransforming(item, ctx))
          return true;
      }
      if (def.rest && isTransforming(def.rest, ctx))
        return true;
      return false;
    }
    case "record": {
      return isTransforming(def.keyType, ctx) || isTransforming(def.valueType, ctx);
    }
    case "map": {
      return isTransforming(def.keyType, ctx) || isTransforming(def.valueType, ctx);
    }
    case "set": {
      return isTransforming(def.valueType, ctx);
    }
    case "promise":
    case "optional":
    case "nonoptional":
    case "nullable":
    case "readonly":
      return isTransforming(def.innerType, ctx);
    case "lazy":
      return isTransforming(def.getter(), ctx);
    case "default": {
      return isTransforming(def.innerType, ctx);
    }
    case "prefault": {
      return isTransforming(def.innerType, ctx);
    }
    case "custom": {
      return false;
    }
    case "transform": {
      return true;
    }
    case "pipe": {
      return isTransforming(def.in, ctx) || isTransforming(def.out, ctx);
    }
    case "success": {
      return false;
    }
    case "catch": {
      return false;
    }
    default:
  }
  throw new Error(`Unknown schema type: ${def.type}`);
}
// node_modules/zod/v4/core/json-schema.js
var exports_json_schema = {};
// node_modules/zod/v4/classic/iso.js
var exports_iso = {};
__export(exports_iso, {
  time: () => time2,
  duration: () => duration2,
  datetime: () => datetime2,
  date: () => date2,
  ZodISOTime: () => ZodISOTime,
  ZodISODuration: () => ZodISODuration,
  ZodISODateTime: () => ZodISODateTime,
  ZodISODate: () => ZodISODate
});
var ZodISODateTime = /* @__PURE__ */ $constructor("ZodISODateTime", (inst, def) => {
  $ZodISODateTime.init(inst, def);
  ZodStringFormat.init(inst, def);
});
function datetime2(params) {
  return _isoDateTime(ZodISODateTime, params);
}
var ZodISODate = /* @__PURE__ */ $constructor("ZodISODate", (inst, def) => {
  $ZodISODate.init(inst, def);
  ZodStringFormat.init(inst, def);
});
function date2(params) {
  return _isoDate(ZodISODate, params);
}
var ZodISOTime = /* @__PURE__ */ $constructor("ZodISOTime", (inst, def) => {
  $ZodISOTime.init(inst, def);
  ZodStringFormat.init(inst, def);
});
function time2(params) {
  return _isoTime(ZodISOTime, params);
}
var ZodISODuration = /* @__PURE__ */ $constructor("ZodISODuration", (inst, def) => {
  $ZodISODuration.init(inst, def);
  ZodStringFormat.init(inst, def);
});
function duration2(params) {
  return _isoDuration(ZodISODuration, params);
}

// node_modules/zod/v4/classic/errors.js
var initializer2 = (inst, issues) => {
  $ZodError.init(inst, issues);
  inst.name = "ZodError";
  Object.defineProperties(inst, {
    format: {
      value: (mapper) => formatError(inst, mapper)
    },
    flatten: {
      value: (mapper) => flattenError(inst, mapper)
    },
    addIssue: {
      value: (issue2) => inst.issues.push(issue2)
    },
    addIssues: {
      value: (issues2) => inst.issues.push(...issues2)
    },
    isEmpty: {
      get() {
        return inst.issues.length === 0;
      }
    }
  });
};
var ZodError = $constructor("ZodError", initializer2);
var ZodRealError = $constructor("ZodError", initializer2, {
  Parent: Error
});

// node_modules/zod/v4/classic/parse.js
var parse5 = /* @__PURE__ */ _parse(ZodRealError);
var parseAsync2 = /* @__PURE__ */ _parseAsync(ZodRealError);
var safeParse2 = /* @__PURE__ */ _safeParse(ZodRealError);
var safeParseAsync2 = /* @__PURE__ */ _safeParseAsync(ZodRealError);

// node_modules/zod/v4/classic/schemas.js
var ZodType = /* @__PURE__ */ $constructor("ZodType", (inst, def) => {
  $ZodType.init(inst, def);
  inst.def = def;
  Object.defineProperty(inst, "_def", { value: def });
  inst.check = (...checks2) => {
    return inst.clone({
      ...def,
      checks: [
        ...def.checks ?? [],
        ...checks2.map((ch) => typeof ch === "function" ? { _zod: { check: ch, def: { check: "custom" }, onattach: [] } } : ch)
      ]
    });
  };
  inst.clone = (def2, params) => clone2(inst, def2, params);
  inst.brand = () => inst;
  inst.register = (reg, meta) => {
    reg.add(inst, meta);
    return inst;
  };
  inst.parse = (data, params) => parse5(inst, data, params, { callee: inst.parse });
  inst.safeParse = (data, params) => safeParse2(inst, data, params);
  inst.parseAsync = async (data, params) => parseAsync2(inst, data, params, { callee: inst.parseAsync });
  inst.safeParseAsync = async (data, params) => safeParseAsync2(inst, data, params);
  inst.spa = inst.safeParseAsync;
  inst.refine = (check, params) => inst.check(refine(check, params));
  inst.superRefine = (refinement) => inst.check(superRefine(refinement));
  inst.overwrite = (fn2) => inst.check(_overwrite(fn2));
  inst.optional = () => optional(inst);
  inst.nullable = () => nullable(inst);
  inst.nullish = () => optional(nullable(inst));
  inst.nonoptional = (params) => nonoptional(inst, params);
  inst.array = () => array(inst);
  inst.or = (arg) => union([inst, arg]);
  inst.and = (arg) => intersection(inst, arg);
  inst.transform = (tx) => pipe(inst, transform2(tx));
  inst.default = (def2) => _default2(inst, def2);
  inst.prefault = (def2) => prefault(inst, def2);
  inst.catch = (params) => _catch2(inst, params);
  inst.pipe = (target) => pipe(inst, target);
  inst.readonly = () => readonly(inst);
  inst.describe = (description) => {
    const cl = inst.clone();
    globalRegistry.add(cl, { description });
    return cl;
  };
  Object.defineProperty(inst, "description", {
    get() {
      return globalRegistry.get(inst)?.description;
    },
    configurable: true
  });
  inst.meta = (...args) => {
    if (args.length === 0) {
      return globalRegistry.get(inst);
    }
    const cl = inst.clone();
    globalRegistry.add(cl, args[0]);
    return cl;
  };
  inst.isOptional = () => inst.safeParse(undefined).success;
  inst.isNullable = () => inst.safeParse(null).success;
  return inst;
});
var _ZodString = /* @__PURE__ */ $constructor("_ZodString", (inst, def) => {
  $ZodString.init(inst, def);
  ZodType.init(inst, def);
  const bag = inst._zod.bag;
  inst.format = bag.format ?? null;
  inst.minLength = bag.minimum ?? null;
  inst.maxLength = bag.maximum ?? null;
  inst.regex = (...args) => inst.check(_regex(...args));
  inst.includes = (...args) => inst.check(_includes(...args));
  inst.startsWith = (...args) => inst.check(_startsWith(...args));
  inst.endsWith = (...args) => inst.check(_endsWith(...args));
  inst.min = (...args) => inst.check(_minLength(...args));
  inst.max = (...args) => inst.check(_maxLength(...args));
  inst.length = (...args) => inst.check(_length(...args));
  inst.nonempty = (...args) => inst.check(_minLength(1, ...args));
  inst.lowercase = (params) => inst.check(_lowercase(params));
  inst.uppercase = (params) => inst.check(_uppercase(params));
  inst.trim = () => inst.check(_trim());
  inst.normalize = (...args) => inst.check(_normalize(...args));
  inst.toLowerCase = () => inst.check(_toLowerCase());
  inst.toUpperCase = () => inst.check(_toUpperCase());
});
var ZodString = /* @__PURE__ */ $constructor("ZodString", (inst, def) => {
  $ZodString.init(inst, def);
  _ZodString.init(inst, def);
  inst.email = (params) => inst.check(_email(ZodEmail, params));
  inst.url = (params) => inst.check(_url(ZodURL, params));
  inst.jwt = (params) => inst.check(_jwt(ZodJWT, params));
  inst.emoji = (params) => inst.check(_emoji2(ZodEmoji, params));
  inst.guid = (params) => inst.check(_guid(ZodGUID, params));
  inst.uuid = (params) => inst.check(_uuid(ZodUUID, params));
  inst.uuidv4 = (params) => inst.check(_uuidv4(ZodUUID, params));
  inst.uuidv6 = (params) => inst.check(_uuidv6(ZodUUID, params));
  inst.uuidv7 = (params) => inst.check(_uuidv7(ZodUUID, params));
  inst.nanoid = (params) => inst.check(_nanoid(ZodNanoID, params));
  inst.guid = (params) => inst.check(_guid(ZodGUID, params));
  inst.cuid = (params) => inst.check(_cuid(ZodCUID, params));
  inst.cuid2 = (params) => inst.check(_cuid2(ZodCUID2, params));
  inst.ulid = (params) => inst.check(_ulid(ZodULID, params));
  inst.base64 = (params) => inst.check(_base64(ZodBase64, params));
  inst.base64url = (params) => inst.check(_base64url(ZodBase64URL, params));
  inst.xid = (params) => inst.check(_xid(ZodXID, params));
  inst.ksuid = (params) => inst.check(_ksuid(ZodKSUID, params));
  inst.ipv4 = (params) => inst.check(_ipv4(ZodIPv4, params));
  inst.ipv6 = (params) => inst.check(_ipv6(ZodIPv6, params));
  inst.cidrv4 = (params) => inst.check(_cidrv4(ZodCIDRv4, params));
  inst.cidrv6 = (params) => inst.check(_cidrv6(ZodCIDRv6, params));
  inst.e164 = (params) => inst.check(_e164(ZodE164, params));
  inst.datetime = (params) => inst.check(datetime2(params));
  inst.date = (params) => inst.check(date2(params));
  inst.time = (params) => inst.check(time2(params));
  inst.duration = (params) => inst.check(duration2(params));
});
function string2(params) {
  return _string(ZodString, params);
}
var ZodStringFormat = /* @__PURE__ */ $constructor("ZodStringFormat", (inst, def) => {
  $ZodStringFormat.init(inst, def);
  _ZodString.init(inst, def);
});
var ZodEmail = /* @__PURE__ */ $constructor("ZodEmail", (inst, def) => {
  $ZodEmail.init(inst, def);
  ZodStringFormat.init(inst, def);
});
function email2(params) {
  return _email(ZodEmail, params);
}
var ZodGUID = /* @__PURE__ */ $constructor("ZodGUID", (inst, def) => {
  $ZodGUID.init(inst, def);
  ZodStringFormat.init(inst, def);
});
function guid2(params) {
  return _guid(ZodGUID, params);
}
var ZodUUID = /* @__PURE__ */ $constructor("ZodUUID", (inst, def) => {
  $ZodUUID.init(inst, def);
  ZodStringFormat.init(inst, def);
});
function uuid2(params) {
  return _uuid(ZodUUID, params);
}
function uuidv4(params) {
  return _uuidv4(ZodUUID, params);
}
function uuidv6(params) {
  return _uuidv6(ZodUUID, params);
}
function uuidv7(params) {
  return _uuidv7(ZodUUID, params);
}
var ZodURL = /* @__PURE__ */ $constructor("ZodURL", (inst, def) => {
  $ZodURL.init(inst, def);
  ZodStringFormat.init(inst, def);
});
function url(params) {
  return _url(ZodURL, params);
}
var ZodEmoji = /* @__PURE__ */ $constructor("ZodEmoji", (inst, def) => {
  $ZodEmoji.init(inst, def);
  ZodStringFormat.init(inst, def);
});
function emoji2(params) {
  return _emoji2(ZodEmoji, params);
}
var ZodNanoID = /* @__PURE__ */ $constructor("ZodNanoID", (inst, def) => {
  $ZodNanoID.init(inst, def);
  ZodStringFormat.init(inst, def);
});
function nanoid2(params) {
  return _nanoid(ZodNanoID, params);
}
var ZodCUID = /* @__PURE__ */ $constructor("ZodCUID", (inst, def) => {
  $ZodCUID.init(inst, def);
  ZodStringFormat.init(inst, def);
});
function cuid3(params) {
  return _cuid(ZodCUID, params);
}
var ZodCUID2 = /* @__PURE__ */ $constructor("ZodCUID2", (inst, def) => {
  $ZodCUID2.init(inst, def);
  ZodStringFormat.init(inst, def);
});
function cuid22(params) {
  return _cuid2(ZodCUID2, params);
}
var ZodULID = /* @__PURE__ */ $constructor("ZodULID", (inst, def) => {
  $ZodULID.init(inst, def);
  ZodStringFormat.init(inst, def);
});
function ulid2(params) {
  return _ulid(ZodULID, params);
}
var ZodXID = /* @__PURE__ */ $constructor("ZodXID", (inst, def) => {
  $ZodXID.init(inst, def);
  ZodStringFormat.init(inst, def);
});
function xid2(params) {
  return _xid(ZodXID, params);
}
var ZodKSUID = /* @__PURE__ */ $constructor("ZodKSUID", (inst, def) => {
  $ZodKSUID.init(inst, def);
  ZodStringFormat.init(inst, def);
});
function ksuid2(params) {
  return _ksuid(ZodKSUID, params);
}
var ZodIPv4 = /* @__PURE__ */ $constructor("ZodIPv4", (inst, def) => {
  $ZodIPv4.init(inst, def);
  ZodStringFormat.init(inst, def);
});
function ipv42(params) {
  return _ipv4(ZodIPv4, params);
}
var ZodIPv6 = /* @__PURE__ */ $constructor("ZodIPv6", (inst, def) => {
  $ZodIPv6.init(inst, def);
  ZodStringFormat.init(inst, def);
});
function ipv62(params) {
  return _ipv6(ZodIPv6, params);
}
var ZodCIDRv4 = /* @__PURE__ */ $constructor("ZodCIDRv4", (inst, def) => {
  $ZodCIDRv4.init(inst, def);
  ZodStringFormat.init(inst, def);
});
function cidrv42(params) {
  return _cidrv4(ZodCIDRv4, params);
}
var ZodCIDRv6 = /* @__PURE__ */ $constructor("ZodCIDRv6", (inst, def) => {
  $ZodCIDRv6.init(inst, def);
  ZodStringFormat.init(inst, def);
});
function cidrv62(params) {
  return _cidrv6(ZodCIDRv6, params);
}
var ZodBase64 = /* @__PURE__ */ $constructor("ZodBase64", (inst, def) => {
  $ZodBase64.init(inst, def);
  ZodStringFormat.init(inst, def);
});
function base642(params) {
  return _base64(ZodBase64, params);
}
var ZodBase64URL = /* @__PURE__ */ $constructor("ZodBase64URL", (inst, def) => {
  $ZodBase64URL.init(inst, def);
  ZodStringFormat.init(inst, def);
});
function base64url2(params) {
  return _base64url(ZodBase64URL, params);
}
var ZodE164 = /* @__PURE__ */ $constructor("ZodE164", (inst, def) => {
  $ZodE164.init(inst, def);
  ZodStringFormat.init(inst, def);
});
function e1642(params) {
  return _e164(ZodE164, params);
}
var ZodJWT = /* @__PURE__ */ $constructor("ZodJWT", (inst, def) => {
  $ZodJWT.init(inst, def);
  ZodStringFormat.init(inst, def);
});
function jwt(params) {
  return _jwt(ZodJWT, params);
}
var ZodCustomStringFormat = /* @__PURE__ */ $constructor("ZodCustomStringFormat", (inst, def) => {
  $ZodCustomStringFormat.init(inst, def);
  ZodStringFormat.init(inst, def);
});
function stringFormat(format, fnOrRegex, _params = {}) {
  return _stringFormat(ZodCustomStringFormat, format, fnOrRegex, _params);
}
var ZodNumber = /* @__PURE__ */ $constructor("ZodNumber", (inst, def) => {
  $ZodNumber.init(inst, def);
  ZodType.init(inst, def);
  inst.gt = (value, params) => inst.check(_gt(value, params));
  inst.gte = (value, params) => inst.check(_gte(value, params));
  inst.min = (value, params) => inst.check(_gte(value, params));
  inst.lt = (value, params) => inst.check(_lt(value, params));
  inst.lte = (value, params) => inst.check(_lte(value, params));
  inst.max = (value, params) => inst.check(_lte(value, params));
  inst.int = (params) => inst.check(int(params));
  inst.safe = (params) => inst.check(int(params));
  inst.positive = (params) => inst.check(_gt(0, params));
  inst.nonnegative = (params) => inst.check(_gte(0, params));
  inst.negative = (params) => inst.check(_lt(0, params));
  inst.nonpositive = (params) => inst.check(_lte(0, params));
  inst.multipleOf = (value, params) => inst.check(_multipleOf(value, params));
  inst.step = (value, params) => inst.check(_multipleOf(value, params));
  inst.finite = () => inst;
  const bag = inst._zod.bag;
  inst.minValue = Math.max(bag.minimum ?? Number.NEGATIVE_INFINITY, bag.exclusiveMinimum ?? Number.NEGATIVE_INFINITY) ?? null;
  inst.maxValue = Math.min(bag.maximum ?? Number.POSITIVE_INFINITY, bag.exclusiveMaximum ?? Number.POSITIVE_INFINITY) ?? null;
  inst.isInt = (bag.format ?? "").includes("int") || Number.isSafeInteger(bag.multipleOf ?? 0.5);
  inst.isFinite = true;
  inst.format = bag.format ?? null;
});
function number2(params) {
  return _number(ZodNumber, params);
}
var ZodNumberFormat = /* @__PURE__ */ $constructor("ZodNumberFormat", (inst, def) => {
  $ZodNumberFormat.init(inst, def);
  ZodNumber.init(inst, def);
});
function int(params) {
  return _int(ZodNumberFormat, params);
}
function float32(params) {
  return _float32(ZodNumberFormat, params);
}
function float64(params) {
  return _float64(ZodNumberFormat, params);
}
function int32(params) {
  return _int32(ZodNumberFormat, params);
}
function uint32(params) {
  return _uint32(ZodNumberFormat, params);
}
var ZodBoolean = /* @__PURE__ */ $constructor("ZodBoolean", (inst, def) => {
  $ZodBoolean.init(inst, def);
  ZodType.init(inst, def);
});
function boolean2(params) {
  return _boolean(ZodBoolean, params);
}
var ZodBigInt = /* @__PURE__ */ $constructor("ZodBigInt", (inst, def) => {
  $ZodBigInt.init(inst, def);
  ZodType.init(inst, def);
  inst.gte = (value, params) => inst.check(_gte(value, params));
  inst.min = (value, params) => inst.check(_gte(value, params));
  inst.gt = (value, params) => inst.check(_gt(value, params));
  inst.gte = (value, params) => inst.check(_gte(value, params));
  inst.min = (value, params) => inst.check(_gte(value, params));
  inst.lt = (value, params) => inst.check(_lt(value, params));
  inst.lte = (value, params) => inst.check(_lte(value, params));
  inst.max = (value, params) => inst.check(_lte(value, params));
  inst.positive = (params) => inst.check(_gt(BigInt(0), params));
  inst.negative = (params) => inst.check(_lt(BigInt(0), params));
  inst.nonpositive = (params) => inst.check(_lte(BigInt(0), params));
  inst.nonnegative = (params) => inst.check(_gte(BigInt(0), params));
  inst.multipleOf = (value, params) => inst.check(_multipleOf(value, params));
  const bag = inst._zod.bag;
  inst.minValue = bag.minimum ?? null;
  inst.maxValue = bag.maximum ?? null;
  inst.format = bag.format ?? null;
});
function bigint2(params) {
  return _bigint(ZodBigInt, params);
}
var ZodBigIntFormat = /* @__PURE__ */ $constructor("ZodBigIntFormat", (inst, def) => {
  $ZodBigIntFormat.init(inst, def);
  ZodBigInt.init(inst, def);
});
function int64(params) {
  return _int64(ZodBigIntFormat, params);
}
function uint64(params) {
  return _uint64(ZodBigIntFormat, params);
}
var ZodSymbol = /* @__PURE__ */ $constructor("ZodSymbol", (inst, def) => {
  $ZodSymbol.init(inst, def);
  ZodType.init(inst, def);
});
function symbol(params) {
  return _symbol(ZodSymbol, params);
}
var ZodUndefined = /* @__PURE__ */ $constructor("ZodUndefined", (inst, def) => {
  $ZodUndefined.init(inst, def);
  ZodType.init(inst, def);
});
function _undefined3(params) {
  return _undefined2(ZodUndefined, params);
}
var ZodNull = /* @__PURE__ */ $constructor("ZodNull", (inst, def) => {
  $ZodNull.init(inst, def);
  ZodType.init(inst, def);
});
function _null3(params) {
  return _null2(ZodNull, params);
}
var ZodAny = /* @__PURE__ */ $constructor("ZodAny", (inst, def) => {
  $ZodAny.init(inst, def);
  ZodType.init(inst, def);
});
function any() {
  return _any(ZodAny);
}
var ZodUnknown = /* @__PURE__ */ $constructor("ZodUnknown", (inst, def) => {
  $ZodUnknown.init(inst, def);
  ZodType.init(inst, def);
});
function unknown() {
  return _unknown(ZodUnknown);
}
var ZodNever = /* @__PURE__ */ $constructor("ZodNever", (inst, def) => {
  $ZodNever.init(inst, def);
  ZodType.init(inst, def);
});
function never(params) {
  return _never(ZodNever, params);
}
var ZodVoid = /* @__PURE__ */ $constructor("ZodVoid", (inst, def) => {
  $ZodVoid.init(inst, def);
  ZodType.init(inst, def);
});
function _void2(params) {
  return _void(ZodVoid, params);
}
var ZodDate = /* @__PURE__ */ $constructor("ZodDate", (inst, def) => {
  $ZodDate.init(inst, def);
  ZodType.init(inst, def);
  inst.min = (value, params) => inst.check(_gte(value, params));
  inst.max = (value, params) => inst.check(_lte(value, params));
  const c = inst._zod.bag;
  inst.minDate = c.minimum ? new Date(c.minimum) : null;
  inst.maxDate = c.maximum ? new Date(c.maximum) : null;
});
function date3(params) {
  return _date(ZodDate, params);
}
var ZodArray = /* @__PURE__ */ $constructor("ZodArray", (inst, def) => {
  $ZodArray.init(inst, def);
  ZodType.init(inst, def);
  inst.element = def.element;
  inst.min = (minLength, params) => inst.check(_minLength(minLength, params));
  inst.nonempty = (params) => inst.check(_minLength(1, params));
  inst.max = (maxLength, params) => inst.check(_maxLength(maxLength, params));
  inst.length = (len, params) => inst.check(_length(len, params));
  inst.unwrap = () => inst.element;
});
function array(element2, params) {
  return _array(ZodArray, element2, params);
}
function keyof(schema) {
  const shape2 = schema._zod.def.shape;
  return literal(Object.keys(shape2));
}
var ZodObject = /* @__PURE__ */ $constructor("ZodObject", (inst, def) => {
  $ZodObject.init(inst, def);
  ZodType.init(inst, def);
  exports_util2.defineLazy(inst, "shape", () => def.shape);
  inst.keyof = () => _enum2(Object.keys(inst._zod.def.shape));
  inst.catchall = (catchall) => inst.clone({ ...inst._zod.def, catchall });
  inst.passthrough = () => inst.clone({ ...inst._zod.def, catchall: unknown() });
  inst.loose = () => inst.clone({ ...inst._zod.def, catchall: unknown() });
  inst.strict = () => inst.clone({ ...inst._zod.def, catchall: never() });
  inst.strip = () => inst.clone({ ...inst._zod.def, catchall: undefined });
  inst.extend = (incoming) => {
    return exports_util2.extend(inst, incoming);
  };
  inst.merge = (other) => exports_util2.merge(inst, other);
  inst.pick = (mask) => exports_util2.pick(inst, mask);
  inst.omit = (mask) => exports_util2.omit(inst, mask);
  inst.partial = (...args) => exports_util2.partial(ZodOptional, inst, args[0]);
  inst.required = (...args) => exports_util2.required(ZodNonOptional, inst, args[0]);
});
function object(shape2, params) {
  const def = {
    type: "object",
    get shape() {
      exports_util2.assignProp(this, "shape", { ...shape2 });
      return this.shape;
    },
    ...exports_util2.normalizeParams(params)
  };
  return new ZodObject(def);
}
function strictObject(shape2, params) {
  return new ZodObject({
    type: "object",
    get shape() {
      exports_util2.assignProp(this, "shape", { ...shape2 });
      return this.shape;
    },
    catchall: never(),
    ...exports_util2.normalizeParams(params)
  });
}
function looseObject(shape2, params) {
  return new ZodObject({
    type: "object",
    get shape() {
      exports_util2.assignProp(this, "shape", { ...shape2 });
      return this.shape;
    },
    catchall: unknown(),
    ...exports_util2.normalizeParams(params)
  });
}
var ZodUnion = /* @__PURE__ */ $constructor("ZodUnion", (inst, def) => {
  $ZodUnion.init(inst, def);
  ZodType.init(inst, def);
  inst.options = def.options;
});
function union(options2, params) {
  return new ZodUnion({
    type: "union",
    options: options2,
    ...exports_util2.normalizeParams(params)
  });
}
var ZodDiscriminatedUnion = /* @__PURE__ */ $constructor("ZodDiscriminatedUnion", (inst, def) => {
  ZodUnion.init(inst, def);
  $ZodDiscriminatedUnion.init(inst, def);
});
function discriminatedUnion(discriminator, options2, params) {
  return new ZodDiscriminatedUnion({
    type: "union",
    options: options2,
    discriminator,
    ...exports_util2.normalizeParams(params)
  });
}
var ZodIntersection = /* @__PURE__ */ $constructor("ZodIntersection", (inst, def) => {
  $ZodIntersection.init(inst, def);
  ZodType.init(inst, def);
});
function intersection(left, right) {
  return new ZodIntersection({
    type: "intersection",
    left,
    right
  });
}
var ZodTuple = /* @__PURE__ */ $constructor("ZodTuple", (inst, def) => {
  $ZodTuple.init(inst, def);
  ZodType.init(inst, def);
  inst.rest = (rest) => inst.clone({
    ...inst._zod.def,
    rest
  });
});
function tuple(items, _paramsOrRest, _params) {
  const hasRest = _paramsOrRest instanceof $ZodType;
  const params = hasRest ? _params : _paramsOrRest;
  const rest = hasRest ? _paramsOrRest : null;
  return new ZodTuple({
    type: "tuple",
    items,
    rest,
    ...exports_util2.normalizeParams(params)
  });
}
var ZodRecord = /* @__PURE__ */ $constructor("ZodRecord", (inst, def) => {
  $ZodRecord.init(inst, def);
  ZodType.init(inst, def);
  inst.keyType = def.keyType;
  inst.valueType = def.valueType;
});
function record(keyType, valueType, params) {
  return new ZodRecord({
    type: "record",
    keyType,
    valueType,
    ...exports_util2.normalizeParams(params)
  });
}
function partialRecord(keyType, valueType, params) {
  return new ZodRecord({
    type: "record",
    keyType: union([keyType, never()]),
    valueType,
    ...exports_util2.normalizeParams(params)
  });
}
var ZodMap = /* @__PURE__ */ $constructor("ZodMap", (inst, def) => {
  $ZodMap.init(inst, def);
  ZodType.init(inst, def);
  inst.keyType = def.keyType;
  inst.valueType = def.valueType;
});
function map2(keyType, valueType, params) {
  return new ZodMap({
    type: "map",
    keyType,
    valueType,
    ...exports_util2.normalizeParams(params)
  });
}
var ZodSet = /* @__PURE__ */ $constructor("ZodSet", (inst, def) => {
  $ZodSet.init(inst, def);
  ZodType.init(inst, def);
  inst.min = (...args) => inst.check(_minSize(...args));
  inst.nonempty = (params) => inst.check(_minSize(1, params));
  inst.max = (...args) => inst.check(_maxSize(...args));
  inst.size = (...args) => inst.check(_size(...args));
});
function set2(valueType, params) {
  return new ZodSet({
    type: "set",
    valueType,
    ...exports_util2.normalizeParams(params)
  });
}
var ZodEnum = /* @__PURE__ */ $constructor("ZodEnum", (inst, def) => {
  $ZodEnum.init(inst, def);
  ZodType.init(inst, def);
  inst.enum = def.entries;
  inst.options = Object.values(def.entries);
  const keys = new Set(Object.keys(def.entries));
  inst.extract = (values, params) => {
    const newEntries = {};
    for (const value of values) {
      if (keys.has(value)) {
        newEntries[value] = def.entries[value];
      } else
        throw new Error(`Key ${value} not found in enum`);
    }
    return new ZodEnum({
      ...def,
      checks: [],
      ...exports_util2.normalizeParams(params),
      entries: newEntries
    });
  };
  inst.exclude = (values, params) => {
    const newEntries = { ...def.entries };
    for (const value of values) {
      if (keys.has(value)) {
        delete newEntries[value];
      } else
        throw new Error(`Key ${value} not found in enum`);
    }
    return new ZodEnum({
      ...def,
      checks: [],
      ...exports_util2.normalizeParams(params),
      entries: newEntries
    });
  };
});
function _enum2(values, params) {
  const entries = Array.isArray(values) ? Object.fromEntries(values.map((v) => [v, v])) : values;
  return new ZodEnum({
    type: "enum",
    entries,
    ...exports_util2.normalizeParams(params)
  });
}
function nativeEnum(entries, params) {
  return new ZodEnum({
    type: "enum",
    entries,
    ...exports_util2.normalizeParams(params)
  });
}
var ZodLiteral = /* @__PURE__ */ $constructor("ZodLiteral", (inst, def) => {
  $ZodLiteral.init(inst, def);
  ZodType.init(inst, def);
  inst.values = new Set(def.values);
  Object.defineProperty(inst, "value", {
    get() {
      if (def.values.length > 1) {
        throw new Error("This schema contains multiple valid literal values. Use `.values` instead.");
      }
      return def.values[0];
    }
  });
});
function literal(value, params) {
  return new ZodLiteral({
    type: "literal",
    values: Array.isArray(value) ? value : [value],
    ...exports_util2.normalizeParams(params)
  });
}
var ZodFile = /* @__PURE__ */ $constructor("ZodFile", (inst, def) => {
  $ZodFile.init(inst, def);
  ZodType.init(inst, def);
  inst.min = (size, params) => inst.check(_minSize(size, params));
  inst.max = (size, params) => inst.check(_maxSize(size, params));
  inst.mime = (types, params) => inst.check(_mime(Array.isArray(types) ? types : [types], params));
});
function file2(params) {
  return _file(ZodFile, params);
}
var ZodTransform = /* @__PURE__ */ $constructor("ZodTransform", (inst, def) => {
  $ZodTransform.init(inst, def);
  ZodType.init(inst, def);
  inst._zod.parse = (payload, _ctx) => {
    payload.addIssue = (issue2) => {
      if (typeof issue2 === "string") {
        payload.issues.push(exports_util2.issue(issue2, payload.value, def));
      } else {
        const _issue = issue2;
        if (_issue.fatal)
          _issue.continue = false;
        _issue.code ?? (_issue.code = "custom");
        _issue.input ?? (_issue.input = payload.value);
        _issue.inst ?? (_issue.inst = inst);
        _issue.continue ?? (_issue.continue = true);
        payload.issues.push(exports_util2.issue(_issue));
      }
    };
    const output2 = def.transform(payload.value, payload);
    if (output2 instanceof Promise) {
      return output2.then((output3) => {
        payload.value = output3;
        return payload;
      });
    }
    payload.value = output2;
    return payload;
  };
});
function transform2(fn2) {
  return new ZodTransform({
    type: "transform",
    transform: fn2
  });
}
var ZodOptional = /* @__PURE__ */ $constructor("ZodOptional", (inst, def) => {
  $ZodOptional.init(inst, def);
  ZodType.init(inst, def);
  inst.unwrap = () => inst._zod.def.innerType;
});
function optional(innerType) {
  return new ZodOptional({
    type: "optional",
    innerType
  });
}
var ZodNullable = /* @__PURE__ */ $constructor("ZodNullable", (inst, def) => {
  $ZodNullable.init(inst, def);
  ZodType.init(inst, def);
  inst.unwrap = () => inst._zod.def.innerType;
});
function nullable(innerType) {
  return new ZodNullable({
    type: "nullable",
    innerType
  });
}
function nullish2(innerType) {
  return optional(nullable(innerType));
}
var ZodDefault = /* @__PURE__ */ $constructor("ZodDefault", (inst, def) => {
  $ZodDefault.init(inst, def);
  ZodType.init(inst, def);
  inst.unwrap = () => inst._zod.def.innerType;
  inst.removeDefault = inst.unwrap;
});
function _default2(innerType, defaultValue) {
  return new ZodDefault({
    type: "default",
    innerType,
    get defaultValue() {
      return typeof defaultValue === "function" ? defaultValue() : defaultValue;
    }
  });
}
var ZodPrefault = /* @__PURE__ */ $constructor("ZodPrefault", (inst, def) => {
  $ZodPrefault.init(inst, def);
  ZodType.init(inst, def);
  inst.unwrap = () => inst._zod.def.innerType;
});
function prefault(innerType, defaultValue) {
  return new ZodPrefault({
    type: "prefault",
    innerType,
    get defaultValue() {
      return typeof defaultValue === "function" ? defaultValue() : defaultValue;
    }
  });
}
var ZodNonOptional = /* @__PURE__ */ $constructor("ZodNonOptional", (inst, def) => {
  $ZodNonOptional.init(inst, def);
  ZodType.init(inst, def);
  inst.unwrap = () => inst._zod.def.innerType;
});
function nonoptional(innerType, params) {
  return new ZodNonOptional({
    type: "nonoptional",
    innerType,
    ...exports_util2.normalizeParams(params)
  });
}
var ZodSuccess = /* @__PURE__ */ $constructor("ZodSuccess", (inst, def) => {
  $ZodSuccess.init(inst, def);
  ZodType.init(inst, def);
  inst.unwrap = () => inst._zod.def.innerType;
});
function success(innerType) {
  return new ZodSuccess({
    type: "success",
    innerType
  });
}
var ZodCatch = /* @__PURE__ */ $constructor("ZodCatch", (inst, def) => {
  $ZodCatch.init(inst, def);
  ZodType.init(inst, def);
  inst.unwrap = () => inst._zod.def.innerType;
  inst.removeCatch = inst.unwrap;
});
function _catch2(innerType, catchValue) {
  return new ZodCatch({
    type: "catch",
    innerType,
    catchValue: typeof catchValue === "function" ? catchValue : () => catchValue
  });
}
var ZodNaN = /* @__PURE__ */ $constructor("ZodNaN", (inst, def) => {
  $ZodNaN.init(inst, def);
  ZodType.init(inst, def);
});
function nan(params) {
  return _nan(ZodNaN, params);
}
var ZodPipe = /* @__PURE__ */ $constructor("ZodPipe", (inst, def) => {
  $ZodPipe.init(inst, def);
  ZodType.init(inst, def);
  inst.in = def.in;
  inst.out = def.out;
});
function pipe(in_, out) {
  return new ZodPipe({
    type: "pipe",
    in: in_,
    out
  });
}
var ZodReadonly = /* @__PURE__ */ $constructor("ZodReadonly", (inst, def) => {
  $ZodReadonly.init(inst, def);
  ZodType.init(inst, def);
});
function readonly(innerType) {
  return new ZodReadonly({
    type: "readonly",
    innerType
  });
}
var ZodTemplateLiteral = /* @__PURE__ */ $constructor("ZodTemplateLiteral", (inst, def) => {
  $ZodTemplateLiteral.init(inst, def);
  ZodType.init(inst, def);
});
function templateLiteral(parts, params) {
  return new ZodTemplateLiteral({
    type: "template_literal",
    parts,
    ...exports_util2.normalizeParams(params)
  });
}
var ZodLazy = /* @__PURE__ */ $constructor("ZodLazy", (inst, def) => {
  $ZodLazy.init(inst, def);
  ZodType.init(inst, def);
  inst.unwrap = () => inst._zod.def.getter();
});
function lazy(getter) {
  return new ZodLazy({
    type: "lazy",
    getter
  });
}
var ZodPromise = /* @__PURE__ */ $constructor("ZodPromise", (inst, def) => {
  $ZodPromise.init(inst, def);
  ZodType.init(inst, def);
  inst.unwrap = () => inst._zod.def.innerType;
});
function promise(innerType) {
  return new ZodPromise({
    type: "promise",
    innerType
  });
}
var ZodCustom = /* @__PURE__ */ $constructor("ZodCustom", (inst, def) => {
  $ZodCustom.init(inst, def);
  ZodType.init(inst, def);
});
function check(fn2) {
  const ch = new $ZodCheck({
    check: "custom"
  });
  ch._zod.check = fn2;
  return ch;
}
function custom(fn2, _params) {
  return _custom(ZodCustom, fn2 ?? (() => true), _params);
}
function refine(fn2, _params = {}) {
  return _refine(ZodCustom, fn2, _params);
}
function superRefine(fn2) {
  const ch = check((payload) => {
    payload.addIssue = (issue2) => {
      if (typeof issue2 === "string") {
        payload.issues.push(exports_util2.issue(issue2, payload.value, ch._zod.def));
      } else {
        const _issue = issue2;
        if (_issue.fatal)
          _issue.continue = false;
        _issue.code ?? (_issue.code = "custom");
        _issue.input ?? (_issue.input = payload.value);
        _issue.inst ?? (_issue.inst = ch);
        _issue.continue ?? (_issue.continue = !ch._zod.def.abort);
        payload.issues.push(exports_util2.issue(_issue));
      }
    };
    return fn2(payload.value, payload);
  });
  return ch;
}
function _instanceof(cls, params = {
  error: `Input not instance of ${cls.name}`
}) {
  const inst = new ZodCustom({
    type: "custom",
    check: "custom",
    fn: (data) => data instanceof cls,
    abort: true,
    ...exports_util2.normalizeParams(params)
  });
  inst._zod.bag.Class = cls;
  return inst;
}
var stringbool = (...args) => _stringbool({
  Pipe: ZodPipe,
  Boolean: ZodBoolean,
  String: ZodString,
  Transform: ZodTransform
}, ...args);
function json(params) {
  const jsonSchema = lazy(() => {
    return union([string2(params), number2(), boolean2(), _null3(), array(jsonSchema), record(string2(), jsonSchema)]);
  });
  return jsonSchema;
}
function preprocess(fn2, schema) {
  return pipe(transform2(fn2), schema);
}
// node_modules/zod/v4/classic/compat.js
var ZodIssueCode = {
  invalid_type: "invalid_type",
  too_big: "too_big",
  too_small: "too_small",
  invalid_format: "invalid_format",
  not_multiple_of: "not_multiple_of",
  unrecognized_keys: "unrecognized_keys",
  invalid_union: "invalid_union",
  invalid_key: "invalid_key",
  invalid_element: "invalid_element",
  invalid_value: "invalid_value",
  custom: "custom"
};
function setErrorMap(map3) {
  config({
    customError: map3
  });
}
function getErrorMap() {
  return config().customError;
}
// node_modules/zod/v4/classic/coerce.js
var exports_coerce = {};
__export(exports_coerce, {
  string: () => string3,
  number: () => number3,
  date: () => date4,
  boolean: () => boolean3,
  bigint: () => bigint3
});
function string3(params) {
  return _coercedString(ZodString, params);
}
function number3(params) {
  return _coercedNumber(ZodNumber, params);
}
function boolean3(params) {
  return _coercedBoolean(ZodBoolean, params);
}
function bigint3(params) {
  return _coercedBigint(ZodBigInt, params);
}
function date4(params) {
  return _coercedDate(ZodDate, params);
}

// node_modules/zod/v4/classic/external.js
config(en_default());
// node_modules/p5/dist/core/friendly_errors/param_validator.js
var p5$1 = {
  describe: {
    overloads: [
      [
        "String",
        "FALLBACK|LABEL?"
      ]
    ]
  },
  describeElement: {
    overloads: [
      [
        "String",
        "String",
        "FALLBACK|LABEL?"
      ]
    ]
  },
  textOutput: {
    overloads: [
      [
        "FALLBACK|LABEL?"
      ]
    ]
  },
  gridOutput: {
    overloads: [
      [
        "FALLBACK|LABEL?"
      ]
    ]
  },
  remove: {
    overloads: [
      []
    ]
  },
  p5: {
    overloads: [
      [
        "Object",
        "String|HTMLElement"
      ]
    ]
  },
  color: {
    overloads: [
      [
        "Number",
        "Number?"
      ],
      [
        "Number",
        "Number",
        "Number",
        "Number?"
      ],
      [
        "String"
      ],
      [
        "Number[]"
      ],
      [
        "p5.Color"
      ]
    ]
  },
  red: {
    overloads: [
      [
        "p5.Color|Number[]|String"
      ]
    ]
  },
  green: {
    overloads: [
      [
        "p5.Color|Number[]|String"
      ]
    ]
  },
  blue: {
    overloads: [
      [
        "p5.Color|Number[]|String"
      ]
    ]
  },
  alpha: {
    overloads: [
      [
        "p5.Color|Number[]|String"
      ]
    ]
  },
  hue: {
    overloads: [
      [
        "p5.Color|Number[]|String"
      ]
    ]
  },
  saturation: {
    overloads: [
      [
        "p5.Color|Number[]|String"
      ]
    ]
  },
  brightness: {
    overloads: [
      [
        "p5.Color|Number[]|String"
      ]
    ]
  },
  lightness: {
    overloads: [
      [
        "p5.Color|Number[]|String"
      ]
    ]
  },
  lerpColor: {
    overloads: [
      [
        "p5.Color",
        "p5.Color",
        "Number"
      ]
    ]
  },
  paletteLerp: {
    overloads: [
      [
        "[p5.Color|String|Number|Number[], Number][]",
        "Number"
      ]
    ]
  },
  beginClip: {
    overloads: [
      [
        "Object?"
      ]
    ]
  },
  endClip: {
    overloads: [
      []
    ]
  },
  clip: {
    overloads: [
      [
        "Function",
        "Object?"
      ]
    ]
  },
  background: {
    overloads: [
      [
        "p5.Color"
      ],
      [
        "String",
        "Number?"
      ],
      [
        "Number",
        "Number?"
      ],
      [
        "Number",
        "Number",
        "Number",
        "Number?"
      ],
      [
        "Number[]"
      ],
      [
        "p5.Image",
        "Number?"
      ]
    ]
  },
  clear: {
    overloads: [
      [
        "Number?",
        "Number?",
        "Number?",
        "Number?"
      ],
      []
    ]
  },
  colorMode: {
    overloads: [
      [
        "RGB|HSB|HSL|RGBHDR|HWB|LAB|LCH|OKLAB|OKLCH",
        "Number?"
      ],
      [
        "RGB|HSB|HSL|RGBHDR|HWB|LAB|LCH|OKLAB|OKLCH",
        "Number",
        "Number",
        "Number",
        "Number?"
      ],
      []
    ]
  },
  fill: {
    overloads: [
      [
        "Number",
        "Number",
        "Number",
        "Number?"
      ],
      [
        "String"
      ],
      [
        "Number",
        "Number?"
      ],
      [
        "Number[]"
      ],
      [
        "p5.Color"
      ]
    ]
  },
  noFill: {
    overloads: [
      []
    ]
  },
  noStroke: {
    overloads: [
      []
    ]
  },
  stroke: {
    overloads: [
      [
        "Number",
        "Number",
        "Number",
        "Number?"
      ],
      [
        "String"
      ],
      [
        "Number",
        "Number?"
      ],
      [
        "Number[]"
      ],
      [
        "p5.Color"
      ]
    ]
  },
  erase: {
    overloads: [
      [
        "Number?",
        "Number?"
      ]
    ]
  },
  noErase: {
    overloads: [
      []
    ]
  },
  blendMode: {
    overloads: [
      [
        "BLEND|DARKEST|LIGHTEST|DIFFERENCE|MULTIPLY|EXCLUSION|SCREEN|REPLACE|OVERLAY|HARD_LIGHT|SOFT_LIGHT|DODGE|BURN|ADD|REMOVE|SUBTRACT"
      ]
    ]
  },
  print: {
    overloads: [
      [
        "Any"
      ],
      [
        "String|Number|Array"
      ]
    ]
  },
  cursor: {
    overloads: [
      [
        "ARROW|CROSS|HAND|MOVE|TEXT|WAIT|String",
        "Number?",
        "Number?"
      ]
    ]
  },
  frameRate: {
    overloads: [
      [
        "Number"
      ],
      []
    ]
  },
  getTargetFrameRate: {
    overloads: [
      []
    ]
  },
  noCursor: {
    overloads: [
      []
    ]
  },
  windowResized: {
    overloads: [
      [
        "Event?"
      ]
    ]
  },
  fullscreen: {
    overloads: [
      [
        "Boolean?"
      ]
    ]
  },
  pixelDensity: {
    overloads: [
      [
        "Number?"
      ],
      []
    ]
  },
  displayDensity: {
    overloads: [
      []
    ]
  },
  getURL: {
    overloads: [
      []
    ]
  },
  getURLPath: {
    overloads: [
      []
    ]
  },
  getURLParams: {
    overloads: [
      []
    ]
  },
  worldToScreen: {
    overloads: [
      [
        "Number|p5.Vector",
        "Number",
        "Number?"
      ]
    ]
  },
  screenToWorld: {
    overloads: [
      [
        "Number|p5.Vector",
        "Number",
        "Number?"
      ]
    ]
  },
  setup: {
    overloads: [
      []
    ]
  },
  draw: {
    overloads: [
      []
    ]
  },
  registerAddon: {
    overloads: [
      [
        "Function"
      ]
    ]
  },
  createCanvas: {
    overloads: [
      [
        "Number?",
        "Number?",
        "P2D|WEBGL|P2DHDR?",
        "HTMLCanvasElement?"
      ],
      [
        "Number?",
        "Number?",
        "HTMLCanvasElement?"
      ]
    ]
  },
  resizeCanvas: {
    overloads: [
      [
        "Number",
        "Number",
        "Boolean?"
      ]
    ]
  },
  noCanvas: {
    overloads: [
      []
    ]
  },
  createGraphics: {
    overloads: [
      [
        "Number",
        "Number",
        "P2D|WEBGL?",
        "HTMLCanvasElement?"
      ],
      [
        "Number",
        "Number",
        "HTMLCanvasElement?"
      ]
    ]
  },
  createFramebuffer: {
    overloads: [
      [
        "Object?"
      ]
    ]
  },
  clearDepth: {
    overloads: [
      [
        "Number?"
      ]
    ]
  },
  noLoop: {
    overloads: [
      []
    ]
  },
  loop: {
    overloads: [
      []
    ]
  },
  isLooping: {
    overloads: [
      []
    ]
  },
  redraw: {
    overloads: [
      [
        "Integer?"
      ]
    ]
  },
  applyMatrix: {
    overloads: [
      [
        "Number[]"
      ],
      [
        "Number",
        "Number",
        "Number",
        "Number",
        "Number",
        "Number"
      ],
      [
        "Number",
        "Number",
        "Number",
        "Number",
        "Number",
        "Number",
        "Number",
        "Number",
        "Number",
        "Number",
        "Number",
        "Number",
        "Number",
        "Number",
        "Number",
        "Number"
      ]
    ]
  },
  resetMatrix: {
    overloads: [
      []
    ]
  },
  rotate: {
    overloads: [
      [
        "Number",
        "p5.Vector|Number[]?"
      ]
    ]
  },
  rotateX: {
    overloads: [
      [
        "Number"
      ]
    ]
  },
  rotateY: {
    overloads: [
      [
        "Number"
      ]
    ]
  },
  rotateZ: {
    overloads: [
      [
        "Number"
      ]
    ]
  },
  scale: {
    overloads: [
      [
        "Number|p5.Vector|Number[]",
        "Number?",
        "Number?"
      ],
      [
        "p5.Vector|Number[]"
      ]
    ]
  },
  shearX: {
    overloads: [
      [
        "Number"
      ]
    ]
  },
  shearY: {
    overloads: [
      [
        "Number"
      ]
    ]
  },
  translate: {
    overloads: [
      [
        "Number",
        "Number",
        "Number?"
      ],
      [
        "p5.Vector"
      ]
    ]
  },
  push: {
    overloads: [
      []
    ]
  },
  pop: {
    overloads: [
      []
    ]
  },
  storeItem: {
    overloads: [
      [
        "String",
        "String|Number|Boolean|Object|Array"
      ]
    ]
  },
  getItem: {
    overloads: [
      [
        "String"
      ]
    ]
  },
  clearStorage: {
    overloads: [
      []
    ]
  },
  removeItem: {
    overloads: [
      [
        "String"
      ]
    ]
  },
  select: {
    overloads: [
      [
        "String",
        "String|p5.Element|HTMLElement?"
      ]
    ]
  },
  selectAll: {
    overloads: [
      [
        "String",
        "String|p5.Element|HTMLElement?"
      ]
    ]
  },
  createElement: {
    overloads: [
      [
        "String",
        "String?"
      ]
    ]
  },
  removeElements: {
    overloads: [
      []
    ]
  },
  addElement: {
    overloads: [
      []
    ]
  },
  createDiv: {
    overloads: [
      [
        "String?"
      ]
    ]
  },
  createP: {
    overloads: [
      [
        "String?"
      ]
    ]
  },
  createSpan: {
    overloads: [
      [
        "String?"
      ]
    ]
  },
  createImg: {
    overloads: [
      [
        "String",
        "String"
      ],
      [
        "String",
        "String",
        "String?",
        "Function?"
      ]
    ]
  },
  createA: {
    overloads: [
      [
        "String",
        "String",
        "String?"
      ]
    ]
  },
  createSlider: {
    overloads: [
      [
        "Number",
        "Number",
        "Number?",
        "Number?"
      ]
    ]
  },
  createButton: {
    overloads: [
      [
        "String",
        "String?"
      ]
    ]
  },
  createCheckbox: {
    overloads: [
      [
        "String?",
        "Boolean?"
      ]
    ]
  },
  createSelect: {
    overloads: [
      [
        "Boolean?"
      ],
      [
        "Object"
      ]
    ]
  },
  createRadio: {
    overloads: [
      [
        "Object?"
      ],
      [
        "String?"
      ],
      []
    ]
  },
  createColorPicker: {
    overloads: [
      [
        "String|p5.Color?"
      ]
    ]
  },
  createInput: {
    overloads: [
      [
        "String?",
        "String?"
      ],
      [
        "String?"
      ]
    ]
  },
  createFileInput: {
    overloads: [
      [
        "Function",
        "Boolean?"
      ]
    ]
  },
  createVideo: {
    overloads: [
      [
        "String|String[]?",
        "Function?"
      ]
    ]
  },
  createAudio: {
    overloads: [
      [
        "String|String[]?",
        "Function?"
      ]
    ]
  },
  createCapture: {
    overloads: [
      [
        "AUDIO|VIDEO|Object?",
        "Object?",
        "Function?"
      ]
    ]
  },
  setMoveThreshold: {
    overloads: [
      [
        "Number"
      ]
    ]
  },
  setShakeThreshold: {
    overloads: [
      [
        "Number"
      ]
    ]
  },
  deviceMoved: {
    overloads: [
      []
    ]
  },
  deviceTurned: {
    overloads: [
      []
    ]
  },
  deviceShaken: {
    overloads: [
      []
    ]
  },
  keyPressed: {
    overloads: [
      [
        "KeyboardEvent?"
      ]
    ]
  },
  keyReleased: {
    overloads: [
      [
        "KeyboardEvent?"
      ]
    ]
  },
  keyTyped: {
    overloads: [
      [
        "KeyboardEvent?"
      ]
    ]
  },
  keyIsDown: {
    overloads: [
      [
        "Number|String"
      ]
    ]
  },
  mouseMoved: {
    overloads: [
      [
        "MouseEvent?"
      ]
    ]
  },
  mouseDragged: {
    overloads: [
      [
        "MouseEvent?"
      ]
    ]
  },
  mousePressed: {
    overloads: [
      [
        "MouseEvent?"
      ]
    ]
  },
  mouseReleased: {
    overloads: [
      [
        "MouseEvent?"
      ]
    ]
  },
  mouseClicked: {
    overloads: [
      [
        "MouseEvent?"
      ]
    ]
  },
  doubleClicked: {
    overloads: [
      [
        "MouseEvent?"
      ]
    ]
  },
  mouseWheel: {
    overloads: [
      [
        "WheelEvent?"
      ]
    ]
  },
  requestPointerLock: {
    overloads: [
      []
    ]
  },
  exitPointerLock: {
    overloads: [
      []
    ]
  },
  createImage: {
    overloads: [
      [
        "Integer",
        "Integer"
      ]
    ]
  },
  saveCanvas: {
    overloads: [
      [
        "p5.Framebuffer|p5.Element|HTMLCanvasElement",
        "String?",
        "String?"
      ],
      [
        "String?",
        "String?"
      ]
    ]
  },
  saveFrames: {
    overloads: [
      [
        "String",
        "String",
        "Number",
        "Number",
        "function(Array)?"
      ]
    ]
  },
  loadImage: {
    overloads: [
      [
        "String|Request",
        "function(p5.Image)?",
        "function(Event)?"
      ]
    ]
  },
  saveGif: {
    overloads: [
      [
        "String",
        "Number",
        "Object?"
      ]
    ]
  },
  image: {
    overloads: [
      [
        "p5.Image|p5.Element|p5.Texture|p5.Framebuffer|p5.FramebufferTexture|p5.Renderer|p5.Graphics",
        "Number",
        "Number",
        "Number?",
        "Number?"
      ],
      [
        "p5.Image|p5.Element|p5.Texture|p5.Framebuffer|p5.FramebufferTexture",
        "Number",
        "Number",
        "Number",
        "Number",
        "Number",
        "Number",
        "Number?",
        "Number?",
        "CONTAIN|COVER?",
        "LEFT|RIGHT|CENTER?",
        "TOP|BOTTOM|CENTER?"
      ]
    ]
  },
  tint: {
    overloads: [
      [
        "Number",
        "Number",
        "Number",
        "Number?"
      ],
      [
        "String"
      ],
      [
        "Number",
        "Number?"
      ],
      [
        "Number[]"
      ],
      [
        "p5.Color"
      ]
    ]
  },
  noTint: {
    overloads: [
      []
    ]
  },
  imageMode: {
    overloads: [
      [
        "CORNER|CORNERS|CENTER"
      ]
    ]
  },
  blend: {
    overloads: [
      [
        "p5.Image",
        "Integer",
        "Integer",
        "Integer",
        "Integer",
        "Integer",
        "Integer",
        "Integer",
        "Integer",
        "BLEND|DARKEST|LIGHTEST|DIFFERENCE|MULTIPLY|EXCLUSION|SCREEN|REPLACE|OVERLAY|HARD_LIGHT|SOFT_LIGHT|DODGE|BURN|ADD|NORMAL"
      ],
      [
        "Integer",
        "Integer",
        "Integer",
        "Integer",
        "Integer",
        "Integer",
        "Integer",
        "Integer",
        "BLEND|DARKEST|LIGHTEST|DIFFERENCE|MULTIPLY|EXCLUSION|SCREEN|REPLACE|OVERLAY|HARD_LIGHT|SOFT_LIGHT|DODGE|BURN|ADD|NORMAL"
      ]
    ]
  },
  copy: {
    overloads: [
      [
        "p5.Image|p5.Element",
        "Integer",
        "Integer",
        "Integer",
        "Integer",
        "Integer",
        "Integer",
        "Integer",
        "Integer"
      ],
      [
        "Integer",
        "Integer",
        "Integer",
        "Integer",
        "Integer",
        "Integer",
        "Integer",
        "Integer"
      ]
    ]
  },
  filter: {
    overloads: [
      [
        "THRESHOLD|GRAY|OPAQUE|INVERT|POSTERIZE|BLUR|ERODE|DILATE|BLUR",
        "Number?",
        "Boolean?"
      ],
      [
        "p5.Shader"
      ]
    ]
  },
  get: {
    overloads: [
      [
        "Number",
        "Number",
        "Number",
        "Number"
      ],
      [],
      [
        "Number",
        "Number"
      ]
    ]
  },
  loadPixels: {
    overloads: [
      []
    ]
  },
  set: {
    overloads: [
      [
        "Number",
        "Number",
        "Number|Number[]|Object"
      ]
    ]
  },
  updatePixels: {
    overloads: [
      [
        "Number?",
        "Number?",
        "Number?",
        "Number?"
      ],
      []
    ]
  },
  loadJSON: {
    overloads: [
      [
        "String|Request",
        "Function?",
        "Function?"
      ]
    ]
  },
  loadStrings: {
    overloads: [
      [
        "String|Request",
        "Function?",
        "Function?"
      ]
    ]
  },
  loadTable: {
    overloads: [
      [
        "String|Request",
        "String?",
        "String?",
        "Function?",
        "Function?"
      ]
    ]
  },
  loadXML: {
    overloads: [
      [
        "String|Request",
        "Function?",
        "Function?"
      ]
    ]
  },
  loadBytes: {
    overloads: [
      [
        "String|Request",
        "Function?",
        "Function?"
      ]
    ]
  },
  loadBlob: {
    overloads: [
      [
        "String|Request",
        "Function?",
        "Function?"
      ]
    ]
  },
  httpGet: {
    overloads: [
      [
        "String|Request",
        "String?",
        "Function?",
        "Function?"
      ],
      [
        "String|Request",
        "Function",
        "Function?"
      ]
    ]
  },
  httpPost: {
    overloads: [
      [
        "String|Request",
        "Object|Boolean?",
        "String?",
        "Function?",
        "Function?"
      ],
      [
        "String|Request",
        "Object|Boolean",
        "Function?",
        "Function?"
      ],
      [
        "String|Request",
        "Function?",
        "Function?"
      ]
    ]
  },
  httpDo: {
    overloads: [
      [
        "String|Request",
        "String?",
        "String?",
        "Object?",
        "Function?",
        "Function?"
      ],
      [
        "String|Request",
        "Function?",
        "Function?"
      ]
    ]
  },
  createWriter: {
    overloads: [
      [
        "String",
        "String?"
      ]
    ]
  },
  write: {
    overloads: [
      [
        "String|Number|Array"
      ]
    ]
  },
  close: {
    overloads: [
      []
    ]
  },
  save: {
    overloads: [
      [
        "Object|String?",
        "String?",
        "Boolean|String?"
      ]
    ]
  },
  saveJSON: {
    overloads: [
      [
        "Array|Object",
        "String",
        "Boolean?"
      ]
    ]
  },
  saveStrings: {
    overloads: [
      [
        "String[]",
        "String",
        "String?",
        "Boolean?"
      ]
    ]
  },
  saveTable: {
    overloads: [
      [
        "p5.Table",
        "String",
        "String?"
      ]
    ]
  },
  setContent: {
    overloads: [
      [
        "String"
      ]
    ]
  },
  abs: {
    overloads: [
      [
        "Number"
      ]
    ]
  },
  ceil: {
    overloads: [
      [
        "Number"
      ]
    ]
  },
  constrain: {
    overloads: [
      [
        "Number",
        "Number",
        "Number"
      ]
    ]
  },
  dist: {
    overloads: [
      [
        "Number",
        "Number",
        "Number",
        "Number"
      ],
      [
        "Number",
        "Number",
        "Number",
        "Number",
        "Number",
        "Number"
      ]
    ]
  },
  exp: {
    overloads: [
      [
        "Number"
      ]
    ]
  },
  floor: {
    overloads: [
      [
        "Number"
      ]
    ]
  },
  lerp: {
    overloads: [
      [
        "Number",
        "Number",
        "Number"
      ]
    ]
  },
  log: {
    overloads: [
      [
        "Number"
      ]
    ]
  },
  mag: {
    overloads: [
      [
        "Number",
        "Number"
      ]
    ]
  },
  map: {
    overloads: [
      [
        "Number",
        "Number",
        "Number",
        "Number",
        "Number",
        "Boolean?"
      ]
    ]
  },
  max: {
    overloads: [
      [
        "Number",
        "Number"
      ],
      [
        "Number[]"
      ]
    ]
  },
  min: {
    overloads: [
      [
        "Number",
        "Number"
      ],
      [
        "Number[]"
      ]
    ]
  },
  norm: {
    overloads: [
      [
        "Number",
        "Number",
        "Number"
      ]
    ]
  },
  pow: {
    overloads: [
      [
        "Number",
        "Number"
      ]
    ]
  },
  round: {
    overloads: [
      [
        "Number",
        "Number?"
      ]
    ]
  },
  sq: {
    overloads: [
      [
        "Number"
      ]
    ]
  },
  sqrt: {
    overloads: [
      [
        "Number"
      ]
    ]
  },
  fract: {
    overloads: [
      [
        "Number"
      ]
    ]
  },
  createVector: {
    overloads: [
      [
        "...Number[]"
      ]
    ]
  },
  noise: {
    overloads: [
      [
        "Number",
        "Number?",
        "Number?"
      ]
    ]
  },
  noiseDetail: {
    overloads: [
      [
        "Number",
        "Number"
      ]
    ]
  },
  noiseSeed: {
    overloads: [
      [
        "Number"
      ]
    ]
  },
  randomSeed: {
    overloads: [
      [
        "Number"
      ]
    ]
  },
  random: {
    overloads: [
      [
        "Number?",
        "Number?"
      ],
      [
        "Array"
      ]
    ]
  },
  randomGaussian: {
    overloads: [
      [
        "Number?",
        "Number?"
      ]
    ]
  },
  acos: {
    overloads: [
      [
        "Number"
      ]
    ]
  },
  asin: {
    overloads: [
      [
        "Number"
      ]
    ]
  },
  atan: {
    overloads: [
      [
        "Number"
      ]
    ]
  },
  atan2: {
    overloads: [
      [
        "Number",
        "Number"
      ]
    ]
  },
  cos: {
    overloads: [
      [
        "Number"
      ]
    ]
  },
  sin: {
    overloads: [
      [
        "Number"
      ]
    ]
  },
  tan: {
    overloads: [
      [
        "Number"
      ]
    ]
  },
  degrees: {
    overloads: [
      [
        "Number"
      ]
    ]
  },
  radians: {
    overloads: [
      [
        "Number"
      ]
    ]
  },
  angleMode: {
    overloads: [
      [
        "RADIANS|DEGREES"
      ],
      []
    ]
  },
  arc: {
    overloads: [
      [
        "Number",
        "Number",
        "Number",
        "Number",
        "Number",
        "Number",
        "CHORD|PIE|OPEN?",
        "Integer?"
      ]
    ]
  },
  ellipse: {
    overloads: [
      [
        "Number",
        "Number",
        "Number",
        "Number?"
      ],
      [
        "Number",
        "Number",
        "Number",
        "Number",
        "Integer?"
      ]
    ]
  },
  circle: {
    overloads: [
      [
        "Number",
        "Number",
        "Number"
      ]
    ]
  },
  line: {
    overloads: [
      [
        "Number",
        "Number",
        "Number",
        "Number"
      ],
      [
        "Number",
        "Number",
        "Number",
        "Number",
        "Number",
        "Number"
      ]
    ]
  },
  point: {
    overloads: [
      [
        "Number",
        "Number",
        "Number?"
      ],
      [
        "p5.Vector"
      ]
    ]
  },
  quad: {
    overloads: [
      [
        "Number",
        "Number",
        "Number",
        "Number",
        "Number",
        "Number",
        "Number",
        "Number",
        "Integer?",
        "Integer?"
      ],
      [
        "Number",
        "Number",
        "Number",
        "Number",
        "Number",
        "Number",
        "Number",
        "Number",
        "Number",
        "Number",
        "Number",
        "Number",
        "Integer?",
        "Integer?"
      ]
    ]
  },
  rect: {
    overloads: [
      [
        "Number",
        "Number",
        "Number",
        "Number?",
        "Number?",
        "Number?",
        "Number?",
        "Number?"
      ],
      [
        "Number",
        "Number",
        "Number",
        "Number",
        "Integer?",
        "Integer?"
      ]
    ]
  },
  square: {
    overloads: [
      [
        "Number",
        "Number",
        "Number",
        "Number?",
        "Number?",
        "Number?",
        "Number?"
      ]
    ]
  },
  triangle: {
    overloads: [
      [
        "Number",
        "Number",
        "Number",
        "Number",
        "Number",
        "Number"
      ]
    ]
  },
  ellipseMode: {
    overloads: [
      [
        "CENTER|RADIUS|CORNER|CORNERS"
      ]
    ]
  },
  noSmooth: {
    overloads: [
      []
    ]
  },
  rectMode: {
    overloads: [
      [
        "CENTER|RADIUS|CORNER|CORNERS"
      ]
    ]
  },
  smooth: {
    overloads: [
      []
    ]
  },
  strokeCap: {
    overloads: [
      [
        "ROUND|SQUARE|PROJECT"
      ]
    ]
  },
  strokeJoin: {
    overloads: [
      [
        "MITER|BEVEL|ROUND"
      ]
    ]
  },
  strokeWeight: {
    overloads: [
      [
        "Number"
      ]
    ]
  },
  bezier: {
    overloads: [
      [
        "Number",
        "Number",
        "Number",
        "Number",
        "Number",
        "Number",
        "Number",
        "Number"
      ],
      [
        "Number",
        "Number",
        "Number",
        "Number",
        "Number",
        "Number",
        "Number",
        "Number",
        "Number",
        "Number",
        "Number",
        "Number"
      ]
    ]
  },
  bezierPoint: {
    overloads: [
      [
        "Number",
        "Number",
        "Number",
        "Number",
        "Number"
      ]
    ]
  },
  bezierTangent: {
    overloads: [
      [
        "Number",
        "Number",
        "Number",
        "Number",
        "Number"
      ]
    ]
  },
  spline: {
    overloads: [
      [
        "Number",
        "Number",
        "Number",
        "Number",
        "Number",
        "Number",
        "Number",
        "Number"
      ],
      [
        "Number",
        "Number",
        "Number",
        "Number",
        "Number",
        "Number",
        "Number",
        "Number",
        "Number",
        "Number",
        "Number",
        "Number"
      ]
    ]
  },
  splinePoint: {
    overloads: [
      [
        "Number",
        "Number",
        "Number",
        "Number",
        "Number"
      ]
    ]
  },
  splineTangent: {
    overloads: [
      [
        "Number",
        "Number",
        "Number",
        "Number",
        "Number"
      ]
    ]
  },
  bezierOrder: {
    overloads: [
      [
        "Number"
      ],
      []
    ]
  },
  splineVertex: {
    overloads: [
      [
        "Number",
        "Number"
      ],
      [
        "Number",
        "Number",
        "Number?"
      ],
      [
        "Number",
        "Number",
        "Number?",
        "Number?"
      ],
      [
        "Number",
        "Number",
        "Number",
        "Number?",
        "Number?"
      ]
    ]
  },
  splineProperty: {
    overloads: [
      [
        "String",
        null
      ],
      [
        "String"
      ]
    ]
  },
  splineProperties: {
    overloads: [
      [
        "Object"
      ],
      []
    ]
  },
  vertex: {
    overloads: [
      [
        "Number",
        "Number"
      ],
      [
        "Number",
        "Number",
        "Number?",
        "Number?"
      ],
      [
        "Number",
        "Number",
        "Number",
        "Number?",
        "Number?"
      ]
    ]
  },
  beginContour: {
    overloads: [
      []
    ]
  },
  endContour: {
    overloads: [
      [
        "OPEN|CLOSE?"
      ]
    ]
  },
  beginShape: {
    overloads: [
      [
        "POINTS|LINES|TRIANGLES|TRIANGLE_FAN|TRIANGLE_STRIP|QUADS|QUAD_STRIP|PATH?"
      ]
    ]
  },
  bezierVertex: {
    overloads: [
      [
        "Number",
        "Number",
        "Number?",
        "Number?"
      ],
      [
        "Number",
        "Number",
        "Number",
        "Number?",
        "Number?"
      ]
    ]
  },
  endShape: {
    overloads: [
      [
        "CLOSE?",
        "Integer?"
      ]
    ]
  },
  normal: {
    overloads: [
      [
        "p5.Vector"
      ],
      [
        "Number",
        "Number",
        "Number"
      ]
    ]
  },
  vertexProperty: {
    overloads: [
      [
        "String",
        "Number|Number[]"
      ]
    ]
  },
  getWorldInputs: {
    overloads: [
      [
        "Function"
      ]
    ]
  },
  combineColors: {
    overloads: [
      [
        "Function"
      ]
    ]
  },
  getPixelInputs: {
    overloads: [
      [
        "Function"
      ]
    ]
  },
  getFinalColor: {
    overloads: [
      [
        "Function"
      ]
    ]
  },
  getColor: {
    overloads: [
      [
        "Function"
      ]
    ]
  },
  getObjectInputs: {
    overloads: [
      [
        "Function"
      ]
    ]
  },
  getCameraInputs: {
    overloads: [
      [
        "Function"
      ]
    ]
  },
  loadFont: {
    overloads: [
      [
        "String",
        "String?",
        "Object?",
        "Function?",
        "Function?"
      ],
      [
        "String",
        "Function?",
        "Function?"
      ]
    ]
  },
  text: {
    overloads: [
      [
        "String|Object|Array|Number|Boolean",
        "Number",
        "Number",
        "Number?",
        "Number?"
      ]
    ]
  },
  textAlign: {
    overloads: [
      [
        "LEFT|CENTER|RIGHT?",
        "TOP|BOTTOM|CENTER|BASELINE?"
      ]
    ]
  },
  textAscent: {
    overloads: [
      [
        "String?"
      ]
    ]
  },
  textDescent: {
    overloads: [
      [
        "String?"
      ]
    ]
  },
  textLeading: {
    overloads: [
      [
        "Number?"
      ]
    ]
  },
  textFont: {
    overloads: [
      [
        "p5.Font|String|Object?",
        "Number?"
      ]
    ]
  },
  textSize: {
    overloads: [
      [
        "Number"
      ],
      []
    ]
  },
  textStyle: {
    overloads: [
      [
        "NORMAL|ITALIC|BOLD|BOLDITALIC"
      ],
      []
    ]
  },
  textWidth: {
    overloads: [
      [
        "String"
      ]
    ]
  },
  textWrap: {
    overloads: [
      [
        "WORD|CHAR"
      ],
      []
    ]
  },
  textBounds: {
    overloads: [
      [
        "String",
        "Number",
        "Number",
        "Number?",
        "Number?"
      ]
    ]
  },
  textDirection: {
    overloads: [
      [
        "String"
      ],
      []
    ]
  },
  textProperty: {
    overloads: [
      [
        "String",
        null
      ],
      [
        "String"
      ]
    ]
  },
  textProperties: {
    overloads: [
      [
        "Object"
      ],
      []
    ]
  },
  fontBounds: {
    overloads: [
      [
        "String",
        "Number",
        "Number",
        "Number?",
        "Number?"
      ]
    ]
  },
  fontWidth: {
    overloads: [
      [
        "String"
      ]
    ]
  },
  fontAscent: {
    overloads: [
      []
    ]
  },
  fontDescent: {
    overloads: [
      []
    ]
  },
  textWeight: {
    overloads: [
      [
        "Number"
      ],
      []
    ]
  },
  float: {
    overloads: [
      [
        "String"
      ],
      [
        "String[]"
      ]
    ]
  },
  int: {
    overloads: [
      [
        "String|Boolean|Number"
      ],
      [
        "Array"
      ]
    ]
  },
  str: {
    overloads: [
      [
        "String|Boolean|Number"
      ]
    ]
  },
  boolean: {
    overloads: [
      [
        "String|Boolean|Number"
      ],
      [
        "Array"
      ]
    ]
  },
  byte: {
    overloads: [
      [
        "String|Boolean|Number"
      ],
      [
        "Array"
      ]
    ]
  },
  char: {
    overloads: [
      [
        "String|Number"
      ],
      [
        "Array"
      ]
    ]
  },
  unchar: {
    overloads: [
      [
        "String"
      ],
      [
        "String[]"
      ]
    ]
  },
  hex: {
    overloads: [
      [
        "Number",
        "Number?"
      ],
      [
        "Number[]",
        "Number?"
      ]
    ]
  },
  unhex: {
    overloads: [
      [
        "String"
      ],
      [
        "String[]"
      ]
    ]
  },
  day: {
    overloads: [
      []
    ]
  },
  hour: {
    overloads: [
      []
    ]
  },
  minute: {
    overloads: [
      []
    ]
  },
  millis: {
    overloads: [
      []
    ]
  },
  month: {
    overloads: [
      []
    ]
  },
  second: {
    overloads: [
      []
    ]
  },
  year: {
    overloads: [
      []
    ]
  },
  nf: {
    overloads: [
      [
        "Number|String",
        "Integer|String?",
        "Integer|String?"
      ],
      [
        "Number[]",
        "Integer|String?",
        "Integer|String?"
      ]
    ]
  },
  nfc: {
    overloads: [
      [
        "Number|String",
        "Integer|String?"
      ],
      [
        "Number[]",
        "Integer|String?"
      ]
    ]
  },
  nfp: {
    overloads: [
      [
        "Number",
        "Integer?",
        "Integer?"
      ],
      [
        "Number[]",
        "Integer?",
        "Integer?"
      ]
    ]
  },
  nfs: {
    overloads: [
      [
        "Number",
        "Integer?",
        "Integer?"
      ],
      [
        "Array",
        "Integer?",
        "Integer?"
      ]
    ]
  },
  splitTokens: {
    overloads: [
      [
        "String",
        "String?"
      ]
    ]
  },
  shuffle: {
    overloads: [
      [
        "Array",
        "Boolean?"
      ]
    ]
  },
  strokeMode: {
    overloads: [
      [
        "String"
      ]
    ]
  },
  buildGeometry: {
    overloads: [
      [
        "Function"
      ]
    ]
  },
  freeGeometry: {
    overloads: [
      [
        "p5.Geometry"
      ]
    ]
  },
  plane: {
    overloads: [
      [
        "Number?",
        "Number?",
        "Integer?",
        "Integer?"
      ]
    ]
  },
  box: {
    overloads: [
      [
        "Number?",
        "Number?",
        "Number?",
        "Integer?",
        "Integer?"
      ]
    ]
  },
  sphere: {
    overloads: [
      [
        "Number?",
        "Integer?",
        "Integer?"
      ]
    ]
  },
  cylinder: {
    overloads: [
      [
        "Number?",
        "Number?",
        "Integer?",
        "Integer?",
        "Boolean?",
        "Boolean?"
      ]
    ]
  },
  cone: {
    overloads: [
      [
        "Number?",
        "Number?",
        "Integer?",
        "Integer?",
        "Boolean?"
      ]
    ]
  },
  ellipsoid: {
    overloads: [
      [
        "Number?",
        "Number?",
        "Number?",
        "Integer?",
        "Integer?"
      ]
    ]
  },
  torus: {
    overloads: [
      [
        "Number?",
        "Number?",
        "Integer?",
        "Integer?"
      ]
    ]
  },
  curveDetail: {
    overloads: [
      [
        "Number"
      ]
    ]
  },
  orbitControl: {
    overloads: [
      [
        "Number?",
        "Number?",
        "Number?",
        "Object?"
      ]
    ]
  },
  debugMode: {
    overloads: [
      [],
      [
        "GRID|AXES"
      ],
      [
        "GRID|AXES",
        "Number?",
        "Number?",
        "Number?",
        "Number?",
        "Number?"
      ],
      [
        "GRID|AXES",
        "Number?",
        "Number?",
        "Number?",
        "Number?"
      ],
      [
        "Number?",
        "Number?",
        "Number?",
        "Number?",
        "Number?",
        "Number?",
        "Number?",
        "Number?",
        "Number?"
      ]
    ]
  },
  noDebugMode: {
    overloads: [
      []
    ]
  },
  ambientLight: {
    overloads: [
      [
        "Number",
        "Number",
        "Number",
        "Number?"
      ],
      [
        "Number",
        "Number?"
      ],
      [
        "String"
      ],
      [
        "Number[]"
      ],
      [
        "p5.Color"
      ]
    ]
  },
  specularColor: {
    overloads: [
      [
        "Number",
        "Number",
        "Number"
      ],
      [
        "Number"
      ],
      [
        "String"
      ],
      [
        "Number[]"
      ],
      [
        "p5.Color"
      ]
    ]
  },
  directionalLight: {
    overloads: [
      [
        "Number",
        "Number",
        "Number",
        "Number",
        "Number",
        "Number"
      ],
      [
        "Number",
        "Number",
        "Number",
        "p5.Vector"
      ],
      [
        "p5.Color|Number[]|String",
        "Number",
        "Number",
        "Number"
      ],
      [
        "p5.Color|Number[]|String",
        "p5.Vector"
      ]
    ]
  },
  pointLight: {
    overloads: [
      [
        "Number",
        "Number",
        "Number",
        "Number",
        "Number",
        "Number"
      ],
      [
        "Number",
        "Number",
        "Number",
        "p5.Vector"
      ],
      [
        "p5.Color|Number[]|String",
        "Number",
        "Number",
        "Number"
      ],
      [
        "p5.Color|Number[]|String",
        "p5.Vector"
      ]
    ]
  },
  imageLight: {
    overloads: [
      [
        "p5.Image"
      ]
    ]
  },
  panorama: {
    overloads: [
      [
        "p5.Image"
      ]
    ]
  },
  lights: {
    overloads: [
      []
    ]
  },
  lightFalloff: {
    overloads: [
      [
        "Number",
        "Number",
        "Number"
      ]
    ]
  },
  spotLight: {
    overloads: [
      [
        "Number",
        "Number",
        "Number",
        "Number",
        "Number",
        "Number",
        "Number",
        "Number",
        "Number",
        "Number?",
        "Number?"
      ],
      [
        "p5.Color|Number[]|String",
        "p5.Vector",
        "p5.Vector",
        "Number?",
        "Number?"
      ],
      [
        "Number",
        "Number",
        "Number",
        "p5.Vector",
        "p5.Vector",
        "Number?",
        "Number?"
      ],
      [
        "p5.Color|Number[]|String",
        "Number",
        "Number",
        "Number",
        "p5.Vector",
        "Number?",
        "Number?"
      ],
      [
        "p5.Color|Number[]|String",
        "p5.Vector",
        "Number",
        "Number",
        "Number",
        "Number?",
        "Number?"
      ],
      [
        "Number",
        "Number",
        "Number",
        "Number",
        "Number",
        "Number",
        "p5.Vector",
        "Number?",
        "Number?"
      ],
      [
        "Number",
        "Number",
        "Number",
        "p5.Vector",
        "Number",
        "Number",
        "Number",
        "Number?",
        "Number?"
      ],
      [
        "p5.Color|Number[]|String",
        "Number",
        "Number",
        "Number",
        "Number",
        "Number",
        "Number",
        "Number?",
        "Number?"
      ]
    ]
  },
  noLights: {
    overloads: [
      []
    ]
  },
  loadModel: {
    overloads: [
      [
        "String|Request",
        "String?",
        "Boolean?",
        "function(p5.Geometry)?",
        "function(Event)?"
      ],
      [
        "String|Request",
        "String?",
        "function(p5.Geometry)?",
        "function(Event)?"
      ],
      [
        "String|Request",
        "Object?"
      ]
    ]
  },
  model: {
    overloads: [
      [
        "p5.Geometry",
        "Number?"
      ]
    ]
  },
  createModel: {
    overloads: [
      [
        "String",
        "String?",
        "Boolean?",
        "function(p5.Geometry)?",
        "function(Event)?"
      ],
      [
        "String",
        "String?",
        "function(p5.Geometry)?",
        "function(Event)?"
      ],
      [
        "String",
        "String?",
        "Object?"
      ]
    ]
  },
  loadShader: {
    overloads: [
      [
        "String|Request",
        "String|Request",
        "Function?",
        "Function?"
      ]
    ]
  },
  createShader: {
    overloads: [
      [
        "String",
        "String",
        "Object?"
      ]
    ]
  },
  loadFilterShader: {
    overloads: [
      [
        "String",
        "Function?",
        "Function?"
      ]
    ]
  },
  createFilterShader: {
    overloads: [
      [
        "String"
      ]
    ]
  },
  shader: {
    overloads: [
      [
        "p5.Shader"
      ]
    ]
  },
  strokeShader: {
    overloads: [
      [
        "p5.Shader"
      ]
    ]
  },
  imageShader: {
    overloads: [
      [
        "p5.Shader"
      ]
    ]
  },
  baseMaterialShader: {
    overloads: [
      []
    ]
  },
  baseFilterShader: {
    overloads: [
      []
    ]
  },
  baseNormalShader: {
    overloads: [
      []
    ]
  },
  baseColorShader: {
    overloads: [
      []
    ]
  },
  baseStrokeShader: {
    overloads: [
      []
    ]
  },
  resetShader: {
    overloads: [
      []
    ]
  },
  texture: {
    overloads: [
      [
        "p5.Image|p5.MediaElement|p5.Graphics|p5.Texture|p5.Framebuffer|p5.FramebufferTexture"
      ]
    ]
  },
  textureMode: {
    overloads: [
      [
        "IMAGE|NORMAL"
      ]
    ]
  },
  textureWrap: {
    overloads: [
      [
        "CLAMP|REPEAT|MIRROR",
        "CLAMP|REPEAT|MIRROR?"
      ]
    ]
  },
  normalMaterial: {
    overloads: [
      []
    ]
  },
  ambientMaterial: {
    overloads: [
      [
        "Number",
        "Number",
        "Number"
      ],
      [
        "Number"
      ],
      [
        "p5.Color|Number[]|String"
      ]
    ]
  },
  emissiveMaterial: {
    overloads: [
      [
        "Number",
        "Number",
        "Number",
        "Number?"
      ],
      [
        "Number"
      ],
      [
        "p5.Color|Number[]|String"
      ]
    ]
  },
  specularMaterial: {
    overloads: [
      [
        "Number",
        "Number?"
      ],
      [
        "Number",
        "Number",
        "Number",
        "Number?"
      ],
      [
        "p5.Color|Number[]|String"
      ]
    ]
  },
  shininess: {
    overloads: [
      [
        "Number"
      ]
    ]
  },
  metalness: {
    overloads: [
      [
        "Number"
      ]
    ]
  },
  roll: {
    overloads: [
      [
        "Number"
      ]
    ]
  },
  camera: {
    overloads: [
      [
        "Number?",
        "Number?",
        "Number?",
        "Number?",
        "Number?",
        "Number?",
        "Number?",
        "Number?",
        "Number?"
      ]
    ]
  },
  perspective: {
    overloads: [
      [
        "Number?",
        "Number?",
        "Number?",
        "Number?"
      ]
    ]
  },
  linePerspective: {
    overloads: [
      [
        "Boolean"
      ],
      []
    ]
  },
  ortho: {
    overloads: [
      [
        "Number?",
        "Number?",
        "Number?",
        "Number?",
        "Number?",
        "Number?"
      ]
    ]
  },
  frustum: {
    overloads: [
      [
        "Number?",
        "Number?",
        "Number?",
        "Number?",
        "Number?",
        "Number?"
      ]
    ]
  },
  createCamera: {
    overloads: [
      []
    ]
  },
  setCamera: {
    overloads: [
      [
        "p5.Camera"
      ]
    ]
  },
  saveObj: {
    overloads: [
      [
        "String?"
      ]
    ]
  },
  saveStl: {
    overloads: [
      [
        "String?",
        "Object?"
      ]
    ]
  },
  fromAxisAngle: {
    overloads: [
      [
        "Number?",
        "Number?",
        "Number?",
        "Number?"
      ]
    ]
  },
  mult: {
    overloads: [
      [
        "p5.Quat?"
      ]
    ]
  },
  rotateBy: {
    overloads: [
      [
        "p5.Quat?"
      ]
    ]
  },
  setAttributes: {
    overloads: [
      [
        "String",
        "Boolean"
      ],
      [
        "Object"
      ]
    ]
  }
};
var dataDoc = {
  p5: p5$1,
  "p5.Color": {
    toString: {
      overloads: [
        [
          "String?"
        ]
      ]
    },
    contrast: {
      overloads: [
        [
          "Color"
        ]
      ]
    },
    setRed: {
      overloads: [
        [
          "Number"
        ]
      ]
    },
    setGreen: {
      overloads: [
        [
          "Number"
        ]
      ]
    },
    setBlue: {
      overloads: [
        [
          "Number"
        ]
      ]
    },
    setAlpha: {
      overloads: [
        [
          "Number"
        ]
      ]
    }
  },
  "p5.Graphics": {
    reset: {
      overloads: [
        []
      ]
    },
    remove: {
      overloads: [
        []
      ]
    },
    createFramebuffer: {
      overloads: [
        [
          "Object?"
        ]
      ]
    }
  },
  "p5.Element": {
    remove: {
      overloads: [
        []
      ]
    },
    parent: {
      overloads: [
        [
          "String|p5.Element|Object"
        ],
        []
      ]
    },
    child: {
      overloads: [
        [],
        [
          "String|p5.Element?"
        ]
      ]
    },
    html: {
      overloads: [
        [],
        [
          "String?",
          "Boolean?"
        ]
      ]
    },
    id: {
      overloads: [
        [
          "String"
        ],
        []
      ]
    },
    class: {
      overloads: [
        [
          "String"
        ],
        []
      ]
    },
    addClass: {
      overloads: [
        [
          "String"
        ]
      ]
    },
    removeClass: {
      overloads: [
        [
          "String"
        ]
      ]
    },
    hasClass: {
      overloads: [
        [
          null
        ]
      ]
    },
    toggleClass: {
      overloads: [
        [
          null
        ]
      ]
    },
    center: {
      overloads: [
        [
          "String?"
        ]
      ]
    },
    position: {
      overloads: [
        [],
        [
          "Number?",
          "Number?",
          "String?"
        ]
      ]
    },
    show: {
      overloads: [
        []
      ]
    },
    hide: {
      overloads: [
        []
      ]
    },
    size: {
      overloads: [
        [],
        [
          "Number|AUTO?",
          "Number|AUTO?"
        ]
      ]
    },
    style: {
      overloads: [
        [
          "String"
        ],
        [
          "String",
          "String|p5.Color"
        ]
      ]
    },
    attribute: {
      overloads: [
        [],
        [
          "String",
          "String"
        ]
      ]
    },
    removeAttribute: {
      overloads: [
        [
          "String"
        ]
      ]
    },
    value: {
      overloads: [
        [],
        [
          "String|Number"
        ]
      ]
    },
    mousePressed: {
      overloads: [
        [
          "Function|Boolean"
        ]
      ]
    },
    doubleClicked: {
      overloads: [
        [
          "Function|Boolean"
        ]
      ]
    },
    mouseWheel: {
      overloads: [
        [
          "Function|Boolean"
        ]
      ]
    },
    mouseReleased: {
      overloads: [
        [
          "Function|Boolean"
        ]
      ]
    },
    mouseClicked: {
      overloads: [
        [
          "Function|Boolean"
        ]
      ]
    },
    mouseMoved: {
      overloads: [
        [
          "Function|Boolean"
        ]
      ]
    },
    mouseOver: {
      overloads: [
        [
          "Function|Boolean"
        ]
      ]
    },
    mouseOut: {
      overloads: [
        [
          "Function|Boolean"
        ]
      ]
    },
    dragOver: {
      overloads: [
        [
          "Function|Boolean"
        ]
      ]
    },
    dragLeave: {
      overloads: [
        [
          "Function|Boolean"
        ]
      ]
    },
    changed: {
      overloads: [
        [
          "Function|Boolean"
        ]
      ]
    },
    input: {
      overloads: [
        [
          "Function|Boolean"
        ]
      ]
    },
    drop: {
      overloads: [
        [
          "Function",
          "Function?"
        ]
      ]
    },
    draggable: {
      overloads: [
        [
          "p5.Element?"
        ]
      ]
    }
  },
  "p5.MediaElement": {
    play: {
      overloads: [
        []
      ]
    },
    stop: {
      overloads: [
        []
      ]
    },
    pause: {
      overloads: [
        []
      ]
    },
    loop: {
      overloads: [
        []
      ]
    },
    noLoop: {
      overloads: [
        []
      ]
    },
    autoplay: {
      overloads: [
        [
          "Boolean?"
        ]
      ]
    },
    volume: {
      overloads: [
        [],
        [
          "Number"
        ]
      ]
    },
    speed: {
      overloads: [
        [],
        [
          "Number"
        ]
      ]
    },
    time: {
      overloads: [
        [
          "Number?"
        ]
      ]
    },
    duration: {
      overloads: [
        []
      ]
    },
    onended: {
      overloads: [
        [
          "Function"
        ]
      ]
    },
    connect: {
      overloads: [
        [
          "AudioNode|Object"
        ]
      ]
    },
    disconnect: {
      overloads: [
        []
      ]
    },
    showControls: {
      overloads: [
        []
      ]
    },
    hideControls: {
      overloads: [
        []
      ]
    },
    addCue: {
      overloads: [
        [
          "Number",
          "Function",
          "Object?"
        ]
      ]
    },
    removeCue: {
      overloads: [
        [
          "Number"
        ]
      ]
    },
    clearCues: {
      overloads: [
        []
      ]
    }
  },
  "p5.Image": {
    pixelDensity: {
      overloads: [
        [
          "Number?"
        ]
      ]
    },
    loadPixels: {
      overloads: [
        []
      ]
    },
    updatePixels: {
      overloads: [
        [
          "Integer?",
          "Integer?",
          "Integer?",
          "Integer?"
        ]
      ]
    },
    get: {
      overloads: [
        [
          "Number",
          "Number",
          "Number",
          "Number"
        ],
        [],
        [
          "Number",
          "Number"
        ]
      ]
    },
    set: {
      overloads: [
        [
          "Number",
          "Number",
          "Number|Number[]|Object"
        ]
      ]
    },
    resize: {
      overloads: [
        [
          "Number",
          "Number"
        ]
      ]
    },
    copy: {
      overloads: [
        [
          "p5.Image|p5.Element",
          "Integer",
          "Integer",
          "Integer",
          "Integer",
          "Integer",
          "Integer",
          "Integer",
          "Integer"
        ],
        [
          "Integer",
          "Integer",
          "Integer",
          "Integer",
          "Integer",
          "Integer",
          "Integer",
          "Integer"
        ]
      ]
    },
    mask: {
      overloads: [
        [
          "p5.Image"
        ]
      ]
    },
    filter: {
      overloads: [
        [
          "THRESHOLD|GRAY|OPAQUE|INVERT|POSTERIZE|ERODE|DILATE|BLUR",
          "Number?"
        ]
      ]
    },
    blend: {
      overloads: [
        [
          "p5.Image",
          "Integer",
          "Integer",
          "Integer",
          "Integer",
          "Integer",
          "Integer",
          "Integer",
          "Integer",
          "BLEND|DARKEST|LIGHTEST|DIFFERENCE|MULTIPLY|EXCLUSION|SCREEN|REPLACE|OVERLAY|HARD_LIGHT|SOFT_LIGHT|DODGE|BURN|ADD|NORMAL"
        ],
        [
          "Integer",
          "Integer",
          "Integer",
          "Integer",
          "Integer",
          "Integer",
          "Integer",
          "Integer",
          "BLEND|DARKEST|LIGHTEST|DIFFERENCE|MULTIPLY|EXCLUSION|SCREEN|REPLACE|OVERLAY|HARD_LIGHT|SOFT_LIGHT|DODGE|BURN|ADD|NORMAL"
        ]
      ]
    },
    save: {
      overloads: [
        [
          "String",
          "String?"
        ]
      ]
    },
    reset: {
      overloads: [
        []
      ]
    },
    getCurrentFrame: {
      overloads: [
        []
      ]
    },
    setFrame: {
      overloads: [
        [
          "Number"
        ]
      ]
    },
    numFrames: {
      overloads: [
        []
      ]
    },
    play: {
      overloads: [
        []
      ]
    },
    pause: {
      overloads: [
        []
      ]
    },
    delay: {
      overloads: [
        [
          "Number",
          "Number?"
        ]
      ]
    }
  },
  "p5.Table": {
    addRow: {
      overloads: [
        [
          "p5.TableRow?"
        ]
      ]
    },
    removeRow: {
      overloads: [
        [
          "Integer"
        ]
      ]
    },
    getRow: {
      overloads: [
        [
          "Integer"
        ]
      ]
    },
    getRows: {
      overloads: [
        []
      ]
    },
    findRow: {
      overloads: [
        [
          "String",
          "Integer|String"
        ]
      ]
    },
    findRows: {
      overloads: [
        [
          "String",
          "Integer|String"
        ]
      ]
    },
    matchRow: {
      overloads: [
        [
          "String|RegExp",
          "String|Integer"
        ]
      ]
    },
    matchRows: {
      overloads: [
        [
          "String",
          "String|Integer?"
        ]
      ]
    },
    getColumn: {
      overloads: [
        [
          "String|Number"
        ]
      ]
    },
    clearRows: {
      overloads: [
        []
      ]
    },
    addColumn: {
      overloads: [
        [
          "String?"
        ]
      ]
    },
    getColumnCount: {
      overloads: [
        []
      ]
    },
    getRowCount: {
      overloads: [
        []
      ]
    },
    removeTokens: {
      overloads: [
        [
          "String",
          "String|Integer?"
        ]
      ]
    },
    trim: {
      overloads: [
        [
          "String|Integer?"
        ]
      ]
    },
    removeColumn: {
      overloads: [
        [
          "String|Integer"
        ]
      ]
    },
    set: {
      overloads: [
        [
          "Integer",
          "String|Integer",
          "String|Number"
        ]
      ]
    },
    setNum: {
      overloads: [
        [
          "Integer",
          "String|Integer",
          "Number"
        ]
      ]
    },
    setString: {
      overloads: [
        [
          "Integer",
          "String|Integer",
          "String"
        ]
      ]
    },
    get: {
      overloads: [
        [
          "Integer",
          "String|Integer"
        ]
      ]
    },
    getNum: {
      overloads: [
        [
          "Integer",
          "String|Integer"
        ]
      ]
    },
    getString: {
      overloads: [
        [
          "Integer",
          "String|Integer"
        ]
      ]
    },
    getObject: {
      overloads: [
        [
          "String?"
        ]
      ]
    },
    getArray: {
      overloads: [
        []
      ]
    }
  },
  "p5.TableRow": {
    set: {
      overloads: [
        [
          "String|Integer",
          "String|Number"
        ]
      ]
    },
    setNum: {
      overloads: [
        [
          "String|Integer",
          "Number|String"
        ]
      ]
    },
    setString: {
      overloads: [
        [
          "String|Integer",
          "String|Number|Boolean|Object"
        ]
      ]
    },
    get: {
      overloads: [
        [
          "String|Integer"
        ]
      ]
    },
    getNum: {
      overloads: [
        [
          "String|Integer"
        ]
      ]
    },
    getString: {
      overloads: [
        [
          "String|Integer"
        ]
      ]
    }
  },
  "p5.XML": {
    getParent: {
      overloads: [
        []
      ]
    },
    getName: {
      overloads: [
        []
      ]
    },
    setName: {
      overloads: [
        [
          "String"
        ]
      ]
    },
    hasChildren: {
      overloads: [
        []
      ]
    },
    listChildren: {
      overloads: [
        []
      ]
    },
    getChildren: {
      overloads: [
        [
          "String?"
        ]
      ]
    },
    getChild: {
      overloads: [
        [
          "String|Integer"
        ]
      ]
    },
    addChild: {
      overloads: [
        [
          "p5.XML"
        ]
      ]
    },
    removeChild: {
      overloads: [
        [
          "String|Integer"
        ]
      ]
    },
    getAttributeCount: {
      overloads: [
        []
      ]
    },
    listAttributes: {
      overloads: [
        []
      ]
    },
    hasAttribute: {
      overloads: [
        [
          "String"
        ]
      ]
    },
    getNum: {
      overloads: [
        [
          "String",
          "Number?"
        ]
      ]
    },
    getString: {
      overloads: [
        [
          "String",
          "Number?"
        ]
      ]
    },
    setAttribute: {
      overloads: [
        [
          "String",
          "Number|String|Boolean"
        ]
      ]
    },
    getContent: {
      overloads: [
        [
          "String?"
        ]
      ]
    },
    serialize: {
      overloads: [
        []
      ]
    }
  },
  "p5.Vector": {
    getValue: {
      overloads: [
        [
          "Number"
        ]
      ]
    },
    setValue: {
      overloads: [
        [
          "Number",
          "Number"
        ]
      ]
    },
    set: {
      overloads: [
        [
          "Number?",
          "Number?",
          "Number?"
        ],
        [
          "p5.Vector|Number[]"
        ]
      ]
    },
    copy: {
      overloads: [
        []
      ]
    },
    add: {
      overloads: [
        [
          "Number|Array",
          "Number?",
          "Number?"
        ],
        [
          "p5.Vector|Number[]"
        ]
      ]
    },
    rem: {
      overloads: [
        [
          "Number",
          "Number",
          "Number"
        ],
        [
          "p5.Vector|Number[]"
        ]
      ]
    },
    sub: {
      overloads: [
        [
          "Number",
          "Number?",
          "Number?"
        ],
        [
          "p5.Vector|Number[]"
        ]
      ]
    },
    mult: {
      overloads: [
        [
          "Number"
        ],
        [
          "Number",
          "Number",
          "Number?"
        ],
        [
          "Number[]"
        ],
        [
          "p5.Vector"
        ]
      ]
    },
    div: {
      overloads: [
        [
          "Number"
        ],
        [
          "Number",
          "Number",
          "Number?"
        ],
        [
          "Number[]"
        ],
        [
          "p5.Vector"
        ]
      ]
    },
    mag: {
      overloads: [
        []
      ]
    },
    magSq: {
      overloads: [
        []
      ]
    },
    dot: {
      overloads: [
        [
          "Number",
          "Number?",
          "Number?"
        ],
        [
          "p5.Vector"
        ]
      ]
    },
    cross: {
      overloads: [
        [
          "p5.Vector"
        ]
      ]
    },
    dist: {
      overloads: [
        [
          "p5.Vector"
        ]
      ]
    },
    normalize: {
      overloads: [
        []
      ]
    },
    limit: {
      overloads: [
        [
          "Number"
        ]
      ]
    },
    setMag: {
      overloads: [
        [
          "Number"
        ]
      ]
    },
    heading: {
      overloads: [
        []
      ]
    },
    setHeading: {
      overloads: [
        [
          "Number"
        ]
      ]
    },
    rotate: {
      overloads: [
        [
          "Number"
        ]
      ]
    },
    angleBetween: {
      overloads: [
        [
          "p5.Vector"
        ]
      ]
    },
    lerp: {
      overloads: [
        [
          "Number",
          "Number",
          "Number",
          "Number"
        ],
        [
          "p5.Vector",
          "Number"
        ]
      ]
    },
    slerp: {
      overloads: [
        [
          "p5.Vector",
          "Number"
        ]
      ]
    },
    reflect: {
      overloads: [
        [
          "p5.Vector"
        ]
      ]
    },
    array: {
      overloads: [
        []
      ]
    },
    equals: {
      overloads: [
        [
          "Number?",
          "Number?",
          "Number?"
        ],
        [
          "p5.Vector|Array"
        ]
      ]
    },
    clampToZero: {
      overloads: [
        []
      ]
    },
    fromAngle: {
      overloads: [
        [
          "Number",
          "Number?"
        ]
      ]
    },
    fromAngles: {
      overloads: [
        [
          "Number",
          "Number",
          "Number?"
        ]
      ]
    },
    random2D: {
      overloads: [
        []
      ]
    },
    random3D: {
      overloads: [
        []
      ]
    }
  },
  "p5.Font": {
    textToPaths: {
      overloads: [
        [
          "String",
          "Number",
          "Number",
          "Number?",
          "Number?"
        ]
      ]
    },
    textToPoints: {
      overloads: [
        [
          "String",
          "Number",
          "Number",
          "Object?"
        ]
      ]
    },
    textToContours: {
      overloads: [
        [
          "String",
          "Number",
          "Number",
          "Object?"
        ]
      ]
    },
    textToModel: {
      overloads: [
        [
          "String",
          "Number",
          "Number",
          "Number",
          "Number",
          "Object?"
        ]
      ]
    }
  },
  "p5.Camera": {
    perspective: {
      overloads: [
        [
          "Number?",
          "Number?",
          "Number?",
          "Number?"
        ]
      ]
    },
    ortho: {
      overloads: [
        [
          "Number?",
          "Number?",
          "Number?",
          "Number?",
          "Number?",
          "Number?"
        ]
      ]
    },
    frustum: {
      overloads: [
        [
          "Number?",
          "Number?",
          "Number?",
          "Number?",
          "Number?",
          "Number?"
        ]
      ]
    },
    pan: {
      overloads: [
        [
          "Number"
        ]
      ]
    },
    tilt: {
      overloads: [
        [
          "Number"
        ]
      ]
    },
    lookAt: {
      overloads: [
        [
          "Number",
          "Number",
          "Number"
        ]
      ]
    },
    camera: {
      overloads: [
        [
          "Number?",
          "Number?",
          "Number?",
          "Number?",
          "Number?",
          "Number?",
          "Number?",
          "Number?",
          "Number?"
        ]
      ]
    },
    move: {
      overloads: [
        [
          "Number",
          "Number",
          "Number"
        ]
      ]
    },
    setPosition: {
      overloads: [
        [
          "Number",
          "Number",
          "Number"
        ]
      ]
    },
    set: {
      overloads: [
        [
          "p5.Camera"
        ]
      ]
    },
    slerp: {
      overloads: [
        [
          "p5.Camera",
          "p5.Camera",
          "Number"
        ]
      ]
    }
  },
  "p5.Framebuffer": {
    resize: {
      overloads: [
        [
          "Number",
          "Number"
        ]
      ]
    },
    pixelDensity: {
      overloads: [
        [
          "Number?"
        ]
      ]
    },
    autoSized: {
      overloads: [
        [
          "Boolean?"
        ]
      ]
    },
    createCamera: {
      overloads: [
        []
      ]
    },
    remove: {
      overloads: [
        []
      ]
    },
    begin: {
      overloads: [
        []
      ]
    },
    end: {
      overloads: [
        []
      ]
    },
    draw: {
      overloads: [
        [
          "Function"
        ]
      ]
    },
    loadPixels: {
      overloads: [
        []
      ]
    },
    get: {
      overloads: [
        [
          "Number",
          "Number",
          "Number",
          "Number"
        ],
        [],
        [
          "Number",
          "Number"
        ]
      ]
    }
  },
  "p5.Geometry": {
    calculateBoundingBox: {
      overloads: [
        []
      ]
    },
    clearColors: {
      overloads: [
        []
      ]
    },
    flipU: {
      overloads: [
        []
      ]
    },
    computeFaces: {
      overloads: [
        []
      ]
    },
    computeNormals: {
      overloads: [
        [
          "FLAT|SMOOTH?",
          "Object?"
        ]
      ]
    },
    makeEdgesFromFaces: {
      overloads: [
        []
      ]
    },
    normalize: {
      overloads: [
        []
      ]
    },
    vertexProperty: {
      overloads: [
        [
          "String",
          "Number|Number[]",
          "Number?"
        ]
      ]
    },
    flipV: {
      overloads: [
        []
      ]
    }
  },
  "p5.Shader": {
    version: {
      overloads: [
        []
      ]
    },
    inspectHooks: {
      overloads: [
        []
      ]
    },
    modify: {
      overloads: [
        [
          "Function",
          "Object?"
        ],
        [
          "Object?"
        ]
      ]
    },
    copyToContext: {
      overloads: [
        [
          "p5|p5.Graphics"
        ]
      ]
    },
    setUniform: {
      overloads: [
        [
          "String",
          "Boolean|Number|Number[]|p5.Image|p5.Graphics|p5.MediaElement|p5.Texture"
        ]
      ]
    }
  }
};
function validateParams(p53, fn2, lifecycles) {
  let schemaRegistry = new Map;
  const p5Constructors = Object.keys(p53).reduce((acc, val) => {
    if (val.match(/^[A-Z]/) && !val.match(/^[A-Z][A-Z0-9]*$/) && p53[val] instanceof Function) {
      acc[val] = p53[val];
    }
    return acc;
  }, {});
  function loadP5Constructors() {
    for (let key of Object.keys(p53)) {
      if (typeof p53[key] === "function" && key[0] !== key[0].toLowerCase()) {
        p5Constructors[key] = p53[key];
      }
    }
  }
  const constantsMap = {};
  for (const [key, value] of Object.entries(constants)) {
    constantsMap[key] = value;
  }
  const schemaMap = {
    Any: exports_external.any(),
    Array: exports_external.array(exports_external.any()),
    Boolean: exports_external.boolean(),
    Function: exports_external.function(),
    Integer: exports_external.number().int(),
    Number: exports_external.number(),
    Object: exports_external.object({}),
    String: exports_external.string()
  };
  const webAPIObjects = [
    "AudioNode",
    "HTMLCanvasElement",
    "HTMLElement",
    "KeyboardEvent",
    "MouseEvent",
    "RegExp",
    "TouchEvent",
    "UIEvent",
    "WheelEvent"
  ];
  function generateWebAPISchemas(apiObjects) {
    return apiObjects.reduce((acc, obj) => {
      acc[obj] = exports_external.custom((data) => data instanceof globalThis[obj], {
        message: `Expected a ${obj}`
      });
      return acc;
    }, {});
  }
  const webAPISchemas = generateWebAPISchemas(webAPIObjects);
  Object.assign(schemaMap, webAPISchemas);
  const ordinals = ["first", "second", "third", "fourth", "fifth", "sixth", "seventh", "eighth", "ninth", "tenth"];
  function extractFuncNameAndClass(func) {
    const ichDot = func.lastIndexOf(".");
    const funcName = func.slice(ichDot + 1);
    const funcClass = func.slice(0, ichDot !== -1 ? ichDot : 0) || "p5";
    return { funcName, funcClass };
  }
  function validBracketNesting(type2) {
    let level = 0;
    for (let i = 0;i < type2.length; i++) {
      if (type2[i] === "[") {
        level++;
      } else if (type2[i] === "]") {
        level--;
        if (level < 0)
          return false;
      }
    }
    return level === 0;
  }
  const generateZodSchemasForFunc = function(func) {
    const { funcName, funcClass } = extractFuncNameAndClass(func);
    let funcInfo = dataDoc[funcClass][funcName];
    if (!funcInfo)
      return;
    let overloads = [];
    if (funcInfo.hasOwnProperty("overloads")) {
      overloads = funcInfo.overloads;
    }
    const generateTypeSchema = (baseType) => {
      if (!baseType)
        return exports_external.any();
      let typeSchema;
      if (baseType in constantsMap) {
        typeSchema = exports_external.literal(constantsMap[baseType]);
      } else if (baseType.match(/^[A-Z][A-Z0-9]*$/) && baseType in fn2) {
        typeSchema = exports_external.literal(fn2[baseType]);
      } else if (baseType.startsWith("function")) {
        typeSchema = exports_external.function();
      } else if (/^p5\.[a-zA-Z0-9]+$/.exec(baseType) || baseType === "p5") {
        const className = baseType.substring(baseType.indexOf(".") + 1);
        typeSchema = exports_external.instanceof(p5Constructors[className]);
      } else if (schemaMap[baseType]) {
        typeSchema = schemaMap[baseType];
      } else if (baseType.startsWith("[") && baseType.endsWith("]") && validBracketNesting(baseType.slice(1, -1))) {
        typeSchema = exports_external.tuple(baseType.slice(1, -1).split(/, */g).map((entry) => generateTypeSchema(entry)));
      } else if (baseType.match(/^[A-Z]/) && baseType in window) {
        typeSchema = exports_external.instanceof(window[baseType]);
      } else if (baseType.includes("|") && baseType.split("|").every((t) => validBracketNesting(t))) {
        const types = baseType.split("|");
        typeSchema = exports_external.union(types.map((t) => generateTypeSchema(t)).filter((s) => s !== undefined));
      } else if (baseType.endsWith("[]")) {
        typeSchema = exports_external.array(generateTypeSchema(baseType.slice(0, -2)));
      } else {
        throw new Error(`Unsupported type '${baseType}' in parameter validation. Please report this issue.`);
      }
      return typeSchema;
    };
    const generateParamSchema = (param) => {
      const isOptional = param?.endsWith("?");
      param = param?.replace(/\?$/, "");
      const isRest = param?.startsWith("...") && param?.endsWith("[]");
      param = param?.replace(/^\.\.\.(.+)\[\]$/, "$1");
      let schema = generateTypeSchema(param);
      if (schema.def.type === "function") {
        schema = exports_external.custom((val) => val instanceof Function);
      }
      if (isOptional) {
        schema = schema.optional();
      }
      return { schema, rest: isRest };
    };
    const generateOverloadCombinations = (params) => {
      if (!params.some((p2) => p2?.endsWith("?"))) {
        return [params];
      }
      const requiredParamsCount = params.filter((p2) => p2 === null || !p2.endsWith("?")).length;
      const result = [];
      for (let i = requiredParamsCount;i <= params.length; i++) {
        result.push(params.slice(0, i));
      }
      return result;
    };
    const overloadSchemas = overloads.flatMap((overload) => {
      const combinations = generateOverloadCombinations(overload);
      return combinations.map((combo) => {
        const params = combo.map((p2) => generateParamSchema(p2)).filter((s) => s.schema !== undefined);
        let rest;
        if (params.at(-1)?.rest) {
          rest = params.pop();
        }
        let combined = exports_external.tuple(params.map((s) => s.schema));
        if (rest) {
          combined = combined.rest(rest.schema);
        }
        return combined;
      });
    });
    return overloadSchemas.length === 1 ? overloadSchemas[0] : exports_external.union(overloadSchemas);
  };
  const findClosestSchema = function(schema, args) {
    if (!(schema instanceof exports_external.ZodUnion)) {
      return schema;
    }
    const scoreSchema = (schema2) => {
      let score = Infinity;
      if (!(schema2 instanceof exports_external.ZodTuple)) {
        console.warn("Schema below is not a tuple: ");
        printZodSchema(schema2);
        return score;
      }
      const numArgs = args.length;
      const schemaItems = schema2.def.items;
      const numSchemaItems = schemaItems.length;
      const numRequiredSchemaItems = schemaItems.filter((item) => !item.isOptional()).length;
      if (numArgs >= numRequiredSchemaItems && numArgs <= numSchemaItems) {
        score = 0;
      } else {
        score = Math.abs(numArgs < numRequiredSchemaItems ? numRequiredSchemaItems - numArgs : numArgs - numSchemaItems) * 4;
      }
      for (let i = 0;i < Math.min(schemaItems.length, args.length); i++) {
        const paramSchema = schemaItems[i];
        const arg = args[i];
        if (!paramSchema.safeParse(arg).success)
          score++;
      }
      return score;
    };
    let closestSchema = schema.def.options[0];
    let bestScore = Infinity;
    const schemaUnion = schema.def.options;
    schemaUnion.forEach((schema2) => {
      const score = scoreSchema(schema2);
      if (score < bestScore) {
        closestSchema = schema2;
        bestScore = score;
      }
    });
    return closestSchema;
  };
  const friendlyParamError = function(zodErrorObj, func, args) {
    let message = "\uD83C\uDF38 p5.js says: ";
    let isVersionError = false;
    let currentError = zodErrorObj.issues[0];
    const buildTypeMismatchMessage = (actualType, expectedTypeStr, position) => {
      const positionStr = position ? `at the ${ordinals[position]} parameter` : "";
      const actualTypeStr = actualType ? `, but received ${actualType}` : "";
      return `Expected ${expectedTypeStr} ${positionStr}${actualTypeStr}`;
    };
    const processUnionError = (error41) => {
      const expectedTypes = new Set;
      let actualType;
      error41.errors.forEach((err) => {
        const issue2 = err[0];
        if (issue2) {
          if (!actualType) {
            actualType = issue2.message;
          }
          if (issue2.code === "invalid_type") {
            actualType = issue2.message.split(", received ")[1];
            expectedTypes.add(issue2.expected);
          } else if (issue2.code === "invalid_value") {
            expectedTypes.add("constant (please refer to documentation for allowed values)");
            actualType = args[error41.path[0]];
          } else if (issue2.code === "custom") {
            const match = issue2.message.match(/Input not instance of (\w+)/);
            if (match)
              expectedTypes.add(match[1]);
            actualType = undefined;
          }
        }
      });
      if (expectedTypes.size > 0) {
        if (error41.path?.length > 0 && args[error41.path[0]] instanceof Promise) {
          message += "Did you mean to put `await` before a loading function? " + "An unexpected Promise was found. ";
          isVersionError = true;
        }
        const expectedTypesStr = Array.from(expectedTypes).join(" or ");
        const position = error41.path.join(".");
        message += buildTypeMismatchMessage(actualType, expectedTypesStr, position);
      }
      return message;
    };
    switch (currentError.code) {
      case "invalid_union": {
        processUnionError(currentError);
        break;
      }
      case "too_small": {
        const minArgs = currentError.minimum;
        message += `Expected at least ${minArgs} argument${minArgs > 1 ? "s" : ""}, but received fewer`;
        break;
      }
      case "invalid_type": {
        message += buildTypeMismatchMessage(currentError.message.split(", received ")[1], currentError.expected, currentError.path.join("."));
        break;
      }
      case "too_big": {
        const maxArgs = currentError.maximum;
        message += `Expected at most ${maxArgs} argument${maxArgs > 1 ? "s" : ""}, but received more`;
        break;
      }
      default: {
        console.log("Zod error object", currentError);
      }
    }
    message += ` in ${func}().`;
    const generateDocumentationLink = (func2) => {
      const { funcName, funcClass } = extractFuncNameAndClass(func2);
      const p5BaseUrl = "https://p5js.org/reference";
      const url2 = `${p5BaseUrl}/${funcClass}/${funcName}`;
      return url2;
    };
    if (currentError.code === "too_big" || currentError.code === "too_small") {
      const documentationLink = generateDocumentationLink(func);
      message += ` For more information, see ${documentationLink}.`;
    }
    if (isVersionError) {
      p53._error(this, message);
    } else {
      console.log(message);
    }
    return message;
  };
  const validate = function(func, args) {
    if (p53.disableFriendlyErrors) {
      return;
    }
    if (!Array.isArray(args)) {
      args = Array.from(args);
    }
    if (Array.isArray(args) && args.length > 0 && args.every((arg) => arg === undefined)) {
      const undefinedErrorMessage = `\uD83C\uDF38 p5.js says: All arguments for ${func}() are undefined. There is likely an error in the code.`;
      return {
        success: false,
        error: undefinedErrorMessage
      };
    }
    let funcSchemas = schemaRegistry.get(func);
    if (!funcSchemas) {
      funcSchemas = generateZodSchemasForFunc(func);
      if (!funcSchemas)
        return;
      schemaRegistry.set(func, funcSchemas);
    }
    try {
      return {
        success: true,
        data: funcSchemas.parse(args)
      };
    } catch (error41) {
      const closestSchema = findClosestSchema(funcSchemas, args);
      const zodError = closestSchema.safeParse(args).error;
      const errorMessage = friendlyParamError(zodError, func, args);
      return {
        success: false,
        error: errorMessage
      };
    }
  };
  fn2._validate = validate;
  p53.decorateHelper(/^(?!_).+$/, function(target, { name }) {
    return function(...args) {
      if (!p53.disableFriendlyErrors && !p53.disableParameterValidator) {
        validate(name, args);
      }
      return target.call(this, ...args);
    };
  });
  lifecycles.presetup = function() {
    loadP5Constructors();
  };
}
if (typeof p5 !== "undefined") {
  validateParams(p5, p5.prototype);
}

// node_modules/acorn/dist/acorn.mjs
var astralIdentifierCodes = [509, 0, 227, 0, 150, 4, 294, 9, 1368, 2, 2, 1, 6, 3, 41, 2, 5, 0, 166, 1, 574, 3, 9, 9, 7, 9, 32, 4, 318, 1, 80, 3, 71, 10, 50, 3, 123, 2, 54, 14, 32, 10, 3, 1, 11, 3, 46, 10, 8, 0, 46, 9, 7, 2, 37, 13, 2, 9, 6, 1, 45, 0, 13, 2, 49, 13, 9, 3, 2, 11, 83, 11, 7, 0, 3, 0, 158, 11, 6, 9, 7, 3, 56, 1, 2, 6, 3, 1, 3, 2, 10, 0, 11, 1, 3, 6, 4, 4, 68, 8, 2, 0, 3, 0, 2, 3, 2, 4, 2, 0, 15, 1, 83, 17, 10, 9, 5, 0, 82, 19, 13, 9, 214, 6, 3, 8, 28, 1, 83, 16, 16, 9, 82, 12, 9, 9, 7, 19, 58, 14, 5, 9, 243, 14, 166, 9, 71, 5, 2, 1, 3, 3, 2, 0, 2, 1, 13, 9, 120, 6, 3, 6, 4, 0, 29, 9, 41, 6, 2, 3, 9, 0, 10, 10, 47, 15, 343, 9, 54, 7, 2, 7, 17, 9, 57, 21, 2, 13, 123, 5, 4, 0, 2, 1, 2, 6, 2, 0, 9, 9, 49, 4, 2, 1, 2, 4, 9, 9, 330, 3, 10, 1, 2, 0, 49, 6, 4, 4, 14, 10, 5350, 0, 7, 14, 11465, 27, 2343, 9, 87, 9, 39, 4, 60, 6, 26, 9, 535, 9, 470, 0, 2, 54, 8, 3, 82, 0, 12, 1, 19628, 1, 4178, 9, 519, 45, 3, 22, 543, 4, 4, 5, 9, 7, 3, 6, 31, 3, 149, 2, 1418, 49, 513, 54, 5, 49, 9, 0, 15, 0, 23, 4, 2, 14, 1361, 6, 2, 16, 3, 6, 2, 1, 2, 4, 101, 0, 161, 6, 10, 9, 357, 0, 62, 13, 499, 13, 245, 1, 2, 9, 726, 6, 110, 6, 6, 9, 4759, 9, 787719, 239];
var astralIdentifierStartCodes = [0, 11, 2, 25, 2, 18, 2, 1, 2, 14, 3, 13, 35, 122, 70, 52, 268, 28, 4, 48, 48, 31, 14, 29, 6, 37, 11, 29, 3, 35, 5, 7, 2, 4, 43, 157, 19, 35, 5, 35, 5, 39, 9, 51, 13, 10, 2, 14, 2, 6, 2, 1, 2, 10, 2, 14, 2, 6, 2, 1, 4, 51, 13, 310, 10, 21, 11, 7, 25, 5, 2, 41, 2, 8, 70, 5, 3, 0, 2, 43, 2, 1, 4, 0, 3, 22, 11, 22, 10, 30, 66, 18, 2, 1, 11, 21, 11, 25, 71, 55, 7, 1, 65, 0, 16, 3, 2, 2, 2, 28, 43, 28, 4, 28, 36, 7, 2, 27, 28, 53, 11, 21, 11, 18, 14, 17, 111, 72, 56, 50, 14, 50, 14, 35, 39, 27, 10, 22, 251, 41, 7, 1, 17, 2, 60, 28, 11, 0, 9, 21, 43, 17, 47, 20, 28, 22, 13, 52, 58, 1, 3, 0, 14, 44, 33, 24, 27, 35, 30, 0, 3, 0, 9, 34, 4, 0, 13, 47, 15, 3, 22, 0, 2, 0, 36, 17, 2, 24, 20, 1, 64, 6, 2, 0, 2, 3, 2, 14, 2, 9, 8, 46, 39, 7, 3, 1, 3, 21, 2, 6, 2, 1, 2, 4, 4, 0, 19, 0, 13, 4, 31, 9, 2, 0, 3, 0, 2, 37, 2, 0, 26, 0, 2, 0, 45, 52, 19, 3, 21, 2, 31, 47, 21, 1, 2, 0, 185, 46, 42, 3, 37, 47, 21, 0, 60, 42, 14, 0, 72, 26, 38, 6, 186, 43, 117, 63, 32, 7, 3, 0, 3, 7, 2, 1, 2, 23, 16, 0, 2, 0, 95, 7, 3, 38, 17, 0, 2, 0, 29, 0, 11, 39, 8, 0, 22, 0, 12, 45, 20, 0, 19, 72, 200, 32, 32, 8, 2, 36, 18, 0, 50, 29, 113, 6, 2, 1, 2, 37, 22, 0, 26, 5, 2, 1, 2, 31, 15, 0, 328, 18, 16, 0, 2, 12, 2, 33, 125, 0, 80, 921, 103, 110, 18, 195, 2637, 96, 16, 1071, 18, 5, 26, 3994, 6, 582, 6842, 29, 1763, 568, 8, 30, 18, 78, 18, 29, 19, 47, 17, 3, 32, 20, 6, 18, 433, 44, 212, 63, 129, 74, 6, 0, 67, 12, 65, 1, 2, 0, 29, 6135, 9, 1237, 42, 9, 8936, 3, 2, 6, 2, 1, 2, 290, 16, 0, 30, 2, 3, 0, 15, 3, 9, 395, 2309, 106, 6, 12, 4, 8, 8, 9, 5991, 84, 2, 70, 2, 1, 3, 0, 3, 1, 3, 3, 2, 11, 2, 0, 2, 6, 2, 64, 2, 3, 3, 7, 2, 6, 2, 27, 2, 3, 2, 4, 2, 0, 4, 6, 2, 339, 3, 24, 2, 24, 2, 30, 2, 24, 2, 30, 2, 24, 2, 30, 2, 24, 2, 30, 2, 24, 2, 7, 1845, 30, 7, 5, 262, 61, 147, 44, 11, 6, 17, 0, 322, 29, 19, 43, 485, 27, 229, 29, 3, 0, 496, 6, 2, 3, 2, 1, 2, 14, 2, 196, 60, 67, 8, 0, 1205, 3, 2, 26, 2, 1, 2, 0, 3, 0, 2, 9, 2, 3, 2, 0, 2, 0, 7, 0, 5, 0, 2, 0, 2, 0, 2, 2, 2, 1, 2, 0, 3, 0, 2, 0, 2, 0, 2, 0, 2, 0, 2, 1, 2, 0, 3, 3, 2, 6, 2, 3, 2, 3, 2, 0, 2, 9, 2, 16, 6, 2, 2, 4, 2, 16, 4421, 42719, 33, 4153, 7, 221, 3, 5761, 15, 7472, 16, 621, 2467, 541, 1507, 4938, 6, 4191];
var nonASCIIidentifierChars = "-----------------------------------------------------------------------------------------------------------------------------------------------------";
var nonASCIIidentifierStartChars = "------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------";
var reservedWords = {
  3: "abstract boolean byte char class double enum export extends final float goto implements import int interface long native package private protected public short static super synchronized throws transient volatile",
  5: "class enum extends super const export import",
  6: "enum",
  strict: "implements interface let package private protected public static yield",
  strictBind: "eval arguments"
};
var ecma5AndLessKeywords = "break case catch continue debugger default do else finally for function if return switch throw try var while with null true false instanceof typeof void delete new in this";
var keywords$1 = {
  5: ecma5AndLessKeywords,
  "5module": ecma5AndLessKeywords + " export import",
  6: ecma5AndLessKeywords + " const class extends export import super"
};
var keywordRelationalOperator = /^in(stanceof)?$/;
var nonASCIIidentifierStart = new RegExp("[" + nonASCIIidentifierStartChars + "]");
var nonASCIIidentifier = new RegExp("[" + nonASCIIidentifierStartChars + nonASCIIidentifierChars + "]");
function isInAstralSet(code, set3) {
  var pos = 65536;
  for (var i = 0;i < set3.length; i += 2) {
    pos += set3[i];
    if (pos > code) {
      return false;
    }
    pos += set3[i + 1];
    if (pos >= code) {
      return true;
    }
  }
  return false;
}
function isIdentifierStart(code, astral) {
  if (code < 65) {
    return code === 36;
  }
  if (code < 91) {
    return true;
  }
  if (code < 97) {
    return code === 95;
  }
  if (code < 123) {
    return true;
  }
  if (code <= 65535) {
    return code >= 170 && nonASCIIidentifierStart.test(String.fromCharCode(code));
  }
  if (astral === false) {
    return false;
  }
  return isInAstralSet(code, astralIdentifierStartCodes);
}
function isIdentifierChar(code, astral) {
  if (code < 48) {
    return code === 36;
  }
  if (code < 58) {
    return true;
  }
  if (code < 65) {
    return false;
  }
  if (code < 91) {
    return true;
  }
  if (code < 97) {
    return code === 95;
  }
  if (code < 123) {
    return true;
  }
  if (code <= 65535) {
    return code >= 170 && nonASCIIidentifier.test(String.fromCharCode(code));
  }
  if (astral === false) {
    return false;
  }
  return isInAstralSet(code, astralIdentifierStartCodes) || isInAstralSet(code, astralIdentifierCodes);
}
var TokenType = function TokenType2(label, conf) {
  if (conf === undefined)
    conf = {};
  this.label = label;
  this.keyword = conf.keyword;
  this.beforeExpr = !!conf.beforeExpr;
  this.startsExpr = !!conf.startsExpr;
  this.isLoop = !!conf.isLoop;
  this.isAssign = !!conf.isAssign;
  this.prefix = !!conf.prefix;
  this.postfix = !!conf.postfix;
  this.binop = conf.binop || null;
  this.updateContext = null;
};
function binop(name, prec) {
  return new TokenType(name, { beforeExpr: true, binop: prec });
}
var beforeExpr = { beforeExpr: true };
var startsExpr = { startsExpr: true };
var keywords = {};
function kw(name, options2) {
  if (options2 === undefined)
    options2 = {};
  options2.keyword = name;
  return keywords[name] = new TokenType(name, options2);
}
var types$1 = {
  num: new TokenType("num", startsExpr),
  regexp: new TokenType("regexp", startsExpr),
  string: new TokenType("string", startsExpr),
  name: new TokenType("name", startsExpr),
  privateId: new TokenType("privateId", startsExpr),
  eof: new TokenType("eof"),
  bracketL: new TokenType("[", { beforeExpr: true, startsExpr: true }),
  bracketR: new TokenType("]"),
  braceL: new TokenType("{", { beforeExpr: true, startsExpr: true }),
  braceR: new TokenType("}"),
  parenL: new TokenType("(", { beforeExpr: true, startsExpr: true }),
  parenR: new TokenType(")"),
  comma: new TokenType(",", beforeExpr),
  semi: new TokenType(";", beforeExpr),
  colon: new TokenType(":", beforeExpr),
  dot: new TokenType("."),
  question: new TokenType("?", beforeExpr),
  questionDot: new TokenType("?."),
  arrow: new TokenType("=>", beforeExpr),
  template: new TokenType("template"),
  invalidTemplate: new TokenType("invalidTemplate"),
  ellipsis: new TokenType("...", beforeExpr),
  backQuote: new TokenType("`", startsExpr),
  dollarBraceL: new TokenType("${", { beforeExpr: true, startsExpr: true }),
  eq: new TokenType("=", { beforeExpr: true, isAssign: true }),
  assign: new TokenType("_=", { beforeExpr: true, isAssign: true }),
  incDec: new TokenType("++/--", { prefix: true, postfix: true, startsExpr: true }),
  prefix: new TokenType("!/~", { beforeExpr: true, prefix: true, startsExpr: true }),
  logicalOR: binop("||", 1),
  logicalAND: binop("&&", 2),
  bitwiseOR: binop("|", 3),
  bitwiseXOR: binop("^", 4),
  bitwiseAND: binop("&", 5),
  equality: binop("==/!=/===/!==", 6),
  relational: binop("</>/<=/>=", 7),
  bitShift: binop("<</>>/>>>", 8),
  plusMin: new TokenType("+/-", { beforeExpr: true, binop: 9, prefix: true, startsExpr: true }),
  modulo: binop("%", 10),
  star: binop("*", 10),
  slash: binop("/", 10),
  starstar: new TokenType("**", { beforeExpr: true }),
  coalesce: binop("??", 1),
  _break: kw("break"),
  _case: kw("case", beforeExpr),
  _catch: kw("catch"),
  _continue: kw("continue"),
  _debugger: kw("debugger"),
  _default: kw("default", beforeExpr),
  _do: kw("do", { isLoop: true, beforeExpr: true }),
  _else: kw("else", beforeExpr),
  _finally: kw("finally"),
  _for: kw("for", { isLoop: true }),
  _function: kw("function", startsExpr),
  _if: kw("if"),
  _return: kw("return", beforeExpr),
  _switch: kw("switch"),
  _throw: kw("throw", beforeExpr),
  _try: kw("try"),
  _var: kw("var"),
  _const: kw("const"),
  _while: kw("while", { isLoop: true }),
  _with: kw("with"),
  _new: kw("new", { beforeExpr: true, startsExpr: true }),
  _this: kw("this", startsExpr),
  _super: kw("super", startsExpr),
  _class: kw("class", startsExpr),
  _extends: kw("extends", beforeExpr),
  _export: kw("export"),
  _import: kw("import", startsExpr),
  _null: kw("null", startsExpr),
  _true: kw("true", startsExpr),
  _false: kw("false", startsExpr),
  _in: kw("in", { beforeExpr: true, binop: 7 }),
  _instanceof: kw("instanceof", { beforeExpr: true, binop: 7 }),
  _typeof: kw("typeof", { beforeExpr: true, prefix: true, startsExpr: true }),
  _void: kw("void", { beforeExpr: true, prefix: true, startsExpr: true }),
  _delete: kw("delete", { beforeExpr: true, prefix: true, startsExpr: true })
};
var lineBreak = /\r\n?|\n|\u2028|\u2029/;
var lineBreakG = new RegExp(lineBreak.source, "g");
function isNewLine(code) {
  return code === 10 || code === 13 || code === 8232 || code === 8233;
}
function nextLineBreak(code, from, end) {
  if (end === undefined)
    end = code.length;
  for (var i = from;i < end; i++) {
    var next = code.charCodeAt(i);
    if (isNewLine(next)) {
      return i < end - 1 && next === 13 && code.charCodeAt(i + 1) === 10 ? i + 2 : i + 1;
    }
  }
  return -1;
}
var nonASCIIwhitespace = /[\u1680\u2000-\u200a\u202f\u205f\u3000\ufeff]/;
var skipWhiteSpace = /(?:\s|\/\/.*|\/\*[^]*?\*\/)*/g;
var ref = Object.prototype;
var hasOwnProperty = ref.hasOwnProperty;
var toString = ref.toString;
var hasOwn = Object.hasOwn || function(obj, propName) {
  return hasOwnProperty.call(obj, propName);
};
var isArray = Array.isArray || function(obj) {
  return toString.call(obj) === "[object Array]";
};
var regexpCache = Object.create(null);
function wordsRegexp(words) {
  return regexpCache[words] || (regexpCache[words] = new RegExp("^(?:" + words.replace(/ /g, "|") + ")$"));
}
function codePointToString(code) {
  if (code <= 65535) {
    return String.fromCharCode(code);
  }
  code -= 65536;
  return String.fromCharCode((code >> 10) + 55296, (code & 1023) + 56320);
}
var loneSurrogate = /(?:[\uD800-\uDBFF](?![\uDC00-\uDFFF])|(?:[^\uD800-\uDBFF]|^)[\uDC00-\uDFFF])/;
var Position = function Position2(line, col) {
  this.line = line;
  this.column = col;
};
Position.prototype.offset = function offset(n2) {
  return new Position(this.line, this.column + n2);
};
var SourceLocation = function SourceLocation2(p2, start, end) {
  this.start = start;
  this.end = end;
  if (p2.sourceFile !== null) {
    this.source = p2.sourceFile;
  }
};
function getLineInfo(input, offset2) {
  for (var line = 1, cur = 0;; ) {
    var nextBreak = nextLineBreak(input, cur, offset2);
    if (nextBreak < 0) {
      return new Position(line, offset2 - cur);
    }
    ++line;
    cur = nextBreak;
  }
}
var defaultOptions = {
  ecmaVersion: null,
  sourceType: "script",
  onInsertedSemicolon: null,
  onTrailingComma: null,
  allowReserved: null,
  allowReturnOutsideFunction: false,
  allowImportExportEverywhere: false,
  allowAwaitOutsideFunction: null,
  allowSuperOutsideMethod: null,
  allowHashBang: false,
  checkPrivateFields: true,
  locations: false,
  onToken: null,
  onComment: null,
  ranges: false,
  program: null,
  sourceFile: null,
  directSourceFile: null,
  preserveParens: false
};
var warnedAboutEcmaVersion = false;
function getOptions(opts) {
  var options2 = {};
  for (var opt in defaultOptions) {
    options2[opt] = opts && hasOwn(opts, opt) ? opts[opt] : defaultOptions[opt];
  }
  if (options2.ecmaVersion === "latest") {
    options2.ecmaVersion = 1e8;
  } else if (options2.ecmaVersion == null) {
    if (!warnedAboutEcmaVersion && typeof console === "object" && console.warn) {
      warnedAboutEcmaVersion = true;
      console.warn(`Since Acorn 8.0.0, options.ecmaVersion is required.
Defaulting to 2020, but this will stop working in the future.`);
    }
    options2.ecmaVersion = 11;
  } else if (options2.ecmaVersion >= 2015) {
    options2.ecmaVersion -= 2009;
  }
  if (options2.allowReserved == null) {
    options2.allowReserved = options2.ecmaVersion < 5;
  }
  if (!opts || opts.allowHashBang == null) {
    options2.allowHashBang = options2.ecmaVersion >= 14;
  }
  if (isArray(options2.onToken)) {
    var tokens = options2.onToken;
    options2.onToken = function(token) {
      return tokens.push(token);
    };
  }
  if (isArray(options2.onComment)) {
    options2.onComment = pushComment(options2, options2.onComment);
  }
  return options2;
}
function pushComment(options2, array2) {
  return function(block, text, start, end, startLoc, endLoc) {
    var comment = {
      type: block ? "Block" : "Line",
      value: text,
      start,
      end
    };
    if (options2.locations) {
      comment.loc = new SourceLocation(this, startLoc, endLoc);
    }
    if (options2.ranges) {
      comment.range = [start, end];
    }
    array2.push(comment);
  };
}
var SCOPE_TOP = 1;
var SCOPE_FUNCTION = 2;
var SCOPE_ASYNC = 4;
var SCOPE_GENERATOR = 8;
var SCOPE_ARROW = 16;
var SCOPE_SIMPLE_CATCH = 32;
var SCOPE_SUPER = 64;
var SCOPE_DIRECT_SUPER = 128;
var SCOPE_CLASS_STATIC_BLOCK = 256;
var SCOPE_CLASS_FIELD_INIT = 512;
var SCOPE_VAR = SCOPE_TOP | SCOPE_FUNCTION | SCOPE_CLASS_STATIC_BLOCK;
function functionFlags(async, generator) {
  return SCOPE_FUNCTION | (async ? SCOPE_ASYNC : 0) | (generator ? SCOPE_GENERATOR : 0);
}
var BIND_NONE = 0;
var BIND_VAR = 1;
var BIND_LEXICAL = 2;
var BIND_FUNCTION = 3;
var BIND_SIMPLE_CATCH = 4;
var BIND_OUTSIDE = 5;
var Parser = function Parser2(options2, input, startPos) {
  this.options = options2 = getOptions(options2);
  this.sourceFile = options2.sourceFile;
  this.keywords = wordsRegexp(keywords$1[options2.ecmaVersion >= 6 ? 6 : options2.sourceType === "module" ? "5module" : 5]);
  var reserved = "";
  if (options2.allowReserved !== true) {
    reserved = reservedWords[options2.ecmaVersion >= 6 ? 6 : options2.ecmaVersion === 5 ? 5 : 3];
    if (options2.sourceType === "module") {
      reserved += " await";
    }
  }
  this.reservedWords = wordsRegexp(reserved);
  var reservedStrict = (reserved ? reserved + " " : "") + reservedWords.strict;
  this.reservedWordsStrict = wordsRegexp(reservedStrict);
  this.reservedWordsStrictBind = wordsRegexp(reservedStrict + " " + reservedWords.strictBind);
  this.input = String(input);
  this.containsEsc = false;
  if (startPos) {
    this.pos = startPos;
    this.lineStart = this.input.lastIndexOf(`
`, startPos - 1) + 1;
    this.curLine = this.input.slice(0, this.lineStart).split(lineBreak).length;
  } else {
    this.pos = this.lineStart = 0;
    this.curLine = 1;
  }
  this.type = types$1.eof;
  this.value = null;
  this.start = this.end = this.pos;
  this.startLoc = this.endLoc = this.curPosition();
  this.lastTokEndLoc = this.lastTokStartLoc = null;
  this.lastTokStart = this.lastTokEnd = this.pos;
  this.context = this.initialContext();
  this.exprAllowed = true;
  this.inModule = options2.sourceType === "module";
  this.strict = this.inModule || this.strictDirective(this.pos);
  this.potentialArrowAt = -1;
  this.potentialArrowInForAwait = false;
  this.yieldPos = this.awaitPos = this.awaitIdentPos = 0;
  this.labels = [];
  this.undefinedExports = Object.create(null);
  if (this.pos === 0 && options2.allowHashBang && this.input.slice(0, 2) === "#!") {
    this.skipLineComment(2);
  }
  this.scopeStack = [];
  this.enterScope(SCOPE_TOP);
  this.regexpState = null;
  this.privateNameStack = [];
};
var prototypeAccessors = { inFunction: { configurable: true }, inGenerator: { configurable: true }, inAsync: { configurable: true }, canAwait: { configurable: true }, allowSuper: { configurable: true }, allowDirectSuper: { configurable: true }, treatFunctionsAsVar: { configurable: true }, allowNewDotTarget: { configurable: true }, inClassStaticBlock: { configurable: true } };
Parser.prototype.parse = function parse7() {
  var node = this.options.program || this.startNode();
  this.nextToken();
  return this.parseTopLevel(node);
};
prototypeAccessors.inFunction.get = function() {
  return (this.currentVarScope().flags & SCOPE_FUNCTION) > 0;
};
prototypeAccessors.inGenerator.get = function() {
  return (this.currentVarScope().flags & SCOPE_GENERATOR) > 0;
};
prototypeAccessors.inAsync.get = function() {
  return (this.currentVarScope().flags & SCOPE_ASYNC) > 0;
};
prototypeAccessors.canAwait.get = function() {
  for (var i = this.scopeStack.length - 1;i >= 0; i--) {
    var ref2 = this.scopeStack[i];
    var flags = ref2.flags;
    if (flags & (SCOPE_CLASS_STATIC_BLOCK | SCOPE_CLASS_FIELD_INIT)) {
      return false;
    }
    if (flags & SCOPE_FUNCTION) {
      return (flags & SCOPE_ASYNC) > 0;
    }
  }
  return this.inModule && this.options.ecmaVersion >= 13 || this.options.allowAwaitOutsideFunction;
};
prototypeAccessors.allowSuper.get = function() {
  var ref2 = this.currentThisScope();
  var flags = ref2.flags;
  return (flags & SCOPE_SUPER) > 0 || this.options.allowSuperOutsideMethod;
};
prototypeAccessors.allowDirectSuper.get = function() {
  return (this.currentThisScope().flags & SCOPE_DIRECT_SUPER) > 0;
};
prototypeAccessors.treatFunctionsAsVar.get = function() {
  return this.treatFunctionsAsVarInScope(this.currentScope());
};
prototypeAccessors.allowNewDotTarget.get = function() {
  for (var i = this.scopeStack.length - 1;i >= 0; i--) {
    var ref2 = this.scopeStack[i];
    var flags = ref2.flags;
    if (flags & (SCOPE_CLASS_STATIC_BLOCK | SCOPE_CLASS_FIELD_INIT) || flags & SCOPE_FUNCTION && !(flags & SCOPE_ARROW)) {
      return true;
    }
  }
  return false;
};
prototypeAccessors.inClassStaticBlock.get = function() {
  return (this.currentVarScope().flags & SCOPE_CLASS_STATIC_BLOCK) > 0;
};
Parser.extend = function extend2() {
  var plugins = [], len = arguments.length;
  while (len--)
    plugins[len] = arguments[len];
  var cls = this;
  for (var i = 0;i < plugins.length; i++) {
    cls = plugins[i](cls);
  }
  return cls;
};
Parser.parse = function parse8(input, options2) {
  return new this(options2, input).parse();
};
Parser.parseExpressionAt = function parseExpressionAt(input, pos, options2) {
  var parser = new this(options2, input, pos);
  parser.nextToken();
  return parser.parseExpression();
};
Parser.tokenizer = function tokenizer(input, options2) {
  return new this(options2, input);
};
Object.defineProperties(Parser.prototype, prototypeAccessors);
var pp$9 = Parser.prototype;
var literal2 = /^(?:'((?:\\[^]|[^'\\])*?)'|"((?:\\[^]|[^"\\])*?)")/;
pp$9.strictDirective = function(start) {
  if (this.options.ecmaVersion < 5) {
    return false;
  }
  for (;; ) {
    skipWhiteSpace.lastIndex = start;
    start += skipWhiteSpace.exec(this.input)[0].length;
    var match = literal2.exec(this.input.slice(start));
    if (!match) {
      return false;
    }
    if ((match[1] || match[2]) === "use strict") {
      skipWhiteSpace.lastIndex = start + match[0].length;
      var spaceAfter = skipWhiteSpace.exec(this.input), end = spaceAfter.index + spaceAfter[0].length;
      var next = this.input.charAt(end);
      return next === ";" || next === "}" || lineBreak.test(spaceAfter[0]) && !(/[(`.[+\-/*%<>=,?^&]/.test(next) || next === "!" && this.input.charAt(end + 1) === "=");
    }
    start += match[0].length;
    skipWhiteSpace.lastIndex = start;
    start += skipWhiteSpace.exec(this.input)[0].length;
    if (this.input[start] === ";") {
      start++;
    }
  }
};
pp$9.eat = function(type2) {
  if (this.type === type2) {
    this.next();
    return true;
  } else {
    return false;
  }
};
pp$9.isContextual = function(name) {
  return this.type === types$1.name && this.value === name && !this.containsEsc;
};
pp$9.eatContextual = function(name) {
  if (!this.isContextual(name)) {
    return false;
  }
  this.next();
  return true;
};
pp$9.expectContextual = function(name) {
  if (!this.eatContextual(name)) {
    this.unexpected();
  }
};
pp$9.canInsertSemicolon = function() {
  return this.type === types$1.eof || this.type === types$1.braceR || lineBreak.test(this.input.slice(this.lastTokEnd, this.start));
};
pp$9.insertSemicolon = function() {
  if (this.canInsertSemicolon()) {
    if (this.options.onInsertedSemicolon) {
      this.options.onInsertedSemicolon(this.lastTokEnd, this.lastTokEndLoc);
    }
    return true;
  }
};
pp$9.semicolon = function() {
  if (!this.eat(types$1.semi) && !this.insertSemicolon()) {
    this.unexpected();
  }
};
pp$9.afterTrailingComma = function(tokType, notNext) {
  if (this.type === tokType) {
    if (this.options.onTrailingComma) {
      this.options.onTrailingComma(this.lastTokStart, this.lastTokStartLoc);
    }
    if (!notNext) {
      this.next();
    }
    return true;
  }
};
pp$9.expect = function(type2) {
  this.eat(type2) || this.unexpected();
};
pp$9.unexpected = function(pos) {
  this.raise(pos != null ? pos : this.start, "Unexpected token");
};
var DestructuringErrors = function DestructuringErrors2() {
  this.shorthandAssign = this.trailingComma = this.parenthesizedAssign = this.parenthesizedBind = this.doubleProto = -1;
};
pp$9.checkPatternErrors = function(refDestructuringErrors, isAssign) {
  if (!refDestructuringErrors) {
    return;
  }
  if (refDestructuringErrors.trailingComma > -1) {
    this.raiseRecoverable(refDestructuringErrors.trailingComma, "Comma is not permitted after the rest element");
  }
  var parens = isAssign ? refDestructuringErrors.parenthesizedAssign : refDestructuringErrors.parenthesizedBind;
  if (parens > -1) {
    this.raiseRecoverable(parens, isAssign ? "Assigning to rvalue" : "Parenthesized pattern");
  }
};
pp$9.checkExpressionErrors = function(refDestructuringErrors, andThrow) {
  if (!refDestructuringErrors) {
    return false;
  }
  var shorthandAssign = refDestructuringErrors.shorthandAssign;
  var doubleProto = refDestructuringErrors.doubleProto;
  if (!andThrow) {
    return shorthandAssign >= 0 || doubleProto >= 0;
  }
  if (shorthandAssign >= 0) {
    this.raise(shorthandAssign, "Shorthand property assignments are valid only in destructuring patterns");
  }
  if (doubleProto >= 0) {
    this.raiseRecoverable(doubleProto, "Redefinition of __proto__ property");
  }
};
pp$9.checkYieldAwaitInDefaultParams = function() {
  if (this.yieldPos && (!this.awaitPos || this.yieldPos < this.awaitPos)) {
    this.raise(this.yieldPos, "Yield expression cannot be a default value");
  }
  if (this.awaitPos) {
    this.raise(this.awaitPos, "Await expression cannot be a default value");
  }
};
pp$9.isSimpleAssignTarget = function(expr) {
  if (expr.type === "ParenthesizedExpression") {
    return this.isSimpleAssignTarget(expr.expression);
  }
  return expr.type === "Identifier" || expr.type === "MemberExpression";
};
var pp$8 = Parser.prototype;
pp$8.parseTopLevel = function(node) {
  var exports = Object.create(null);
  if (!node.body) {
    node.body = [];
  }
  while (this.type !== types$1.eof) {
    var stmt = this.parseStatement(null, true, exports);
    node.body.push(stmt);
  }
  if (this.inModule) {
    for (var i = 0, list = Object.keys(this.undefinedExports);i < list.length; i += 1) {
      var name = list[i];
      this.raiseRecoverable(this.undefinedExports[name].start, "Export '" + name + "' is not defined");
    }
  }
  this.adaptDirectivePrologue(node.body);
  this.next();
  node.sourceType = this.options.sourceType;
  return this.finishNode(node, "Program");
};
var loopLabel = { kind: "loop" };
var switchLabel = { kind: "switch" };
pp$8.isLet = function(context) {
  if (this.options.ecmaVersion < 6 || !this.isContextual("let")) {
    return false;
  }
  skipWhiteSpace.lastIndex = this.pos;
  var skip = skipWhiteSpace.exec(this.input);
  var next = this.pos + skip[0].length, nextCh = this.input.charCodeAt(next);
  if (nextCh === 91 || nextCh === 92) {
    return true;
  }
  if (context) {
    return false;
  }
  if (nextCh === 123 || nextCh > 55295 && nextCh < 56320) {
    return true;
  }
  if (isIdentifierStart(nextCh, true)) {
    var pos = next + 1;
    while (isIdentifierChar(nextCh = this.input.charCodeAt(pos), true)) {
      ++pos;
    }
    if (nextCh === 92 || nextCh > 55295 && nextCh < 56320) {
      return true;
    }
    var ident = this.input.slice(next, pos);
    if (!keywordRelationalOperator.test(ident)) {
      return true;
    }
  }
  return false;
};
pp$8.isAsyncFunction = function() {
  if (this.options.ecmaVersion < 8 || !this.isContextual("async")) {
    return false;
  }
  skipWhiteSpace.lastIndex = this.pos;
  var skip = skipWhiteSpace.exec(this.input);
  var next = this.pos + skip[0].length, after;
  return !lineBreak.test(this.input.slice(this.pos, next)) && this.input.slice(next, next + 8) === "function" && (next + 8 === this.input.length || !(isIdentifierChar(after = this.input.charCodeAt(next + 8)) || after > 55295 && after < 56320));
};
pp$8.isUsingKeyword = function(isAwaitUsing, isFor) {
  if (this.options.ecmaVersion < 17 || !this.isContextual(isAwaitUsing ? "await" : "using")) {
    return false;
  }
  skipWhiteSpace.lastIndex = this.pos;
  var skip = skipWhiteSpace.exec(this.input);
  var next = this.pos + skip[0].length;
  if (lineBreak.test(this.input.slice(this.pos, next))) {
    return false;
  }
  if (isAwaitUsing) {
    var awaitEndPos = next + 5, after;
    if (this.input.slice(next, awaitEndPos) !== "using" || awaitEndPos === this.input.length || isIdentifierChar(after = this.input.charCodeAt(awaitEndPos)) || after > 55295 && after < 56320) {
      return false;
    }
    skipWhiteSpace.lastIndex = awaitEndPos;
    var skipAfterUsing = skipWhiteSpace.exec(this.input);
    if (skipAfterUsing && lineBreak.test(this.input.slice(awaitEndPos, awaitEndPos + skipAfterUsing[0].length))) {
      return false;
    }
  }
  if (isFor) {
    var ofEndPos = next + 2, after$1;
    if (this.input.slice(next, ofEndPos) === "of") {
      if (ofEndPos === this.input.length || !isIdentifierChar(after$1 = this.input.charCodeAt(ofEndPos)) && !(after$1 > 55295 && after$1 < 56320)) {
        return false;
      }
    }
  }
  var ch = this.input.charCodeAt(next);
  return isIdentifierStart(ch, true) || ch === 92;
};
pp$8.isAwaitUsing = function(isFor) {
  return this.isUsingKeyword(true, isFor);
};
pp$8.isUsing = function(isFor) {
  return this.isUsingKeyword(false, isFor);
};
pp$8.parseStatement = function(context, topLevel, exports) {
  var starttype = this.type, node = this.startNode(), kind;
  if (this.isLet(context)) {
    starttype = types$1._var;
    kind = "let";
  }
  switch (starttype) {
    case types$1._break:
    case types$1._continue:
      return this.parseBreakContinueStatement(node, starttype.keyword);
    case types$1._debugger:
      return this.parseDebuggerStatement(node);
    case types$1._do:
      return this.parseDoStatement(node);
    case types$1._for:
      return this.parseForStatement(node);
    case types$1._function:
      if (context && (this.strict || context !== "if" && context !== "label") && this.options.ecmaVersion >= 6) {
        this.unexpected();
      }
      return this.parseFunctionStatement(node, false, !context);
    case types$1._class:
      if (context) {
        this.unexpected();
      }
      return this.parseClass(node, true);
    case types$1._if:
      return this.parseIfStatement(node);
    case types$1._return:
      return this.parseReturnStatement(node);
    case types$1._switch:
      return this.parseSwitchStatement(node);
    case types$1._throw:
      return this.parseThrowStatement(node);
    case types$1._try:
      return this.parseTryStatement(node);
    case types$1._const:
    case types$1._var:
      kind = kind || this.value;
      if (context && kind !== "var") {
        this.unexpected();
      }
      return this.parseVarStatement(node, kind);
    case types$1._while:
      return this.parseWhileStatement(node);
    case types$1._with:
      return this.parseWithStatement(node);
    case types$1.braceL:
      return this.parseBlock(true, node);
    case types$1.semi:
      return this.parseEmptyStatement(node);
    case types$1._export:
    case types$1._import:
      if (this.options.ecmaVersion > 10 && starttype === types$1._import) {
        skipWhiteSpace.lastIndex = this.pos;
        var skip = skipWhiteSpace.exec(this.input);
        var next = this.pos + skip[0].length, nextCh = this.input.charCodeAt(next);
        if (nextCh === 40 || nextCh === 46) {
          return this.parseExpressionStatement(node, this.parseExpression());
        }
      }
      if (!this.options.allowImportExportEverywhere) {
        if (!topLevel) {
          this.raise(this.start, "'import' and 'export' may only appear at the top level");
        }
        if (!this.inModule) {
          this.raise(this.start, "'import' and 'export' may appear only with 'sourceType: module'");
        }
      }
      return starttype === types$1._import ? this.parseImport(node) : this.parseExport(node, exports);
    default:
      if (this.isAsyncFunction()) {
        if (context) {
          this.unexpected();
        }
        this.next();
        return this.parseFunctionStatement(node, true, !context);
      }
      var usingKind = this.isAwaitUsing(false) ? "await using" : this.isUsing(false) ? "using" : null;
      if (usingKind) {
        if (topLevel && this.options.sourceType === "script") {
          this.raise(this.start, "Using declaration cannot appear in the top level when source type is `script`");
        }
        if (usingKind === "await using") {
          if (!this.canAwait) {
            this.raise(this.start, "Await using cannot appear outside of async function");
          }
          this.next();
        }
        this.next();
        this.parseVar(node, false, usingKind);
        this.semicolon();
        return this.finishNode(node, "VariableDeclaration");
      }
      var maybeName = this.value, expr = this.parseExpression();
      if (starttype === types$1.name && expr.type === "Identifier" && this.eat(types$1.colon)) {
        return this.parseLabeledStatement(node, maybeName, expr, context);
      } else {
        return this.parseExpressionStatement(node, expr);
      }
  }
};
pp$8.parseBreakContinueStatement = function(node, keyword) {
  var isBreak = keyword === "break";
  this.next();
  if (this.eat(types$1.semi) || this.insertSemicolon()) {
    node.label = null;
  } else if (this.type !== types$1.name) {
    this.unexpected();
  } else {
    node.label = this.parseIdent();
    this.semicolon();
  }
  var i = 0;
  for (;i < this.labels.length; ++i) {
    var lab = this.labels[i];
    if (node.label == null || lab.name === node.label.name) {
      if (lab.kind != null && (isBreak || lab.kind === "loop")) {
        break;
      }
      if (node.label && isBreak) {
        break;
      }
    }
  }
  if (i === this.labels.length) {
    this.raise(node.start, "Unsyntactic " + keyword);
  }
  return this.finishNode(node, isBreak ? "BreakStatement" : "ContinueStatement");
};
pp$8.parseDebuggerStatement = function(node) {
  this.next();
  this.semicolon();
  return this.finishNode(node, "DebuggerStatement");
};
pp$8.parseDoStatement = function(node) {
  this.next();
  this.labels.push(loopLabel);
  node.body = this.parseStatement("do");
  this.labels.pop();
  this.expect(types$1._while);
  node.test = this.parseParenExpression();
  if (this.options.ecmaVersion >= 6) {
    this.eat(types$1.semi);
  } else {
    this.semicolon();
  }
  return this.finishNode(node, "DoWhileStatement");
};
pp$8.parseForStatement = function(node) {
  this.next();
  var awaitAt = this.options.ecmaVersion >= 9 && this.canAwait && this.eatContextual("await") ? this.lastTokStart : -1;
  this.labels.push(loopLabel);
  this.enterScope(0);
  this.expect(types$1.parenL);
  if (this.type === types$1.semi) {
    if (awaitAt > -1) {
      this.unexpected(awaitAt);
    }
    return this.parseFor(node, null);
  }
  var isLet = this.isLet();
  if (this.type === types$1._var || this.type === types$1._const || isLet) {
    var init$1 = this.startNode(), kind = isLet ? "let" : this.value;
    this.next();
    this.parseVar(init$1, true, kind);
    this.finishNode(init$1, "VariableDeclaration");
    return this.parseForAfterInit(node, init$1, awaitAt);
  }
  var startsWithLet = this.isContextual("let"), isForOf = false;
  var usingKind = this.isUsing(true) ? "using" : this.isAwaitUsing(true) ? "await using" : null;
  if (usingKind) {
    var init$2 = this.startNode();
    this.next();
    if (usingKind === "await using") {
      this.next();
    }
    this.parseVar(init$2, true, usingKind);
    this.finishNode(init$2, "VariableDeclaration");
    return this.parseForAfterInit(node, init$2, awaitAt);
  }
  var containsEsc = this.containsEsc;
  var refDestructuringErrors = new DestructuringErrors;
  var initPos = this.start;
  var init = awaitAt > -1 ? this.parseExprSubscripts(refDestructuringErrors, "await") : this.parseExpression(true, refDestructuringErrors);
  if (this.type === types$1._in || (isForOf = this.options.ecmaVersion >= 6 && this.isContextual("of"))) {
    if (awaitAt > -1) {
      if (this.type === types$1._in) {
        this.unexpected(awaitAt);
      }
      node.await = true;
    } else if (isForOf && this.options.ecmaVersion >= 8) {
      if (init.start === initPos && !containsEsc && init.type === "Identifier" && init.name === "async") {
        this.unexpected();
      } else if (this.options.ecmaVersion >= 9) {
        node.await = false;
      }
    }
    if (startsWithLet && isForOf) {
      this.raise(init.start, "The left-hand side of a for-of loop may not start with 'let'.");
    }
    this.toAssignable(init, false, refDestructuringErrors);
    this.checkLValPattern(init);
    return this.parseForIn(node, init);
  } else {
    this.checkExpressionErrors(refDestructuringErrors, true);
  }
  if (awaitAt > -1) {
    this.unexpected(awaitAt);
  }
  return this.parseFor(node, init);
};
pp$8.parseForAfterInit = function(node, init, awaitAt) {
  if ((this.type === types$1._in || this.options.ecmaVersion >= 6 && this.isContextual("of")) && init.declarations.length === 1) {
    if (this.options.ecmaVersion >= 9) {
      if (this.type === types$1._in) {
        if (awaitAt > -1) {
          this.unexpected(awaitAt);
        }
      } else {
        node.await = awaitAt > -1;
      }
    }
    return this.parseForIn(node, init);
  }
  if (awaitAt > -1) {
    this.unexpected(awaitAt);
  }
  return this.parseFor(node, init);
};
pp$8.parseFunctionStatement = function(node, isAsync, declarationPosition) {
  this.next();
  return this.parseFunction(node, FUNC_STATEMENT | (declarationPosition ? 0 : FUNC_HANGING_STATEMENT), false, isAsync);
};
pp$8.parseIfStatement = function(node) {
  this.next();
  node.test = this.parseParenExpression();
  node.consequent = this.parseStatement("if");
  node.alternate = this.eat(types$1._else) ? this.parseStatement("if") : null;
  return this.finishNode(node, "IfStatement");
};
pp$8.parseReturnStatement = function(node) {
  if (!this.inFunction && !this.options.allowReturnOutsideFunction) {
    this.raise(this.start, "'return' outside of function");
  }
  this.next();
  if (this.eat(types$1.semi) || this.insertSemicolon()) {
    node.argument = null;
  } else {
    node.argument = this.parseExpression();
    this.semicolon();
  }
  return this.finishNode(node, "ReturnStatement");
};
pp$8.parseSwitchStatement = function(node) {
  this.next();
  node.discriminant = this.parseParenExpression();
  node.cases = [];
  this.expect(types$1.braceL);
  this.labels.push(switchLabel);
  this.enterScope(0);
  var cur;
  for (var sawDefault = false;this.type !== types$1.braceR; ) {
    if (this.type === types$1._case || this.type === types$1._default) {
      var isCase = this.type === types$1._case;
      if (cur) {
        this.finishNode(cur, "SwitchCase");
      }
      node.cases.push(cur = this.startNode());
      cur.consequent = [];
      this.next();
      if (isCase) {
        cur.test = this.parseExpression();
      } else {
        if (sawDefault) {
          this.raiseRecoverable(this.lastTokStart, "Multiple default clauses");
        }
        sawDefault = true;
        cur.test = null;
      }
      this.expect(types$1.colon);
    } else {
      if (!cur) {
        this.unexpected();
      }
      cur.consequent.push(this.parseStatement(null));
    }
  }
  this.exitScope();
  if (cur) {
    this.finishNode(cur, "SwitchCase");
  }
  this.next();
  this.labels.pop();
  return this.finishNode(node, "SwitchStatement");
};
pp$8.parseThrowStatement = function(node) {
  this.next();
  if (lineBreak.test(this.input.slice(this.lastTokEnd, this.start))) {
    this.raise(this.lastTokEnd, "Illegal newline after throw");
  }
  node.argument = this.parseExpression();
  this.semicolon();
  return this.finishNode(node, "ThrowStatement");
};
var empty$1 = [];
pp$8.parseCatchClauseParam = function() {
  var param = this.parseBindingAtom();
  var simple = param.type === "Identifier";
  this.enterScope(simple ? SCOPE_SIMPLE_CATCH : 0);
  this.checkLValPattern(param, simple ? BIND_SIMPLE_CATCH : BIND_LEXICAL);
  this.expect(types$1.parenR);
  return param;
};
pp$8.parseTryStatement = function(node) {
  this.next();
  node.block = this.parseBlock();
  node.handler = null;
  if (this.type === types$1._catch) {
    var clause = this.startNode();
    this.next();
    if (this.eat(types$1.parenL)) {
      clause.param = this.parseCatchClauseParam();
    } else {
      if (this.options.ecmaVersion < 10) {
        this.unexpected();
      }
      clause.param = null;
      this.enterScope(0);
    }
    clause.body = this.parseBlock(false);
    this.exitScope();
    node.handler = this.finishNode(clause, "CatchClause");
  }
  node.finalizer = this.eat(types$1._finally) ? this.parseBlock() : null;
  if (!node.handler && !node.finalizer) {
    this.raise(node.start, "Missing catch or finally clause");
  }
  return this.finishNode(node, "TryStatement");
};
pp$8.parseVarStatement = function(node, kind, allowMissingInitializer) {
  this.next();
  this.parseVar(node, false, kind, allowMissingInitializer);
  this.semicolon();
  return this.finishNode(node, "VariableDeclaration");
};
pp$8.parseWhileStatement = function(node) {
  this.next();
  node.test = this.parseParenExpression();
  this.labels.push(loopLabel);
  node.body = this.parseStatement("while");
  this.labels.pop();
  return this.finishNode(node, "WhileStatement");
};
pp$8.parseWithStatement = function(node) {
  if (this.strict) {
    this.raise(this.start, "'with' in strict mode");
  }
  this.next();
  node.object = this.parseParenExpression();
  node.body = this.parseStatement("with");
  return this.finishNode(node, "WithStatement");
};
pp$8.parseEmptyStatement = function(node) {
  this.next();
  return this.finishNode(node, "EmptyStatement");
};
pp$8.parseLabeledStatement = function(node, maybeName, expr, context) {
  for (var i$1 = 0, list = this.labels;i$1 < list.length; i$1 += 1) {
    var label = list[i$1];
    if (label.name === maybeName) {
      this.raise(expr.start, "Label '" + maybeName + "' is already declared");
    }
  }
  var kind = this.type.isLoop ? "loop" : this.type === types$1._switch ? "switch" : null;
  for (var i = this.labels.length - 1;i >= 0; i--) {
    var label$1 = this.labels[i];
    if (label$1.statementStart === node.start) {
      label$1.statementStart = this.start;
      label$1.kind = kind;
    } else {
      break;
    }
  }
  this.labels.push({ name: maybeName, kind, statementStart: this.start });
  node.body = this.parseStatement(context ? context.indexOf("label") === -1 ? context + "label" : context : "label");
  this.labels.pop();
  node.label = expr;
  return this.finishNode(node, "LabeledStatement");
};
pp$8.parseExpressionStatement = function(node, expr) {
  node.expression = expr;
  this.semicolon();
  return this.finishNode(node, "ExpressionStatement");
};
pp$8.parseBlock = function(createNewLexicalScope, node, exitStrict) {
  if (createNewLexicalScope === undefined)
    createNewLexicalScope = true;
  if (node === undefined)
    node = this.startNode();
  node.body = [];
  this.expect(types$1.braceL);
  if (createNewLexicalScope) {
    this.enterScope(0);
  }
  while (this.type !== types$1.braceR) {
    var stmt = this.parseStatement(null);
    node.body.push(stmt);
  }
  if (exitStrict) {
    this.strict = false;
  }
  this.next();
  if (createNewLexicalScope) {
    this.exitScope();
  }
  return this.finishNode(node, "BlockStatement");
};
pp$8.parseFor = function(node, init) {
  node.init = init;
  this.expect(types$1.semi);
  node.test = this.type === types$1.semi ? null : this.parseExpression();
  this.expect(types$1.semi);
  node.update = this.type === types$1.parenR ? null : this.parseExpression();
  this.expect(types$1.parenR);
  node.body = this.parseStatement("for");
  this.exitScope();
  this.labels.pop();
  return this.finishNode(node, "ForStatement");
};
pp$8.parseForIn = function(node, init) {
  var isForIn = this.type === types$1._in;
  this.next();
  if (init.type === "VariableDeclaration" && init.declarations[0].init != null && (!isForIn || this.options.ecmaVersion < 8 || this.strict || init.kind !== "var" || init.declarations[0].id.type !== "Identifier")) {
    this.raise(init.start, (isForIn ? "for-in" : "for-of") + " loop variable declaration may not have an initializer");
  }
  node.left = init;
  node.right = isForIn ? this.parseExpression() : this.parseMaybeAssign();
  this.expect(types$1.parenR);
  node.body = this.parseStatement("for");
  this.exitScope();
  this.labels.pop();
  return this.finishNode(node, isForIn ? "ForInStatement" : "ForOfStatement");
};
pp$8.parseVar = function(node, isFor, kind, allowMissingInitializer) {
  node.declarations = [];
  node.kind = kind;
  for (;; ) {
    var decl = this.startNode();
    this.parseVarId(decl, kind);
    if (this.eat(types$1.eq)) {
      decl.init = this.parseMaybeAssign(isFor);
    } else if (!allowMissingInitializer && kind === "const" && !(this.type === types$1._in || this.options.ecmaVersion >= 6 && this.isContextual("of"))) {
      this.unexpected();
    } else if (!allowMissingInitializer && (kind === "using" || kind === "await using") && this.options.ecmaVersion >= 17 && this.type !== types$1._in && !this.isContextual("of")) {
      this.raise(this.lastTokEnd, "Missing initializer in " + kind + " declaration");
    } else if (!allowMissingInitializer && decl.id.type !== "Identifier" && !(isFor && (this.type === types$1._in || this.isContextual("of")))) {
      this.raise(this.lastTokEnd, "Complex binding patterns require an initialization value");
    } else {
      decl.init = null;
    }
    node.declarations.push(this.finishNode(decl, "VariableDeclarator"));
    if (!this.eat(types$1.comma)) {
      break;
    }
  }
  return node;
};
pp$8.parseVarId = function(decl, kind) {
  decl.id = kind === "using" || kind === "await using" ? this.parseIdent() : this.parseBindingAtom();
  this.checkLValPattern(decl.id, kind === "var" ? BIND_VAR : BIND_LEXICAL, false);
};
var FUNC_STATEMENT = 1;
var FUNC_HANGING_STATEMENT = 2;
var FUNC_NULLABLE_ID = 4;
pp$8.parseFunction = function(node, statement, allowExpressionBody, isAsync, forInit) {
  this.initFunction(node);
  if (this.options.ecmaVersion >= 9 || this.options.ecmaVersion >= 6 && !isAsync) {
    if (this.type === types$1.star && statement & FUNC_HANGING_STATEMENT) {
      this.unexpected();
    }
    node.generator = this.eat(types$1.star);
  }
  if (this.options.ecmaVersion >= 8) {
    node.async = !!isAsync;
  }
  if (statement & FUNC_STATEMENT) {
    node.id = statement & FUNC_NULLABLE_ID && this.type !== types$1.name ? null : this.parseIdent();
    if (node.id && !(statement & FUNC_HANGING_STATEMENT)) {
      this.checkLValSimple(node.id, this.strict || node.generator || node.async ? this.treatFunctionsAsVar ? BIND_VAR : BIND_LEXICAL : BIND_FUNCTION);
    }
  }
  var oldYieldPos = this.yieldPos, oldAwaitPos = this.awaitPos, oldAwaitIdentPos = this.awaitIdentPos;
  this.yieldPos = 0;
  this.awaitPos = 0;
  this.awaitIdentPos = 0;
  this.enterScope(functionFlags(node.async, node.generator));
  if (!(statement & FUNC_STATEMENT)) {
    node.id = this.type === types$1.name ? this.parseIdent() : null;
  }
  this.parseFunctionParams(node);
  this.parseFunctionBody(node, allowExpressionBody, false, forInit);
  this.yieldPos = oldYieldPos;
  this.awaitPos = oldAwaitPos;
  this.awaitIdentPos = oldAwaitIdentPos;
  return this.finishNode(node, statement & FUNC_STATEMENT ? "FunctionDeclaration" : "FunctionExpression");
};
pp$8.parseFunctionParams = function(node) {
  this.expect(types$1.parenL);
  node.params = this.parseBindingList(types$1.parenR, false, this.options.ecmaVersion >= 8);
  this.checkYieldAwaitInDefaultParams();
};
pp$8.parseClass = function(node, isStatement) {
  this.next();
  var oldStrict = this.strict;
  this.strict = true;
  this.parseClassId(node, isStatement);
  this.parseClassSuper(node);
  var privateNameMap = this.enterClassBody();
  var classBody = this.startNode();
  var hadConstructor = false;
  classBody.body = [];
  this.expect(types$1.braceL);
  while (this.type !== types$1.braceR) {
    var element2 = this.parseClassElement(node.superClass !== null);
    if (element2) {
      classBody.body.push(element2);
      if (element2.type === "MethodDefinition" && element2.kind === "constructor") {
        if (hadConstructor) {
          this.raiseRecoverable(element2.start, "Duplicate constructor in the same class");
        }
        hadConstructor = true;
      } else if (element2.key && element2.key.type === "PrivateIdentifier" && isPrivateNameConflicted(privateNameMap, element2)) {
        this.raiseRecoverable(element2.key.start, "Identifier '#" + element2.key.name + "' has already been declared");
      }
    }
  }
  this.strict = oldStrict;
  this.next();
  node.body = this.finishNode(classBody, "ClassBody");
  this.exitClassBody();
  return this.finishNode(node, isStatement ? "ClassDeclaration" : "ClassExpression");
};
pp$8.parseClassElement = function(constructorAllowsSuper) {
  if (this.eat(types$1.semi)) {
    return null;
  }
  var ecmaVersion = this.options.ecmaVersion;
  var node = this.startNode();
  var keyName = "";
  var isGenerator = false;
  var isAsync = false;
  var kind = "method";
  var isStatic = false;
  if (this.eatContextual("static")) {
    if (ecmaVersion >= 13 && this.eat(types$1.braceL)) {
      this.parseClassStaticBlock(node);
      return node;
    }
    if (this.isClassElementNameStart() || this.type === types$1.star) {
      isStatic = true;
    } else {
      keyName = "static";
    }
  }
  node.static = isStatic;
  if (!keyName && ecmaVersion >= 8 && this.eatContextual("async")) {
    if ((this.isClassElementNameStart() || this.type === types$1.star) && !this.canInsertSemicolon()) {
      isAsync = true;
    } else {
      keyName = "async";
    }
  }
  if (!keyName && (ecmaVersion >= 9 || !isAsync) && this.eat(types$1.star)) {
    isGenerator = true;
  }
  if (!keyName && !isAsync && !isGenerator) {
    var lastValue = this.value;
    if (this.eatContextual("get") || this.eatContextual("set")) {
      if (this.isClassElementNameStart()) {
        kind = lastValue;
      } else {
        keyName = lastValue;
      }
    }
  }
  if (keyName) {
    node.computed = false;
    node.key = this.startNodeAt(this.lastTokStart, this.lastTokStartLoc);
    node.key.name = keyName;
    this.finishNode(node.key, "Identifier");
  } else {
    this.parseClassElementName(node);
  }
  if (ecmaVersion < 13 || this.type === types$1.parenL || kind !== "method" || isGenerator || isAsync) {
    var isConstructor = !node.static && checkKeyName(node, "constructor");
    var allowsDirectSuper = isConstructor && constructorAllowsSuper;
    if (isConstructor && kind !== "method") {
      this.raise(node.key.start, "Constructor can't have get/set modifier");
    }
    node.kind = isConstructor ? "constructor" : kind;
    this.parseClassMethod(node, isGenerator, isAsync, allowsDirectSuper);
  } else {
    this.parseClassField(node);
  }
  return node;
};
pp$8.isClassElementNameStart = function() {
  return this.type === types$1.name || this.type === types$1.privateId || this.type === types$1.num || this.type === types$1.string || this.type === types$1.bracketL || this.type.keyword;
};
pp$8.parseClassElementName = function(element2) {
  if (this.type === types$1.privateId) {
    if (this.value === "constructor") {
      this.raise(this.start, "Classes can't have an element named '#constructor'");
    }
    element2.computed = false;
    element2.key = this.parsePrivateIdent();
  } else {
    this.parsePropertyName(element2);
  }
};
pp$8.parseClassMethod = function(method, isGenerator, isAsync, allowsDirectSuper) {
  var key = method.key;
  if (method.kind === "constructor") {
    if (isGenerator) {
      this.raise(key.start, "Constructor can't be a generator");
    }
    if (isAsync) {
      this.raise(key.start, "Constructor can't be an async method");
    }
  } else if (method.static && checkKeyName(method, "prototype")) {
    this.raise(key.start, "Classes may not have a static property named prototype");
  }
  var value = method.value = this.parseMethod(isGenerator, isAsync, allowsDirectSuper);
  if (method.kind === "get" && value.params.length !== 0) {
    this.raiseRecoverable(value.start, "getter should have no params");
  }
  if (method.kind === "set" && value.params.length !== 1) {
    this.raiseRecoverable(value.start, "setter should have exactly one param");
  }
  if (method.kind === "set" && value.params[0].type === "RestElement") {
    this.raiseRecoverable(value.params[0].start, "Setter cannot use rest params");
  }
  return this.finishNode(method, "MethodDefinition");
};
pp$8.parseClassField = function(field) {
  if (checkKeyName(field, "constructor")) {
    this.raise(field.key.start, "Classes can't have a field named 'constructor'");
  } else if (field.static && checkKeyName(field, "prototype")) {
    this.raise(field.key.start, "Classes can't have a static field named 'prototype'");
  }
  if (this.eat(types$1.eq)) {
    this.enterScope(SCOPE_CLASS_FIELD_INIT | SCOPE_SUPER);
    field.value = this.parseMaybeAssign();
    this.exitScope();
  } else {
    field.value = null;
  }
  this.semicolon();
  return this.finishNode(field, "PropertyDefinition");
};
pp$8.parseClassStaticBlock = function(node) {
  node.body = [];
  var oldLabels = this.labels;
  this.labels = [];
  this.enterScope(SCOPE_CLASS_STATIC_BLOCK | SCOPE_SUPER);
  while (this.type !== types$1.braceR) {
    var stmt = this.parseStatement(null);
    node.body.push(stmt);
  }
  this.next();
  this.exitScope();
  this.labels = oldLabels;
  return this.finishNode(node, "StaticBlock");
};
pp$8.parseClassId = function(node, isStatement) {
  if (this.type === types$1.name) {
    node.id = this.parseIdent();
    if (isStatement) {
      this.checkLValSimple(node.id, BIND_LEXICAL, false);
    }
  } else {
    if (isStatement === true) {
      this.unexpected();
    }
    node.id = null;
  }
};
pp$8.parseClassSuper = function(node) {
  node.superClass = this.eat(types$1._extends) ? this.parseExprSubscripts(null, false) : null;
};
pp$8.enterClassBody = function() {
  var element2 = { declared: Object.create(null), used: [] };
  this.privateNameStack.push(element2);
  return element2.declared;
};
pp$8.exitClassBody = function() {
  var ref2 = this.privateNameStack.pop();
  var declared = ref2.declared;
  var used = ref2.used;
  if (!this.options.checkPrivateFields) {
    return;
  }
  var len = this.privateNameStack.length;
  var parent = len === 0 ? null : this.privateNameStack[len - 1];
  for (var i = 0;i < used.length; ++i) {
    var id = used[i];
    if (!hasOwn(declared, id.name)) {
      if (parent) {
        parent.used.push(id);
      } else {
        this.raiseRecoverable(id.start, "Private field '#" + id.name + "' must be declared in an enclosing class");
      }
    }
  }
};
function isPrivateNameConflicted(privateNameMap, element2) {
  var name = element2.key.name;
  var curr = privateNameMap[name];
  var next = "true";
  if (element2.type === "MethodDefinition" && (element2.kind === "get" || element2.kind === "set")) {
    next = (element2.static ? "s" : "i") + element2.kind;
  }
  if (curr === "iget" && next === "iset" || curr === "iset" && next === "iget" || curr === "sget" && next === "sset" || curr === "sset" && next === "sget") {
    privateNameMap[name] = "true";
    return false;
  } else if (!curr) {
    privateNameMap[name] = next;
    return false;
  } else {
    return true;
  }
}
function checkKeyName(node, name) {
  var computed = node.computed;
  var key = node.key;
  return !computed && (key.type === "Identifier" && key.name === name || key.type === "Literal" && key.value === name);
}
pp$8.parseExportAllDeclaration = function(node, exports) {
  if (this.options.ecmaVersion >= 11) {
    if (this.eatContextual("as")) {
      node.exported = this.parseModuleExportName();
      this.checkExport(exports, node.exported, this.lastTokStart);
    } else {
      node.exported = null;
    }
  }
  this.expectContextual("from");
  if (this.type !== types$1.string) {
    this.unexpected();
  }
  node.source = this.parseExprAtom();
  if (this.options.ecmaVersion >= 16) {
    node.attributes = this.parseWithClause();
  }
  this.semicolon();
  return this.finishNode(node, "ExportAllDeclaration");
};
pp$8.parseExport = function(node, exports) {
  this.next();
  if (this.eat(types$1.star)) {
    return this.parseExportAllDeclaration(node, exports);
  }
  if (this.eat(types$1._default)) {
    this.checkExport(exports, "default", this.lastTokStart);
    node.declaration = this.parseExportDefaultDeclaration();
    return this.finishNode(node, "ExportDefaultDeclaration");
  }
  if (this.shouldParseExportStatement()) {
    node.declaration = this.parseExportDeclaration(node);
    if (node.declaration.type === "VariableDeclaration") {
      this.checkVariableExport(exports, node.declaration.declarations);
    } else {
      this.checkExport(exports, node.declaration.id, node.declaration.id.start);
    }
    node.specifiers = [];
    node.source = null;
    if (this.options.ecmaVersion >= 16) {
      node.attributes = [];
    }
  } else {
    node.declaration = null;
    node.specifiers = this.parseExportSpecifiers(exports);
    if (this.eatContextual("from")) {
      if (this.type !== types$1.string) {
        this.unexpected();
      }
      node.source = this.parseExprAtom();
      if (this.options.ecmaVersion >= 16) {
        node.attributes = this.parseWithClause();
      }
    } else {
      for (var i = 0, list = node.specifiers;i < list.length; i += 1) {
        var spec = list[i];
        this.checkUnreserved(spec.local);
        this.checkLocalExport(spec.local);
        if (spec.local.type === "Literal") {
          this.raise(spec.local.start, "A string literal cannot be used as an exported binding without `from`.");
        }
      }
      node.source = null;
      if (this.options.ecmaVersion >= 16) {
        node.attributes = [];
      }
    }
    this.semicolon();
  }
  return this.finishNode(node, "ExportNamedDeclaration");
};
pp$8.parseExportDeclaration = function(node) {
  return this.parseStatement(null);
};
pp$8.parseExportDefaultDeclaration = function() {
  var isAsync;
  if (this.type === types$1._function || (isAsync = this.isAsyncFunction())) {
    var fNode = this.startNode();
    this.next();
    if (isAsync) {
      this.next();
    }
    return this.parseFunction(fNode, FUNC_STATEMENT | FUNC_NULLABLE_ID, false, isAsync);
  } else if (this.type === types$1._class) {
    var cNode = this.startNode();
    return this.parseClass(cNode, "nullableID");
  } else {
    var declaration = this.parseMaybeAssign();
    this.semicolon();
    return declaration;
  }
};
pp$8.checkExport = function(exports, name, pos) {
  if (!exports) {
    return;
  }
  if (typeof name !== "string") {
    name = name.type === "Identifier" ? name.name : name.value;
  }
  if (hasOwn(exports, name)) {
    this.raiseRecoverable(pos, "Duplicate export '" + name + "'");
  }
  exports[name] = true;
};
pp$8.checkPatternExport = function(exports, pat) {
  var type2 = pat.type;
  if (type2 === "Identifier") {
    this.checkExport(exports, pat, pat.start);
  } else if (type2 === "ObjectPattern") {
    for (var i = 0, list = pat.properties;i < list.length; i += 1) {
      var prop = list[i];
      this.checkPatternExport(exports, prop);
    }
  } else if (type2 === "ArrayPattern") {
    for (var i$1 = 0, list$1 = pat.elements;i$1 < list$1.length; i$1 += 1) {
      var elt = list$1[i$1];
      if (elt) {
        this.checkPatternExport(exports, elt);
      }
    }
  } else if (type2 === "Property") {
    this.checkPatternExport(exports, pat.value);
  } else if (type2 === "AssignmentPattern") {
    this.checkPatternExport(exports, pat.left);
  } else if (type2 === "RestElement") {
    this.checkPatternExport(exports, pat.argument);
  }
};
pp$8.checkVariableExport = function(exports, decls) {
  if (!exports) {
    return;
  }
  for (var i = 0, list = decls;i < list.length; i += 1) {
    var decl = list[i];
    this.checkPatternExport(exports, decl.id);
  }
};
pp$8.shouldParseExportStatement = function() {
  return this.type.keyword === "var" || this.type.keyword === "const" || this.type.keyword === "class" || this.type.keyword === "function" || this.isLet() || this.isAsyncFunction();
};
pp$8.parseExportSpecifier = function(exports) {
  var node = this.startNode();
  node.local = this.parseModuleExportName();
  node.exported = this.eatContextual("as") ? this.parseModuleExportName() : node.local;
  this.checkExport(exports, node.exported, node.exported.start);
  return this.finishNode(node, "ExportSpecifier");
};
pp$8.parseExportSpecifiers = function(exports) {
  var nodes = [], first = true;
  this.expect(types$1.braceL);
  while (!this.eat(types$1.braceR)) {
    if (!first) {
      this.expect(types$1.comma);
      if (this.afterTrailingComma(types$1.braceR)) {
        break;
      }
    } else {
      first = false;
    }
    nodes.push(this.parseExportSpecifier(exports));
  }
  return nodes;
};
pp$8.parseImport = function(node) {
  this.next();
  if (this.type === types$1.string) {
    node.specifiers = empty$1;
    node.source = this.parseExprAtom();
  } else {
    node.specifiers = this.parseImportSpecifiers();
    this.expectContextual("from");
    node.source = this.type === types$1.string ? this.parseExprAtom() : this.unexpected();
  }
  if (this.options.ecmaVersion >= 16) {
    node.attributes = this.parseWithClause();
  }
  this.semicolon();
  return this.finishNode(node, "ImportDeclaration");
};
pp$8.parseImportSpecifier = function() {
  var node = this.startNode();
  node.imported = this.parseModuleExportName();
  if (this.eatContextual("as")) {
    node.local = this.parseIdent();
  } else {
    this.checkUnreserved(node.imported);
    node.local = node.imported;
  }
  this.checkLValSimple(node.local, BIND_LEXICAL);
  return this.finishNode(node, "ImportSpecifier");
};
pp$8.parseImportDefaultSpecifier = function() {
  var node = this.startNode();
  node.local = this.parseIdent();
  this.checkLValSimple(node.local, BIND_LEXICAL);
  return this.finishNode(node, "ImportDefaultSpecifier");
};
pp$8.parseImportNamespaceSpecifier = function() {
  var node = this.startNode();
  this.next();
  this.expectContextual("as");
  node.local = this.parseIdent();
  this.checkLValSimple(node.local, BIND_LEXICAL);
  return this.finishNode(node, "ImportNamespaceSpecifier");
};
pp$8.parseImportSpecifiers = function() {
  var nodes = [], first = true;
  if (this.type === types$1.name) {
    nodes.push(this.parseImportDefaultSpecifier());
    if (!this.eat(types$1.comma)) {
      return nodes;
    }
  }
  if (this.type === types$1.star) {
    nodes.push(this.parseImportNamespaceSpecifier());
    return nodes;
  }
  this.expect(types$1.braceL);
  while (!this.eat(types$1.braceR)) {
    if (!first) {
      this.expect(types$1.comma);
      if (this.afterTrailingComma(types$1.braceR)) {
        break;
      }
    } else {
      first = false;
    }
    nodes.push(this.parseImportSpecifier());
  }
  return nodes;
};
pp$8.parseWithClause = function() {
  var nodes = [];
  if (!this.eat(types$1._with)) {
    return nodes;
  }
  this.expect(types$1.braceL);
  var attributeKeys = {};
  var first = true;
  while (!this.eat(types$1.braceR)) {
    if (!first) {
      this.expect(types$1.comma);
      if (this.afterTrailingComma(types$1.braceR)) {
        break;
      }
    } else {
      first = false;
    }
    var attr = this.parseImportAttribute();
    var keyName = attr.key.type === "Identifier" ? attr.key.name : attr.key.value;
    if (hasOwn(attributeKeys, keyName)) {
      this.raiseRecoverable(attr.key.start, "Duplicate attribute key '" + keyName + "'");
    }
    attributeKeys[keyName] = true;
    nodes.push(attr);
  }
  return nodes;
};
pp$8.parseImportAttribute = function() {
  var node = this.startNode();
  node.key = this.type === types$1.string ? this.parseExprAtom() : this.parseIdent(this.options.allowReserved !== "never");
  this.expect(types$1.colon);
  if (this.type !== types$1.string) {
    this.unexpected();
  }
  node.value = this.parseExprAtom();
  return this.finishNode(node, "ImportAttribute");
};
pp$8.parseModuleExportName = function() {
  if (this.options.ecmaVersion >= 13 && this.type === types$1.string) {
    var stringLiteral = this.parseLiteral(this.value);
    if (loneSurrogate.test(stringLiteral.value)) {
      this.raise(stringLiteral.start, "An export name cannot include a lone surrogate.");
    }
    return stringLiteral;
  }
  return this.parseIdent(true);
};
pp$8.adaptDirectivePrologue = function(statements) {
  for (var i = 0;i < statements.length && this.isDirectiveCandidate(statements[i]); ++i) {
    statements[i].directive = statements[i].expression.raw.slice(1, -1);
  }
};
pp$8.isDirectiveCandidate = function(statement) {
  return this.options.ecmaVersion >= 5 && statement.type === "ExpressionStatement" && statement.expression.type === "Literal" && typeof statement.expression.value === "string" && (this.input[statement.start] === '"' || this.input[statement.start] === "'");
};
var pp$7 = Parser.prototype;
pp$7.toAssignable = function(node, isBinding, refDestructuringErrors) {
  if (this.options.ecmaVersion >= 6 && node) {
    switch (node.type) {
      case "Identifier":
        if (this.inAsync && node.name === "await") {
          this.raise(node.start, "Cannot use 'await' as identifier inside an async function");
        }
        break;
      case "ObjectPattern":
      case "ArrayPattern":
      case "AssignmentPattern":
      case "RestElement":
        break;
      case "ObjectExpression":
        node.type = "ObjectPattern";
        if (refDestructuringErrors) {
          this.checkPatternErrors(refDestructuringErrors, true);
        }
        for (var i = 0, list = node.properties;i < list.length; i += 1) {
          var prop = list[i];
          this.toAssignable(prop, isBinding);
          if (prop.type === "RestElement" && (prop.argument.type === "ArrayPattern" || prop.argument.type === "ObjectPattern")) {
            this.raise(prop.argument.start, "Unexpected token");
          }
        }
        break;
      case "Property":
        if (node.kind !== "init") {
          this.raise(node.key.start, "Object pattern can't contain getter or setter");
        }
        this.toAssignable(node.value, isBinding);
        break;
      case "ArrayExpression":
        node.type = "ArrayPattern";
        if (refDestructuringErrors) {
          this.checkPatternErrors(refDestructuringErrors, true);
        }
        this.toAssignableList(node.elements, isBinding);
        break;
      case "SpreadElement":
        node.type = "RestElement";
        this.toAssignable(node.argument, isBinding);
        if (node.argument.type === "AssignmentPattern") {
          this.raise(node.argument.start, "Rest elements cannot have a default value");
        }
        break;
      case "AssignmentExpression":
        if (node.operator !== "=") {
          this.raise(node.left.end, "Only '=' operator can be used for specifying default value.");
        }
        node.type = "AssignmentPattern";
        delete node.operator;
        this.toAssignable(node.left, isBinding);
        break;
      case "ParenthesizedExpression":
        this.toAssignable(node.expression, isBinding, refDestructuringErrors);
        break;
      case "ChainExpression":
        this.raiseRecoverable(node.start, "Optional chaining cannot appear in left-hand side");
        break;
      case "MemberExpression":
        if (!isBinding) {
          break;
        }
      default:
        this.raise(node.start, "Assigning to rvalue");
    }
  } else if (refDestructuringErrors) {
    this.checkPatternErrors(refDestructuringErrors, true);
  }
  return node;
};
pp$7.toAssignableList = function(exprList, isBinding) {
  var end = exprList.length;
  for (var i = 0;i < end; i++) {
    var elt = exprList[i];
    if (elt) {
      this.toAssignable(elt, isBinding);
    }
  }
  if (end) {
    var last2 = exprList[end - 1];
    if (this.options.ecmaVersion === 6 && isBinding && last2 && last2.type === "RestElement" && last2.argument.type !== "Identifier") {
      this.unexpected(last2.argument.start);
    }
  }
  return exprList;
};
pp$7.parseSpread = function(refDestructuringErrors) {
  var node = this.startNode();
  this.next();
  node.argument = this.parseMaybeAssign(false, refDestructuringErrors);
  return this.finishNode(node, "SpreadElement");
};
pp$7.parseRestBinding = function() {
  var node = this.startNode();
  this.next();
  if (this.options.ecmaVersion === 6 && this.type !== types$1.name) {
    this.unexpected();
  }
  node.argument = this.parseBindingAtom();
  return this.finishNode(node, "RestElement");
};
pp$7.parseBindingAtom = function() {
  if (this.options.ecmaVersion >= 6) {
    switch (this.type) {
      case types$1.bracketL:
        var node = this.startNode();
        this.next();
        node.elements = this.parseBindingList(types$1.bracketR, true, true);
        return this.finishNode(node, "ArrayPattern");
      case types$1.braceL:
        return this.parseObj(true);
    }
  }
  return this.parseIdent();
};
pp$7.parseBindingList = function(close, allowEmpty, allowTrailingComma, allowModifiers) {
  var elts = [], first = true;
  while (!this.eat(close)) {
    if (first) {
      first = false;
    } else {
      this.expect(types$1.comma);
    }
    if (allowEmpty && this.type === types$1.comma) {
      elts.push(null);
    } else if (allowTrailingComma && this.afterTrailingComma(close)) {
      break;
    } else if (this.type === types$1.ellipsis) {
      var rest = this.parseRestBinding();
      this.parseBindingListItem(rest);
      elts.push(rest);
      if (this.type === types$1.comma) {
        this.raiseRecoverable(this.start, "Comma is not permitted after the rest element");
      }
      this.expect(close);
      break;
    } else {
      elts.push(this.parseAssignableListItem(allowModifiers));
    }
  }
  return elts;
};
pp$7.parseAssignableListItem = function(allowModifiers) {
  var elem = this.parseMaybeDefault(this.start, this.startLoc);
  this.parseBindingListItem(elem);
  return elem;
};
pp$7.parseBindingListItem = function(param) {
  return param;
};
pp$7.parseMaybeDefault = function(startPos, startLoc, left) {
  left = left || this.parseBindingAtom();
  if (this.options.ecmaVersion < 6 || !this.eat(types$1.eq)) {
    return left;
  }
  var node = this.startNodeAt(startPos, startLoc);
  node.left = left;
  node.right = this.parseMaybeAssign();
  return this.finishNode(node, "AssignmentPattern");
};
pp$7.checkLValSimple = function(expr, bindingType, checkClashes) {
  if (bindingType === undefined)
    bindingType = BIND_NONE;
  var isBind = bindingType !== BIND_NONE;
  switch (expr.type) {
    case "Identifier":
      if (this.strict && this.reservedWordsStrictBind.test(expr.name)) {
        this.raiseRecoverable(expr.start, (isBind ? "Binding " : "Assigning to ") + expr.name + " in strict mode");
      }
      if (isBind) {
        if (bindingType === BIND_LEXICAL && expr.name === "let") {
          this.raiseRecoverable(expr.start, "let is disallowed as a lexically bound name");
        }
        if (checkClashes) {
          if (hasOwn(checkClashes, expr.name)) {
            this.raiseRecoverable(expr.start, "Argument name clash");
          }
          checkClashes[expr.name] = true;
        }
        if (bindingType !== BIND_OUTSIDE) {
          this.declareName(expr.name, bindingType, expr.start);
        }
      }
      break;
    case "ChainExpression":
      this.raiseRecoverable(expr.start, "Optional chaining cannot appear in left-hand side");
      break;
    case "MemberExpression":
      if (isBind) {
        this.raiseRecoverable(expr.start, "Binding member expression");
      }
      break;
    case "ParenthesizedExpression":
      if (isBind) {
        this.raiseRecoverable(expr.start, "Binding parenthesized expression");
      }
      return this.checkLValSimple(expr.expression, bindingType, checkClashes);
    default:
      this.raise(expr.start, (isBind ? "Binding" : "Assigning to") + " rvalue");
  }
};
pp$7.checkLValPattern = function(expr, bindingType, checkClashes) {
  if (bindingType === undefined)
    bindingType = BIND_NONE;
  switch (expr.type) {
    case "ObjectPattern":
      for (var i = 0, list = expr.properties;i < list.length; i += 1) {
        var prop = list[i];
        this.checkLValInnerPattern(prop, bindingType, checkClashes);
      }
      break;
    case "ArrayPattern":
      for (var i$1 = 0, list$1 = expr.elements;i$1 < list$1.length; i$1 += 1) {
        var elem = list$1[i$1];
        if (elem) {
          this.checkLValInnerPattern(elem, bindingType, checkClashes);
        }
      }
      break;
    default:
      this.checkLValSimple(expr, bindingType, checkClashes);
  }
};
pp$7.checkLValInnerPattern = function(expr, bindingType, checkClashes) {
  if (bindingType === undefined)
    bindingType = BIND_NONE;
  switch (expr.type) {
    case "Property":
      this.checkLValInnerPattern(expr.value, bindingType, checkClashes);
      break;
    case "AssignmentPattern":
      this.checkLValPattern(expr.left, bindingType, checkClashes);
      break;
    case "RestElement":
      this.checkLValPattern(expr.argument, bindingType, checkClashes);
      break;
    default:
      this.checkLValPattern(expr, bindingType, checkClashes);
  }
};
var TokContext = function TokContext2(token, isExpr, preserveSpace, override, generator) {
  this.token = token;
  this.isExpr = !!isExpr;
  this.preserveSpace = !!preserveSpace;
  this.override = override;
  this.generator = !!generator;
};
var types = {
  b_stat: new TokContext("{", false),
  b_expr: new TokContext("{", true),
  b_tmpl: new TokContext("${", false),
  p_stat: new TokContext("(", false),
  p_expr: new TokContext("(", true),
  q_tmpl: new TokContext("`", true, true, function(p2) {
    return p2.tryReadTemplateToken();
  }),
  f_stat: new TokContext("function", false),
  f_expr: new TokContext("function", true),
  f_expr_gen: new TokContext("function", true, false, null, true),
  f_gen: new TokContext("function", false, false, null, true)
};
var pp$6 = Parser.prototype;
pp$6.initialContext = function() {
  return [types.b_stat];
};
pp$6.curContext = function() {
  return this.context[this.context.length - 1];
};
pp$6.braceIsBlock = function(prevType) {
  var parent = this.curContext();
  if (parent === types.f_expr || parent === types.f_stat) {
    return true;
  }
  if (prevType === types$1.colon && (parent === types.b_stat || parent === types.b_expr)) {
    return !parent.isExpr;
  }
  if (prevType === types$1._return || prevType === types$1.name && this.exprAllowed) {
    return lineBreak.test(this.input.slice(this.lastTokEnd, this.start));
  }
  if (prevType === types$1._else || prevType === types$1.semi || prevType === types$1.eof || prevType === types$1.parenR || prevType === types$1.arrow) {
    return true;
  }
  if (prevType === types$1.braceL) {
    return parent === types.b_stat;
  }
  if (prevType === types$1._var || prevType === types$1._const || prevType === types$1.name) {
    return false;
  }
  return !this.exprAllowed;
};
pp$6.inGeneratorContext = function() {
  for (var i = this.context.length - 1;i >= 1; i--) {
    var context = this.context[i];
    if (context.token === "function") {
      return context.generator;
    }
  }
  return false;
};
pp$6.updateContext = function(prevType) {
  var update, type2 = this.type;
  if (type2.keyword && prevType === types$1.dot) {
    this.exprAllowed = false;
  } else if (update = type2.updateContext) {
    update.call(this, prevType);
  } else {
    this.exprAllowed = type2.beforeExpr;
  }
};
pp$6.overrideContext = function(tokenCtx) {
  if (this.curContext() !== tokenCtx) {
    this.context[this.context.length - 1] = tokenCtx;
  }
};
types$1.parenR.updateContext = types$1.braceR.updateContext = function() {
  if (this.context.length === 1) {
    this.exprAllowed = true;
    return;
  }
  var out = this.context.pop();
  if (out === types.b_stat && this.curContext().token === "function") {
    out = this.context.pop();
  }
  this.exprAllowed = !out.isExpr;
};
types$1.braceL.updateContext = function(prevType) {
  this.context.push(this.braceIsBlock(prevType) ? types.b_stat : types.b_expr);
  this.exprAllowed = true;
};
types$1.dollarBraceL.updateContext = function() {
  this.context.push(types.b_tmpl);
  this.exprAllowed = true;
};
types$1.parenL.updateContext = function(prevType) {
  var statementParens = prevType === types$1._if || prevType === types$1._for || prevType === types$1._with || prevType === types$1._while;
  this.context.push(statementParens ? types.p_stat : types.p_expr);
  this.exprAllowed = true;
};
types$1.incDec.updateContext = function() {};
types$1._function.updateContext = types$1._class.updateContext = function(prevType) {
  if (prevType.beforeExpr && prevType !== types$1._else && !(prevType === types$1.semi && this.curContext() !== types.p_stat) && !(prevType === types$1._return && lineBreak.test(this.input.slice(this.lastTokEnd, this.start))) && !((prevType === types$1.colon || prevType === types$1.braceL) && this.curContext() === types.b_stat)) {
    this.context.push(types.f_expr);
  } else {
    this.context.push(types.f_stat);
  }
  this.exprAllowed = false;
};
types$1.colon.updateContext = function() {
  if (this.curContext().token === "function") {
    this.context.pop();
  }
  this.exprAllowed = true;
};
types$1.backQuote.updateContext = function() {
  if (this.curContext() === types.q_tmpl) {
    this.context.pop();
  } else {
    this.context.push(types.q_tmpl);
  }
  this.exprAllowed = false;
};
types$1.star.updateContext = function(prevType) {
  if (prevType === types$1._function) {
    var index = this.context.length - 1;
    if (this.context[index] === types.f_expr) {
      this.context[index] = types.f_expr_gen;
    } else {
      this.context[index] = types.f_gen;
    }
  }
  this.exprAllowed = true;
};
types$1.name.updateContext = function(prevType) {
  var allowed = false;
  if (this.options.ecmaVersion >= 6 && prevType !== types$1.dot) {
    if (this.value === "of" && !this.exprAllowed || this.value === "yield" && this.inGeneratorContext()) {
      allowed = true;
    }
  }
  this.exprAllowed = allowed;
};
var pp$5 = Parser.prototype;
pp$5.checkPropClash = function(prop, propHash, refDestructuringErrors) {
  if (this.options.ecmaVersion >= 9 && prop.type === "SpreadElement") {
    return;
  }
  if (this.options.ecmaVersion >= 6 && (prop.computed || prop.method || prop.shorthand)) {
    return;
  }
  var key = prop.key;
  var name;
  switch (key.type) {
    case "Identifier":
      name = key.name;
      break;
    case "Literal":
      name = String(key.value);
      break;
    default:
      return;
  }
  var kind = prop.kind;
  if (this.options.ecmaVersion >= 6) {
    if (name === "__proto__" && kind === "init") {
      if (propHash.proto) {
        if (refDestructuringErrors) {
          if (refDestructuringErrors.doubleProto < 0) {
            refDestructuringErrors.doubleProto = key.start;
          }
        } else {
          this.raiseRecoverable(key.start, "Redefinition of __proto__ property");
        }
      }
      propHash.proto = true;
    }
    return;
  }
  name = "$" + name;
  var other = propHash[name];
  if (other) {
    var redefinition;
    if (kind === "init") {
      redefinition = this.strict && other.init || other.get || other.set;
    } else {
      redefinition = other.init || other[kind];
    }
    if (redefinition) {
      this.raiseRecoverable(key.start, "Redefinition of property");
    }
  } else {
    other = propHash[name] = {
      init: false,
      get: false,
      set: false
    };
  }
  other[kind] = true;
};
pp$5.parseExpression = function(forInit, refDestructuringErrors) {
  var startPos = this.start, startLoc = this.startLoc;
  var expr = this.parseMaybeAssign(forInit, refDestructuringErrors);
  if (this.type === types$1.comma) {
    var node = this.startNodeAt(startPos, startLoc);
    node.expressions = [expr];
    while (this.eat(types$1.comma)) {
      node.expressions.push(this.parseMaybeAssign(forInit, refDestructuringErrors));
    }
    return this.finishNode(node, "SequenceExpression");
  }
  return expr;
};
pp$5.parseMaybeAssign = function(forInit, refDestructuringErrors, afterLeftParse) {
  if (this.isContextual("yield")) {
    if (this.inGenerator) {
      return this.parseYield(forInit);
    } else {
      this.exprAllowed = false;
    }
  }
  var ownDestructuringErrors = false, oldParenAssign = -1, oldTrailingComma = -1, oldDoubleProto = -1;
  if (refDestructuringErrors) {
    oldParenAssign = refDestructuringErrors.parenthesizedAssign;
    oldTrailingComma = refDestructuringErrors.trailingComma;
    oldDoubleProto = refDestructuringErrors.doubleProto;
    refDestructuringErrors.parenthesizedAssign = refDestructuringErrors.trailingComma = -1;
  } else {
    refDestructuringErrors = new DestructuringErrors;
    ownDestructuringErrors = true;
  }
  var startPos = this.start, startLoc = this.startLoc;
  if (this.type === types$1.parenL || this.type === types$1.name) {
    this.potentialArrowAt = this.start;
    this.potentialArrowInForAwait = forInit === "await";
  }
  var left = this.parseMaybeConditional(forInit, refDestructuringErrors);
  if (afterLeftParse) {
    left = afterLeftParse.call(this, left, startPos, startLoc);
  }
  if (this.type.isAssign) {
    var node = this.startNodeAt(startPos, startLoc);
    node.operator = this.value;
    if (this.type === types$1.eq) {
      left = this.toAssignable(left, false, refDestructuringErrors);
    }
    if (!ownDestructuringErrors) {
      refDestructuringErrors.parenthesizedAssign = refDestructuringErrors.trailingComma = refDestructuringErrors.doubleProto = -1;
    }
    if (refDestructuringErrors.shorthandAssign >= left.start) {
      refDestructuringErrors.shorthandAssign = -1;
    }
    if (this.type === types$1.eq) {
      this.checkLValPattern(left);
    } else {
      this.checkLValSimple(left);
    }
    node.left = left;
    this.next();
    node.right = this.parseMaybeAssign(forInit);
    if (oldDoubleProto > -1) {
      refDestructuringErrors.doubleProto = oldDoubleProto;
    }
    return this.finishNode(node, "AssignmentExpression");
  } else {
    if (ownDestructuringErrors) {
      this.checkExpressionErrors(refDestructuringErrors, true);
    }
  }
  if (oldParenAssign > -1) {
    refDestructuringErrors.parenthesizedAssign = oldParenAssign;
  }
  if (oldTrailingComma > -1) {
    refDestructuringErrors.trailingComma = oldTrailingComma;
  }
  return left;
};
pp$5.parseMaybeConditional = function(forInit, refDestructuringErrors) {
  var startPos = this.start, startLoc = this.startLoc;
  var expr = this.parseExprOps(forInit, refDestructuringErrors);
  if (this.checkExpressionErrors(refDestructuringErrors)) {
    return expr;
  }
  if (this.eat(types$1.question)) {
    var node = this.startNodeAt(startPos, startLoc);
    node.test = expr;
    node.consequent = this.parseMaybeAssign();
    this.expect(types$1.colon);
    node.alternate = this.parseMaybeAssign(forInit);
    return this.finishNode(node, "ConditionalExpression");
  }
  return expr;
};
pp$5.parseExprOps = function(forInit, refDestructuringErrors) {
  var startPos = this.start, startLoc = this.startLoc;
  var expr = this.parseMaybeUnary(refDestructuringErrors, false, false, forInit);
  if (this.checkExpressionErrors(refDestructuringErrors)) {
    return expr;
  }
  return expr.start === startPos && expr.type === "ArrowFunctionExpression" ? expr : this.parseExprOp(expr, startPos, startLoc, -1, forInit);
};
pp$5.parseExprOp = function(left, leftStartPos, leftStartLoc, minPrec, forInit) {
  var prec = this.type.binop;
  if (prec != null && (!forInit || this.type !== types$1._in)) {
    if (prec > minPrec) {
      var logical = this.type === types$1.logicalOR || this.type === types$1.logicalAND;
      var coalesce = this.type === types$1.coalesce;
      if (coalesce) {
        prec = types$1.logicalAND.binop;
      }
      var op = this.value;
      this.next();
      var startPos = this.start, startLoc = this.startLoc;
      var right = this.parseExprOp(this.parseMaybeUnary(null, false, false, forInit), startPos, startLoc, prec, forInit);
      var node = this.buildBinary(leftStartPos, leftStartLoc, left, right, op, logical || coalesce);
      if (logical && this.type === types$1.coalesce || coalesce && (this.type === types$1.logicalOR || this.type === types$1.logicalAND)) {
        this.raiseRecoverable(this.start, "Logical expressions and coalesce expressions cannot be mixed. Wrap either by parentheses");
      }
      return this.parseExprOp(node, leftStartPos, leftStartLoc, minPrec, forInit);
    }
  }
  return left;
};
pp$5.buildBinary = function(startPos, startLoc, left, right, op, logical) {
  if (right.type === "PrivateIdentifier") {
    this.raise(right.start, "Private identifier can only be left side of binary expression");
  }
  var node = this.startNodeAt(startPos, startLoc);
  node.left = left;
  node.operator = op;
  node.right = right;
  return this.finishNode(node, logical ? "LogicalExpression" : "BinaryExpression");
};
pp$5.parseMaybeUnary = function(refDestructuringErrors, sawUnary, incDec, forInit) {
  var startPos = this.start, startLoc = this.startLoc, expr;
  if (this.isContextual("await") && this.canAwait) {
    expr = this.parseAwait(forInit);
    sawUnary = true;
  } else if (this.type.prefix) {
    var node = this.startNode(), update = this.type === types$1.incDec;
    node.operator = this.value;
    node.prefix = true;
    this.next();
    node.argument = this.parseMaybeUnary(null, true, update, forInit);
    this.checkExpressionErrors(refDestructuringErrors, true);
    if (update) {
      this.checkLValSimple(node.argument);
    } else if (this.strict && node.operator === "delete" && isLocalVariableAccess(node.argument)) {
      this.raiseRecoverable(node.start, "Deleting local variable in strict mode");
    } else if (node.operator === "delete" && isPrivateFieldAccess(node.argument)) {
      this.raiseRecoverable(node.start, "Private fields can not be deleted");
    } else {
      sawUnary = true;
    }
    expr = this.finishNode(node, update ? "UpdateExpression" : "UnaryExpression");
  } else if (!sawUnary && this.type === types$1.privateId) {
    if ((forInit || this.privateNameStack.length === 0) && this.options.checkPrivateFields) {
      this.unexpected();
    }
    expr = this.parsePrivateIdent();
    if (this.type !== types$1._in) {
      this.unexpected();
    }
  } else {
    expr = this.parseExprSubscripts(refDestructuringErrors, forInit);
    if (this.checkExpressionErrors(refDestructuringErrors)) {
      return expr;
    }
    while (this.type.postfix && !this.canInsertSemicolon()) {
      var node$1 = this.startNodeAt(startPos, startLoc);
      node$1.operator = this.value;
      node$1.prefix = false;
      node$1.argument = expr;
      this.checkLValSimple(expr);
      this.next();
      expr = this.finishNode(node$1, "UpdateExpression");
    }
  }
  if (!incDec && this.eat(types$1.starstar)) {
    if (sawUnary) {
      this.unexpected(this.lastTokStart);
    } else {
      return this.buildBinary(startPos, startLoc, expr, this.parseMaybeUnary(null, false, false, forInit), "**", false);
    }
  } else {
    return expr;
  }
};
function isLocalVariableAccess(node) {
  return node.type === "Identifier" || node.type === "ParenthesizedExpression" && isLocalVariableAccess(node.expression);
}
function isPrivateFieldAccess(node) {
  return node.type === "MemberExpression" && node.property.type === "PrivateIdentifier" || node.type === "ChainExpression" && isPrivateFieldAccess(node.expression) || node.type === "ParenthesizedExpression" && isPrivateFieldAccess(node.expression);
}
pp$5.parseExprSubscripts = function(refDestructuringErrors, forInit) {
  var startPos = this.start, startLoc = this.startLoc;
  var expr = this.parseExprAtom(refDestructuringErrors, forInit);
  if (expr.type === "ArrowFunctionExpression" && this.input.slice(this.lastTokStart, this.lastTokEnd) !== ")") {
    return expr;
  }
  var result = this.parseSubscripts(expr, startPos, startLoc, false, forInit);
  if (refDestructuringErrors && result.type === "MemberExpression") {
    if (refDestructuringErrors.parenthesizedAssign >= result.start) {
      refDestructuringErrors.parenthesizedAssign = -1;
    }
    if (refDestructuringErrors.parenthesizedBind >= result.start) {
      refDestructuringErrors.parenthesizedBind = -1;
    }
    if (refDestructuringErrors.trailingComma >= result.start) {
      refDestructuringErrors.trailingComma = -1;
    }
  }
  return result;
};
pp$5.parseSubscripts = function(base, startPos, startLoc, noCalls, forInit) {
  var maybeAsyncArrow = this.options.ecmaVersion >= 8 && base.type === "Identifier" && base.name === "async" && this.lastTokEnd === base.end && !this.canInsertSemicolon() && base.end - base.start === 5 && this.potentialArrowAt === base.start;
  var optionalChained = false;
  while (true) {
    var element2 = this.parseSubscript(base, startPos, startLoc, noCalls, maybeAsyncArrow, optionalChained, forInit);
    if (element2.optional) {
      optionalChained = true;
    }
    if (element2 === base || element2.type === "ArrowFunctionExpression") {
      if (optionalChained) {
        var chainNode = this.startNodeAt(startPos, startLoc);
        chainNode.expression = element2;
        element2 = this.finishNode(chainNode, "ChainExpression");
      }
      return element2;
    }
    base = element2;
  }
};
pp$5.shouldParseAsyncArrow = function() {
  return !this.canInsertSemicolon() && this.eat(types$1.arrow);
};
pp$5.parseSubscriptAsyncArrow = function(startPos, startLoc, exprList, forInit) {
  return this.parseArrowExpression(this.startNodeAt(startPos, startLoc), exprList, true, forInit);
};
pp$5.parseSubscript = function(base, startPos, startLoc, noCalls, maybeAsyncArrow, optionalChained, forInit) {
  var optionalSupported = this.options.ecmaVersion >= 11;
  var optional2 = optionalSupported && this.eat(types$1.questionDot);
  if (noCalls && optional2) {
    this.raise(this.lastTokStart, "Optional chaining cannot appear in the callee of new expressions");
  }
  var computed = this.eat(types$1.bracketL);
  if (computed || optional2 && this.type !== types$1.parenL && this.type !== types$1.backQuote || this.eat(types$1.dot)) {
    var node = this.startNodeAt(startPos, startLoc);
    node.object = base;
    if (computed) {
      node.property = this.parseExpression();
      this.expect(types$1.bracketR);
    } else if (this.type === types$1.privateId && base.type !== "Super") {
      node.property = this.parsePrivateIdent();
    } else {
      node.property = this.parseIdent(this.options.allowReserved !== "never");
    }
    node.computed = !!computed;
    if (optionalSupported) {
      node.optional = optional2;
    }
    base = this.finishNode(node, "MemberExpression");
  } else if (!noCalls && this.eat(types$1.parenL)) {
    var refDestructuringErrors = new DestructuringErrors, oldYieldPos = this.yieldPos, oldAwaitPos = this.awaitPos, oldAwaitIdentPos = this.awaitIdentPos;
    this.yieldPos = 0;
    this.awaitPos = 0;
    this.awaitIdentPos = 0;
    var exprList = this.parseExprList(types$1.parenR, this.options.ecmaVersion >= 8, false, refDestructuringErrors);
    if (maybeAsyncArrow && !optional2 && this.shouldParseAsyncArrow()) {
      this.checkPatternErrors(refDestructuringErrors, false);
      this.checkYieldAwaitInDefaultParams();
      if (this.awaitIdentPos > 0) {
        this.raise(this.awaitIdentPos, "Cannot use 'await' as identifier inside an async function");
      }
      this.yieldPos = oldYieldPos;
      this.awaitPos = oldAwaitPos;
      this.awaitIdentPos = oldAwaitIdentPos;
      return this.parseSubscriptAsyncArrow(startPos, startLoc, exprList, forInit);
    }
    this.checkExpressionErrors(refDestructuringErrors, true);
    this.yieldPos = oldYieldPos || this.yieldPos;
    this.awaitPos = oldAwaitPos || this.awaitPos;
    this.awaitIdentPos = oldAwaitIdentPos || this.awaitIdentPos;
    var node$1 = this.startNodeAt(startPos, startLoc);
    node$1.callee = base;
    node$1.arguments = exprList;
    if (optionalSupported) {
      node$1.optional = optional2;
    }
    base = this.finishNode(node$1, "CallExpression");
  } else if (this.type === types$1.backQuote) {
    if (optional2 || optionalChained) {
      this.raise(this.start, "Optional chaining cannot appear in the tag of tagged template expressions");
    }
    var node$2 = this.startNodeAt(startPos, startLoc);
    node$2.tag = base;
    node$2.quasi = this.parseTemplate({ isTagged: true });
    base = this.finishNode(node$2, "TaggedTemplateExpression");
  }
  return base;
};
pp$5.parseExprAtom = function(refDestructuringErrors, forInit, forNew) {
  if (this.type === types$1.slash) {
    this.readRegexp();
  }
  var node, canBeArrow = this.potentialArrowAt === this.start;
  switch (this.type) {
    case types$1._super:
      if (!this.allowSuper) {
        this.raise(this.start, "'super' keyword outside a method");
      }
      node = this.startNode();
      this.next();
      if (this.type === types$1.parenL && !this.allowDirectSuper) {
        this.raise(node.start, "super() call outside constructor of a subclass");
      }
      if (this.type !== types$1.dot && this.type !== types$1.bracketL && this.type !== types$1.parenL) {
        this.unexpected();
      }
      return this.finishNode(node, "Super");
    case types$1._this:
      node = this.startNode();
      this.next();
      return this.finishNode(node, "ThisExpression");
    case types$1.name:
      var startPos = this.start, startLoc = this.startLoc, containsEsc = this.containsEsc;
      var id = this.parseIdent(false);
      if (this.options.ecmaVersion >= 8 && !containsEsc && id.name === "async" && !this.canInsertSemicolon() && this.eat(types$1._function)) {
        this.overrideContext(types.f_expr);
        return this.parseFunction(this.startNodeAt(startPos, startLoc), 0, false, true, forInit);
      }
      if (canBeArrow && !this.canInsertSemicolon()) {
        if (this.eat(types$1.arrow)) {
          return this.parseArrowExpression(this.startNodeAt(startPos, startLoc), [id], false, forInit);
        }
        if (this.options.ecmaVersion >= 8 && id.name === "async" && this.type === types$1.name && !containsEsc && (!this.potentialArrowInForAwait || this.value !== "of" || this.containsEsc)) {
          id = this.parseIdent(false);
          if (this.canInsertSemicolon() || !this.eat(types$1.arrow)) {
            this.unexpected();
          }
          return this.parseArrowExpression(this.startNodeAt(startPos, startLoc), [id], true, forInit);
        }
      }
      return id;
    case types$1.regexp:
      var value = this.value;
      node = this.parseLiteral(value.value);
      node.regex = { pattern: value.pattern, flags: value.flags };
      return node;
    case types$1.num:
    case types$1.string:
      return this.parseLiteral(this.value);
    case types$1._null:
    case types$1._true:
    case types$1._false:
      node = this.startNode();
      node.value = this.type === types$1._null ? null : this.type === types$1._true;
      node.raw = this.type.keyword;
      this.next();
      return this.finishNode(node, "Literal");
    case types$1.parenL:
      var start = this.start, expr = this.parseParenAndDistinguishExpression(canBeArrow, forInit);
      if (refDestructuringErrors) {
        if (refDestructuringErrors.parenthesizedAssign < 0 && !this.isSimpleAssignTarget(expr)) {
          refDestructuringErrors.parenthesizedAssign = start;
        }
        if (refDestructuringErrors.parenthesizedBind < 0) {
          refDestructuringErrors.parenthesizedBind = start;
        }
      }
      return expr;
    case types$1.bracketL:
      node = this.startNode();
      this.next();
      node.elements = this.parseExprList(types$1.bracketR, true, true, refDestructuringErrors);
      return this.finishNode(node, "ArrayExpression");
    case types$1.braceL:
      this.overrideContext(types.b_expr);
      return this.parseObj(false, refDestructuringErrors);
    case types$1._function:
      node = this.startNode();
      this.next();
      return this.parseFunction(node, 0);
    case types$1._class:
      return this.parseClass(this.startNode(), false);
    case types$1._new:
      return this.parseNew();
    case types$1.backQuote:
      return this.parseTemplate();
    case types$1._import:
      if (this.options.ecmaVersion >= 11) {
        return this.parseExprImport(forNew);
      } else {
        return this.unexpected();
      }
    default:
      return this.parseExprAtomDefault();
  }
};
pp$5.parseExprAtomDefault = function() {
  this.unexpected();
};
pp$5.parseExprImport = function(forNew) {
  var node = this.startNode();
  if (this.containsEsc) {
    this.raiseRecoverable(this.start, "Escape sequence in keyword import");
  }
  this.next();
  if (this.type === types$1.parenL && !forNew) {
    return this.parseDynamicImport(node);
  } else if (this.type === types$1.dot) {
    var meta = this.startNodeAt(node.start, node.loc && node.loc.start);
    meta.name = "import";
    node.meta = this.finishNode(meta, "Identifier");
    return this.parseImportMeta(node);
  } else {
    this.unexpected();
  }
};
pp$5.parseDynamicImport = function(node) {
  this.next();
  node.source = this.parseMaybeAssign();
  if (this.options.ecmaVersion >= 16) {
    if (!this.eat(types$1.parenR)) {
      this.expect(types$1.comma);
      if (!this.afterTrailingComma(types$1.parenR)) {
        node.options = this.parseMaybeAssign();
        if (!this.eat(types$1.parenR)) {
          this.expect(types$1.comma);
          if (!this.afterTrailingComma(types$1.parenR)) {
            this.unexpected();
          }
        }
      } else {
        node.options = null;
      }
    } else {
      node.options = null;
    }
  } else {
    if (!this.eat(types$1.parenR)) {
      var errorPos = this.start;
      if (this.eat(types$1.comma) && this.eat(types$1.parenR)) {
        this.raiseRecoverable(errorPos, "Trailing comma is not allowed in import()");
      } else {
        this.unexpected(errorPos);
      }
    }
  }
  return this.finishNode(node, "ImportExpression");
};
pp$5.parseImportMeta = function(node) {
  this.next();
  var containsEsc = this.containsEsc;
  node.property = this.parseIdent(true);
  if (node.property.name !== "meta") {
    this.raiseRecoverable(node.property.start, "The only valid meta property for import is 'import.meta'");
  }
  if (containsEsc) {
    this.raiseRecoverable(node.start, "'import.meta' must not contain escaped characters");
  }
  if (this.options.sourceType !== "module" && !this.options.allowImportExportEverywhere) {
    this.raiseRecoverable(node.start, "Cannot use 'import.meta' outside a module");
  }
  return this.finishNode(node, "MetaProperty");
};
pp$5.parseLiteral = function(value) {
  var node = this.startNode();
  node.value = value;
  node.raw = this.input.slice(this.start, this.end);
  if (node.raw.charCodeAt(node.raw.length - 1) === 110) {
    node.bigint = node.value != null ? node.value.toString() : node.raw.slice(0, -1).replace(/_/g, "");
  }
  this.next();
  return this.finishNode(node, "Literal");
};
pp$5.parseParenExpression = function() {
  this.expect(types$1.parenL);
  var val = this.parseExpression();
  this.expect(types$1.parenR);
  return val;
};
pp$5.shouldParseArrow = function(exprList) {
  return !this.canInsertSemicolon();
};
pp$5.parseParenAndDistinguishExpression = function(canBeArrow, forInit) {
  var startPos = this.start, startLoc = this.startLoc, val, allowTrailingComma = this.options.ecmaVersion >= 8;
  if (this.options.ecmaVersion >= 6) {
    this.next();
    var innerStartPos = this.start, innerStartLoc = this.startLoc;
    var exprList = [], first = true, lastIsComma = false;
    var refDestructuringErrors = new DestructuringErrors, oldYieldPos = this.yieldPos, oldAwaitPos = this.awaitPos, spreadStart;
    this.yieldPos = 0;
    this.awaitPos = 0;
    while (this.type !== types$1.parenR) {
      first ? first = false : this.expect(types$1.comma);
      if (allowTrailingComma && this.afterTrailingComma(types$1.parenR, true)) {
        lastIsComma = true;
        break;
      } else if (this.type === types$1.ellipsis) {
        spreadStart = this.start;
        exprList.push(this.parseParenItem(this.parseRestBinding()));
        if (this.type === types$1.comma) {
          this.raiseRecoverable(this.start, "Comma is not permitted after the rest element");
        }
        break;
      } else {
        exprList.push(this.parseMaybeAssign(false, refDestructuringErrors, this.parseParenItem));
      }
    }
    var innerEndPos = this.lastTokEnd, innerEndLoc = this.lastTokEndLoc;
    this.expect(types$1.parenR);
    if (canBeArrow && this.shouldParseArrow(exprList) && this.eat(types$1.arrow)) {
      this.checkPatternErrors(refDestructuringErrors, false);
      this.checkYieldAwaitInDefaultParams();
      this.yieldPos = oldYieldPos;
      this.awaitPos = oldAwaitPos;
      return this.parseParenArrowList(startPos, startLoc, exprList, forInit);
    }
    if (!exprList.length || lastIsComma) {
      this.unexpected(this.lastTokStart);
    }
    if (spreadStart) {
      this.unexpected(spreadStart);
    }
    this.checkExpressionErrors(refDestructuringErrors, true);
    this.yieldPos = oldYieldPos || this.yieldPos;
    this.awaitPos = oldAwaitPos || this.awaitPos;
    if (exprList.length > 1) {
      val = this.startNodeAt(innerStartPos, innerStartLoc);
      val.expressions = exprList;
      this.finishNodeAt(val, "SequenceExpression", innerEndPos, innerEndLoc);
    } else {
      val = exprList[0];
    }
  } else {
    val = this.parseParenExpression();
  }
  if (this.options.preserveParens) {
    var par = this.startNodeAt(startPos, startLoc);
    par.expression = val;
    return this.finishNode(par, "ParenthesizedExpression");
  } else {
    return val;
  }
};
pp$5.parseParenItem = function(item) {
  return item;
};
pp$5.parseParenArrowList = function(startPos, startLoc, exprList, forInit) {
  return this.parseArrowExpression(this.startNodeAt(startPos, startLoc), exprList, false, forInit);
};
var empty = [];
pp$5.parseNew = function() {
  if (this.containsEsc) {
    this.raiseRecoverable(this.start, "Escape sequence in keyword new");
  }
  var node = this.startNode();
  this.next();
  if (this.options.ecmaVersion >= 6 && this.type === types$1.dot) {
    var meta = this.startNodeAt(node.start, node.loc && node.loc.start);
    meta.name = "new";
    node.meta = this.finishNode(meta, "Identifier");
    this.next();
    var containsEsc = this.containsEsc;
    node.property = this.parseIdent(true);
    if (node.property.name !== "target") {
      this.raiseRecoverable(node.property.start, "The only valid meta property for new is 'new.target'");
    }
    if (containsEsc) {
      this.raiseRecoverable(node.start, "'new.target' must not contain escaped characters");
    }
    if (!this.allowNewDotTarget) {
      this.raiseRecoverable(node.start, "'new.target' can only be used in functions and class static block");
    }
    return this.finishNode(node, "MetaProperty");
  }
  var startPos = this.start, startLoc = this.startLoc;
  node.callee = this.parseSubscripts(this.parseExprAtom(null, false, true), startPos, startLoc, true, false);
  if (this.eat(types$1.parenL)) {
    node.arguments = this.parseExprList(types$1.parenR, this.options.ecmaVersion >= 8, false);
  } else {
    node.arguments = empty;
  }
  return this.finishNode(node, "NewExpression");
};
pp$5.parseTemplateElement = function(ref2) {
  var isTagged = ref2.isTagged;
  var elem = this.startNode();
  if (this.type === types$1.invalidTemplate) {
    if (!isTagged) {
      this.raiseRecoverable(this.start, "Bad escape sequence in untagged template literal");
    }
    elem.value = {
      raw: this.value.replace(/\r\n?/g, `
`),
      cooked: null
    };
  } else {
    elem.value = {
      raw: this.input.slice(this.start, this.end).replace(/\r\n?/g, `
`),
      cooked: this.value
    };
  }
  this.next();
  elem.tail = this.type === types$1.backQuote;
  return this.finishNode(elem, "TemplateElement");
};
pp$5.parseTemplate = function(ref2) {
  if (ref2 === undefined)
    ref2 = {};
  var isTagged = ref2.isTagged;
  if (isTagged === undefined)
    isTagged = false;
  var node = this.startNode();
  this.next();
  node.expressions = [];
  var curElt = this.parseTemplateElement({ isTagged });
  node.quasis = [curElt];
  while (!curElt.tail) {
    if (this.type === types$1.eof) {
      this.raise(this.pos, "Unterminated template literal");
    }
    this.expect(types$1.dollarBraceL);
    node.expressions.push(this.parseExpression());
    this.expect(types$1.braceR);
    node.quasis.push(curElt = this.parseTemplateElement({ isTagged }));
  }
  this.next();
  return this.finishNode(node, "TemplateLiteral");
};
pp$5.isAsyncProp = function(prop) {
  return !prop.computed && prop.key.type === "Identifier" && prop.key.name === "async" && (this.type === types$1.name || this.type === types$1.num || this.type === types$1.string || this.type === types$1.bracketL || this.type.keyword || this.options.ecmaVersion >= 9 && this.type === types$1.star) && !lineBreak.test(this.input.slice(this.lastTokEnd, this.start));
};
pp$5.parseObj = function(isPattern, refDestructuringErrors) {
  var node = this.startNode(), first = true, propHash = {};
  node.properties = [];
  this.next();
  while (!this.eat(types$1.braceR)) {
    if (!first) {
      this.expect(types$1.comma);
      if (this.options.ecmaVersion >= 5 && this.afterTrailingComma(types$1.braceR)) {
        break;
      }
    } else {
      first = false;
    }
    var prop = this.parseProperty(isPattern, refDestructuringErrors);
    if (!isPattern) {
      this.checkPropClash(prop, propHash, refDestructuringErrors);
    }
    node.properties.push(prop);
  }
  return this.finishNode(node, isPattern ? "ObjectPattern" : "ObjectExpression");
};
pp$5.parseProperty = function(isPattern, refDestructuringErrors) {
  var prop = this.startNode(), isGenerator, isAsync, startPos, startLoc;
  if (this.options.ecmaVersion >= 9 && this.eat(types$1.ellipsis)) {
    if (isPattern) {
      prop.argument = this.parseIdent(false);
      if (this.type === types$1.comma) {
        this.raiseRecoverable(this.start, "Comma is not permitted after the rest element");
      }
      return this.finishNode(prop, "RestElement");
    }
    prop.argument = this.parseMaybeAssign(false, refDestructuringErrors);
    if (this.type === types$1.comma && refDestructuringErrors && refDestructuringErrors.trailingComma < 0) {
      refDestructuringErrors.trailingComma = this.start;
    }
    return this.finishNode(prop, "SpreadElement");
  }
  if (this.options.ecmaVersion >= 6) {
    prop.method = false;
    prop.shorthand = false;
    if (isPattern || refDestructuringErrors) {
      startPos = this.start;
      startLoc = this.startLoc;
    }
    if (!isPattern) {
      isGenerator = this.eat(types$1.star);
    }
  }
  var containsEsc = this.containsEsc;
  this.parsePropertyName(prop);
  if (!isPattern && !containsEsc && this.options.ecmaVersion >= 8 && !isGenerator && this.isAsyncProp(prop)) {
    isAsync = true;
    isGenerator = this.options.ecmaVersion >= 9 && this.eat(types$1.star);
    this.parsePropertyName(prop);
  } else {
    isAsync = false;
  }
  this.parsePropertyValue(prop, isPattern, isGenerator, isAsync, startPos, startLoc, refDestructuringErrors, containsEsc);
  return this.finishNode(prop, "Property");
};
pp$5.parseGetterSetter = function(prop) {
  var kind = prop.key.name;
  this.parsePropertyName(prop);
  prop.value = this.parseMethod(false);
  prop.kind = kind;
  var paramCount = prop.kind === "get" ? 0 : 1;
  if (prop.value.params.length !== paramCount) {
    var start = prop.value.start;
    if (prop.kind === "get") {
      this.raiseRecoverable(start, "getter should have no params");
    } else {
      this.raiseRecoverable(start, "setter should have exactly one param");
    }
  } else {
    if (prop.kind === "set" && prop.value.params[0].type === "RestElement") {
      this.raiseRecoverable(prop.value.params[0].start, "Setter cannot use rest params");
    }
  }
};
pp$5.parsePropertyValue = function(prop, isPattern, isGenerator, isAsync, startPos, startLoc, refDestructuringErrors, containsEsc) {
  if ((isGenerator || isAsync) && this.type === types$1.colon) {
    this.unexpected();
  }
  if (this.eat(types$1.colon)) {
    prop.value = isPattern ? this.parseMaybeDefault(this.start, this.startLoc) : this.parseMaybeAssign(false, refDestructuringErrors);
    prop.kind = "init";
  } else if (this.options.ecmaVersion >= 6 && this.type === types$1.parenL) {
    if (isPattern) {
      this.unexpected();
    }
    prop.method = true;
    prop.value = this.parseMethod(isGenerator, isAsync);
    prop.kind = "init";
  } else if (!isPattern && !containsEsc && this.options.ecmaVersion >= 5 && !prop.computed && prop.key.type === "Identifier" && (prop.key.name === "get" || prop.key.name === "set") && (this.type !== types$1.comma && this.type !== types$1.braceR && this.type !== types$1.eq)) {
    if (isGenerator || isAsync) {
      this.unexpected();
    }
    this.parseGetterSetter(prop);
  } else if (this.options.ecmaVersion >= 6 && !prop.computed && prop.key.type === "Identifier") {
    if (isGenerator || isAsync) {
      this.unexpected();
    }
    this.checkUnreserved(prop.key);
    if (prop.key.name === "await" && !this.awaitIdentPos) {
      this.awaitIdentPos = startPos;
    }
    if (isPattern) {
      prop.value = this.parseMaybeDefault(startPos, startLoc, this.copyNode(prop.key));
    } else if (this.type === types$1.eq && refDestructuringErrors) {
      if (refDestructuringErrors.shorthandAssign < 0) {
        refDestructuringErrors.shorthandAssign = this.start;
      }
      prop.value = this.parseMaybeDefault(startPos, startLoc, this.copyNode(prop.key));
    } else {
      prop.value = this.copyNode(prop.key);
    }
    prop.kind = "init";
    prop.shorthand = true;
  } else {
    this.unexpected();
  }
};
pp$5.parsePropertyName = function(prop) {
  if (this.options.ecmaVersion >= 6) {
    if (this.eat(types$1.bracketL)) {
      prop.computed = true;
      prop.key = this.parseMaybeAssign();
      this.expect(types$1.bracketR);
      return prop.key;
    } else {
      prop.computed = false;
    }
  }
  return prop.key = this.type === types$1.num || this.type === types$1.string ? this.parseExprAtom() : this.parseIdent(this.options.allowReserved !== "never");
};
pp$5.initFunction = function(node) {
  node.id = null;
  if (this.options.ecmaVersion >= 6) {
    node.generator = node.expression = false;
  }
  if (this.options.ecmaVersion >= 8) {
    node.async = false;
  }
};
pp$5.parseMethod = function(isGenerator, isAsync, allowDirectSuper) {
  var node = this.startNode(), oldYieldPos = this.yieldPos, oldAwaitPos = this.awaitPos, oldAwaitIdentPos = this.awaitIdentPos;
  this.initFunction(node);
  if (this.options.ecmaVersion >= 6) {
    node.generator = isGenerator;
  }
  if (this.options.ecmaVersion >= 8) {
    node.async = !!isAsync;
  }
  this.yieldPos = 0;
  this.awaitPos = 0;
  this.awaitIdentPos = 0;
  this.enterScope(functionFlags(isAsync, node.generator) | SCOPE_SUPER | (allowDirectSuper ? SCOPE_DIRECT_SUPER : 0));
  this.expect(types$1.parenL);
  node.params = this.parseBindingList(types$1.parenR, false, this.options.ecmaVersion >= 8);
  this.checkYieldAwaitInDefaultParams();
  this.parseFunctionBody(node, false, true, false);
  this.yieldPos = oldYieldPos;
  this.awaitPos = oldAwaitPos;
  this.awaitIdentPos = oldAwaitIdentPos;
  return this.finishNode(node, "FunctionExpression");
};
pp$5.parseArrowExpression = function(node, params, isAsync, forInit) {
  var oldYieldPos = this.yieldPos, oldAwaitPos = this.awaitPos, oldAwaitIdentPos = this.awaitIdentPos;
  this.enterScope(functionFlags(isAsync, false) | SCOPE_ARROW);
  this.initFunction(node);
  if (this.options.ecmaVersion >= 8) {
    node.async = !!isAsync;
  }
  this.yieldPos = 0;
  this.awaitPos = 0;
  this.awaitIdentPos = 0;
  node.params = this.toAssignableList(params, true);
  this.parseFunctionBody(node, true, false, forInit);
  this.yieldPos = oldYieldPos;
  this.awaitPos = oldAwaitPos;
  this.awaitIdentPos = oldAwaitIdentPos;
  return this.finishNode(node, "ArrowFunctionExpression");
};
pp$5.parseFunctionBody = function(node, isArrowFunction, isMethod, forInit) {
  var isExpression = isArrowFunction && this.type !== types$1.braceL;
  var oldStrict = this.strict, useStrict = false;
  if (isExpression) {
    node.body = this.parseMaybeAssign(forInit);
    node.expression = true;
    this.checkParams(node, false);
  } else {
    var nonSimple = this.options.ecmaVersion >= 7 && !this.isSimpleParamList(node.params);
    if (!oldStrict || nonSimple) {
      useStrict = this.strictDirective(this.end);
      if (useStrict && nonSimple) {
        this.raiseRecoverable(node.start, "Illegal 'use strict' directive in function with non-simple parameter list");
      }
    }
    var oldLabels = this.labels;
    this.labels = [];
    if (useStrict) {
      this.strict = true;
    }
    this.checkParams(node, !oldStrict && !useStrict && !isArrowFunction && !isMethod && this.isSimpleParamList(node.params));
    if (this.strict && node.id) {
      this.checkLValSimple(node.id, BIND_OUTSIDE);
    }
    node.body = this.parseBlock(false, undefined, useStrict && !oldStrict);
    node.expression = false;
    this.adaptDirectivePrologue(node.body.body);
    this.labels = oldLabels;
  }
  this.exitScope();
};
pp$5.isSimpleParamList = function(params) {
  for (var i = 0, list = params;i < list.length; i += 1) {
    var param = list[i];
    if (param.type !== "Identifier") {
      return false;
    }
  }
  return true;
};
pp$5.checkParams = function(node, allowDuplicates) {
  var nameHash = Object.create(null);
  for (var i = 0, list = node.params;i < list.length; i += 1) {
    var param = list[i];
    this.checkLValInnerPattern(param, BIND_VAR, allowDuplicates ? null : nameHash);
  }
};
pp$5.parseExprList = function(close, allowTrailingComma, allowEmpty, refDestructuringErrors) {
  var elts = [], first = true;
  while (!this.eat(close)) {
    if (!first) {
      this.expect(types$1.comma);
      if (allowTrailingComma && this.afterTrailingComma(close)) {
        break;
      }
    } else {
      first = false;
    }
    var elt = undefined;
    if (allowEmpty && this.type === types$1.comma) {
      elt = null;
    } else if (this.type === types$1.ellipsis) {
      elt = this.parseSpread(refDestructuringErrors);
      if (refDestructuringErrors && this.type === types$1.comma && refDestructuringErrors.trailingComma < 0) {
        refDestructuringErrors.trailingComma = this.start;
      }
    } else {
      elt = this.parseMaybeAssign(false, refDestructuringErrors);
    }
    elts.push(elt);
  }
  return elts;
};
pp$5.checkUnreserved = function(ref2) {
  var start = ref2.start;
  var end = ref2.end;
  var name = ref2.name;
  if (this.inGenerator && name === "yield") {
    this.raiseRecoverable(start, "Cannot use 'yield' as identifier inside a generator");
  }
  if (this.inAsync && name === "await") {
    this.raiseRecoverable(start, "Cannot use 'await' as identifier inside an async function");
  }
  if (!(this.currentThisScope().flags & SCOPE_VAR) && name === "arguments") {
    this.raiseRecoverable(start, "Cannot use 'arguments' in class field initializer");
  }
  if (this.inClassStaticBlock && (name === "arguments" || name === "await")) {
    this.raise(start, "Cannot use " + name + " in class static initialization block");
  }
  if (this.keywords.test(name)) {
    this.raise(start, "Unexpected keyword '" + name + "'");
  }
  if (this.options.ecmaVersion < 6 && this.input.slice(start, end).indexOf("\\") !== -1) {
    return;
  }
  var re = this.strict ? this.reservedWordsStrict : this.reservedWords;
  if (re.test(name)) {
    if (!this.inAsync && name === "await") {
      this.raiseRecoverable(start, "Cannot use keyword 'await' outside an async function");
    }
    this.raiseRecoverable(start, "The keyword '" + name + "' is reserved");
  }
};
pp$5.parseIdent = function(liberal) {
  var node = this.parseIdentNode();
  this.next(!!liberal);
  this.finishNode(node, "Identifier");
  if (!liberal) {
    this.checkUnreserved(node);
    if (node.name === "await" && !this.awaitIdentPos) {
      this.awaitIdentPos = node.start;
    }
  }
  return node;
};
pp$5.parseIdentNode = function() {
  var node = this.startNode();
  if (this.type === types$1.name) {
    node.name = this.value;
  } else if (this.type.keyword) {
    node.name = this.type.keyword;
    if ((node.name === "class" || node.name === "function") && (this.lastTokEnd !== this.lastTokStart + 1 || this.input.charCodeAt(this.lastTokStart) !== 46)) {
      this.context.pop();
    }
    this.type = types$1.name;
  } else {
    this.unexpected();
  }
  return node;
};
pp$5.parsePrivateIdent = function() {
  var node = this.startNode();
  if (this.type === types$1.privateId) {
    node.name = this.value;
  } else {
    this.unexpected();
  }
  this.next();
  this.finishNode(node, "PrivateIdentifier");
  if (this.options.checkPrivateFields) {
    if (this.privateNameStack.length === 0) {
      this.raise(node.start, "Private field '#" + node.name + "' must be declared in an enclosing class");
    } else {
      this.privateNameStack[this.privateNameStack.length - 1].used.push(node);
    }
  }
  return node;
};
pp$5.parseYield = function(forInit) {
  if (!this.yieldPos) {
    this.yieldPos = this.start;
  }
  var node = this.startNode();
  this.next();
  if (this.type === types$1.semi || this.canInsertSemicolon() || this.type !== types$1.star && !this.type.startsExpr) {
    node.delegate = false;
    node.argument = null;
  } else {
    node.delegate = this.eat(types$1.star);
    node.argument = this.parseMaybeAssign(forInit);
  }
  return this.finishNode(node, "YieldExpression");
};
pp$5.parseAwait = function(forInit) {
  if (!this.awaitPos) {
    this.awaitPos = this.start;
  }
  var node = this.startNode();
  this.next();
  node.argument = this.parseMaybeUnary(null, true, false, forInit);
  return this.finishNode(node, "AwaitExpression");
};
var pp$4 = Parser.prototype;
pp$4.raise = function(pos, message) {
  var loc = getLineInfo(this.input, pos);
  message += " (" + loc.line + ":" + loc.column + ")";
  if (this.sourceFile) {
    message += " in " + this.sourceFile;
  }
  var err = new SyntaxError(message);
  err.pos = pos;
  err.loc = loc;
  err.raisedAt = this.pos;
  throw err;
};
pp$4.raiseRecoverable = pp$4.raise;
pp$4.curPosition = function() {
  if (this.options.locations) {
    return new Position(this.curLine, this.pos - this.lineStart);
  }
};
var pp$3 = Parser.prototype;
var Scope = function Scope2(flags) {
  this.flags = flags;
  this.var = [];
  this.lexical = [];
  this.functions = [];
};
pp$3.enterScope = function(flags) {
  this.scopeStack.push(new Scope(flags));
};
pp$3.exitScope = function() {
  this.scopeStack.pop();
};
pp$3.treatFunctionsAsVarInScope = function(scope) {
  return scope.flags & SCOPE_FUNCTION || !this.inModule && scope.flags & SCOPE_TOP;
};
pp$3.declareName = function(name, bindingType, pos) {
  var redeclared = false;
  if (bindingType === BIND_LEXICAL) {
    var scope = this.currentScope();
    redeclared = scope.lexical.indexOf(name) > -1 || scope.functions.indexOf(name) > -1 || scope.var.indexOf(name) > -1;
    scope.lexical.push(name);
    if (this.inModule && scope.flags & SCOPE_TOP) {
      delete this.undefinedExports[name];
    }
  } else if (bindingType === BIND_SIMPLE_CATCH) {
    var scope$1 = this.currentScope();
    scope$1.lexical.push(name);
  } else if (bindingType === BIND_FUNCTION) {
    var scope$2 = this.currentScope();
    if (this.treatFunctionsAsVar) {
      redeclared = scope$2.lexical.indexOf(name) > -1;
    } else {
      redeclared = scope$2.lexical.indexOf(name) > -1 || scope$2.var.indexOf(name) > -1;
    }
    scope$2.functions.push(name);
  } else {
    for (var i = this.scopeStack.length - 1;i >= 0; --i) {
      var scope$3 = this.scopeStack[i];
      if (scope$3.lexical.indexOf(name) > -1 && !(scope$3.flags & SCOPE_SIMPLE_CATCH && scope$3.lexical[0] === name) || !this.treatFunctionsAsVarInScope(scope$3) && scope$3.functions.indexOf(name) > -1) {
        redeclared = true;
        break;
      }
      scope$3.var.push(name);
      if (this.inModule && scope$3.flags & SCOPE_TOP) {
        delete this.undefinedExports[name];
      }
      if (scope$3.flags & SCOPE_VAR) {
        break;
      }
    }
  }
  if (redeclared) {
    this.raiseRecoverable(pos, "Identifier '" + name + "' has already been declared");
  }
};
pp$3.checkLocalExport = function(id) {
  if (this.scopeStack[0].lexical.indexOf(id.name) === -1 && this.scopeStack[0].var.indexOf(id.name) === -1) {
    this.undefinedExports[id.name] = id;
  }
};
pp$3.currentScope = function() {
  return this.scopeStack[this.scopeStack.length - 1];
};
pp$3.currentVarScope = function() {
  for (var i = this.scopeStack.length - 1;; i--) {
    var scope = this.scopeStack[i];
    if (scope.flags & (SCOPE_VAR | SCOPE_CLASS_FIELD_INIT | SCOPE_CLASS_STATIC_BLOCK)) {
      return scope;
    }
  }
};
pp$3.currentThisScope = function() {
  for (var i = this.scopeStack.length - 1;; i--) {
    var scope = this.scopeStack[i];
    if (scope.flags & (SCOPE_VAR | SCOPE_CLASS_FIELD_INIT | SCOPE_CLASS_STATIC_BLOCK) && !(scope.flags & SCOPE_ARROW)) {
      return scope;
    }
  }
};
var Node = function Node2(parser, pos, loc) {
  this.type = "";
  this.start = pos;
  this.end = 0;
  if (parser.options.locations) {
    this.loc = new SourceLocation(parser, loc);
  }
  if (parser.options.directSourceFile) {
    this.sourceFile = parser.options.directSourceFile;
  }
  if (parser.options.ranges) {
    this.range = [pos, 0];
  }
};
var pp$2 = Parser.prototype;
pp$2.startNode = function() {
  return new Node(this, this.start, this.startLoc);
};
pp$2.startNodeAt = function(pos, loc) {
  return new Node(this, pos, loc);
};
function finishNodeAt(node, type2, pos, loc) {
  node.type = type2;
  node.end = pos;
  if (this.options.locations) {
    node.loc.end = loc;
  }
  if (this.options.ranges) {
    node.range[1] = pos;
  }
  return node;
}
pp$2.finishNode = function(node, type2) {
  return finishNodeAt.call(this, node, type2, this.lastTokEnd, this.lastTokEndLoc);
};
pp$2.finishNodeAt = function(node, type2, pos, loc) {
  return finishNodeAt.call(this, node, type2, pos, loc);
};
pp$2.copyNode = function(node) {
  var newNode = new Node(this, node.start, this.startLoc);
  for (var prop in node) {
    newNode[prop] = node[prop];
  }
  return newNode;
};
var scriptValuesAddedInUnicode = "Gara Garay Gukh Gurung_Khema Hrkt Katakana_Or_Hiragana Kawi Kirat_Rai Krai Nag_Mundari Nagm Ol_Onal Onao Sunu Sunuwar Todhri Todr Tulu_Tigalari Tutg Unknown Zzzz";
var ecma9BinaryProperties = "ASCII ASCII_Hex_Digit AHex Alphabetic Alpha Any Assigned Bidi_Control Bidi_C Bidi_Mirrored Bidi_M Case_Ignorable CI Cased Changes_When_Casefolded CWCF Changes_When_Casemapped CWCM Changes_When_Lowercased CWL Changes_When_NFKC_Casefolded CWKCF Changes_When_Titlecased CWT Changes_When_Uppercased CWU Dash Default_Ignorable_Code_Point DI Deprecated Dep Diacritic Dia Emoji Emoji_Component Emoji_Modifier Emoji_Modifier_Base Emoji_Presentation Extender Ext Grapheme_Base Gr_Base Grapheme_Extend Gr_Ext Hex_Digit Hex IDS_Binary_Operator IDSB IDS_Trinary_Operator IDST ID_Continue IDC ID_Start IDS Ideographic Ideo Join_Control Join_C Logical_Order_Exception LOE Lowercase Lower Math Noncharacter_Code_Point NChar Pattern_Syntax Pat_Syn Pattern_White_Space Pat_WS Quotation_Mark QMark Radical Regional_Indicator RI Sentence_Terminal STerm Soft_Dotted SD Terminal_Punctuation Term Unified_Ideograph UIdeo Uppercase Upper Variation_Selector VS White_Space space XID_Continue XIDC XID_Start XIDS";
var ecma10BinaryProperties = ecma9BinaryProperties + " Extended_Pictographic";
var ecma11BinaryProperties = ecma10BinaryProperties;
var ecma12BinaryProperties = ecma11BinaryProperties + " EBase EComp EMod EPres ExtPict";
var ecma13BinaryProperties = ecma12BinaryProperties;
var ecma14BinaryProperties = ecma13BinaryProperties;
var unicodeBinaryProperties = {
  9: ecma9BinaryProperties,
  10: ecma10BinaryProperties,
  11: ecma11BinaryProperties,
  12: ecma12BinaryProperties,
  13: ecma13BinaryProperties,
  14: ecma14BinaryProperties
};
var ecma14BinaryPropertiesOfStrings = "Basic_Emoji Emoji_Keycap_Sequence RGI_Emoji_Modifier_Sequence RGI_Emoji_Flag_Sequence RGI_Emoji_Tag_Sequence RGI_Emoji_ZWJ_Sequence RGI_Emoji";
var unicodeBinaryPropertiesOfStrings = {
  9: "",
  10: "",
  11: "",
  12: "",
  13: "",
  14: ecma14BinaryPropertiesOfStrings
};
var unicodeGeneralCategoryValues = "Cased_Letter LC Close_Punctuation Pe Connector_Punctuation Pc Control Cc cntrl Currency_Symbol Sc Dash_Punctuation Pd Decimal_Number Nd digit Enclosing_Mark Me Final_Punctuation Pf Format Cf Initial_Punctuation Pi Letter L Letter_Number Nl Line_Separator Zl Lowercase_Letter Ll Mark M Combining_Mark Math_Symbol Sm Modifier_Letter Lm Modifier_Symbol Sk Nonspacing_Mark Mn Number N Open_Punctuation Ps Other C Other_Letter Lo Other_Number No Other_Punctuation Po Other_Symbol So Paragraph_Separator Zp Private_Use Co Punctuation P punct Separator Z Space_Separator Zs Spacing_Mark Mc Surrogate Cs Symbol S Titlecase_Letter Lt Unassigned Cn Uppercase_Letter Lu";
var ecma9ScriptValues = "Adlam Adlm Ahom Anatolian_Hieroglyphs Hluw Arabic Arab Armenian Armn Avestan Avst Balinese Bali Bamum Bamu Bassa_Vah Bass Batak Batk Bengali Beng Bhaiksuki Bhks Bopomofo Bopo Brahmi Brah Braille Brai Buginese Bugi Buhid Buhd Canadian_Aboriginal Cans Carian Cari Caucasian_Albanian Aghb Chakma Cakm Cham Cham Cherokee Cher Common Zyyy Coptic Copt Qaac Cuneiform Xsux Cypriot Cprt Cyrillic Cyrl Deseret Dsrt Devanagari Deva Duployan Dupl Egyptian_Hieroglyphs Egyp Elbasan Elba Ethiopic Ethi Georgian Geor Glagolitic Glag Gothic Goth Grantha Gran Greek Grek Gujarati Gujr Gurmukhi Guru Han Hani Hangul Hang Hanunoo Hano Hatran Hatr Hebrew Hebr Hiragana Hira Imperial_Aramaic Armi Inherited Zinh Qaai Inscriptional_Pahlavi Phli Inscriptional_Parthian Prti Javanese Java Kaithi Kthi Kannada Knda Katakana Kana Kayah_Li Kali Kharoshthi Khar Khmer Khmr Khojki Khoj Khudawadi Sind Lao Laoo Latin Latn Lepcha Lepc Limbu Limb Linear_A Lina Linear_B Linb Lisu Lisu Lycian Lyci Lydian Lydi Mahajani Mahj Malayalam Mlym Mandaic Mand Manichaean Mani Marchen Marc Masaram_Gondi Gonm Meetei_Mayek Mtei Mende_Kikakui Mend Meroitic_Cursive Merc Meroitic_Hieroglyphs Mero Miao Plrd Modi Mongolian Mong Mro Mroo Multani Mult Myanmar Mymr Nabataean Nbat New_Tai_Lue Talu Newa Newa Nko Nkoo Nushu Nshu Ogham Ogam Ol_Chiki Olck Old_Hungarian Hung Old_Italic Ital Old_North_Arabian Narb Old_Permic Perm Old_Persian Xpeo Old_South_Arabian Sarb Old_Turkic Orkh Oriya Orya Osage Osge Osmanya Osma Pahawh_Hmong Hmng Palmyrene Palm Pau_Cin_Hau Pauc Phags_Pa Phag Phoenician Phnx Psalter_Pahlavi Phlp Rejang Rjng Runic Runr Samaritan Samr Saurashtra Saur Sharada Shrd Shavian Shaw Siddham Sidd SignWriting Sgnw Sinhala Sinh Sora_Sompeng Sora Soyombo Soyo Sundanese Sund Syloti_Nagri Sylo Syriac Syrc Tagalog Tglg Tagbanwa Tagb Tai_Le Tale Tai_Tham Lana Tai_Viet Tavt Takri Takr Tamil Taml Tangut Tang Telugu Telu Thaana Thaa Thai Thai Tibetan Tibt Tifinagh Tfng Tirhuta Tirh Ugaritic Ugar Vai Vaii Warang_Citi Wara Yi Yiii Zanabazar_Square Zanb";
var ecma10ScriptValues = ecma9ScriptValues + " Dogra Dogr Gunjala_Gondi Gong Hanifi_Rohingya Rohg Makasar Maka Medefaidrin Medf Old_Sogdian Sogo Sogdian Sogd";
var ecma11ScriptValues = ecma10ScriptValues + " Elymaic Elym Nandinagari Nand Nyiakeng_Puachue_Hmong Hmnp Wancho Wcho";
var ecma12ScriptValues = ecma11ScriptValues + " Chorasmian Chrs Diak Dives_Akuru Khitan_Small_Script Kits Yezi Yezidi";
var ecma13ScriptValues = ecma12ScriptValues + " Cypro_Minoan Cpmn Old_Uyghur Ougr Tangsa Tnsa Toto Vithkuqi Vith";
var ecma14ScriptValues = ecma13ScriptValues + " " + scriptValuesAddedInUnicode;
var unicodeScriptValues = {
  9: ecma9ScriptValues,
  10: ecma10ScriptValues,
  11: ecma11ScriptValues,
  12: ecma12ScriptValues,
  13: ecma13ScriptValues,
  14: ecma14ScriptValues
};
var data = {};
function buildUnicodeData(ecmaVersion) {
  var d2 = data[ecmaVersion] = {
    binary: wordsRegexp(unicodeBinaryProperties[ecmaVersion] + " " + unicodeGeneralCategoryValues),
    binaryOfStrings: wordsRegexp(unicodeBinaryPropertiesOfStrings[ecmaVersion]),
    nonBinary: {
      General_Category: wordsRegexp(unicodeGeneralCategoryValues),
      Script: wordsRegexp(unicodeScriptValues[ecmaVersion])
    }
  };
  d2.nonBinary.Script_Extensions = d2.nonBinary.Script;
  d2.nonBinary.gc = d2.nonBinary.General_Category;
  d2.nonBinary.sc = d2.nonBinary.Script;
  d2.nonBinary.scx = d2.nonBinary.Script_Extensions;
}
for (i = 0, list = [9, 10, 11, 12, 13, 14];i < list.length; i += 1) {
  ecmaVersion = list[i];
  buildUnicodeData(ecmaVersion);
}
var ecmaVersion;
var i;
var list;
var pp$1 = Parser.prototype;
var BranchID = function BranchID2(parent, base) {
  this.parent = parent;
  this.base = base || this;
};
BranchID.prototype.separatedFrom = function separatedFrom(alt) {
  for (var self2 = this;self2; self2 = self2.parent) {
    for (var other = alt;other; other = other.parent) {
      if (self2.base === other.base && self2 !== other) {
        return true;
      }
    }
  }
  return false;
};
BranchID.prototype.sibling = function sibling() {
  return new BranchID(this.parent, this.base);
};
var RegExpValidationState = function RegExpValidationState2(parser) {
  this.parser = parser;
  this.validFlags = "gim" + (parser.options.ecmaVersion >= 6 ? "uy" : "") + (parser.options.ecmaVersion >= 9 ? "s" : "") + (parser.options.ecmaVersion >= 13 ? "d" : "") + (parser.options.ecmaVersion >= 15 ? "v" : "");
  this.unicodeProperties = data[parser.options.ecmaVersion >= 14 ? 14 : parser.options.ecmaVersion];
  this.source = "";
  this.flags = "";
  this.start = 0;
  this.switchU = false;
  this.switchV = false;
  this.switchN = false;
  this.pos = 0;
  this.lastIntValue = 0;
  this.lastStringValue = "";
  this.lastAssertionIsQuantifiable = false;
  this.numCapturingParens = 0;
  this.maxBackReference = 0;
  this.groupNames = Object.create(null);
  this.backReferenceNames = [];
  this.branchID = null;
};
RegExpValidationState.prototype.reset = function reset(start, pattern, flags) {
  var unicodeSets = flags.indexOf("v") !== -1;
  var unicode = flags.indexOf("u") !== -1;
  this.start = start | 0;
  this.source = pattern + "";
  this.flags = flags;
  if (unicodeSets && this.parser.options.ecmaVersion >= 15) {
    this.switchU = true;
    this.switchV = true;
    this.switchN = true;
  } else {
    this.switchU = unicode && this.parser.options.ecmaVersion >= 6;
    this.switchV = false;
    this.switchN = unicode && this.parser.options.ecmaVersion >= 9;
  }
};
RegExpValidationState.prototype.raise = function raise(message) {
  this.parser.raiseRecoverable(this.start, "Invalid regular expression: /" + this.source + "/: " + message);
};
RegExpValidationState.prototype.at = function at(i2, forceU) {
  if (forceU === undefined)
    forceU = false;
  var s = this.source;
  var l = s.length;
  if (i2 >= l) {
    return -1;
  }
  var c = s.charCodeAt(i2);
  if (!(forceU || this.switchU) || c <= 55295 || c >= 57344 || i2 + 1 >= l) {
    return c;
  }
  var next = s.charCodeAt(i2 + 1);
  return next >= 56320 && next <= 57343 ? (c << 10) + next - 56613888 : c;
};
RegExpValidationState.prototype.nextIndex = function nextIndex(i2, forceU) {
  if (forceU === undefined)
    forceU = false;
  var s = this.source;
  var l = s.length;
  if (i2 >= l) {
    return l;
  }
  var c = s.charCodeAt(i2), next;
  if (!(forceU || this.switchU) || c <= 55295 || c >= 57344 || i2 + 1 >= l || (next = s.charCodeAt(i2 + 1)) < 56320 || next > 57343) {
    return i2 + 1;
  }
  return i2 + 2;
};
RegExpValidationState.prototype.current = function current(forceU) {
  if (forceU === undefined)
    forceU = false;
  return this.at(this.pos, forceU);
};
RegExpValidationState.prototype.lookahead = function lookahead(forceU) {
  if (forceU === undefined)
    forceU = false;
  return this.at(this.nextIndex(this.pos, forceU), forceU);
};
RegExpValidationState.prototype.advance = function advance(forceU) {
  if (forceU === undefined)
    forceU = false;
  this.pos = this.nextIndex(this.pos, forceU);
};
RegExpValidationState.prototype.eat = function eat(ch, forceU) {
  if (forceU === undefined)
    forceU = false;
  if (this.current(forceU) === ch) {
    this.advance(forceU);
    return true;
  }
  return false;
};
RegExpValidationState.prototype.eatChars = function eatChars(chs, forceU) {
  if (forceU === undefined)
    forceU = false;
  var pos = this.pos;
  for (var i2 = 0, list2 = chs;i2 < list2.length; i2 += 1) {
    var ch = list2[i2];
    var current2 = this.at(pos, forceU);
    if (current2 === -1 || current2 !== ch) {
      return false;
    }
    pos = this.nextIndex(pos, forceU);
  }
  this.pos = pos;
  return true;
};
pp$1.validateRegExpFlags = function(state) {
  var validFlags = state.validFlags;
  var flags = state.flags;
  var u = false;
  var v = false;
  for (var i2 = 0;i2 < flags.length; i2++) {
    var flag = flags.charAt(i2);
    if (validFlags.indexOf(flag) === -1) {
      this.raise(state.start, "Invalid regular expression flag");
    }
    if (flags.indexOf(flag, i2 + 1) > -1) {
      this.raise(state.start, "Duplicate regular expression flag");
    }
    if (flag === "u") {
      u = true;
    }
    if (flag === "v") {
      v = true;
    }
  }
  if (this.options.ecmaVersion >= 15 && u && v) {
    this.raise(state.start, "Invalid regular expression flag");
  }
};
function hasProp(obj) {
  for (var _23 in obj) {
    return true;
  }
  return false;
}
pp$1.validateRegExpPattern = function(state) {
  this.regexp_pattern(state);
  if (!state.switchN && this.options.ecmaVersion >= 9 && hasProp(state.groupNames)) {
    state.switchN = true;
    this.regexp_pattern(state);
  }
};
pp$1.regexp_pattern = function(state) {
  state.pos = 0;
  state.lastIntValue = 0;
  state.lastStringValue = "";
  state.lastAssertionIsQuantifiable = false;
  state.numCapturingParens = 0;
  state.maxBackReference = 0;
  state.groupNames = Object.create(null);
  state.backReferenceNames.length = 0;
  state.branchID = null;
  this.regexp_disjunction(state);
  if (state.pos !== state.source.length) {
    if (state.eat(41)) {
      state.raise("Unmatched ')'");
    }
    if (state.eat(93) || state.eat(125)) {
      state.raise("Lone quantifier brackets");
    }
  }
  if (state.maxBackReference > state.numCapturingParens) {
    state.raise("Invalid escape");
  }
  for (var i2 = 0, list2 = state.backReferenceNames;i2 < list2.length; i2 += 1) {
    var name = list2[i2];
    if (!state.groupNames[name]) {
      state.raise("Invalid named capture referenced");
    }
  }
};
pp$1.regexp_disjunction = function(state) {
  var trackDisjunction = this.options.ecmaVersion >= 16;
  if (trackDisjunction) {
    state.branchID = new BranchID(state.branchID, null);
  }
  this.regexp_alternative(state);
  while (state.eat(124)) {
    if (trackDisjunction) {
      state.branchID = state.branchID.sibling();
    }
    this.regexp_alternative(state);
  }
  if (trackDisjunction) {
    state.branchID = state.branchID.parent;
  }
  if (this.regexp_eatQuantifier(state, true)) {
    state.raise("Nothing to repeat");
  }
  if (state.eat(123)) {
    state.raise("Lone quantifier brackets");
  }
};
pp$1.regexp_alternative = function(state) {
  while (state.pos < state.source.length && this.regexp_eatTerm(state)) {}
};
pp$1.regexp_eatTerm = function(state) {
  if (this.regexp_eatAssertion(state)) {
    if (state.lastAssertionIsQuantifiable && this.regexp_eatQuantifier(state)) {
      if (state.switchU) {
        state.raise("Invalid quantifier");
      }
    }
    return true;
  }
  if (state.switchU ? this.regexp_eatAtom(state) : this.regexp_eatExtendedAtom(state)) {
    this.regexp_eatQuantifier(state);
    return true;
  }
  return false;
};
pp$1.regexp_eatAssertion = function(state) {
  var start = state.pos;
  state.lastAssertionIsQuantifiable = false;
  if (state.eat(94) || state.eat(36)) {
    return true;
  }
  if (state.eat(92)) {
    if (state.eat(66) || state.eat(98)) {
      return true;
    }
    state.pos = start;
  }
  if (state.eat(40) && state.eat(63)) {
    var lookbehind = false;
    if (this.options.ecmaVersion >= 9) {
      lookbehind = state.eat(60);
    }
    if (state.eat(61) || state.eat(33)) {
      this.regexp_disjunction(state);
      if (!state.eat(41)) {
        state.raise("Unterminated group");
      }
      state.lastAssertionIsQuantifiable = !lookbehind;
      return true;
    }
  }
  state.pos = start;
  return false;
};
pp$1.regexp_eatQuantifier = function(state, noError) {
  if (noError === undefined)
    noError = false;
  if (this.regexp_eatQuantifierPrefix(state, noError)) {
    state.eat(63);
    return true;
  }
  return false;
};
pp$1.regexp_eatQuantifierPrefix = function(state, noError) {
  return state.eat(42) || state.eat(43) || state.eat(63) || this.regexp_eatBracedQuantifier(state, noError);
};
pp$1.regexp_eatBracedQuantifier = function(state, noError) {
  var start = state.pos;
  if (state.eat(123)) {
    var min = 0, max = -1;
    if (this.regexp_eatDecimalDigits(state)) {
      min = state.lastIntValue;
      if (state.eat(44) && this.regexp_eatDecimalDigits(state)) {
        max = state.lastIntValue;
      }
      if (state.eat(125)) {
        if (max !== -1 && max < min && !noError) {
          state.raise("numbers out of order in {} quantifier");
        }
        return true;
      }
    }
    if (state.switchU && !noError) {
      state.raise("Incomplete quantifier");
    }
    state.pos = start;
  }
  return false;
};
pp$1.regexp_eatAtom = function(state) {
  return this.regexp_eatPatternCharacters(state) || state.eat(46) || this.regexp_eatReverseSolidusAtomEscape(state) || this.regexp_eatCharacterClass(state) || this.regexp_eatUncapturingGroup(state) || this.regexp_eatCapturingGroup(state);
};
pp$1.regexp_eatReverseSolidusAtomEscape = function(state) {
  var start = state.pos;
  if (state.eat(92)) {
    if (this.regexp_eatAtomEscape(state)) {
      return true;
    }
    state.pos = start;
  }
  return false;
};
pp$1.regexp_eatUncapturingGroup = function(state) {
  var start = state.pos;
  if (state.eat(40)) {
    if (state.eat(63)) {
      if (this.options.ecmaVersion >= 16) {
        var addModifiers = this.regexp_eatModifiers(state);
        var hasHyphen = state.eat(45);
        if (addModifiers || hasHyphen) {
          for (var i2 = 0;i2 < addModifiers.length; i2++) {
            var modifier = addModifiers.charAt(i2);
            if (addModifiers.indexOf(modifier, i2 + 1) > -1) {
              state.raise("Duplicate regular expression modifiers");
            }
          }
          if (hasHyphen) {
            var removeModifiers = this.regexp_eatModifiers(state);
            if (!addModifiers && !removeModifiers && state.current() === 58) {
              state.raise("Invalid regular expression modifiers");
            }
            for (var i$1 = 0;i$1 < removeModifiers.length; i$1++) {
              var modifier$1 = removeModifiers.charAt(i$1);
              if (removeModifiers.indexOf(modifier$1, i$1 + 1) > -1 || addModifiers.indexOf(modifier$1) > -1) {
                state.raise("Duplicate regular expression modifiers");
              }
            }
          }
        }
      }
      if (state.eat(58)) {
        this.regexp_disjunction(state);
        if (state.eat(41)) {
          return true;
        }
        state.raise("Unterminated group");
      }
    }
    state.pos = start;
  }
  return false;
};
pp$1.regexp_eatCapturingGroup = function(state) {
  if (state.eat(40)) {
    if (this.options.ecmaVersion >= 9) {
      this.regexp_groupSpecifier(state);
    } else if (state.current() === 63) {
      state.raise("Invalid group");
    }
    this.regexp_disjunction(state);
    if (state.eat(41)) {
      state.numCapturingParens += 1;
      return true;
    }
    state.raise("Unterminated group");
  }
  return false;
};
pp$1.regexp_eatModifiers = function(state) {
  var modifiers = "";
  var ch = 0;
  while ((ch = state.current()) !== -1 && isRegularExpressionModifier(ch)) {
    modifiers += codePointToString(ch);
    state.advance();
  }
  return modifiers;
};
function isRegularExpressionModifier(ch) {
  return ch === 105 || ch === 109 || ch === 115;
}
pp$1.regexp_eatExtendedAtom = function(state) {
  return state.eat(46) || this.regexp_eatReverseSolidusAtomEscape(state) || this.regexp_eatCharacterClass(state) || this.regexp_eatUncapturingGroup(state) || this.regexp_eatCapturingGroup(state) || this.regexp_eatInvalidBracedQuantifier(state) || this.regexp_eatExtendedPatternCharacter(state);
};
pp$1.regexp_eatInvalidBracedQuantifier = function(state) {
  if (this.regexp_eatBracedQuantifier(state, true)) {
    state.raise("Nothing to repeat");
  }
  return false;
};
pp$1.regexp_eatSyntaxCharacter = function(state) {
  var ch = state.current();
  if (isSyntaxCharacter(ch)) {
    state.lastIntValue = ch;
    state.advance();
    return true;
  }
  return false;
};
function isSyntaxCharacter(ch) {
  return ch === 36 || ch >= 40 && ch <= 43 || ch === 46 || ch === 63 || ch >= 91 && ch <= 94 || ch >= 123 && ch <= 125;
}
pp$1.regexp_eatPatternCharacters = function(state) {
  var start = state.pos;
  var ch = 0;
  while ((ch = state.current()) !== -1 && !isSyntaxCharacter(ch)) {
    state.advance();
  }
  return state.pos !== start;
};
pp$1.regexp_eatExtendedPatternCharacter = function(state) {
  var ch = state.current();
  if (ch !== -1 && ch !== 36 && !(ch >= 40 && ch <= 43) && ch !== 46 && ch !== 63 && ch !== 91 && ch !== 94 && ch !== 124) {
    state.advance();
    return true;
  }
  return false;
};
pp$1.regexp_groupSpecifier = function(state) {
  if (state.eat(63)) {
    if (!this.regexp_eatGroupName(state)) {
      state.raise("Invalid group");
    }
    var trackDisjunction = this.options.ecmaVersion >= 16;
    var known = state.groupNames[state.lastStringValue];
    if (known) {
      if (trackDisjunction) {
        for (var i2 = 0, list2 = known;i2 < list2.length; i2 += 1) {
          var altID = list2[i2];
          if (!altID.separatedFrom(state.branchID)) {
            state.raise("Duplicate capture group name");
          }
        }
      } else {
        state.raise("Duplicate capture group name");
      }
    }
    if (trackDisjunction) {
      (known || (state.groupNames[state.lastStringValue] = [])).push(state.branchID);
    } else {
      state.groupNames[state.lastStringValue] = true;
    }
  }
};
pp$1.regexp_eatGroupName = function(state) {
  state.lastStringValue = "";
  if (state.eat(60)) {
    if (this.regexp_eatRegExpIdentifierName(state) && state.eat(62)) {
      return true;
    }
    state.raise("Invalid capture group name");
  }
  return false;
};
pp$1.regexp_eatRegExpIdentifierName = function(state) {
  state.lastStringValue = "";
  if (this.regexp_eatRegExpIdentifierStart(state)) {
    state.lastStringValue += codePointToString(state.lastIntValue);
    while (this.regexp_eatRegExpIdentifierPart(state)) {
      state.lastStringValue += codePointToString(state.lastIntValue);
    }
    return true;
  }
  return false;
};
pp$1.regexp_eatRegExpIdentifierStart = function(state) {
  var start = state.pos;
  var forceU = this.options.ecmaVersion >= 11;
  var ch = state.current(forceU);
  state.advance(forceU);
  if (ch === 92 && this.regexp_eatRegExpUnicodeEscapeSequence(state, forceU)) {
    ch = state.lastIntValue;
  }
  if (isRegExpIdentifierStart(ch)) {
    state.lastIntValue = ch;
    return true;
  }
  state.pos = start;
  return false;
};
function isRegExpIdentifierStart(ch) {
  return isIdentifierStart(ch, true) || ch === 36 || ch === 95;
}
pp$1.regexp_eatRegExpIdentifierPart = function(state) {
  var start = state.pos;
  var forceU = this.options.ecmaVersion >= 11;
  var ch = state.current(forceU);
  state.advance(forceU);
  if (ch === 92 && this.regexp_eatRegExpUnicodeEscapeSequence(state, forceU)) {
    ch = state.lastIntValue;
  }
  if (isRegExpIdentifierPart(ch)) {
    state.lastIntValue = ch;
    return true;
  }
  state.pos = start;
  return false;
};
function isRegExpIdentifierPart(ch) {
  return isIdentifierChar(ch, true) || ch === 36 || ch === 95 || ch === 8204 || ch === 8205;
}
pp$1.regexp_eatAtomEscape = function(state) {
  if (this.regexp_eatBackReference(state) || this.regexp_eatCharacterClassEscape(state) || this.regexp_eatCharacterEscape(state) || state.switchN && this.regexp_eatKGroupName(state)) {
    return true;
  }
  if (state.switchU) {
    if (state.current() === 99) {
      state.raise("Invalid unicode escape");
    }
    state.raise("Invalid escape");
  }
  return false;
};
pp$1.regexp_eatBackReference = function(state) {
  var start = state.pos;
  if (this.regexp_eatDecimalEscape(state)) {
    var n2 = state.lastIntValue;
    if (state.switchU) {
      if (n2 > state.maxBackReference) {
        state.maxBackReference = n2;
      }
      return true;
    }
    if (n2 <= state.numCapturingParens) {
      return true;
    }
    state.pos = start;
  }
  return false;
};
pp$1.regexp_eatKGroupName = function(state) {
  if (state.eat(107)) {
    if (this.regexp_eatGroupName(state)) {
      state.backReferenceNames.push(state.lastStringValue);
      return true;
    }
    state.raise("Invalid named reference");
  }
  return false;
};
pp$1.regexp_eatCharacterEscape = function(state) {
  return this.regexp_eatControlEscape(state) || this.regexp_eatCControlLetter(state) || this.regexp_eatZero(state) || this.regexp_eatHexEscapeSequence(state) || this.regexp_eatRegExpUnicodeEscapeSequence(state, false) || !state.switchU && this.regexp_eatLegacyOctalEscapeSequence(state) || this.regexp_eatIdentityEscape(state);
};
pp$1.regexp_eatCControlLetter = function(state) {
  var start = state.pos;
  if (state.eat(99)) {
    if (this.regexp_eatControlLetter(state)) {
      return true;
    }
    state.pos = start;
  }
  return false;
};
pp$1.regexp_eatZero = function(state) {
  if (state.current() === 48 && !isDecimalDigit(state.lookahead())) {
    state.lastIntValue = 0;
    state.advance();
    return true;
  }
  return false;
};
pp$1.regexp_eatControlEscape = function(state) {
  var ch = state.current();
  if (ch === 116) {
    state.lastIntValue = 9;
    state.advance();
    return true;
  }
  if (ch === 110) {
    state.lastIntValue = 10;
    state.advance();
    return true;
  }
  if (ch === 118) {
    state.lastIntValue = 11;
    state.advance();
    return true;
  }
  if (ch === 102) {
    state.lastIntValue = 12;
    state.advance();
    return true;
  }
  if (ch === 114) {
    state.lastIntValue = 13;
    state.advance();
    return true;
  }
  return false;
};
pp$1.regexp_eatControlLetter = function(state) {
  var ch = state.current();
  if (isControlLetter(ch)) {
    state.lastIntValue = ch % 32;
    state.advance();
    return true;
  }
  return false;
};
function isControlLetter(ch) {
  return ch >= 65 && ch <= 90 || ch >= 97 && ch <= 122;
}
pp$1.regexp_eatRegExpUnicodeEscapeSequence = function(state, forceU) {
  if (forceU === undefined)
    forceU = false;
  var start = state.pos;
  var switchU = forceU || state.switchU;
  if (state.eat(117)) {
    if (this.regexp_eatFixedHexDigits(state, 4)) {
      var lead = state.lastIntValue;
      if (switchU && lead >= 55296 && lead <= 56319) {
        var leadSurrogateEnd = state.pos;
        if (state.eat(92) && state.eat(117) && this.regexp_eatFixedHexDigits(state, 4)) {
          var trail = state.lastIntValue;
          if (trail >= 56320 && trail <= 57343) {
            state.lastIntValue = (lead - 55296) * 1024 + (trail - 56320) + 65536;
            return true;
          }
        }
        state.pos = leadSurrogateEnd;
        state.lastIntValue = lead;
      }
      return true;
    }
    if (switchU && state.eat(123) && this.regexp_eatHexDigits(state) && state.eat(125) && isValidUnicode(state.lastIntValue)) {
      return true;
    }
    if (switchU) {
      state.raise("Invalid unicode escape");
    }
    state.pos = start;
  }
  return false;
};
function isValidUnicode(ch) {
  return ch >= 0 && ch <= 1114111;
}
pp$1.regexp_eatIdentityEscape = function(state) {
  if (state.switchU) {
    if (this.regexp_eatSyntaxCharacter(state)) {
      return true;
    }
    if (state.eat(47)) {
      state.lastIntValue = 47;
      return true;
    }
    return false;
  }
  var ch = state.current();
  if (ch !== 99 && (!state.switchN || ch !== 107)) {
    state.lastIntValue = ch;
    state.advance();
    return true;
  }
  return false;
};
pp$1.regexp_eatDecimalEscape = function(state) {
  state.lastIntValue = 0;
  var ch = state.current();
  if (ch >= 49 && ch <= 57) {
    do {
      state.lastIntValue = 10 * state.lastIntValue + (ch - 48);
      state.advance();
    } while ((ch = state.current()) >= 48 && ch <= 57);
    return true;
  }
  return false;
};
var CharSetNone = 0;
var CharSetOk = 1;
var CharSetString = 2;
pp$1.regexp_eatCharacterClassEscape = function(state) {
  var ch = state.current();
  if (isCharacterClassEscape(ch)) {
    state.lastIntValue = -1;
    state.advance();
    return CharSetOk;
  }
  var negate = false;
  if (state.switchU && this.options.ecmaVersion >= 9 && ((negate = ch === 80) || ch === 112)) {
    state.lastIntValue = -1;
    state.advance();
    var result;
    if (state.eat(123) && (result = this.regexp_eatUnicodePropertyValueExpression(state)) && state.eat(125)) {
      if (negate && result === CharSetString) {
        state.raise("Invalid property name");
      }
      return result;
    }
    state.raise("Invalid property name");
  }
  return CharSetNone;
};
function isCharacterClassEscape(ch) {
  return ch === 100 || ch === 68 || ch === 115 || ch === 83 || ch === 119 || ch === 87;
}
pp$1.regexp_eatUnicodePropertyValueExpression = function(state) {
  var start = state.pos;
  if (this.regexp_eatUnicodePropertyName(state) && state.eat(61)) {
    var name = state.lastStringValue;
    if (this.regexp_eatUnicodePropertyValue(state)) {
      var value = state.lastStringValue;
      this.regexp_validateUnicodePropertyNameAndValue(state, name, value);
      return CharSetOk;
    }
  }
  state.pos = start;
  if (this.regexp_eatLoneUnicodePropertyNameOrValue(state)) {
    var nameOrValue = state.lastStringValue;
    return this.regexp_validateUnicodePropertyNameOrValue(state, nameOrValue);
  }
  return CharSetNone;
};
pp$1.regexp_validateUnicodePropertyNameAndValue = function(state, name, value) {
  if (!hasOwn(state.unicodeProperties.nonBinary, name)) {
    state.raise("Invalid property name");
  }
  if (!state.unicodeProperties.nonBinary[name].test(value)) {
    state.raise("Invalid property value");
  }
};
pp$1.regexp_validateUnicodePropertyNameOrValue = function(state, nameOrValue) {
  if (state.unicodeProperties.binary.test(nameOrValue)) {
    return CharSetOk;
  }
  if (state.switchV && state.unicodeProperties.binaryOfStrings.test(nameOrValue)) {
    return CharSetString;
  }
  state.raise("Invalid property name");
};
pp$1.regexp_eatUnicodePropertyName = function(state) {
  var ch = 0;
  state.lastStringValue = "";
  while (isUnicodePropertyNameCharacter(ch = state.current())) {
    state.lastStringValue += codePointToString(ch);
    state.advance();
  }
  return state.lastStringValue !== "";
};
function isUnicodePropertyNameCharacter(ch) {
  return isControlLetter(ch) || ch === 95;
}
pp$1.regexp_eatUnicodePropertyValue = function(state) {
  var ch = 0;
  state.lastStringValue = "";
  while (isUnicodePropertyValueCharacter(ch = state.current())) {
    state.lastStringValue += codePointToString(ch);
    state.advance();
  }
  return state.lastStringValue !== "";
};
function isUnicodePropertyValueCharacter(ch) {
  return isUnicodePropertyNameCharacter(ch) || isDecimalDigit(ch);
}
pp$1.regexp_eatLoneUnicodePropertyNameOrValue = function(state) {
  return this.regexp_eatUnicodePropertyValue(state);
};
pp$1.regexp_eatCharacterClass = function(state) {
  if (state.eat(91)) {
    var negate = state.eat(94);
    var result = this.regexp_classContents(state);
    if (!state.eat(93)) {
      state.raise("Unterminated character class");
    }
    if (negate && result === CharSetString) {
      state.raise("Negated character class may contain strings");
    }
    return true;
  }
  return false;
};
pp$1.regexp_classContents = function(state) {
  if (state.current() === 93) {
    return CharSetOk;
  }
  if (state.switchV) {
    return this.regexp_classSetExpression(state);
  }
  this.regexp_nonEmptyClassRanges(state);
  return CharSetOk;
};
pp$1.regexp_nonEmptyClassRanges = function(state) {
  while (this.regexp_eatClassAtom(state)) {
    var left = state.lastIntValue;
    if (state.eat(45) && this.regexp_eatClassAtom(state)) {
      var right = state.lastIntValue;
      if (state.switchU && (left === -1 || right === -1)) {
        state.raise("Invalid character class");
      }
      if (left !== -1 && right !== -1 && left > right) {
        state.raise("Range out of order in character class");
      }
    }
  }
};
pp$1.regexp_eatClassAtom = function(state) {
  var start = state.pos;
  if (state.eat(92)) {
    if (this.regexp_eatClassEscape(state)) {
      return true;
    }
    if (state.switchU) {
      var ch$1 = state.current();
      if (ch$1 === 99 || isOctalDigit(ch$1)) {
        state.raise("Invalid class escape");
      }
      state.raise("Invalid escape");
    }
    state.pos = start;
  }
  var ch = state.current();
  if (ch !== 93) {
    state.lastIntValue = ch;
    state.advance();
    return true;
  }
  return false;
};
pp$1.regexp_eatClassEscape = function(state) {
  var start = state.pos;
  if (state.eat(98)) {
    state.lastIntValue = 8;
    return true;
  }
  if (state.switchU && state.eat(45)) {
    state.lastIntValue = 45;
    return true;
  }
  if (!state.switchU && state.eat(99)) {
    if (this.regexp_eatClassControlLetter(state)) {
      return true;
    }
    state.pos = start;
  }
  return this.regexp_eatCharacterClassEscape(state) || this.regexp_eatCharacterEscape(state);
};
pp$1.regexp_classSetExpression = function(state) {
  var result = CharSetOk, subResult;
  if (this.regexp_eatClassSetRange(state))
    ;
  else if (subResult = this.regexp_eatClassSetOperand(state)) {
    if (subResult === CharSetString) {
      result = CharSetString;
    }
    var start = state.pos;
    while (state.eatChars([38, 38])) {
      if (state.current() !== 38 && (subResult = this.regexp_eatClassSetOperand(state))) {
        if (subResult !== CharSetString) {
          result = CharSetOk;
        }
        continue;
      }
      state.raise("Invalid character in character class");
    }
    if (start !== state.pos) {
      return result;
    }
    while (state.eatChars([45, 45])) {
      if (this.regexp_eatClassSetOperand(state)) {
        continue;
      }
      state.raise("Invalid character in character class");
    }
    if (start !== state.pos) {
      return result;
    }
  } else {
    state.raise("Invalid character in character class");
  }
  for (;; ) {
    if (this.regexp_eatClassSetRange(state)) {
      continue;
    }
    subResult = this.regexp_eatClassSetOperand(state);
    if (!subResult) {
      return result;
    }
    if (subResult === CharSetString) {
      result = CharSetString;
    }
  }
};
pp$1.regexp_eatClassSetRange = function(state) {
  var start = state.pos;
  if (this.regexp_eatClassSetCharacter(state)) {
    var left = state.lastIntValue;
    if (state.eat(45) && this.regexp_eatClassSetCharacter(state)) {
      var right = state.lastIntValue;
      if (left !== -1 && right !== -1 && left > right) {
        state.raise("Range out of order in character class");
      }
      return true;
    }
    state.pos = start;
  }
  return false;
};
pp$1.regexp_eatClassSetOperand = function(state) {
  if (this.regexp_eatClassSetCharacter(state)) {
    return CharSetOk;
  }
  return this.regexp_eatClassStringDisjunction(state) || this.regexp_eatNestedClass(state);
};
pp$1.regexp_eatNestedClass = function(state) {
  var start = state.pos;
  if (state.eat(91)) {
    var negate = state.eat(94);
    var result = this.regexp_classContents(state);
    if (state.eat(93)) {
      if (negate && result === CharSetString) {
        state.raise("Negated character class may contain strings");
      }
      return result;
    }
    state.pos = start;
  }
  if (state.eat(92)) {
    var result$1 = this.regexp_eatCharacterClassEscape(state);
    if (result$1) {
      return result$1;
    }
    state.pos = start;
  }
  return null;
};
pp$1.regexp_eatClassStringDisjunction = function(state) {
  var start = state.pos;
  if (state.eatChars([92, 113])) {
    if (state.eat(123)) {
      var result = this.regexp_classStringDisjunctionContents(state);
      if (state.eat(125)) {
        return result;
      }
    } else {
      state.raise("Invalid escape");
    }
    state.pos = start;
  }
  return null;
};
pp$1.regexp_classStringDisjunctionContents = function(state) {
  var result = this.regexp_classString(state);
  while (state.eat(124)) {
    if (this.regexp_classString(state) === CharSetString) {
      result = CharSetString;
    }
  }
  return result;
};
pp$1.regexp_classString = function(state) {
  var count = 0;
  while (this.regexp_eatClassSetCharacter(state)) {
    count++;
  }
  return count === 1 ? CharSetOk : CharSetString;
};
pp$1.regexp_eatClassSetCharacter = function(state) {
  var start = state.pos;
  if (state.eat(92)) {
    if (this.regexp_eatCharacterEscape(state) || this.regexp_eatClassSetReservedPunctuator(state)) {
      return true;
    }
    if (state.eat(98)) {
      state.lastIntValue = 8;
      return true;
    }
    state.pos = start;
    return false;
  }
  var ch = state.current();
  if (ch < 0 || ch === state.lookahead() && isClassSetReservedDoublePunctuatorCharacter(ch)) {
    return false;
  }
  if (isClassSetSyntaxCharacter(ch)) {
    return false;
  }
  state.advance();
  state.lastIntValue = ch;
  return true;
};
function isClassSetReservedDoublePunctuatorCharacter(ch) {
  return ch === 33 || ch >= 35 && ch <= 38 || ch >= 42 && ch <= 44 || ch === 46 || ch >= 58 && ch <= 64 || ch === 94 || ch === 96 || ch === 126;
}
function isClassSetSyntaxCharacter(ch) {
  return ch === 40 || ch === 41 || ch === 45 || ch === 47 || ch >= 91 && ch <= 93 || ch >= 123 && ch <= 125;
}
pp$1.regexp_eatClassSetReservedPunctuator = function(state) {
  var ch = state.current();
  if (isClassSetReservedPunctuator(ch)) {
    state.lastIntValue = ch;
    state.advance();
    return true;
  }
  return false;
};
function isClassSetReservedPunctuator(ch) {
  return ch === 33 || ch === 35 || ch === 37 || ch === 38 || ch === 44 || ch === 45 || ch >= 58 && ch <= 62 || ch === 64 || ch === 96 || ch === 126;
}
pp$1.regexp_eatClassControlLetter = function(state) {
  var ch = state.current();
  if (isDecimalDigit(ch) || ch === 95) {
    state.lastIntValue = ch % 32;
    state.advance();
    return true;
  }
  return false;
};
pp$1.regexp_eatHexEscapeSequence = function(state) {
  var start = state.pos;
  if (state.eat(120)) {
    if (this.regexp_eatFixedHexDigits(state, 2)) {
      return true;
    }
    if (state.switchU) {
      state.raise("Invalid escape");
    }
    state.pos = start;
  }
  return false;
};
pp$1.regexp_eatDecimalDigits = function(state) {
  var start = state.pos;
  var ch = 0;
  state.lastIntValue = 0;
  while (isDecimalDigit(ch = state.current())) {
    state.lastIntValue = 10 * state.lastIntValue + (ch - 48);
    state.advance();
  }
  return state.pos !== start;
};
function isDecimalDigit(ch) {
  return ch >= 48 && ch <= 57;
}
pp$1.regexp_eatHexDigits = function(state) {
  var start = state.pos;
  var ch = 0;
  state.lastIntValue = 0;
  while (isHexDigit(ch = state.current())) {
    state.lastIntValue = 16 * state.lastIntValue + hexToInt(ch);
    state.advance();
  }
  return state.pos !== start;
};
function isHexDigit(ch) {
  return ch >= 48 && ch <= 57 || ch >= 65 && ch <= 70 || ch >= 97 && ch <= 102;
}
function hexToInt(ch) {
  if (ch >= 65 && ch <= 70) {
    return 10 + (ch - 65);
  }
  if (ch >= 97 && ch <= 102) {
    return 10 + (ch - 97);
  }
  return ch - 48;
}
pp$1.regexp_eatLegacyOctalEscapeSequence = function(state) {
  if (this.regexp_eatOctalDigit(state)) {
    var n1 = state.lastIntValue;
    if (this.regexp_eatOctalDigit(state)) {
      var n2 = state.lastIntValue;
      if (n1 <= 3 && this.regexp_eatOctalDigit(state)) {
        state.lastIntValue = n1 * 64 + n2 * 8 + state.lastIntValue;
      } else {
        state.lastIntValue = n1 * 8 + n2;
      }
    } else {
      state.lastIntValue = n1;
    }
    return true;
  }
  return false;
};
pp$1.regexp_eatOctalDigit = function(state) {
  var ch = state.current();
  if (isOctalDigit(ch)) {
    state.lastIntValue = ch - 48;
    state.advance();
    return true;
  }
  state.lastIntValue = 0;
  return false;
};
function isOctalDigit(ch) {
  return ch >= 48 && ch <= 55;
}
pp$1.regexp_eatFixedHexDigits = function(state, length) {
  var start = state.pos;
  state.lastIntValue = 0;
  for (var i2 = 0;i2 < length; ++i2) {
    var ch = state.current();
    if (!isHexDigit(ch)) {
      state.pos = start;
      return false;
    }
    state.lastIntValue = 16 * state.lastIntValue + hexToInt(ch);
    state.advance();
  }
  return true;
};
var Token = function Token2(p2) {
  this.type = p2.type;
  this.value = p2.value;
  this.start = p2.start;
  this.end = p2.end;
  if (p2.options.locations) {
    this.loc = new SourceLocation(p2, p2.startLoc, p2.endLoc);
  }
  if (p2.options.ranges) {
    this.range = [p2.start, p2.end];
  }
};
var pp = Parser.prototype;
pp.next = function(ignoreEscapeSequenceInKeyword) {
  if (!ignoreEscapeSequenceInKeyword && this.type.keyword && this.containsEsc) {
    this.raiseRecoverable(this.start, "Escape sequence in keyword " + this.type.keyword);
  }
  if (this.options.onToken) {
    this.options.onToken(new Token(this));
  }
  this.lastTokEnd = this.end;
  this.lastTokStart = this.start;
  this.lastTokEndLoc = this.endLoc;
  this.lastTokStartLoc = this.startLoc;
  this.nextToken();
};
pp.getToken = function() {
  this.next();
  return new Token(this);
};
if (typeof Symbol !== "undefined") {
  pp[Symbol.iterator] = function() {
    var this$1$1 = this;
    return {
      next: function() {
        var token = this$1$1.getToken();
        return {
          done: token.type === types$1.eof,
          value: token
        };
      }
    };
  };
}
pp.nextToken = function() {
  var curContext = this.curContext();
  if (!curContext || !curContext.preserveSpace) {
    this.skipSpace();
  }
  this.start = this.pos;
  if (this.options.locations) {
    this.startLoc = this.curPosition();
  }
  if (this.pos >= this.input.length) {
    return this.finishToken(types$1.eof);
  }
  if (curContext.override) {
    return curContext.override(this);
  } else {
    this.readToken(this.fullCharCodeAtPos());
  }
};
pp.readToken = function(code) {
  if (isIdentifierStart(code, this.options.ecmaVersion >= 6) || code === 92) {
    return this.readWord();
  }
  return this.getTokenFromCode(code);
};
pp.fullCharCodeAtPos = function() {
  var code = this.input.charCodeAt(this.pos);
  if (code <= 55295 || code >= 56320) {
    return code;
  }
  var next = this.input.charCodeAt(this.pos + 1);
  return next <= 56319 || next >= 57344 ? code : (code << 10) + next - 56613888;
};
pp.skipBlockComment = function() {
  var startLoc = this.options.onComment && this.curPosition();
  var start = this.pos, end = this.input.indexOf("*/", this.pos += 2);
  if (end === -1) {
    this.raise(this.pos - 2, "Unterminated comment");
  }
  this.pos = end + 2;
  if (this.options.locations) {
    for (var nextBreak = undefined, pos = start;(nextBreak = nextLineBreak(this.input, pos, this.pos)) > -1; ) {
      ++this.curLine;
      pos = this.lineStart = nextBreak;
    }
  }
  if (this.options.onComment) {
    this.options.onComment(true, this.input.slice(start + 2, end), start, this.pos, startLoc, this.curPosition());
  }
};
pp.skipLineComment = function(startSkip) {
  var start = this.pos;
  var startLoc = this.options.onComment && this.curPosition();
  var ch = this.input.charCodeAt(this.pos += startSkip);
  while (this.pos < this.input.length && !isNewLine(ch)) {
    ch = this.input.charCodeAt(++this.pos);
  }
  if (this.options.onComment) {
    this.options.onComment(false, this.input.slice(start + startSkip, this.pos), start, this.pos, startLoc, this.curPosition());
  }
};
pp.skipSpace = function() {
  loop:
    while (this.pos < this.input.length) {
      var ch = this.input.charCodeAt(this.pos);
      switch (ch) {
        case 32:
        case 160:
          ++this.pos;
          break;
        case 13:
          if (this.input.charCodeAt(this.pos + 1) === 10) {
            ++this.pos;
          }
        case 10:
        case 8232:
        case 8233:
          ++this.pos;
          if (this.options.locations) {
            ++this.curLine;
            this.lineStart = this.pos;
          }
          break;
        case 47:
          switch (this.input.charCodeAt(this.pos + 1)) {
            case 42:
              this.skipBlockComment();
              break;
            case 47:
              this.skipLineComment(2);
              break;
            default:
              break loop;
          }
          break;
        default:
          if (ch > 8 && ch < 14 || ch >= 5760 && nonASCIIwhitespace.test(String.fromCharCode(ch))) {
            ++this.pos;
          } else {
            break loop;
          }
      }
    }
};
pp.finishToken = function(type2, val) {
  this.end = this.pos;
  if (this.options.locations) {
    this.endLoc = this.curPosition();
  }
  var prevType = this.type;
  this.type = type2;
  this.value = val;
  this.updateContext(prevType);
};
pp.readToken_dot = function() {
  var next = this.input.charCodeAt(this.pos + 1);
  if (next >= 48 && next <= 57) {
    return this.readNumber(true);
  }
  var next2 = this.input.charCodeAt(this.pos + 2);
  if (this.options.ecmaVersion >= 6 && next === 46 && next2 === 46) {
    this.pos += 3;
    return this.finishToken(types$1.ellipsis);
  } else {
    ++this.pos;
    return this.finishToken(types$1.dot);
  }
};
pp.readToken_slash = function() {
  var next = this.input.charCodeAt(this.pos + 1);
  if (this.exprAllowed) {
    ++this.pos;
    return this.readRegexp();
  }
  if (next === 61) {
    return this.finishOp(types$1.assign, 2);
  }
  return this.finishOp(types$1.slash, 1);
};
pp.readToken_mult_modulo_exp = function(code) {
  var next = this.input.charCodeAt(this.pos + 1);
  var size = 1;
  var tokentype = code === 42 ? types$1.star : types$1.modulo;
  if (this.options.ecmaVersion >= 7 && code === 42 && next === 42) {
    ++size;
    tokentype = types$1.starstar;
    next = this.input.charCodeAt(this.pos + 2);
  }
  if (next === 61) {
    return this.finishOp(types$1.assign, size + 1);
  }
  return this.finishOp(tokentype, size);
};
pp.readToken_pipe_amp = function(code) {
  var next = this.input.charCodeAt(this.pos + 1);
  if (next === code) {
    if (this.options.ecmaVersion >= 12) {
      var next2 = this.input.charCodeAt(this.pos + 2);
      if (next2 === 61) {
        return this.finishOp(types$1.assign, 3);
      }
    }
    return this.finishOp(code === 124 ? types$1.logicalOR : types$1.logicalAND, 2);
  }
  if (next === 61) {
    return this.finishOp(types$1.assign, 2);
  }
  return this.finishOp(code === 124 ? types$1.bitwiseOR : types$1.bitwiseAND, 1);
};
pp.readToken_caret = function() {
  var next = this.input.charCodeAt(this.pos + 1);
  if (next === 61) {
    return this.finishOp(types$1.assign, 2);
  }
  return this.finishOp(types$1.bitwiseXOR, 1);
};
pp.readToken_plus_min = function(code) {
  var next = this.input.charCodeAt(this.pos + 1);
  if (next === code) {
    if (next === 45 && !this.inModule && this.input.charCodeAt(this.pos + 2) === 62 && (this.lastTokEnd === 0 || lineBreak.test(this.input.slice(this.lastTokEnd, this.pos)))) {
      this.skipLineComment(3);
      this.skipSpace();
      return this.nextToken();
    }
    return this.finishOp(types$1.incDec, 2);
  }
  if (next === 61) {
    return this.finishOp(types$1.assign, 2);
  }
  return this.finishOp(types$1.plusMin, 1);
};
pp.readToken_lt_gt = function(code) {
  var next = this.input.charCodeAt(this.pos + 1);
  var size = 1;
  if (next === code) {
    size = code === 62 && this.input.charCodeAt(this.pos + 2) === 62 ? 3 : 2;
    if (this.input.charCodeAt(this.pos + size) === 61) {
      return this.finishOp(types$1.assign, size + 1);
    }
    return this.finishOp(types$1.bitShift, size);
  }
  if (next === 33 && code === 60 && !this.inModule && this.input.charCodeAt(this.pos + 2) === 45 && this.input.charCodeAt(this.pos + 3) === 45) {
    this.skipLineComment(4);
    this.skipSpace();
    return this.nextToken();
  }
  if (next === 61) {
    size = 2;
  }
  return this.finishOp(types$1.relational, size);
};
pp.readToken_eq_excl = function(code) {
  var next = this.input.charCodeAt(this.pos + 1);
  if (next === 61) {
    return this.finishOp(types$1.equality, this.input.charCodeAt(this.pos + 2) === 61 ? 3 : 2);
  }
  if (code === 61 && next === 62 && this.options.ecmaVersion >= 6) {
    this.pos += 2;
    return this.finishToken(types$1.arrow);
  }
  return this.finishOp(code === 61 ? types$1.eq : types$1.prefix, 1);
};
pp.readToken_question = function() {
  var ecmaVersion2 = this.options.ecmaVersion;
  if (ecmaVersion2 >= 11) {
    var next = this.input.charCodeAt(this.pos + 1);
    if (next === 46) {
      var next2 = this.input.charCodeAt(this.pos + 2);
      if (next2 < 48 || next2 > 57) {
        return this.finishOp(types$1.questionDot, 2);
      }
    }
    if (next === 63) {
      if (ecmaVersion2 >= 12) {
        var next2$1 = this.input.charCodeAt(this.pos + 2);
        if (next2$1 === 61) {
          return this.finishOp(types$1.assign, 3);
        }
      }
      return this.finishOp(types$1.coalesce, 2);
    }
  }
  return this.finishOp(types$1.question, 1);
};
pp.readToken_numberSign = function() {
  var ecmaVersion2 = this.options.ecmaVersion;
  var code = 35;
  if (ecmaVersion2 >= 13) {
    ++this.pos;
    code = this.fullCharCodeAtPos();
    if (isIdentifierStart(code, true) || code === 92) {
      return this.finishToken(types$1.privateId, this.readWord1());
    }
  }
  this.raise(this.pos, "Unexpected character '" + codePointToString(code) + "'");
};
pp.getTokenFromCode = function(code) {
  switch (code) {
    case 46:
      return this.readToken_dot();
    case 40:
      ++this.pos;
      return this.finishToken(types$1.parenL);
    case 41:
      ++this.pos;
      return this.finishToken(types$1.parenR);
    case 59:
      ++this.pos;
      return this.finishToken(types$1.semi);
    case 44:
      ++this.pos;
      return this.finishToken(types$1.comma);
    case 91:
      ++this.pos;
      return this.finishToken(types$1.bracketL);
    case 93:
      ++this.pos;
      return this.finishToken(types$1.bracketR);
    case 123:
      ++this.pos;
      return this.finishToken(types$1.braceL);
    case 125:
      ++this.pos;
      return this.finishToken(types$1.braceR);
    case 58:
      ++this.pos;
      return this.finishToken(types$1.colon);
    case 96:
      if (this.options.ecmaVersion < 6) {
        break;
      }
      ++this.pos;
      return this.finishToken(types$1.backQuote);
    case 48:
      var next = this.input.charCodeAt(this.pos + 1);
      if (next === 120 || next === 88) {
        return this.readRadixNumber(16);
      }
      if (this.options.ecmaVersion >= 6) {
        if (next === 111 || next === 79) {
          return this.readRadixNumber(8);
        }
        if (next === 98 || next === 66) {
          return this.readRadixNumber(2);
        }
      }
    case 49:
    case 50:
    case 51:
    case 52:
    case 53:
    case 54:
    case 55:
    case 56:
    case 57:
      return this.readNumber(false);
    case 34:
    case 39:
      return this.readString(code);
    case 47:
      return this.readToken_slash();
    case 37:
    case 42:
      return this.readToken_mult_modulo_exp(code);
    case 124:
    case 38:
      return this.readToken_pipe_amp(code);
    case 94:
      return this.readToken_caret();
    case 43:
    case 45:
      return this.readToken_plus_min(code);
    case 60:
    case 62:
      return this.readToken_lt_gt(code);
    case 61:
    case 33:
      return this.readToken_eq_excl(code);
    case 63:
      return this.readToken_question();
    case 126:
      return this.finishOp(types$1.prefix, 1);
    case 35:
      return this.readToken_numberSign();
  }
  this.raise(this.pos, "Unexpected character '" + codePointToString(code) + "'");
};
pp.finishOp = function(type2, size) {
  var str = this.input.slice(this.pos, this.pos + size);
  this.pos += size;
  return this.finishToken(type2, str);
};
pp.readRegexp = function() {
  var escaped, inClass, start = this.pos;
  for (;; ) {
    if (this.pos >= this.input.length) {
      this.raise(start, "Unterminated regular expression");
    }
    var ch = this.input.charAt(this.pos);
    if (lineBreak.test(ch)) {
      this.raise(start, "Unterminated regular expression");
    }
    if (!escaped) {
      if (ch === "[") {
        inClass = true;
      } else if (ch === "]" && inClass) {
        inClass = false;
      } else if (ch === "/" && !inClass) {
        break;
      }
      escaped = ch === "\\";
    } else {
      escaped = false;
    }
    ++this.pos;
  }
  var pattern = this.input.slice(start, this.pos);
  ++this.pos;
  var flagsStart = this.pos;
  var flags = this.readWord1();
  if (this.containsEsc) {
    this.unexpected(flagsStart);
  }
  var state = this.regexpState || (this.regexpState = new RegExpValidationState(this));
  state.reset(start, pattern, flags);
  this.validateRegExpFlags(state);
  this.validateRegExpPattern(state);
  var value = null;
  try {
    value = new RegExp(pattern, flags);
  } catch (e2) {}
  return this.finishToken(types$1.regexp, { pattern, flags, value });
};
pp.readInt = function(radix, len, maybeLegacyOctalNumericLiteral) {
  var allowSeparators = this.options.ecmaVersion >= 12 && len === undefined;
  var isLegacyOctalNumericLiteral = maybeLegacyOctalNumericLiteral && this.input.charCodeAt(this.pos) === 48;
  var start = this.pos, total = 0, lastCode = 0;
  for (var i2 = 0, e2 = len == null ? Infinity : len;i2 < e2; ++i2, ++this.pos) {
    var code = this.input.charCodeAt(this.pos), val = undefined;
    if (allowSeparators && code === 95) {
      if (isLegacyOctalNumericLiteral) {
        this.raiseRecoverable(this.pos, "Numeric separator is not allowed in legacy octal numeric literals");
      }
      if (lastCode === 95) {
        this.raiseRecoverable(this.pos, "Numeric separator must be exactly one underscore");
      }
      if (i2 === 0) {
        this.raiseRecoverable(this.pos, "Numeric separator is not allowed at the first of digits");
      }
      lastCode = code;
      continue;
    }
    if (code >= 97) {
      val = code - 97 + 10;
    } else if (code >= 65) {
      val = code - 65 + 10;
    } else if (code >= 48 && code <= 57) {
      val = code - 48;
    } else {
      val = Infinity;
    }
    if (val >= radix) {
      break;
    }
    lastCode = code;
    total = total * radix + val;
  }
  if (allowSeparators && lastCode === 95) {
    this.raiseRecoverable(this.pos - 1, "Numeric separator is not allowed at the last of digits");
  }
  if (this.pos === start || len != null && this.pos - start !== len) {
    return null;
  }
  return total;
};
function stringToNumber(str, isLegacyOctalNumericLiteral) {
  if (isLegacyOctalNumericLiteral) {
    return parseInt(str, 8);
  }
  return parseFloat(str.replace(/_/g, ""));
}
function stringToBigInt(str) {
  if (typeof BigInt !== "function") {
    return null;
  }
  return BigInt(str.replace(/_/g, ""));
}
pp.readRadixNumber = function(radix) {
  var start = this.pos;
  this.pos += 2;
  var val = this.readInt(radix);
  if (val == null) {
    this.raise(this.start + 2, "Expected number in radix " + radix);
  }
  if (this.options.ecmaVersion >= 11 && this.input.charCodeAt(this.pos) === 110) {
    val = stringToBigInt(this.input.slice(start, this.pos));
    ++this.pos;
  } else if (isIdentifierStart(this.fullCharCodeAtPos())) {
    this.raise(this.pos, "Identifier directly after number");
  }
  return this.finishToken(types$1.num, val);
};
pp.readNumber = function(startsWithDot) {
  var start = this.pos;
  if (!startsWithDot && this.readInt(10, undefined, true) === null) {
    this.raise(start, "Invalid number");
  }
  var octal = this.pos - start >= 2 && this.input.charCodeAt(start) === 48;
  if (octal && this.strict) {
    this.raise(start, "Invalid number");
  }
  var next = this.input.charCodeAt(this.pos);
  if (!octal && !startsWithDot && this.options.ecmaVersion >= 11 && next === 110) {
    var val$1 = stringToBigInt(this.input.slice(start, this.pos));
    ++this.pos;
    if (isIdentifierStart(this.fullCharCodeAtPos())) {
      this.raise(this.pos, "Identifier directly after number");
    }
    return this.finishToken(types$1.num, val$1);
  }
  if (octal && /[89]/.test(this.input.slice(start, this.pos))) {
    octal = false;
  }
  if (next === 46 && !octal) {
    ++this.pos;
    this.readInt(10);
    next = this.input.charCodeAt(this.pos);
  }
  if ((next === 69 || next === 101) && !octal) {
    next = this.input.charCodeAt(++this.pos);
    if (next === 43 || next === 45) {
      ++this.pos;
    }
    if (this.readInt(10) === null) {
      this.raise(start, "Invalid number");
    }
  }
  if (isIdentifierStart(this.fullCharCodeAtPos())) {
    this.raise(this.pos, "Identifier directly after number");
  }
  var val = stringToNumber(this.input.slice(start, this.pos), octal);
  return this.finishToken(types$1.num, val);
};
pp.readCodePoint = function() {
  var ch = this.input.charCodeAt(this.pos), code;
  if (ch === 123) {
    if (this.options.ecmaVersion < 6) {
      this.unexpected();
    }
    var codePos = ++this.pos;
    code = this.readHexChar(this.input.indexOf("}", this.pos) - this.pos);
    ++this.pos;
    if (code > 1114111) {
      this.invalidStringToken(codePos, "Code point out of bounds");
    }
  } else {
    code = this.readHexChar(4);
  }
  return code;
};
pp.readString = function(quote) {
  var out = "", chunkStart = ++this.pos;
  for (;; ) {
    if (this.pos >= this.input.length) {
      this.raise(this.start, "Unterminated string constant");
    }
    var ch = this.input.charCodeAt(this.pos);
    if (ch === quote) {
      break;
    }
    if (ch === 92) {
      out += this.input.slice(chunkStart, this.pos);
      out += this.readEscapedChar(false);
      chunkStart = this.pos;
    } else if (ch === 8232 || ch === 8233) {
      if (this.options.ecmaVersion < 10) {
        this.raise(this.start, "Unterminated string constant");
      }
      ++this.pos;
      if (this.options.locations) {
        this.curLine++;
        this.lineStart = this.pos;
      }
    } else {
      if (isNewLine(ch)) {
        this.raise(this.start, "Unterminated string constant");
      }
      ++this.pos;
    }
  }
  out += this.input.slice(chunkStart, this.pos++);
  return this.finishToken(types$1.string, out);
};
var INVALID_TEMPLATE_ESCAPE_ERROR = {};
pp.tryReadTemplateToken = function() {
  this.inTemplateElement = true;
  try {
    this.readTmplToken();
  } catch (err) {
    if (err === INVALID_TEMPLATE_ESCAPE_ERROR) {
      this.readInvalidTemplateToken();
    } else {
      throw err;
    }
  }
  this.inTemplateElement = false;
};
pp.invalidStringToken = function(position, message) {
  if (this.inTemplateElement && this.options.ecmaVersion >= 9) {
    throw INVALID_TEMPLATE_ESCAPE_ERROR;
  } else {
    this.raise(position, message);
  }
};
pp.readTmplToken = function() {
  var out = "", chunkStart = this.pos;
  for (;; ) {
    if (this.pos >= this.input.length) {
      this.raise(this.start, "Unterminated template");
    }
    var ch = this.input.charCodeAt(this.pos);
    if (ch === 96 || ch === 36 && this.input.charCodeAt(this.pos + 1) === 123) {
      if (this.pos === this.start && (this.type === types$1.template || this.type === types$1.invalidTemplate)) {
        if (ch === 36) {
          this.pos += 2;
          return this.finishToken(types$1.dollarBraceL);
        } else {
          ++this.pos;
          return this.finishToken(types$1.backQuote);
        }
      }
      out += this.input.slice(chunkStart, this.pos);
      return this.finishToken(types$1.template, out);
    }
    if (ch === 92) {
      out += this.input.slice(chunkStart, this.pos);
      out += this.readEscapedChar(true);
      chunkStart = this.pos;
    } else if (isNewLine(ch)) {
      out += this.input.slice(chunkStart, this.pos);
      ++this.pos;
      switch (ch) {
        case 13:
          if (this.input.charCodeAt(this.pos) === 10) {
            ++this.pos;
          }
        case 10:
          out += `
`;
          break;
        default:
          out += String.fromCharCode(ch);
          break;
      }
      if (this.options.locations) {
        ++this.curLine;
        this.lineStart = this.pos;
      }
      chunkStart = this.pos;
    } else {
      ++this.pos;
    }
  }
};
pp.readInvalidTemplateToken = function() {
  for (;this.pos < this.input.length; this.pos++) {
    switch (this.input[this.pos]) {
      case "\\":
        ++this.pos;
        break;
      case "$":
        if (this.input[this.pos + 1] !== "{") {
          break;
        }
      case "`":
        return this.finishToken(types$1.invalidTemplate, this.input.slice(this.start, this.pos));
      case "\r":
        if (this.input[this.pos + 1] === `
`) {
          ++this.pos;
        }
      case `
`:
      case "\u2028":
      case "\u2029":
        ++this.curLine;
        this.lineStart = this.pos + 1;
        break;
    }
  }
  this.raise(this.start, "Unterminated template");
};
pp.readEscapedChar = function(inTemplate) {
  var ch = this.input.charCodeAt(++this.pos);
  ++this.pos;
  switch (ch) {
    case 110:
      return `
`;
    case 114:
      return "\r";
    case 120:
      return String.fromCharCode(this.readHexChar(2));
    case 117:
      return codePointToString(this.readCodePoint());
    case 116:
      return "\t";
    case 98:
      return "\b";
    case 118:
      return "\v";
    case 102:
      return "\f";
    case 13:
      if (this.input.charCodeAt(this.pos) === 10) {
        ++this.pos;
      }
    case 10:
      if (this.options.locations) {
        this.lineStart = this.pos;
        ++this.curLine;
      }
      return "";
    case 56:
    case 57:
      if (this.strict) {
        this.invalidStringToken(this.pos - 1, "Invalid escape sequence");
      }
      if (inTemplate) {
        var codePos = this.pos - 1;
        this.invalidStringToken(codePos, "Invalid escape sequence in template string");
      }
    default:
      if (ch >= 48 && ch <= 55) {
        var octalStr = this.input.substr(this.pos - 1, 3).match(/^[0-7]+/)[0];
        var octal = parseInt(octalStr, 8);
        if (octal > 255) {
          octalStr = octalStr.slice(0, -1);
          octal = parseInt(octalStr, 8);
        }
        this.pos += octalStr.length - 1;
        ch = this.input.charCodeAt(this.pos);
        if ((octalStr !== "0" || ch === 56 || ch === 57) && (this.strict || inTemplate)) {
          this.invalidStringToken(this.pos - 1 - octalStr.length, inTemplate ? "Octal literal in template string" : "Octal literal in strict mode");
        }
        return String.fromCharCode(octal);
      }
      if (isNewLine(ch)) {
        if (this.options.locations) {
          this.lineStart = this.pos;
          ++this.curLine;
        }
        return "";
      }
      return String.fromCharCode(ch);
  }
};
pp.readHexChar = function(len) {
  var codePos = this.pos;
  var n2 = this.readInt(16, len);
  if (n2 === null) {
    this.invalidStringToken(codePos, "Bad character escape sequence");
  }
  return n2;
};
pp.readWord1 = function() {
  this.containsEsc = false;
  var word = "", first = true, chunkStart = this.pos;
  var astral = this.options.ecmaVersion >= 6;
  while (this.pos < this.input.length) {
    var ch = this.fullCharCodeAtPos();
    if (isIdentifierChar(ch, astral)) {
      this.pos += ch <= 65535 ? 1 : 2;
    } else if (ch === 92) {
      this.containsEsc = true;
      word += this.input.slice(chunkStart, this.pos);
      var escStart = this.pos;
      if (this.input.charCodeAt(++this.pos) !== 117) {
        this.invalidStringToken(this.pos, "Expecting Unicode escape sequence \\uXXXX");
      }
      ++this.pos;
      var esc2 = this.readCodePoint();
      if (!(first ? isIdentifierStart : isIdentifierChar)(esc2, astral)) {
        this.invalidStringToken(escStart, "Invalid Unicode escape");
      }
      word += codePointToString(esc2);
      chunkStart = this.pos;
    } else {
      break;
    }
    first = false;
  }
  return word + this.input.slice(chunkStart, this.pos);
};
pp.readWord = function() {
  var word = this.readWord1();
  var type2 = types$1.name;
  if (this.keywords.test(word)) {
    type2 = keywords[word];
  }
  return this.finishToken(type2, word);
};
var version2 = "8.15.0";
Parser.acorn = {
  Parser,
  version: version2,
  defaultOptions,
  Position,
  SourceLocation,
  getLineInfo,
  Node,
  TokenType,
  tokTypes: types$1,
  keywordTypes: keywords,
  TokContext,
  tokContexts: types,
  isIdentifierChar,
  isIdentifierStart,
  Token,
  isNewLine,
  lineBreak,
  lineBreakG,
  nonASCIIwhitespace
};
function parse9(input, options2) {
  return Parser.parse(input, options2);
}

// node_modules/acorn-walk/dist/walk.mjs
function simple(node, visitors, baseVisitor, state, override) {
  if (!baseVisitor) {
    baseVisitor = base;
  }
  (function c(node2, st, override2) {
    var type2 = override2 || node2.type;
    baseVisitor[type2](node2, st, c);
    if (visitors[type2]) {
      visitors[type2](node2, st);
    }
  })(node, state, override);
}
function ancestor(node, visitors, baseVisitor, state, override) {
  var ancestors = [];
  if (!baseVisitor) {
    baseVisitor = base;
  }
  (function c(node2, st, override2) {
    var type2 = override2 || node2.type;
    var isNew = node2 !== ancestors[ancestors.length - 1];
    if (isNew) {
      ancestors.push(node2);
    }
    baseVisitor[type2](node2, st, c);
    if (visitors[type2]) {
      visitors[type2](node2, st || ancestors, ancestors);
    }
    if (isNew) {
      ancestors.pop();
    }
  })(node, state, override);
}
function recursive(node, state, funcs, baseVisitor, override) {
  var visitor = funcs ? make(funcs, baseVisitor || undefined) : baseVisitor;
  (function c(node2, st, override2) {
    visitor[override2 || node2.type](node2, st, c);
  })(node, state, override);
}
function make(funcs, baseVisitor) {
  var visitor = Object.create(baseVisitor || base);
  for (var type2 in funcs) {
    visitor[type2] = funcs[type2];
  }
  return visitor;
}
function skipThrough(node, st, c) {
  c(node, st);
}
function ignore(_node, _st, _c) {}
var base = {};
base.Program = base.BlockStatement = base.StaticBlock = function(node, st, c) {
  for (var i2 = 0, list2 = node.body;i2 < list2.length; i2 += 1) {
    var stmt = list2[i2];
    c(stmt, st, "Statement");
  }
};
base.Statement = skipThrough;
base.EmptyStatement = ignore;
base.ExpressionStatement = base.ParenthesizedExpression = base.ChainExpression = function(node, st, c) {
  return c(node.expression, st, "Expression");
};
base.IfStatement = function(node, st, c) {
  c(node.test, st, "Expression");
  c(node.consequent, st, "Statement");
  if (node.alternate) {
    c(node.alternate, st, "Statement");
  }
};
base.LabeledStatement = function(node, st, c) {
  return c(node.body, st, "Statement");
};
base.BreakStatement = base.ContinueStatement = ignore;
base.WithStatement = function(node, st, c) {
  c(node.object, st, "Expression");
  c(node.body, st, "Statement");
};
base.SwitchStatement = function(node, st, c) {
  c(node.discriminant, st, "Expression");
  for (var i2 = 0, list2 = node.cases;i2 < list2.length; i2 += 1) {
    var cs = list2[i2];
    c(cs, st);
  }
};
base.SwitchCase = function(node, st, c) {
  if (node.test) {
    c(node.test, st, "Expression");
  }
  for (var i2 = 0, list2 = node.consequent;i2 < list2.length; i2 += 1) {
    var cons = list2[i2];
    c(cons, st, "Statement");
  }
};
base.ReturnStatement = base.YieldExpression = base.AwaitExpression = function(node, st, c) {
  if (node.argument) {
    c(node.argument, st, "Expression");
  }
};
base.ThrowStatement = base.SpreadElement = function(node, st, c) {
  return c(node.argument, st, "Expression");
};
base.TryStatement = function(node, st, c) {
  c(node.block, st, "Statement");
  if (node.handler) {
    c(node.handler, st);
  }
  if (node.finalizer) {
    c(node.finalizer, st, "Statement");
  }
};
base.CatchClause = function(node, st, c) {
  if (node.param) {
    c(node.param, st, "Pattern");
  }
  c(node.body, st, "Statement");
};
base.WhileStatement = base.DoWhileStatement = function(node, st, c) {
  c(node.test, st, "Expression");
  c(node.body, st, "Statement");
};
base.ForStatement = function(node, st, c) {
  if (node.init) {
    c(node.init, st, "ForInit");
  }
  if (node.test) {
    c(node.test, st, "Expression");
  }
  if (node.update) {
    c(node.update, st, "Expression");
  }
  c(node.body, st, "Statement");
};
base.ForInStatement = base.ForOfStatement = function(node, st, c) {
  c(node.left, st, "ForInit");
  c(node.right, st, "Expression");
  c(node.body, st, "Statement");
};
base.ForInit = function(node, st, c) {
  if (node.type === "VariableDeclaration") {
    c(node, st);
  } else {
    c(node, st, "Expression");
  }
};
base.DebuggerStatement = ignore;
base.FunctionDeclaration = function(node, st, c) {
  return c(node, st, "Function");
};
base.VariableDeclaration = function(node, st, c) {
  for (var i2 = 0, list2 = node.declarations;i2 < list2.length; i2 += 1) {
    var decl = list2[i2];
    c(decl, st);
  }
};
base.VariableDeclarator = function(node, st, c) {
  c(node.id, st, "Pattern");
  if (node.init) {
    c(node.init, st, "Expression");
  }
};
base.Function = function(node, st, c) {
  if (node.id) {
    c(node.id, st, "Pattern");
  }
  for (var i2 = 0, list2 = node.params;i2 < list2.length; i2 += 1) {
    var param = list2[i2];
    c(param, st, "Pattern");
  }
  c(node.body, st, node.expression ? "Expression" : "Statement");
};
base.Pattern = function(node, st, c) {
  if (node.type === "Identifier") {
    c(node, st, "VariablePattern");
  } else if (node.type === "MemberExpression") {
    c(node, st, "MemberPattern");
  } else {
    c(node, st);
  }
};
base.VariablePattern = ignore;
base.MemberPattern = skipThrough;
base.RestElement = function(node, st, c) {
  return c(node.argument, st, "Pattern");
};
base.ArrayPattern = function(node, st, c) {
  for (var i2 = 0, list2 = node.elements;i2 < list2.length; i2 += 1) {
    var elt = list2[i2];
    if (elt) {
      c(elt, st, "Pattern");
    }
  }
};
base.ObjectPattern = function(node, st, c) {
  for (var i2 = 0, list2 = node.properties;i2 < list2.length; i2 += 1) {
    var prop = list2[i2];
    if (prop.type === "Property") {
      if (prop.computed) {
        c(prop.key, st, "Expression");
      }
      c(prop.value, st, "Pattern");
    } else if (prop.type === "RestElement") {
      c(prop.argument, st, "Pattern");
    }
  }
};
base.Expression = skipThrough;
base.ThisExpression = base.Super = base.MetaProperty = ignore;
base.ArrayExpression = function(node, st, c) {
  for (var i2 = 0, list2 = node.elements;i2 < list2.length; i2 += 1) {
    var elt = list2[i2];
    if (elt) {
      c(elt, st, "Expression");
    }
  }
};
base.ObjectExpression = function(node, st, c) {
  for (var i2 = 0, list2 = node.properties;i2 < list2.length; i2 += 1) {
    var prop = list2[i2];
    c(prop, st);
  }
};
base.FunctionExpression = base.ArrowFunctionExpression = base.FunctionDeclaration;
base.SequenceExpression = function(node, st, c) {
  for (var i2 = 0, list2 = node.expressions;i2 < list2.length; i2 += 1) {
    var expr = list2[i2];
    c(expr, st, "Expression");
  }
};
base.TemplateLiteral = function(node, st, c) {
  for (var i2 = 0, list2 = node.quasis;i2 < list2.length; i2 += 1) {
    var quasi = list2[i2];
    c(quasi, st);
  }
  for (var i$1 = 0, list$1 = node.expressions;i$1 < list$1.length; i$1 += 1) {
    var expr = list$1[i$1];
    c(expr, st, "Expression");
  }
};
base.TemplateElement = ignore;
base.UnaryExpression = base.UpdateExpression = function(node, st, c) {
  c(node.argument, st, "Expression");
};
base.BinaryExpression = base.LogicalExpression = function(node, st, c) {
  c(node.left, st, "Expression");
  c(node.right, st, "Expression");
};
base.AssignmentExpression = base.AssignmentPattern = function(node, st, c) {
  c(node.left, st, "Pattern");
  c(node.right, st, "Expression");
};
base.ConditionalExpression = function(node, st, c) {
  c(node.test, st, "Expression");
  c(node.consequent, st, "Expression");
  c(node.alternate, st, "Expression");
};
base.NewExpression = base.CallExpression = function(node, st, c) {
  c(node.callee, st, "Expression");
  if (node.arguments) {
    for (var i2 = 0, list2 = node.arguments;i2 < list2.length; i2 += 1) {
      var arg = list2[i2];
      c(arg, st, "Expression");
    }
  }
};
base.MemberExpression = function(node, st, c) {
  c(node.object, st, "Expression");
  if (node.computed) {
    c(node.property, st, "Expression");
  }
};
base.ExportNamedDeclaration = base.ExportDefaultDeclaration = function(node, st, c) {
  if (node.declaration) {
    c(node.declaration, st, node.type === "ExportNamedDeclaration" || node.declaration.id ? "Statement" : "Expression");
  }
  if (node.source) {
    c(node.source, st, "Expression");
  }
};
base.ExportAllDeclaration = function(node, st, c) {
  if (node.exported) {
    c(node.exported, st);
  }
  c(node.source, st, "Expression");
};
base.ImportDeclaration = function(node, st, c) {
  for (var i2 = 0, list2 = node.specifiers;i2 < list2.length; i2 += 1) {
    var spec = list2[i2];
    c(spec, st);
  }
  c(node.source, st, "Expression");
};
base.ImportExpression = function(node, st, c) {
  c(node.source, st, "Expression");
};
base.ImportSpecifier = base.ImportDefaultSpecifier = base.ImportNamespaceSpecifier = base.Identifier = base.PrivateIdentifier = base.Literal = ignore;
base.TaggedTemplateExpression = function(node, st, c) {
  c(node.tag, st, "Expression");
  c(node.quasi, st, "Expression");
};
base.ClassDeclaration = base.ClassExpression = function(node, st, c) {
  return c(node, st, "Class");
};
base.Class = function(node, st, c) {
  if (node.id) {
    c(node.id, st, "Pattern");
  }
  if (node.superClass) {
    c(node.superClass, st, "Expression");
  }
  c(node.body, st);
};
base.ClassBody = function(node, st, c) {
  for (var i2 = 0, list2 = node.body;i2 < list2.length; i2 += 1) {
    var elt = list2[i2];
    c(elt, st);
  }
};
base.MethodDefinition = base.PropertyDefinition = base.Property = function(node, st, c) {
  if (node.computed) {
    c(node.key, st, "Expression");
  }
  if (node.value) {
    c(node.value, st, "Expression");
  }
};

// node_modules/p5/dist/core/friendly_errors/sketch_verifier.js
var ignoreFunction = [
  "setup",
  "draw",
  "preload",
  "deviceMoved",
  "deviceTurned",
  "deviceShaken",
  "doubleClicked",
  "mousePressed",
  "mouseReleased",
  "mouseMoved",
  "mouseDragged",
  "mouseClicked",
  "mouseWheel",
  "touchStarted",
  "touchMoved",
  "touchEnded",
  "keyPressed",
  "keyReleased",
  "keyTyped",
  "windowResized"
];
var verifierUtils = {
  fetchScript: async function(script) {
    if (script.src) {
      try {
        const contents = await fetch(script.src).then((res) => res.text());
        return contents;
      } catch (error41) {
        console.error("Error fetching script:", error41);
        return "";
      }
    } else {
      return script.textContent;
    }
  },
  extractUserDefinedVariablesAndFuncs: function(code) {
    const userDefinitions = {
      variables: [],
      functions: []
    };
    const lineOffset = -1;
    try {
      const ast = parse9(code, {
        ecmaVersion: 2021,
        sourceType: "module",
        locations: true
      });
      simple(ast, {
        VariableDeclarator(node) {
          if (node.id.type === "Identifier") {
            const category = node.init && ["ArrowFunctionExpression", "FunctionExpression"].includes(node.init.type) ? "functions" : "variables";
            userDefinitions[category].push({
              name: node.id.name,
              line: node.loc.start.line + lineOffset
            });
          }
        },
        FunctionDeclaration(node) {
          if (node.id && node.id.type === "Identifier") {
            userDefinitions.functions.push({
              name: node.id.name,
              line: node.loc.start.line + lineOffset
            });
          }
        },
        ClassDeclaration(node) {
          if (node.id && node.id.type === "Identifier") {
            userDefinitions.variables.push({
              name: node.id.name,
              line: node.loc.start.line + lineOffset
            });
          }
        }
      });
    } catch (error41) {
      console.error("Error parsing code:", error41);
    }
    return userDefinitions;
  },
  checkForConstsAndFuncs: function(userDefinitions, p53) {
    const allDefinitions = [
      ...userDefinitions.variables,
      ...userDefinitions.functions
    ];
    function generateFriendlyError(errorType, name, line) {
      const url2 = `https://p5js.org/reference/p5/${name}`;
      const message = `${errorType} "${name}" on line ${line} is being redeclared and conflicts with a p5.js ${errorType.toLowerCase()}. p5.js reference: ${url2}`;
      return message;
    }
    for (let { name, line } of allDefinitions) {
      const libDefinition = constants[name];
      if (libDefinition !== undefined) {
        const message = generateFriendlyError("Constant", name, line);
        console.log(message);
        return true;
      }
    }
    const globalFunctions = new Set(Object.getOwnPropertyNames(p53.prototype).filter((key) => !key.startsWith("_") && key !== "constructor"));
    for (let { name, line } of allDefinitions) {
      if (!ignoreFunction.includes(name) && globalFunctions.has(name)) {
        const message = generateFriendlyError("Function", name, line);
        console.log(message);
        return true;
      }
    }
    return false;
  },
  getUserCode: async function() {
    const scripts = document.querySelectorAll("script");
    const userCodeScript = scripts[scripts.length - 1];
    const userCode = await verifierUtils.fetchScript(userCodeScript);
    return userCode;
  },
  runFES: async function(p53) {
    const userCode = await verifierUtils.getUserCode();
    const userDefinedVariablesAndFuncs = verifierUtils.extractUserDefinedVariablesAndFuncs(userCode);
    verifierUtils.checkForConstsAndFuncs(userDefinedVariablesAndFuncs, p53);
  }
};
function sketchVerifier(p53, _fn, lifecycles) {
  lifecycles.presetup = async function() {
    if (!p53.disableFriendlyErrors && !p53.disableSketchChecker) {
      verifierUtils.runFES(p53);
    }
  };
}
if (typeof p5 !== "undefined") {
  sketchVerifier(p5, p5.prototype);
}

// node_modules/p5/dist/core/friendly_errors/file_errors.js
function fileErrors(p53, fn2) {
  const fileLoadErrorCases = (num, filePath) => {
    const suggestion = translator("fes.fileLoadError.suggestion", {
      filePath,
      url: "https://github.com/processing/p5.js/wiki/Local-server"
    });
    switch (num) {
      case 0:
        return {
          message: translator("fes.fileLoadError.image", {
            suggestion
          }),
          method: "loadImage"
        };
      case 1:
        return {
          message: translator("fes.fileLoadError.xml", {
            suggestion
          }),
          method: "loadXML"
        };
      case 2:
        return {
          message: translator("fes.fileLoadError.table", {
            suggestion
          }),
          method: "loadTable"
        };
      case 3:
        return {
          message: translator("fes.fileLoadError.strings", {
            suggestion
          }),
          method: "loadStrings"
        };
      case 4:
        return {
          message: translator("fes.fileLoadError.font", {
            suggestion
          }),
          method: "loadFont"
        };
      case 5:
        return {
          message: translator("fes.fileLoadError.json", {
            suggestion
          }),
          method: "loadJSON"
        };
      case 6:
        return {
          message: translator("fes.fileLoadError.bytes", {
            suggestion
          }),
          method: "loadBytes"
        };
      case 7:
        return {
          message: translator("fes.fileLoadError.large"),
          method: "loadX"
        };
      case 8:
        return {
          message: translator("fes.fileLoadError.gif"),
          method: "loadImage"
        };
    }
  };
  p53._friendlyFileLoadError = function(errorType, filePath) {
    const { message, method } = fileLoadErrorCases(errorType, filePath);
    p53._friendlyError(message, method, 3);
  };
}
if (typeof p5 !== "undefined") {
  fileErrors(p5, p5.prototype);
}

// node_modules/p5/dist/core/friendly_errors/index.js
function friendlyErrors(p53) {
  p53.registerAddon(fesCore);
  p53.registerAddon(stacktrace);
  p53.registerAddon(validateParams);
  p53.registerAddon(sketchVerifier);
  p53.registerAddon(fileErrors);
}

// node_modules/p5/dist/data/local_storage.js
function storage(p53, fn2) {
  fn2.storeItem = function(key, value) {
    if (typeof key !== "string") {
      console.log(`The argument that you passed to storeItem() - ${key} is not a string.`);
    }
    if (key.endsWith("p5TypeID")) {
      console.log(`The argument that you passed to storeItem() - ${key} must not end with 'p5TypeID'.`);
    }
    if (typeof value === "undefined") {
      console.log("You cannot store undefined variables using storeItem().");
    }
    let type2 = typeof value;
    switch (type2) {
      case "number":
      case "boolean":
        value = value.toString();
        break;
      case "object":
        if (value instanceof p53.Color) {
          type2 = "p5.Color";
          value = value.toString();
        } else if (value instanceof p53.Vector) {
          type2 = "p5.Vector";
          const coord = value.values;
          value = coord;
        }
        value = JSON.stringify(value);
        break;
    }
    localStorage.setItem(key, value);
    const typeKey = `${key}p5TypeID`;
    localStorage.setItem(typeKey, type2);
  };
  fn2.getItem = function(key) {
    let value = localStorage.getItem(key);
    const type2 = localStorage.getItem(`${key}p5TypeID`);
    if (typeof type2 === "undefined") {
      console.log(`Unable to determine type of item stored under ${key}in local storage. Did you save the item with something other than setItem()?`);
    } else if (value !== null) {
      switch (type2) {
        case "number":
          value = parseFloat(value);
          break;
        case "boolean":
          value = value === "true";
          break;
        case "object":
          value = JSON.parse(value);
          break;
        case "p5.Color":
          value = this.color(JSON.parse(value));
          break;
        case "p5.Vector":
          value = JSON.parse(value);
          value = this.createVector(...value);
          break;
      }
    }
    return value;
  };
  fn2.clearStorage = function() {
    const keys = Object.keys(localStorage);
    keys.forEach((key) => {
      if (key.endsWith("p5TypeID")) {
        this.removeItem(key.replace("p5TypeID", ""));
      }
    });
  };
  fn2.removeItem = function(key) {
    if (typeof key !== "string") {
      console.log(`The argument that you passed to removeItem() - ${key} is not a string.`);
    }
    localStorage.removeItem(key);
    localStorage.removeItem(`${key}p5TypeID`);
  };
}
if (typeof p5 !== "undefined") {
  storage(p5, p5.prototype);
}

// node_modules/p5/dist/data/index.js
function data2(p53) {
  p53.registerAddon(storage);
}

// node_modules/p5/dist/dom/dom.js
function dom(p53, fn2) {
  fn2.select = function(e2, p2) {
    const container = this._getContainer(p2);
    const res = container.querySelector(e2);
    if (res) {
      return this._wrapElement(res);
    } else {
      return null;
    }
  };
  fn2.selectAll = function(e2, p2) {
    const arr2 = [];
    const container = this._getContainer(p2);
    const res = container.querySelectorAll(e2);
    if (res) {
      for (let j = 0;j < res.length; j++) {
        const obj = this._wrapElement(res[j]);
        arr2.push(obj);
      }
    }
    return arr2;
  };
  fn2._getContainer = function(p2) {
    let container = document;
    if (typeof p2 === "string") {
      container = document.querySelector(p2) || document;
    } else if (p2 instanceof Element) {
      container = p2.elt;
    } else if (p2 instanceof HTMLElement) {
      container = p2;
    }
    return container;
  };
  fn2._wrapElement = function(elt) {
    const children = Array.prototype.slice.call(elt.children);
    if (elt.tagName === "INPUT" && elt.type === "checkbox") {
      let converted = new Element(elt, this);
      converted.checked = function(...args) {
        if (args.length === 0) {
          return this.elt.checked;
        } else if (args[0]) {
          this.elt.checked = true;
        } else {
          this.elt.checked = false;
        }
        return this;
      };
      return converted;
    } else if (elt.tagName === "VIDEO" || elt.tagName === "AUDIO") {
      return new MediaElement(elt, this);
    } else if (elt.tagName === "SELECT") {
      return this.createSelect(new Element(elt, this));
    } else if (children.length > 0 && children.every(function(c) {
      return c.tagName === "INPUT" || c.tagName === "LABEL";
    }) && (elt.tagName === "DIV" || elt.tagName === "SPAN")) {
      return this.createRadio(new Element(elt, this));
    } else {
      return new Element(elt, this);
    }
  };
  fn2.createElement = function(tag, content) {
    const elt = document.createElement(tag);
    if (typeof content !== "undefined") {
      elt.innerHTML = content;
    }
    return addElement(elt, this);
  };
  fn2.removeElements = function(e2) {
    const isNotCanvasElement = (el) => !(el.elt instanceof HTMLCanvasElement);
    const removeableElements = this._elements.filter(isNotCanvasElement);
    removeableElements.map((el) => el.remove());
  };
  function addElement(elt, pInst, media2) {
    const node = pInst._userNode ? pInst._userNode : document.body;
    node.appendChild(elt);
    const c = media2 ? new MediaElement(elt, pInst) : new Element(elt, pInst);
    pInst._elements.push(c);
    return c;
  }
  fn2.createDiv = function(html = "") {
    let elt = document.createElement("div");
    elt.innerHTML = html;
    return addElement(elt, this);
  };
  fn2.createP = function(html = "") {
    let elt = document.createElement("p");
    elt.innerHTML = html;
    return addElement(elt, this);
  };
  fn2.createSpan = function(html = "") {
    let elt = document.createElement("span");
    elt.innerHTML = html;
    return addElement(elt, this);
  };
  fn2.createImg = function() {
    const elt = document.createElement("img");
    const args = arguments;
    let self2;
    if (args.length > 1 && typeof args[1] === "string") {
      elt.alt = args[1];
    }
    if (args.length > 2 && typeof args[2] === "string") {
      elt.crossOrigin = args[2];
    }
    elt.src = args[0];
    self2 = addElement(elt, this);
    elt.addEventListener("load", function() {
      self2.width = elt.offsetWidth || elt.width;
      self2.height = elt.offsetHeight || elt.height;
      const last2 = args[args.length - 1];
      if (typeof last2 === "function")
        last2(self2);
    });
    return self2;
  };
  fn2.createA = function(href, html, target) {
    const elt = document.createElement("a");
    elt.href = href;
    elt.innerHTML = html;
    if (target)
      elt.target = target;
    return addElement(elt, this);
  };
  fn2.createSlider = function(min, max, value, step) {
    const elt = document.createElement("input");
    elt.type = "range";
    elt.min = min;
    elt.max = max;
    if (step === 0) {
      elt.step = 0.000000000000000001;
    } else if (step) {
      elt.step = step;
    }
    if (typeof value === "number")
      elt.value = value;
    return addElement(elt, this);
  };
  fn2.createButton = function(label, value) {
    const elt = document.createElement("button");
    elt.innerHTML = label;
    if (value)
      elt.value = value;
    return addElement(elt, this);
  };
  fn2.createCheckbox = function(...args) {
    const elt = document.createElement("div");
    const checkbox = document.createElement("input");
    checkbox.type = "checkbox";
    const label = document.createElement("label");
    label.appendChild(checkbox);
    elt.appendChild(label);
    const self2 = addElement(elt, this);
    self2.checked = function(...args2) {
      const cb = self2.elt.firstElementChild.getElementsByTagName("input")[0];
      if (cb) {
        if (args2.length === 0) {
          return cb.checked;
        } else if (args2[0]) {
          cb.checked = true;
        } else {
          cb.checked = false;
        }
      }
      return self2;
    };
    this.value = function(val) {
      self2.value = val;
      return this;
    };
    if (args[0]) {
      self2.value(args[0]);
      const span = document.createElement("span");
      span.innerHTML = args[0];
      label.appendChild(span);
    }
    if (args[1]) {
      checkbox.checked = true;
    }
    return self2;
  };
  fn2.createSelect = function(...args) {
    let self2;
    let arg = args[0];
    if (arg instanceof Element && arg.elt instanceof HTMLSelectElement) {
      self2 = arg;
      this.elt = arg.elt;
    } else if (arg instanceof HTMLSelectElement) {
      self2 = addElement(arg, this);
      this.elt = arg;
    } else {
      const elt = document.createElement("select");
      if (arg && typeof arg === "boolean") {
        elt.setAttribute("multiple", "true");
      }
      self2 = addElement(elt, this);
      this.elt = elt;
    }
    self2.option = function(name, value) {
      let index;
      if (name === undefined) {
        return;
      }
      for (let i2 = 0;i2 < this.elt.length; i2 += 1) {
        if (this.elt[i2].textContent === name) {
          index = i2;
          break;
        }
      }
      if (index !== undefined) {
        if (value === false) {
          this.elt.remove(index);
        } else {
          this.elt[index].value = value;
        }
      } else {
        const opt = document.createElement("option");
        opt.textContent = name;
        opt.value = value === undefined ? name : value;
        this.elt.appendChild(opt);
        this._pInst._elements.push(opt);
      }
    };
    self2.selected = function(value) {
      if (value !== undefined) {
        for (let i2 = 0;i2 < this.elt.length; i2 += 1) {
          if (this.elt[i2].value.toString() === value.toString()) {
            this.elt.selectedIndex = i2;
          }
        }
        return this;
      } else {
        if (this.elt.getAttribute("multiple")) {
          let arr2 = [];
          for (const selectedOption of this.elt.selectedOptions) {
            arr2.push(selectedOption.value);
          }
          return arr2;
        } else {
          return this.elt.value;
        }
      }
    };
    self2.disable = function(value) {
      if (typeof value === "string") {
        for (let i2 = 0;i2 < this.elt.length; i2++) {
          if (this.elt[i2].value.toString() === value) {
            this.elt[i2].disabled = true;
            this.elt[i2].selected = false;
          }
        }
      } else {
        this.elt.disabled = true;
      }
      return this;
    };
    self2.enable = function(value) {
      if (typeof value === "string") {
        for (let i2 = 0;i2 < this.elt.length; i2++) {
          if (this.elt[i2].value.toString() === value) {
            this.elt[i2].disabled = false;
            this.elt[i2].selected = false;
          }
        }
      } else {
        this.elt.disabled = false;
        for (let i2 = 0;i2 < this.elt.length; i2++) {
          this.elt[i2].disabled = false;
          this.elt[i2].selected = false;
        }
      }
      return this;
    };
    return self2;
  };
  let counter = 0;
  fn2.createRadio = function(...args) {
    let self2;
    let radioElement;
    let name;
    const arg0 = args[0];
    if (arg0 instanceof Element && (arg0.elt instanceof HTMLDivElement || arg0.elt instanceof HTMLSpanElement)) {
      self2 = arg0;
      this.elt = arg0.elt;
    } else if (arg0 instanceof HTMLDivElement || arg0 instanceof HTMLSpanElement) {
      self2 = addElement(arg0, this);
      this.elt = arg0;
      radioElement = arg0;
      if (typeof args[1] === "string")
        name = args[1];
    } else {
      if (typeof arg0 === "string")
        name = arg0;
      radioElement = document.createElement("div");
      self2 = addElement(radioElement, this);
      this.elt = radioElement;
    }
    self2._name = name || `radioOption_${counter++}`;
    const isRadioInput = (el) => el instanceof HTMLInputElement && el.type === "radio";
    const isLabelElement = (el) => el instanceof HTMLLabelElement;
    const isSpanElement = (el) => el instanceof HTMLSpanElement;
    self2._getOptionsArray = function() {
      return Array.from(this.elt.children).filter((el) => isRadioInput(el) || isLabelElement(el) && isRadioInput(el.firstElementChild)).map((el) => isRadioInput(el) ? el : el.firstElementChild);
    };
    self2.option = function(value, label) {
      let optionEl;
      for (const option of self2._getOptionsArray()) {
        if (option.value === value) {
          optionEl = option;
          break;
        }
      }
      if (optionEl === undefined) {
        optionEl = document.createElement("input");
        optionEl.setAttribute("type", "radio");
        optionEl.setAttribute("value", value);
      }
      optionEl.setAttribute("name", self2._name);
      let labelElement;
      if (!isLabelElement(optionEl.parentElement)) {
        labelElement = document.createElement("label");
        labelElement.insertAdjacentElement("afterbegin", optionEl);
      } else {
        labelElement = optionEl.parentElement;
      }
      let spanElement;
      if (!isSpanElement(labelElement.lastElementChild)) {
        spanElement = document.createElement("span");
        optionEl.insertAdjacentElement("afterend", spanElement);
      } else {
        spanElement = labelElement.lastElementChild;
      }
      spanElement.innerHTML = label === undefined ? value : label;
      this.elt.appendChild(labelElement);
      return optionEl;
    };
    self2.remove = function(value) {
      for (const optionEl of self2._getOptionsArray()) {
        if (optionEl.value === value) {
          if (isLabelElement(optionEl.parentElement)) {
            optionEl.parentElement.remove();
          } else {
            optionEl.remove();
          }
          return;
        }
      }
    };
    self2.value = function() {
      let result = "";
      for (const option of self2._getOptionsArray()) {
        if (option.checked) {
          result = option.value;
          break;
        }
      }
      return result;
    };
    self2.selected = function(value) {
      let result = null;
      if (value === undefined) {
        for (const option of self2._getOptionsArray()) {
          if (option.checked) {
            result = option;
            break;
          }
        }
      } else {
        self2._getOptionsArray().forEach((option) => {
          option.checked = false;
          option.removeAttribute("checked");
        });
        for (const option of self2._getOptionsArray()) {
          if (option.value === value) {
            option.setAttribute("checked", true);
            option.checked = true;
            result = option;
          }
        }
      }
      return result;
    };
    self2.disable = function(shouldDisable = true) {
      for (const radioInput of self2._getOptionsArray()) {
        radioInput.setAttribute("disabled", shouldDisable);
      }
    };
    return self2;
  };
  fn2.createColorPicker = function(value) {
    const elt = document.createElement("input");
    let self2;
    elt.type = "color";
    if (value) {
      if (value instanceof p53.Color) {
        elt.value = value.toString("#rrggbb");
      } else {
        this.push();
        this.colorMode("rgb");
        elt.value = this.color(value).toString("#rrggbb");
        this.pop();
      }
    } else {
      elt.value = "#000000";
    }
    self2 = addElement(elt, this);
    const inst = this;
    self2.color = function() {
      inst.push();
      if (value) {
        if (value.mode) {
          inst.colorMode(value.mode, ...value?.maxes ? value.maxes[value.mode] || [] : []);
        }
      }
      const c = inst.color(this.elt.value);
      inst.pop();
      return c;
    };
    return self2;
  };
  fn2.createInput = function(value = "", type2 = "text") {
    let elt = document.createElement("input");
    elt.setAttribute("value", value);
    elt.setAttribute("type", type2);
    return addElement(elt, this);
  };
  fn2.createFileInput = function(callback, multiple = false) {
    const handleFileSelect = function(event) {
      for (const file3 of event.target.files) {
        File2._load(file3, callback);
      }
    };
    if (!(window.File && window.FileReader && window.FileList && window.Blob)) {
      console.log("The File APIs are not fully supported in this browser. Cannot create element.");
      return;
    }
    const fileInput = document.createElement("input");
    fileInput.setAttribute("type", "file");
    if (multiple)
      fileInput.setAttribute("multiple", true);
    fileInput.addEventListener("change", handleFileSelect, false);
    return addElement(fileInput, this);
  };
}
if (typeof p5 !== "undefined") {
  dom(p5, p5.prototype);
}

// node_modules/p5/dist/dom/index.js
function dom2(p53) {
  p53.registerAddon(dom);
  p53.registerAddon(element);
  p53.registerAddon(media);
  p53.registerAddon(file);
}

// node_modules/p5/dist/events/acceleration.js
function acceleration(p53, fn2, lifecycles) {
  lifecycles.presetup = function() {
    const events = [
      "deviceorientation",
      "devicemotion"
    ];
    for (const event of events) {
      window.addEventListener(event, this[`_on${event}`].bind(this), {
        passive: false,
        signal: this._removeSignal
      });
    }
  };
  fn2.deviceOrientation = window.innerWidth / window.innerHeight > 1 ? "landscape" : "portrait";
  fn2.accelerationX = 0;
  fn2.accelerationY = 0;
  fn2.accelerationZ = 0;
  fn2.pAccelerationX = 0;
  fn2.pAccelerationY = 0;
  fn2.pAccelerationZ = 0;
  fn2._updatePAccelerations = function() {
    this.pAccelerationX = this.accelerationX;
    this.pAccelerationY = this.accelerationY;
    this.pAccelerationZ = this.accelerationZ;
  };
  fn2.rotationX = 0;
  fn2.rotationY = 0;
  fn2.rotationZ = 0;
  fn2.pRotationX = 0;
  fn2.pRotationY = 0;
  fn2.pRotationZ = 0;
  let startAngleX = 0;
  let startAngleY = 0;
  let startAngleZ = 0;
  let rotateDirectionX = "clockwise";
  let rotateDirectionY = "clockwise";
  let rotateDirectionZ = "clockwise";
  fn2.pRotateDirectionX = undefined;
  fn2.pRotateDirectionY = undefined;
  fn2.pRotateDirectionZ = undefined;
  fn2._updatePRotations = function() {
    this.pRotationX = this.rotationX;
    this.pRotationY = this.rotationY;
    this.pRotationZ = this.rotationZ;
  };
  fn2.turnAxis = undefined;
  let move_threshold = 0.5;
  let shake_threshold = 30;
  fn2.setMoveThreshold = function(val) {
    move_threshold = val;
  };
  fn2.setShakeThreshold = function(val) {
    shake_threshold = val;
  };
  fn2._ondeviceorientation = function(e2) {
    this._updatePRotations();
    this.rotationX = this._fromDegrees(e2.beta);
    this.rotationY = this._fromDegrees(e2.gamma);
    this.rotationZ = this._fromDegrees(e2.alpha);
    this._handleMotion();
  };
  fn2._ondevicemotion = function(e2) {
    this._updatePAccelerations();
    this.accelerationX = e2.acceleration.x * 2;
    this.accelerationY = e2.acceleration.y * 2;
    this.accelerationZ = e2.acceleration.z * 2;
    this._handleMotion();
  };
  fn2._handleMotion = function() {
    if (screen.orientation.type === "landscape-primary" || screen.orientation.type === "landscape-secondary") {
      this.deviceOrientation = "landscape";
    } else if (screen.orientation.type === "portrait-primary" || screen.orientation.type === "portrait-secondary") {
      this.deviceOrientation = "portrait";
    } else {
      this.deviceOrientation = "undefined";
    }
    if (typeof this._customActions.deviceMoved === "function") {
      if (Math.abs(this.accelerationX - this.pAccelerationX) > move_threshold || Math.abs(this.accelerationY - this.pAccelerationY) > move_threshold || Math.abs(this.accelerationZ - this.pAccelerationZ) > move_threshold) {
        this._customActions.deviceMoved();
      }
    }
    if (typeof this._customActions.deviceTurned === "function") {
      const wRX = this._toDegrees(this.rotationX) + 180;
      const wPRX = this._toDegrees(this.pRotationX) + 180;
      let wSAX = startAngleX + 180;
      if (wRX - wPRX > 0 && wRX - wPRX < 270 || wRX - wPRX < -270) {
        rotateDirectionX = "clockwise";
      } else if (wRX - wPRX < 0 || wRX - wPRX > 270) {
        rotateDirectionX = "counter-clockwise";
      }
      if (rotateDirectionX !== this.pRotateDirectionX) {
        wSAX = wRX;
      }
      if (Math.abs(wRX - wSAX) > 90 && Math.abs(wRX - wSAX) < 270) {
        wSAX = wRX;
        this.turnAxis = "X";
        this._customActions.deviceTurned();
      }
      this.pRotateDirectionX = rotateDirectionX;
      startAngleX = wSAX - 180;
      const wRY = this._toDegrees(this.rotationY) + 180;
      const wPRY = this._toDegrees(this.pRotationY) + 180;
      let wSAY = startAngleY + 180;
      if (wRY - wPRY > 0 && wRY - wPRY < 270 || wRY - wPRY < -270) {
        rotateDirectionY = "clockwise";
      } else if (wRY - wPRY < 0 || wRY - this.pRotationY > 270) {
        rotateDirectionY = "counter-clockwise";
      }
      if (rotateDirectionY !== this.pRotateDirectionY) {
        wSAY = wRY;
      }
      if (Math.abs(wRY - wSAY) > 90 && Math.abs(wRY - wSAY) < 270) {
        wSAY = wRY;
        this.turnAxis = "Y";
        this._customActions.deviceTurned();
      }
      this.pRotateDirectionY = rotateDirectionY;
      startAngleY = wSAY - 180;
      const rotZ = this._toDegrees(this.rotationZ);
      const pRotZ = this._toDegrees(this.pRotationZ);
      if (rotZ - pRotZ > 0 && rotZ - pRotZ < 270 || rotZ - pRotZ < -270) {
        rotateDirectionZ = "clockwise";
      } else if (rotZ - pRotZ < 0 || rotZ - pRotZ > 270) {
        rotateDirectionZ = "counter-clockwise";
      }
      if (rotateDirectionZ !== this.pRotateDirectionZ) {
        startAngleZ = rotZ;
      }
      if (Math.abs(rotZ - startAngleZ) > 90 && Math.abs(rotZ - startAngleZ) < 270) {
        startAngleZ = rotZ;
        this.turnAxis = "Z";
        this._customActions.deviceTurned();
      }
      this.pRotateDirectionZ = rotateDirectionZ;
      this.turnAxis = undefined;
    }
    if (typeof this._customActions.deviceShaken === "function") {
      let accelerationChangeX;
      let accelerationChangeY;
      if (this.pAccelerationX !== null) {
        accelerationChangeX = Math.abs(this.accelerationX - this.pAccelerationX);
        accelerationChangeY = Math.abs(this.accelerationY - this.pAccelerationY);
      }
      if (accelerationChangeX + accelerationChangeY > shake_threshold) {
        this._customActions.deviceShaken();
      }
    }
  };
}
if (typeof p5 !== "undefined") {
  acceleration(p5, p5.prototype);
}

// node_modules/p5/dist/events/keyboard.js
function isCode(input) {
  const leftRightKeys = [
    "Alt",
    "Shift",
    "Control",
    "Meta"
  ];
  if (leftRightKeys.includes(input)) {
    return false;
  }
  if (typeof input !== "string") {
    return false;
  }
  return input.length > 1;
}
function keyboard(p53, fn2, lifecycles) {
  lifecycles.presetup = function() {
    const events = [
      "keydown",
      "keyup",
      "keypress",
      "blur"
    ];
    for (const event of events) {
      window.addEventListener(event, this[`_on${event}`].bind(this), {
        passive: false,
        signal: this._removeSignal
      });
    }
  };
  fn2.keyIsPressed = false;
  fn2.key = "";
  fn2.code = "";
  fn2.keyCode = 0;
  fn2._onkeydown = function(e2) {
    if (this._downKeys[e2.code]) {
      return;
    }
    this.keyIsPressed = true;
    this.keyCode = e2.which;
    this.key = e2.key;
    this.code = e2.code;
    this._downKeyCodes[e2.code] = true;
    this._downKeys[e2.key] = true;
    if (typeof this._customActions.keyPressed === "function" && !e2.charCode) {
      const executeDefault = this._customActions.keyPressed(e2);
      if (executeDefault === false) {
        e2.preventDefault();
      }
    }
  };
  fn2._onkeyup = function(e2) {
    if (typeof this._customActions.keyReleased === "function") {
      const executeDefault = this._customActions.keyReleased(e2);
      if (executeDefault === false) {
        e2.preventDefault();
      }
    }
    delete this._downKeyCodes[e2.code];
    delete this._downKeys[e2.key];
    if (!this._areDownKeys()) {
      this.keyIsPressed = false;
      this.key = "";
      this.code = "";
    } else {
      const lastPressedCode = Object.keys(this._downKeyCodes).pop();
      this.code = lastPressedCode;
      const lastPressedKey = Object.keys(this._downKeys).pop();
      this.key = lastPressedKey;
    }
  };
  fn2._onkeypress = function(e2) {
    if (e2.which === this._lastKeyCodeTyped && e2.repeat) {
      return;
    }
    this._lastKeyCodeTyped = e2.which;
    this.key = e2.key || String.fromCharCode(e2.which) || e2.which;
    if (typeof this._customActions.keyTyped === "function") {
      const executeDefault = this._customActions.keyTyped(e2);
      if (executeDefault === false) {
        e2.preventDefault();
      }
    }
  };
  fn2._onblur = function(e2) {
    this._downKeys = {};
  };
  fn2.keyIsDown = function(input) {
    if (isCode(input)) {
      return this._downKeyCodes[input] || this._downKeys[input] || false;
    } else {
      return this._downKeys[input] || this._downKeyCodes[input] || false;
    }
  };
  fn2._areDownKeys = function() {
    for (const key in this._downKeys) {
      if (this._downKeys.hasOwnProperty(key) && this._downKeys[key] === true) {
        return true;
      }
    }
    return false;
  };
}
if (typeof p5 !== "undefined") {
  keyboard(p5, p5.prototype);
}

// node_modules/p5/dist/events/pointer.js
function pointer(p53, fn2, lifecycles) {
  lifecycles.presetup = function() {
    const events = [
      "pointerdown",
      "pointerup",
      "pointermove",
      "dragend",
      "dragover",
      "click",
      "dblclick",
      "wheel"
    ];
    for (const event of events) {
      window.addEventListener(event, this[`_on${event}`].bind(this), {
        passive: false,
        signal: this._removeSignal
      });
    }
  };
  fn2.movedX = 0;
  fn2.movedY = 0;
  fn2._hasMouseInteracted = false;
  fn2.mouseX = 0;
  fn2.mouseY = 0;
  fn2.pmouseX = 0;
  fn2.pmouseY = 0;
  fn2.winMouseX = 0;
  fn2.winMouseY = 0;
  fn2.pwinMouseX = 0;
  fn2.pwinMouseY = 0;
  fn2.mouseButton = {
    left: false,
    right: false,
    center: false
  };
  fn2.touches = [];
  fn2._activePointers = new Map;
  fn2.mouseIsPressed = false;
  fn2._updatePointerCoords = function(e2) {
    if (this._curElement !== null) {
      const canvas2 = this._curElement.elt;
      const sx = canvas2.scrollWidth / this.width || 1;
      const sy = canvas2.scrollHeight / this.height || 1;
      if (e2.pointerType === "touch") {
        const touches = [];
        for (const touch of this._activePointers.values()) {
          touches.push(getTouchInfo(canvas2, sx, sy, touch));
        }
        this.touches = touches;
      }
      const mousePos = getMouseInfo(canvas2, sx, sy, e2);
      this.movedX = e2.movementX || 0;
      this.movedY = e2.movementY || 0;
      this.mouseX = mousePos.x;
      this.mouseY = mousePos.y;
      this.winMouseX = mousePos.winX;
      this.winMouseY = mousePos.winY;
      if (!this._hasMouseInteracted) {
        this._updateMouseCoords();
        this._hasMouseInteracted = true;
      }
    }
  };
  fn2._updateMouseCoords = function() {
    this.pmouseX = this.mouseX;
    this.pmouseY = this.mouseY;
    this.pwinMouseX = this.winMouseX;
    this.pwinMouseY = this.winMouseY;
    this._pmouseWheelDeltaY = this._mouseWheelDeltaY;
  };
  function getMouseInfo(canvas2, sx, sy, evt) {
    const rect = canvas2.getBoundingClientRect();
    return {
      x: (evt.clientX - rect.left) / sx,
      y: (evt.clientY - rect.top) / sy,
      winX: evt.clientX,
      winY: evt.clientY
    };
  }
  function getTouchInfo(canvas2, sx, sy, touch) {
    const rect = canvas2.getBoundingClientRect();
    return {
      x: (touch.clientX - rect.left) / sx,
      y: (touch.clientY - rect.top) / sy,
      winX: touch.clientX,
      winY: touch.clientY,
      id: touch.pointerId
    };
  }
  fn2._setMouseButton = function(e2) {
    this.mouseButton.left = Array.from(this._activePointers.values()).some((touch) => (touch.buttons & 1) !== 0);
    this.mouseButton.center = Array.from(this._activePointers.values()).some((touch) => (touch.buttons & 4) !== 0);
    this.mouseButton.right = Array.from(this._activePointers.values()).some((touch) => (touch.buttons & 2) !== 0);
  };
  fn2._onpointermove = function(e2) {
    let executeDefault;
    this._updatePointerCoords(e2);
    this._activePointers.set(e2.pointerId, e2);
    this._setMouseButton(e2);
    if (!this.mouseIsPressed && typeof this._customActions.mouseMoved === "function") {
      executeDefault = this._customActions.mouseMoved(e2);
      if (executeDefault === false) {
        e2.preventDefault();
      }
    } else if (this.mouseIsPressed && typeof this._customActions.mouseDragged === "function") {
      executeDefault = this._customActions.mouseDragged(e2);
      if (executeDefault === false) {
        e2.preventDefault();
      }
    }
  };
  fn2._onpointerdown = function(e2) {
    let executeDefault;
    this.mouseIsPressed = true;
    this._activePointers.set(e2.pointerId, e2);
    this._setMouseButton(e2);
    this._updatePointerCoords(e2);
    if (typeof this._customActions.mousePressed === "function") {
      executeDefault = this._customActions.mousePressed(e2);
      if (executeDefault === false) {
        e2.preventDefault();
      }
    }
  };
  fn2._onpointerup = function(e2) {
    let executeDefault;
    this.mouseIsPressed = false;
    this._activePointers.delete(e2.pointerId);
    this._setMouseButton(e2);
    this._updatePointerCoords(e2);
    if (typeof this._customActions.mouseReleased === "function") {
      executeDefault = this._customActions.mouseReleased(e2);
      if (executeDefault === false) {
        e2.preventDefault();
      }
    }
  };
  fn2._ondragend = fn2._onpointerup;
  fn2._ondragover = fn2._onpointermove;
  fn2._onclick = function(e2) {
    if (typeof this._customActions.mouseClicked === "function") {
      const executeDefault = this._customActions.mouseClicked(e2);
      if (executeDefault === false) {
        e2.preventDefault();
      }
    }
  };
  fn2._ondblclick = function(e2) {
    if (typeof this._customActions.doubleClicked === "function") {
      const executeDefault = this._customActions.doubleClicked(e2);
      if (executeDefault === false) {
        e2.preventDefault();
      }
    }
  };
  fn2._mouseWheelDeltaY = 0;
  fn2._pmouseWheelDeltaY = 0;
  fn2._onwheel = function(e2) {
    this._mouseWheelDeltaY = e2.deltaY;
    if (typeof this._customActions.mouseWheel === "function") {
      e2.delta = e2.deltaY;
      const executeDefault = this._customActions.mouseWheel(e2);
      if (executeDefault === false) {
        e2.preventDefault();
      }
    }
  };
  fn2.requestPointerLock = function() {
    const canvas2 = this._curElement.elt;
    canvas2.requestPointerLock = canvas2.requestPointerLock || canvas2.mozRequestPointerLock;
    if (!canvas2.requestPointerLock) {
      console.log("requestPointerLock is not implemented in this browser");
      return false;
    }
    canvas2.requestPointerLock();
    return true;
  };
  fn2.exitPointerLock = function() {
    document.exitPointerLock();
  };
}
if (typeof p5 !== "undefined") {
  pointer(p5, p5.prototype);
}

// node_modules/p5/dist/events/index.js
function events(p53) {
  p53.registerAddon(acceleration);
  p53.registerAddon(keyboard);
  p53.registerAddon(pointer);
}

// node_modules/p5/dist/image/index.js
var import_omggif5 = __toESM(require_omggif(), 1);
var import_file_saver8 = __toESM(require_FileSaver(), 1);
var import_gifenc6 = __toESM(require_gifenc(), 1);
var import_libtess6 = __toESM(require_libtess_min(), 1);
function image3(p53) {
  p53.registerAddon(image2);
  p53.registerAddon(loadingDisplaying);
  p53.registerAddon(image);
  p53.registerAddon(pixels);
  p53.registerAddon(shader);
  p53.registerAddon(texture);
}

// node_modules/p5/dist/io/p5.Table.js
class Table {
  constructor(rows) {
    this.columns = [];
    this.rows = [];
  }
  toString(separator = ",") {
    let rows = this.rows.map((row) => row.arr);
    if (!this.columns.some((column) => column === null)) {
      rows = [this.columns, ...rows];
    }
    return stringify(rows, {
      separator
    });
  }
  addRow(row) {
    const r = row || new p5.TableRow;
    if (typeof r.arr === "undefined" || typeof r.obj === "undefined") {
      throw new Error(`invalid TableRow: ${r}`);
    }
    r.table = this;
    this.rows.push(r);
    return r;
  }
  removeRow(id) {
    this.rows[id].table = null;
    const chunk = this.rows.splice(id + 1, this.rows.length);
    this.rows.pop();
    this.rows = this.rows.concat(chunk);
  }
  getRow(r) {
    return this.rows[r];
  }
  getRows() {
    return this.rows;
  }
  findRow(value, column) {
    if (typeof column === "string") {
      for (let i2 = 0;i2 < this.rows.length; i2++) {
        if (this.rows[i2].obj[this.columns.indexOf(column)] === value) {
          return this.rows[i2];
        }
      }
    } else {
      for (let j = 0;j < this.rows.length; j++) {
        if (this.rows[j].arr[column] === value) {
          return this.rows[j];
        }
      }
    }
    return null;
  }
  findRows(value, column) {
    const ret = [];
    if (typeof column === "string") {
      for (let i2 = 0;i2 < this.rows.length; i2++) {
        if (this.rows[i2].obj[this.columns.indexOf(column)] === value) {
          ret.push(this.rows[i2]);
        }
      }
    } else {
      for (let j = 0;j < this.rows.length; j++) {
        if (this.rows[j].arr[column] === value) {
          ret.push(this.rows[j]);
        }
      }
    }
    return ret;
  }
  matchRow(regexp, column) {
    if (typeof column === "number") {
      for (let j = 0;j < this.rows.length; j++) {
        if (this.rows[j].arr[column].match(regexp)) {
          return this.rows[j];
        }
      }
    } else {
      for (let i2 = 0;i2 < this.rows.length; i2++) {
        if (this.rows[i2].obj[this.columns.indexOf(column)].match(regexp)) {
          return this.rows[i2];
        }
      }
    }
    return null;
  }
  matchRows(regexp, column) {
    const ret = [];
    if (typeof column === "number") {
      for (let j = 0;j < this.rows.length; j++) {
        if (this.rows[j].arr[column].match(regexp)) {
          ret.push(this.rows[j]);
        }
      }
    } else {
      for (let i2 = 0;i2 < this.rows.length; i2++) {
        if (this.rows[i2].obj[this.columns.indexOf(column)].match(regexp)) {
          ret.push(this.rows[i2]);
        }
      }
    }
    return ret;
  }
  getColumn(value) {
    const ret = [];
    if (typeof value === "string") {
      for (let i2 = 0;i2 < this.rows.length; i2++) {
        ret.push(this.rows[i2].obj[this.columns.indexOf(value)]);
      }
    } else {
      for (let j = 0;j < this.rows.length; j++) {
        ret.push(this.rows[j].arr[value]);
      }
    }
    return ret;
  }
  clearRows() {
    delete this.rows;
    this.rows = [];
  }
  addColumn(title) {
    const t = title || null;
    this.columns.push(t);
  }
  getColumnCount() {
    return this.columns.length;
  }
  getRowCount() {
    return this.rows.length;
  }
  removeTokens(chars, column) {
    const escape2 = (s) => s.replace(/[-/\\^$*+?.()|[\]{}]/g, "\\$&");
    const charArray = [];
    for (let i2 = 0;i2 < chars.length; i2++) {
      charArray.push(escape2(chars.charAt(i2)));
    }
    const regex = new RegExp(charArray.join("|"), "g");
    if (typeof column === "undefined") {
      for (let c = 0;c < this.columns.length; c++) {
        for (let d2 = 0;d2 < this.rows.length; d2++) {
          let s = this.rows[d2].arr[c];
          s = s.replace(regex, "");
          this.rows[d2].arr[c] = s;
          this.rows[d2].obj[this.columns[c]] = s;
        }
      }
    } else if (typeof column === "string") {
      for (let j = 0;j < this.rows.length; j++) {
        let val = this.rows[j].obj[column];
        val = val.replace(regex, "");
        this.rows[j].obj[column] = val;
        const pos = this.columns.indexOf(column);
        this.rows[j].arr[pos] = val;
      }
    } else {
      for (let k = 0;k < this.rows.length; k++) {
        let str = this.rows[k].arr[column];
        str = str.replace(regex, "");
        this.rows[k].arr[column] = str;
        this.rows[k].obj[this.columns[column]] = str;
      }
    }
  }
  trim(column) {
    const regex = new RegExp(" ", "g");
    if (typeof column === "undefined") {
      for (let c = 0;c < this.columns.length; c++) {
        for (let d2 = 0;d2 < this.rows.length; d2++) {
          let s = this.rows[d2].arr[c];
          s = s.replace(regex, "");
          this.rows[d2].arr[c] = s;
          this.rows[d2].obj[this.columns[c]] = s;
        }
      }
    } else if (typeof column === "string") {
      for (let j = 0;j < this.rows.length; j++) {
        let val = this.rows[j].obj[column];
        val = val.replace(regex, "");
        this.rows[j].obj[column] = val;
        const pos = this.columns.indexOf(column);
        this.rows[j].arr[pos] = val;
      }
    } else {
      for (let k = 0;k < this.rows.length; k++) {
        let str = this.rows[k].arr[column];
        str = str.replace(regex, "");
        this.rows[k].arr[column] = str;
        this.rows[k].obj[this.columns[column]] = str;
      }
    }
  }
  removeColumn(c) {
    let cString;
    let cNumber;
    if (typeof c === "string") {
      cString = c;
      cNumber = this.columns.indexOf(c);
    } else {
      cNumber = c;
      cString = this.columns[c];
    }
    const chunk = this.columns.splice(cNumber + 1, this.columns.length);
    this.columns.pop();
    this.columns = this.columns.concat(chunk);
    for (let i2 = 0;i2 < this.rows.length; i2++) {
      const tempR = this.rows[i2].arr;
      const chip = tempR.splice(cNumber + 1, tempR.length);
      tempR.pop();
      this.rows[i2].arr = tempR.concat(chip);
      delete this.rows[i2].obj[cString];
    }
  }
  set(row, column, value) {
    this.rows[row].set(column, value);
  }
  setNum(row, column, value) {
    this.rows[row].setNum(column, value);
  }
  setString(row, column, value) {
    this.rows[row].setString(column, value);
  }
  get(row, column) {
    if (typeof column === "string") {
      return this.rows[row].get(this.columns.indexOf(column));
    } else {
      return this.rows[row].get(column);
    }
  }
  getNum(row, column) {
    return this.rows[row].getNum(column);
  }
  getString(row, column) {
    return this.rows[row].getString(column);
  }
  getObject(headerColumn) {
    const tableObject = {};
    let obj, cPos, index;
    for (let i2 = 0;i2 < this.rows.length; i2++) {
      obj = this.rows[i2].obj;
      if (typeof headerColumn === "string") {
        cPos = this.columns.indexOf(headerColumn);
        if (cPos >= 0) {
          index = obj[headerColumn];
          tableObject[index] = obj;
        } else {
          throw new Error(`This table has no column named "${headerColumn}"`);
        }
      } else {
        tableObject[i2] = this.rows[i2].obj;
      }
    }
    return tableObject;
  }
  getArray() {
    const tableArray = [];
    for (let i2 = 0;i2 < this.rows.length; i2++) {
      tableArray.push(this.rows[i2].arr);
    }
    return tableArray;
  }
}
function table(p53, fn2) {
  p53.Table = Table;
}
if (typeof p5 !== "undefined") {
  table(p5, p5.prototype);
}

// node_modules/p5/dist/io/p5.TableRow.js
class TableRow {
  constructor(row = []) {
    let arr2 = row;
    this.arr = arr2;
    this.obj = Object.fromEntries(arr2.entries());
    this.table = null;
  }
  set(column, value) {
    if (typeof column === "string") {
      const cPos = this.table.columns.indexOf(column);
      if (cPos >= 0) {
        this.obj[column] = value;
        this.arr[cPos] = value;
      } else {
        throw new Error(`This table has no column named "${column}"`);
      }
    } else {
      if (column < this.table.columns.length) {
        this.arr[column] = value;
        const cTitle = this.table.columns[column];
        this.obj[cTitle] = value;
      } else {
        throw new Error(`Column #${column} is out of the range of this table`);
      }
    }
  }
  setNum(column, value) {
    const floatVal = parseFloat(value);
    this.set(column, floatVal);
  }
  setString(column, value) {
    const stringVal = value.toString();
    this.set(column, stringVal);
  }
  get(column) {
    if (typeof column === "string") {
      return this.obj[this.table.columns.indexOf(column)];
    } else {
      return this.arr[column];
    }
  }
  getNum(column) {
    let ret;
    if (typeof column === "string") {
      ret = parseFloat(this.obj[this.table.columns.indexOf(column)]);
    } else {
      ret = parseFloat(this.arr[column]);
    }
    if (ret.toString() === "NaN") {
      throw `Error: ${this.obj[column]} is NaN (Not a Number)`;
    }
    return ret;
  }
  getString(column) {
    if (typeof column === "string") {
      return this.obj[this.table.columns.indexOf(column)].toString();
    } else {
      return this.arr[column].toString();
    }
  }
}
function tableRow(p53, fn2) {
  p53.TableRow = TableRow;
}
if (typeof p5 !== "undefined") {
  tableRow(p5, p5.prototype);
}

// node_modules/p5/dist/io/index.js
var import_file_saver9 = __toESM(require_FileSaver(), 1);
var import_omggif6 = __toESM(require_omggif(), 1);
var import_gifenc7 = __toESM(require_gifenc(), 1);
var import_libtess7 = __toESM(require_libtess_min(), 1);
function io(p53) {
  p53.registerAddon(files);
  p53.registerAddon(table);
  p53.registerAddon(tableRow);
  p53.registerAddon(xml);
}

// node_modules/p5/dist/math/calculation.js
function calculation(p53, fn2) {
  fn2.abs = Math.abs;
  fn2.ceil = Math.ceil;
  fn2.constrain = function(n2, low, high) {
    return Math.max(Math.min(n2, high), low);
  };
  fn2.dist = function(...args) {
    if (args.length === 4) {
      return Math.hypot(args[2] - args[0], args[3] - args[1]);
    } else if (args.length === 6) {
      return Math.hypot(args[3] - args[0], args[4] - args[1], args[5] - args[2]);
    }
  };
  fn2.exp = Math.exp;
  fn2.floor = Math.floor;
  fn2.lerp = function(start, stop, amt) {
    return amt * (stop - start) + start;
  };
  fn2.log = Math.log;
  fn2.mag = function(x, y) {
    return Math.hypot(x, y);
  };
  fn2.map = function(n2, start1, stop1, start2, stop2, withinBounds) {
    const newval = (n2 - start1) / (stop1 - start1) * (stop2 - start2) + start2;
    if (!withinBounds) {
      return newval;
    }
    if (start2 < stop2) {
      return this.constrain(newval, start2, stop2);
    } else {
      return this.constrain(newval, stop2, start2);
    }
  };
  fn2.max = function(...args) {
    const findMax = (arr2) => {
      let max = -Infinity;
      for (let x of arr2) {
        max = Math.max(max, x);
      }
      return max;
    };
    if (args[0] instanceof Array) {
      return findMax(args[0]);
    } else {
      return findMax(args);
    }
  };
  fn2.min = function(...args) {
    const findMin = (arr2) => {
      let min = Infinity;
      for (let x of arr2) {
        min = Math.min(min, x);
      }
      return min;
    };
    if (args[0] instanceof Array) {
      return findMin(args[0]);
    } else {
      return findMin(args);
    }
  };
  fn2.norm = function(n2, start, stop) {
    return this.map(n2, start, stop, 0, 1);
  };
  fn2.pow = Math.pow;
  fn2.round = function(n2, decimals) {
    if (!decimals) {
      return Math.round(n2);
    }
    const multiplier = Math.pow(10, decimals);
    return Math.round(n2 * multiplier) / multiplier;
  };
  fn2.sq = (n2) => n2 * n2;
  fn2.sqrt = Math.sqrt;
  fn2.fract = function(toConvert) {
    let sign = 0;
    let num = Number(toConvert);
    if (isNaN(num) || Math.abs(num) === Infinity) {
      return num;
    } else if (num < 0) {
      num = -num;
      sign = 1;
    }
    if (String(num).includes(".") && !String(num).includes("e")) {
      let toFract = String(num);
      toFract = Number("0" + toFract.slice(toFract.indexOf(".")));
      return Math.abs(sign - toFract);
    } else if (num < 1) {
      return Math.abs(sign - num);
    } else {
      return 0;
    }
  };
}
if (typeof p5 !== "undefined") {
  calculation(p5, p5.prototype);
}

// node_modules/p5/dist/math/noise.js
function noise(p53, fn2) {
  const PERLIN_YWRAPB = 4;
  const PERLIN_YWRAP = 1 << PERLIN_YWRAPB;
  const PERLIN_ZWRAPB = 8;
  const PERLIN_ZWRAP = 1 << PERLIN_ZWRAPB;
  const PERLIN_SIZE = 4095;
  let perlin_octaves = 4;
  let perlin_amp_falloff = 0.5;
  const scaled_cosine = (i2) => 0.5 * (1 - Math.cos(i2 * Math.PI));
  let perlin;
  fn2.noise = function(x, y = 0, z = 0) {
    if (perlin == null) {
      perlin = new Array(PERLIN_SIZE + 1);
      for (let i2 = 0;i2 < PERLIN_SIZE + 1; i2++) {
        perlin[i2] = Math.random();
      }
    }
    if (x < 0) {
      x = -x;
    }
    if (y < 0) {
      y = -y;
    }
    if (z < 0) {
      z = -z;
    }
    let xi = Math.floor(x), yi = Math.floor(y), zi = Math.floor(z);
    let xf = x - xi;
    let yf = y - yi;
    let zf = z - zi;
    let rxf, ryf;
    let r = 0;
    let ampl = 0.5;
    let n1, n2, n3;
    for (let o = 0;o < perlin_octaves; o++) {
      let of = xi + (yi << PERLIN_YWRAPB) + (zi << PERLIN_ZWRAPB);
      rxf = scaled_cosine(xf);
      ryf = scaled_cosine(yf);
      n1 = perlin[of & PERLIN_SIZE];
      n1 += rxf * (perlin[of + 1 & PERLIN_SIZE] - n1);
      n2 = perlin[of + PERLIN_YWRAP & PERLIN_SIZE];
      n2 += rxf * (perlin[of + PERLIN_YWRAP + 1 & PERLIN_SIZE] - n2);
      n1 += ryf * (n2 - n1);
      of += PERLIN_ZWRAP;
      n2 = perlin[of & PERLIN_SIZE];
      n2 += rxf * (perlin[of + 1 & PERLIN_SIZE] - n2);
      n3 = perlin[of + PERLIN_YWRAP & PERLIN_SIZE];
      n3 += rxf * (perlin[of + PERLIN_YWRAP + 1 & PERLIN_SIZE] - n3);
      n2 += ryf * (n3 - n2);
      n1 += scaled_cosine(zf) * (n2 - n1);
      r += n1 * ampl;
      ampl *= perlin_amp_falloff;
      xi <<= 1;
      xf *= 2;
      yi <<= 1;
      yf *= 2;
      zi <<= 1;
      zf *= 2;
      if (xf >= 1) {
        xi++;
        xf--;
      }
      if (yf >= 1) {
        yi++;
        yf--;
      }
      if (zf >= 1) {
        zi++;
        zf--;
      }
    }
    return r;
  };
  fn2.noiseDetail = function(lod, falloff) {
    if (lod > 0) {
      perlin_octaves = lod;
    }
    if (falloff > 0) {
      perlin_amp_falloff = falloff;
    }
  };
  fn2.noiseSeed = function(seed) {
    const lcg = (() => {
      const m = 4294967296;
      const a = 1664525;
      const c = 1013904223;
      let seed2, z;
      return {
        setSeed(val) {
          z = seed2 = (val == null ? Math.random() * m : val) >>> 0;
        },
        getSeed() {
          return seed2;
        },
        rand() {
          z = (a * z + c) % m;
          return z / m;
        }
      };
    })();
    lcg.setSeed(seed);
    perlin = new Array(PERLIN_SIZE + 1);
    for (let i2 = 0;i2 < PERLIN_SIZE + 1; i2++) {
      perlin[i2] = lcg.rand();
    }
  };
}
if (typeof p5 !== "undefined") {
  noise(p5, p5.prototype);
}

// node_modules/p5/dist/math/random.js
function random(p53, fn2) {
  const randomStateProp = "_lcg_random_state";
  const m = 4294967296;
  const a = 1664525;
  const c = 1013904223;
  let y2 = 0;
  fn2._lcg = function(stateProperty) {
    this[stateProperty] = (a * this[stateProperty] + c) % m;
    return this[stateProperty] / m;
  };
  fn2._lcgSetSeed = function(stateProperty, val) {
    this[stateProperty] = (val == null ? Math.random() * m : val) >>> 0;
  };
  fn2.randomSeed = function(seed) {
    this._lcgSetSeed(randomStateProp, seed);
    this._gaussian_previous = false;
  };
  fn2.random = function(min, max) {
    let rand;
    if (this[randomStateProp] != null) {
      rand = this._lcg(randomStateProp);
    } else {
      rand = Math.random();
    }
    if (typeof min === "undefined") {
      return rand;
    } else if (typeof max === "undefined") {
      if (min instanceof Array) {
        return min[Math.floor(rand * min.length)];
      } else {
        return rand * min;
      }
    } else {
      if (min > max) {
        const tmp = min;
        min = max;
        max = tmp;
      }
      return rand * (max - min) + min;
    }
  };
  fn2.randomGaussian = function(mean, sd = 1) {
    let y1, x1, x2, w;
    if (this._gaussian_previous) {
      y1 = y2;
      this._gaussian_previous = false;
    } else {
      do {
        x1 = this.random(2) - 1;
        x2 = this.random(2) - 1;
        w = x1 * x1 + x2 * x2;
      } while (w >= 1);
      w = Math.sqrt(-2 * Math.log(w) / w);
      y1 = x1 * w;
      y2 = x2 * w;
      this._gaussian_previous = true;
    }
    const m3 = mean || 0;
    return y1 * sd + m3;
  };
}
if (typeof p5 !== "undefined") {
  random(p5, p5.prototype);
}

// node_modules/p5/dist/math/math.js
function math(p53, fn2) {
  fn2.createVector = function(x, y, z) {
    if (arguments.length === 0) {
      p53._friendlyError("In 1.x, createVector() was a shortcut for createVector(0, 0, 0). In 2.x, p5.js has vectors of any dimension, so you must provide your desired number of zeros. Use createVector(0, 0) for a 2D vector and createVector(0, 0, 0) for a 3D vector.");
    }
    if (this instanceof p53) {
      return new p53.Vector(this._fromRadians.bind(this), this._toRadians.bind(this), ...arguments);
    } else {
      return new p53.Vector(x, y, z);
    }
  };
  fn2.createMatrix = function(...args) {
    return new p53.Matrix(...args);
  };
}
if (typeof p5 !== "undefined") {
  math(p5, p5.prototype);
}

// node_modules/p5/dist/math/index.js
function math2(p53) {
  p53.registerAddon(calculation);
  p53.registerAddon(noise);
  p53.registerAddon(random);
  p53.registerAddon(trigonometry);
  p53.registerAddon(math);
  p53.registerAddon(vector);
}

// node_modules/p5/dist/utilities/conversion.js
function conversion(p53, fn2) {
  fn2.float = function(str) {
    if (str instanceof Array) {
      return str.map(parseFloat);
    }
    return parseFloat(str);
  };
  fn2.int = function(n2, radix = 10) {
    if (n2 === Infinity || n2 === "Infinity") {
      return Infinity;
    } else if (n2 === -Infinity || n2 === "-Infinity") {
      return -Infinity;
    } else if (typeof n2 === "string") {
      return parseInt(n2, radix);
    } else if (typeof n2 === "number") {
      return n2 | 0;
    } else if (typeof n2 === "boolean") {
      return n2 ? 1 : 0;
    } else if (n2 instanceof Array) {
      return n2.map((n3) => fn2.int(n3, radix));
    }
  };
  fn2.str = function(n2) {
    if (n2 instanceof Array) {
      return n2.map(fn2.str);
    } else {
      return String(n2);
    }
  };
  fn2.boolean = function(n2) {
    if (typeof n2 === "number") {
      return n2 !== 0;
    } else if (typeof n2 === "string") {
      return n2.toLowerCase() === "true";
    } else if (typeof n2 === "boolean") {
      return n2;
    } else if (n2 instanceof Array) {
      return n2.map(fn2.boolean);
    }
  };
  fn2.byte = function(n2) {
    const nn = fn2.int(n2, 10);
    if (typeof nn === "number") {
      return (nn + 128) % 256 - 128;
    } else if (nn instanceof Array) {
      return nn.map(fn2.byte);
    }
  };
  fn2.char = function(n2) {
    if (typeof n2 === "number" && !isNaN(n2)) {
      return String.fromCharCode(n2);
    } else if (n2 instanceof Array) {
      return n2.map(fn2.char);
    } else if (typeof n2 === "string") {
      return fn2.char(parseInt(n2, 10));
    }
  };
  fn2.unchar = function(n2) {
    if (typeof n2 === "string" && n2.length === 1) {
      return n2.charCodeAt(0);
    } else if (n2 instanceof Array) {
      return n2.map(fn2.unchar);
    }
  };
  fn2.hex = function(n2, digits) {
    digits = digits === undefined || digits === null ? digits = 8 : digits;
    if (n2 instanceof Array) {
      return n2.map((n3) => fn2.hex(n3, digits));
    } else if (n2 === Infinity || n2 === -Infinity) {
      const c = n2 === Infinity ? "F" : "0";
      return c.repeat(digits);
    } else if (typeof n2 === "number") {
      if (n2 < 0) {
        n2 = 4294967295 + n2 + 1;
      }
      let hex = Number(n2).toString(16).toUpperCase();
      while (hex.length < digits) {
        hex = `0${hex}`;
      }
      if (hex.length >= digits) {
        hex = hex.substring(hex.length - digits, hex.length);
      }
      return hex;
    }
  };
  fn2.unhex = function(n2) {
    if (n2 instanceof Array) {
      return n2.map(fn2.unhex);
    } else {
      return parseInt(`0x${n2}`, 16);
    }
  };
}
if (typeof p5 !== "undefined") {
  conversion(p5, p5.prototype);
}

// node_modules/p5/dist/utilities/utility_functions.js
function utilityFunctions(p53, fn2) {
  fn2.nf = function(nums, left, right) {
    if (nums instanceof Array) {
      return nums.map((x) => doNf(x, left, right));
    } else {
      const typeOfFirst = Object.prototype.toString.call(nums);
      if (typeOfFirst === "[object Arguments]") {
        if (nums.length === 3) {
          return this.nf(nums[0], nums[1], nums[2]);
        } else if (nums.length === 2) {
          return this.nf(nums[0], nums[1]);
        } else {
          return this.nf(nums[0]);
        }
      } else {
        return doNf(nums, left, right);
      }
    }
  };
  function doNf(num, left, right) {
    let isNegative = num < 0;
    num = Math.abs(num);
    let [leftPart, rightPart] = num.toString().split(".");
    if (typeof right === "undefined") {
      leftPart = leftPart.padStart(left, "0");
      let result = rightPart ? leftPart + "." + rightPart : leftPart;
      return isNegative ? "-" + result : result;
    } else {
      let roundedOff = num.toFixed(right);
      [leftPart, rightPart] = roundedOff.toString().split(".");
      leftPart = leftPart.padStart(left, "0");
      let result = typeof rightPart === "undefined" ? leftPart : leftPart + "." + rightPart;
      return isNegative ? "-" + result : result;
    }
  }
  fn2.nfc = function(num, right) {
    if (num instanceof Array) {
      return num.map((x) => doNfc(x, right));
    } else {
      return doNfc(num, right);
    }
  };
  function doNfc(num, right) {
    num = num.toString();
    const dec = num.indexOf(".");
    let rem = dec !== -1 ? num.substring(dec) : "";
    let n2 = dec !== -1 ? num.substring(0, dec) : num;
    n2 = n2.toString().replace(/\B(?=(\d{3})+(?!\d))/g, ",");
    if (right === 0) {
      rem = "";
    } else if (typeof right !== "undefined") {
      if (right > rem.length) {
        rem += dec === -1 ? "." : "";
        const len = right - rem.length + 1;
        for (let i2 = 0;i2 < len; i2++) {
          rem += "0";
        }
      } else {
        rem = rem.substring(0, right + 1);
      }
    }
    return n2 + rem;
  }
  fn2.nfp = function(...args) {
    const nfRes = fn2.nf.apply(this, args);
    if (nfRes instanceof Array) {
      return nfRes.map(addNfp);
    } else {
      return addNfp(nfRes);
    }
  };
  function addNfp(num) {
    return parseFloat(num) > 0 ? `+${num.toString()}` : num.toString();
  }
  fn2.nfs = function(...args) {
    const nfRes = fn2.nf.apply(this, args);
    if (nfRes instanceof Array) {
      return nfRes.map(addNfs);
    } else {
      return addNfs(nfRes);
    }
  };
  function addNfs(num) {
    return parseFloat(num) >= 0 ? ` ${num.toString()}` : num.toString();
  }
  fn2.splitTokens = function(value, delims) {
    let d2;
    if (typeof delims !== "undefined") {
      let str = delims;
      const sqc = /\]/g.exec(str);
      let sqo = /\[/g.exec(str);
      if (sqo && sqc) {
        str = str.slice(0, sqc.index) + str.slice(sqc.index + 1);
        sqo = /\[/g.exec(str);
        str = str.slice(0, sqo.index) + str.slice(sqo.index + 1);
        d2 = new RegExp(`[\\[${str}\\]]`, "g");
      } else if (sqc) {
        str = str.slice(0, sqc.index) + str.slice(sqc.index + 1);
        d2 = new RegExp(`[${str}\\]]`, "g");
      } else if (sqo) {
        str = str.slice(0, sqo.index) + str.slice(sqo.index + 1);
        d2 = new RegExp(`[${str}\\[]`, "g");
      } else {
        d2 = new RegExp(`[${str}]`, "g");
      }
    } else {
      d2 = /\s/g;
    }
    return value.split(d2).filter((n2) => n2);
  };
  fn2.shuffle = function(arr2, bool) {
    const isView = ArrayBuffer && ArrayBuffer.isView && ArrayBuffer.isView(arr2);
    arr2 = bool || isView ? arr2 : arr2.slice();
    let rnd, tmp, idx = arr2.length;
    while (idx > 1) {
      rnd = this.random(0, 1) * idx | 0;
      tmp = arr2[--idx];
      arr2[idx] = arr2[rnd];
      arr2[rnd] = tmp;
    }
    return arr2;
  };
}
if (typeof p5 !== "undefined") {
  utilityFunctions(p5, p5.prototype);
}

// node_modules/p5/dist/utilities/time_date.js
function timeDate(p53, fn2) {
  fn2.day = function() {
    return new Date().getDate();
  };
  fn2.hour = function() {
    return new Date().getHours();
  };
  fn2.minute = function() {
    return new Date().getMinutes();
  };
  fn2.millis = function() {
    if (this._millisStart === -1) {
      return 0;
    } else {
      return window.performance.now() - this._millisStart;
    }
  };
  fn2.month = function() {
    return new Date().getMonth() + 1;
  };
  fn2.second = function() {
    return new Date().getSeconds();
  };
  fn2.year = function() {
    return new Date().getFullYear();
  };
}
if (typeof p5 !== "undefined") {
  timeDate(p5, p5.prototype);
}

// node_modules/p5/dist/utilities/index.js
function utilities(p53) {
  p53.registerAddon(conversion);
  p53.registerAddon(utilityFunctions);
  p53.registerAddon(timeDate);
}

// node_modules/p5/dist/webgl/interaction.js
function interaction(p53, fn2) {
  fn2.orbitControl = function(sensitivityX, sensitivityY, sensitivityZ, options2) {
    this._assert3d("orbitControl");
    const cam = this._renderer.states.curCamera;
    if (typeof sensitivityX === "undefined") {
      sensitivityX = 1;
    }
    if (typeof sensitivityY === "undefined") {
      sensitivityY = sensitivityX;
    }
    if (typeof sensitivityZ === "undefined") {
      sensitivityZ = 1;
    }
    if (typeof options2 !== "object") {
      options2 = {};
    }
    if (this.contextMenuDisabled !== true) {
      this.canvas.oncontextmenu = () => false;
      this.contextMenuDisabled = true;
    }
    if (this.wheelDefaultDisabled !== true) {
      this.canvas.onwheel = () => false;
      this.wheelDefaultDisabled = true;
    }
    const { disableTouchActions = true } = options2;
    if (this.touchActionsDisabled !== true && disableTouchActions) {
      this.canvas.style["touch-action"] = "none";
      this.touchActionsDisabled = true;
    }
    const { freeRotation = false } = options2;
    const movedTouches = [];
    this.touches.forEach((curTouch) => {
      this._renderer.prevTouches.forEach((prevTouch) => {
        if (curTouch.id === prevTouch.id) {
          const movedTouch = {
            x: curTouch.x,
            y: curTouch.y,
            px: prevTouch.x,
            py: prevTouch.y
          };
          movedTouches.push(movedTouch);
        }
      });
    });
    this._renderer.prevTouches = this.touches;
    let deltaRadius = 0;
    let deltaTheta = 0;
    let deltaPhi = 0;
    let moveDeltaX = 0;
    let moveDeltaY = 0;
    const damping = 0.85;
    const rotateAccelerationFactor = 0.6;
    const moveAccelerationFactor = 0.15;
    const mouseZoomScaleFactor = 0.01;
    const touchZoomScaleFactor = 0.0004;
    const scaleFactor = this.height < this.width ? this.height : this.width;
    let pointersInCanvas = false;
    if (movedTouches.length > 0) {
      pointersInCanvas = movedTouches[0].x > 0 && movedTouches[0].x < this.width && movedTouches[0].y > 0 && movedTouches[0].y < this.height;
      if (movedTouches.length === 1) {
        const t = movedTouches[0];
        deltaTheta = -sensitivityX * (t.x - t.px) / scaleFactor;
        deltaPhi = sensitivityY * (t.y - t.py) / scaleFactor;
      } else {
        const t0 = movedTouches[0];
        const t1 = movedTouches[1];
        const distWithTouches = Math.hypot(t0.x - t1.x, t0.y - t1.y);
        const prevDistWithTouches = Math.hypot(t0.px - t1.px, t0.py - t1.py);
        const changeDist = distWithTouches - prevDistWithTouches;
        deltaRadius = -changeDist * sensitivityZ * touchZoomScaleFactor;
        moveDeltaX = 0.5 * (t0.x + t1.x) - 0.5 * (t0.px + t1.px);
        moveDeltaY = 0.5 * (t0.y + t1.y) - 0.5 * (t0.py + t1.py);
      }
      if (this.touches.length > 0) {
        if (pointersInCanvas) {
          this._renderer.executeRotateAndMove = true;
          this._renderer.executeZoom = true;
        }
      } else {
        this._renderer.executeRotateAndMove = false;
        this._renderer.executeZoom = false;
      }
    } else {
      pointersInCanvas = this.mouseX > 0 && this.mouseX < this.width && (this.mouseY > 0 && this.mouseY < this.height);
      if (this._mouseWheelDeltaY !== 0) {
        deltaRadius = Math.sign(this._mouseWheelDeltaY) * sensitivityZ;
        deltaRadius *= mouseZoomScaleFactor;
        this._mouseWheelDeltaY = 0;
        if (pointersInCanvas)
          this._renderer.executeZoom = true;
      } else {
        this._renderer.executeZoom = false;
      }
      if (this.mouseIsPressed) {
        if (this.mouseButton.left) {
          deltaTheta = -sensitivityX * this.movedX / scaleFactor;
          deltaPhi = sensitivityY * this.movedY / scaleFactor;
        } else if (this.mouseButton.right) {
          moveDeltaX = this.movedX;
          moveDeltaY = this.movedY * cam.yScale;
        }
        if (pointersInCanvas)
          this._renderer.executeRotateAndMove = true;
      } else {
        this._renderer.executeRotateAndMove = false;
      }
    }
    if (deltaRadius !== 0 && this._renderer.executeZoom) {
      this._renderer.zoomVelocity += deltaRadius;
    }
    if (Math.abs(this._renderer.zoomVelocity) > 0.001) {
      if (freeRotation) {
        cam._orbitFree(0, 0, this._renderer.zoomVelocity);
      } else {
        cam._orbit(0, 0, this._renderer.zoomVelocity);
      }
      if (cam.projMatrix.mat4[15] !== 0) {
        cam.projMatrix.mat4[0] *= Math.pow(10, -this._renderer.zoomVelocity);
        cam.projMatrix.mat4[5] *= Math.pow(10, -this._renderer.zoomVelocity);
        this._renderer.states.setValue("uPMatrix", this._renderer.states.uPMatrix.clone());
        this._renderer.states.uPMatrix.mat4[0] = cam.projMatrix.mat4[0];
        this._renderer.states.uPMatrix.mat4[5] = cam.projMatrix.mat4[5];
      }
      this._renderer.zoomVelocity *= damping;
    } else {
      this._renderer.zoomVelocity = 0;
    }
    if ((deltaTheta !== 0 || deltaPhi !== 0) && this._renderer.executeRotateAndMove) {
      this._renderer.rotateVelocity.add(deltaTheta * rotateAccelerationFactor, deltaPhi * rotateAccelerationFactor);
    }
    if (this._renderer.rotateVelocity.magSq() > 0.000001) {
      if (freeRotation) {
        cam._orbitFree(-this._renderer.rotateVelocity.x, this._renderer.rotateVelocity.y, 0);
      } else {
        cam._orbit(this._renderer.rotateVelocity.x, this._renderer.rotateVelocity.y, 0);
      }
      this._renderer.rotateVelocity.mult(damping);
    } else {
      this._renderer.rotateVelocity.set(0, 0);
    }
    if ((moveDeltaX !== 0 || moveDeltaY !== 0) && this._renderer.executeRotateAndMove) {
      const ndcX = moveDeltaX * 2 / this.width;
      const ndcY = -moveDeltaY * 2 / this.height;
      this._renderer.moveVelocity.add(ndcX * moveAccelerationFactor, ndcY * moveAccelerationFactor);
    }
    if (this._renderer.moveVelocity.magSq() > 0.000001) {
      const local = cam._getLocalAxes();
      const diffX = cam.eyeX - cam.centerX;
      const diffY = cam.eyeY - cam.centerY;
      const diffZ = cam.eyeZ - cam.centerZ;
      const viewZ = Math.sqrt(diffX * diffX + diffY * diffY + diffZ * diffZ);
      let cv = new Vector(cam.centerX, cam.centerY, cam.centerZ);
      cv = cam.cameraMatrix.multiplyPoint(cv);
      cv = this._renderer.states.uPMatrix.multiplyAndNormalizePoint(cv);
      cv.x -= this._renderer.moveVelocity.x;
      cv.y -= this._renderer.moveVelocity.y;
      let dx, dy;
      const uP = this._renderer.states.uPMatrix.mat4;
      if (uP[15] === 0) {
        dx = (uP[8] + cv.x) / uP[0] * viewZ;
        dy = (uP[9] + cv.y) / uP[5] * viewZ;
      } else {
        dx = (cv.x - uP[12]) / uP[0];
        dy = (cv.y - uP[13]) / uP[5];
      }
      cam.setPosition(cam.eyeX + dx * local.x[0] + dy * local.y[0], cam.eyeY + dx * local.x[1] + dy * local.y[1], cam.eyeZ + dx * local.x[2] + dy * local.y[2]);
      this._renderer.moveVelocity.mult(damping);
    } else {
      this._renderer.moveVelocity.set(0, 0);
    }
    return this;
  };
  fn2.debugMode = function(...args) {
    this._assert3d("debugMode");
    for (let i2 = p53.lifecycleHooks.postdraw.length - 1;i2 >= 0; i2--) {
      if (p53.lifecycleHooks.postdraw[i2].toString() === this._grid().toString() || p53.lifecycleHooks.postdraw[i2].toString() === this._axesIcon().toString()) {
        p53.lifecycleHooks.postdraw.splice(i2, 1);
      }
    }
    if (args[0] === GRID) {
      p53.lifecycleHooks.postdraw.push(this._grid(args[1], args[2], args[3], args[4], args[5]));
    } else if (args[0] === AXES) {
      p53.lifecycleHooks.postdraw.push(this._axesIcon(args[1], args[2], args[3], args[4]));
    } else {
      p53.lifecycleHooks.postdraw.push(this._grid(args[0], args[1], args[2], args[3], args[4]));
      p53.lifecycleHooks.postdraw.push(this._axesIcon(args[5], args[6], args[7], args[8]));
    }
  };
  fn2.noDebugMode = function() {
    this._assert3d("noDebugMode");
    for (let i2 = p53.lifecycleHooks.postdraw.length - 1;i2 >= 0; i2--) {
      if (p53.lifecycleHooks.postdraw[i2].toString() === this._grid().toString() || p53.lifecycleHooks.postdraw[i2].toString() === this._axesIcon().toString()) {
        p53.lifecycleHooks.postdraw.splice(i2, 1);
      }
    }
  };
  fn2._grid = function(size, numDivs, xOff, yOff, zOff) {
    if (typeof size === "undefined") {
      size = this.width / 2;
    }
    if (typeof numDivs === "undefined") {
      numDivs = Math.round(size / 30) < 4 ? 4 : Math.round(size / 30);
    }
    if (typeof xOff === "undefined") {
      xOff = 0;
    }
    if (typeof yOff === "undefined") {
      yOff = 0;
    }
    if (typeof zOff === "undefined") {
      zOff = 0;
    }
    const spacing = size / numDivs;
    const halfSize = size / 2;
    return function() {
      this.push();
      this.stroke(this._renderer.states.curStrokeColor[0] * 255, this._renderer.states.curStrokeColor[1] * 255, this._renderer.states.curStrokeColor[2] * 255);
      this._renderer.states.setValue("uModelMatrix", this._renderer.states.uModelMatrix.clone());
      this._renderer.states.uModelMatrix.reset();
      for (let q = 0;q <= numDivs; q++) {
        this.beginShape(this.LINES);
        this.vertex(-halfSize + xOff, yOff, q * spacing - halfSize + zOff);
        this.vertex(+halfSize + xOff, yOff, q * spacing - halfSize + zOff);
        this.endShape();
      }
      for (let i2 = 0;i2 <= numDivs; i2++) {
        this.beginShape(this.LINES);
        this.vertex(i2 * spacing - halfSize + xOff, yOff, -halfSize + zOff);
        this.vertex(i2 * spacing - halfSize + xOff, yOff, +halfSize + zOff);
        this.endShape();
      }
      this.pop();
    };
  };
  fn2._axesIcon = function(size, xOff, yOff, zOff) {
    if (typeof size === "undefined") {
      size = this.width / 20 > 40 ? this.width / 20 : 40;
    }
    if (typeof xOff === "undefined") {
      xOff = -this.width / 4;
    }
    if (typeof yOff === "undefined") {
      yOff = xOff;
    }
    if (typeof zOff === "undefined") {
      zOff = xOff;
    }
    return () => {
      this.push();
      this._renderer.states.setValue("uModelMatrix", this._renderer.states.uModelMatrix.clone());
      this._renderer.states.uModelMatrix.reset();
      this.strokeWeight(2);
      this.stroke(255, 0, 0);
      this.beginShape(this.LINES);
      this.vertex(xOff, yOff, zOff);
      this.vertex(xOff + size, yOff, zOff);
      this.endShape();
      this.stroke(0, 255, 0);
      this.beginShape(this.LINES);
      this.vertex(xOff, yOff, zOff);
      this.vertex(xOff, yOff + size, zOff);
      this.endShape();
      this.stroke(0, 0, 255);
      this.beginShape(this.LINES);
      this.vertex(xOff, yOff, zOff);
      this.vertex(xOff, yOff, zOff + size);
      this.endShape();
      this.pop();
    };
  };
}
if (typeof p5 !== "undefined") {
  interaction(p5, p5.prototype);
}

// node_modules/p5/dist/webgl/loading.js
var import_file_saver10 = __toESM(require_FileSaver(), 1);
var import_omggif7 = __toESM(require_omggif(), 1);
var import_gifenc8 = __toESM(require_gifenc(), 1);
var import_libtess8 = __toESM(require_libtess_min(), 1);
async function fileExists(url2) {
  try {
    const response = await fetch(url2, { method: "HEAD" });
    return response.ok;
  } catch (error41) {
    return false;
  }
}
function loading2(p53, fn2) {
  fn2.loadModel = async function(path2, fileType, normalize, successCallback, failureCallback) {
    let flipU = false;
    let flipV = false;
    if (typeof fileType === "object") {
      normalize = fileType.normalize || false;
      successCallback = fileType.successCallback;
      failureCallback = fileType.failureCallback;
      fileType = fileType.fileType || fileType;
      flipU = fileType.flipU || false;
      flipV = fileType.flipV || false;
    } else {
      if (typeof arguments[arguments.length - 1] === "function") {
        if (typeof arguments[arguments.length - 2] === "function") {
          successCallback = arguments[arguments.length - 2];
          failureCallback = arguments[arguments.length - 1];
        } else {
          successCallback = arguments[arguments.length - 1];
        }
      }
      if (typeof fileType === "string") {
        if (typeof normalize !== "boolean")
          normalize = false;
      } else if (typeof fileType === "boolean") {
        normalize = fileType;
        fileType = path2.slice(-4);
      } else {
        fileType = path2.slice(-4);
        normalize = false;
      }
    }
    if (fileType.toLowerCase() !== ".obj" && fileType.toLowerCase() !== ".stl") {
      fileType = ".obj";
    }
    const model = new Geometry(undefined, undefined, undefined, this._renderer);
    model.gid = `${path2}|${normalize}`;
    async function getMaterials(lines) {
      const parsedMaterialPromises = [];
      for (let line of lines) {
        const mtllibMatch = line.match(/^mtllib (.+)/);
        if (mtllibMatch) {
          let mtlPath = "";
          const mtlFilename = mtllibMatch[1];
          const objPathParts = path2.split("/");
          if (objPathParts.length > 1) {
            objPathParts.pop();
            const objFolderPath = objPathParts.join("/");
            mtlPath = objFolderPath + "/" + mtlFilename;
          } else {
            mtlPath = mtlFilename;
          }
          parsedMaterialPromises.push(fileExists(mtlPath).then((exists) => {
            if (exists) {
              return parseMtl(mtlPath);
            } else {
              console.warn(`MTL file not found or error in parsing; proceeding without materials: ${mtlPath}`);
              return {};
            }
          }).catch((error41) => {
            console.warn(`Error loading MTL file: ${mtlPath}`, error41);
            return {};
          }));
        }
      }
      try {
        const parsedMaterials = await Promise.all(parsedMaterialPromises);
        const materials = Object.assign({}, ...parsedMaterials);
        return materials;
      } catch (error41) {
        return {};
      }
    }
    try {
      if (fileType.match(/\.stl$/i)) {
        const { data: data3 } = await request(path2, "arrayBuffer");
        parseSTL(model, data3);
        if (normalize) {
          model.normalize();
        }
        if (flipU) {
          model.flipU();
        }
        if (flipV) {
          model.flipV();
        }
        model._makeTriangleEdges();
        if (successCallback) {
          return successCallback(model);
        } else {
          return model;
        }
      } else if (fileType.match(/\.obj$/i)) {
        const { data: data3 } = await request(path2, "text");
        const lines = data3.split(`
`);
        const parsedMaterials = await getMaterials(lines);
        parseObj(model, lines, parsedMaterials);
        if (normalize) {
          model.normalize();
        }
        if (flipU) {
          model.flipU();
        }
        if (flipV) {
          model.flipV();
        }
        model._makeTriangleEdges();
        if (successCallback) {
          return successCallback(model);
        } else {
          return model;
        }
      }
    } catch (err) {
      p53._friendlyFileLoadError(3, path2);
      if (failureCallback) {
        return failureCallback(err);
      } else {
        throw err;
      }
    }
  };
  async function parseMtl(mtlPath) {
    let currentMaterial = null;
    let materials = {};
    const { data: data3 } = await request(mtlPath, "text");
    const lines = data3.split(`
`);
    for (let line = 0;line < lines.length; ++line) {
      const tokens = lines[line].trim().split(/\s+/);
      if (tokens[0] === "newmtl") {
        const materialName = tokens[1];
        currentMaterial = materialName;
        materials[currentMaterial] = {};
      } else if (tokens[0] === "Kd") {
        materials[currentMaterial].diffuseColor = [
          parseFloat(tokens[1]),
          parseFloat(tokens[2]),
          parseFloat(tokens[3])
        ];
      } else if (tokens[0] === "Ka") {
        materials[currentMaterial].ambientColor = [
          parseFloat(tokens[1]),
          parseFloat(tokens[2]),
          parseFloat(tokens[3])
        ];
      } else if (tokens[0] === "Ks") {
        materials[currentMaterial].specularColor = [
          parseFloat(tokens[1]),
          parseFloat(tokens[2]),
          parseFloat(tokens[3])
        ];
      } else if (tokens[0] === "map_Kd") {
        materials[currentMaterial].texturePath = tokens[1];
      }
    }
    return materials;
  }
  function parseObj(model, lines, materials = {}) {
    const loadedVerts = {
      v: [],
      vt: [],
      vn: []
    };
    const usedVerts = {};
    let currentMaterial = null;
    let hasColoredVertices = false;
    let hasColorlessVertices = false;
    for (let line = 0;line < lines.length; ++line) {
      const tokens = lines[line].trim().split(/\b\s+/);
      if (tokens.length > 0) {
        if (tokens[0] === "usemtl") {
          currentMaterial = tokens[1];
        } else if (tokens[0] === "v" || tokens[0] === "vn") {
          const vertex2 = new Vector(parseFloat(tokens[1]), parseFloat(tokens[2]), parseFloat(tokens[3]));
          loadedVerts[tokens[0]].push(vertex2);
        } else if (tokens[0] === "vt") {
          const texVertex = [parseFloat(tokens[1]), 1 - parseFloat(tokens[2])];
          loadedVerts[tokens[0]].push(texVertex);
        } else if (tokens[0] === "f") {
          for (let tri = 3;tri < tokens.length; ++tri) {
            const face = [];
            const vertexTokens = [1, tri - 1, tri];
            for (let tokenInd = 0;tokenInd < vertexTokens.length; ++tokenInd) {
              const vertString = tokens[vertexTokens[tokenInd]];
              let vertParts = vertString.split("/");
              for (let i2 = 0;i2 < vertParts.length; i2++) {
                vertParts[i2] = parseInt(vertParts[i2]) - 1;
              }
              if (!usedVerts[vertString]) {
                usedVerts[vertString] = {};
              }
              if (usedVerts[vertString][currentMaterial] === undefined) {
                const vertIndex = model.vertices.length;
                model.vertices.push(loadedVerts.v[vertParts[0]].copy());
                model.uvs.push(loadedVerts.vt[vertParts[1]] ? loadedVerts.vt[vertParts[1]].slice() : [0, 0]);
                model.vertexNormals.push(loadedVerts.vn[vertParts[2]] ? loadedVerts.vn[vertParts[2]].copy() : new Vector);
                usedVerts[vertString][currentMaterial] = vertIndex;
                face.push(vertIndex);
                if (currentMaterial && materials[currentMaterial] && materials[currentMaterial].diffuseColor) {
                  hasColoredVertices = true;
                  const materialDiffuseColor = materials[currentMaterial].diffuseColor;
                  model.vertexColors.push(materialDiffuseColor[0]);
                  model.vertexColors.push(materialDiffuseColor[1]);
                  model.vertexColors.push(materialDiffuseColor[2]);
                  model.vertexColors.push(1);
                } else {
                  hasColorlessVertices = true;
                }
              } else {
                face.push(usedVerts[vertString][currentMaterial]);
              }
            }
            if (face[0] !== face[1] && face[0] !== face[2] && face[1] !== face[2]) {
              model.faces.push(face);
            }
          }
        }
      }
    }
    if (model.vertexNormals.length === 0) {
      model.computeNormals();
    }
    if (hasColoredVertices === hasColorlessVertices) {
      throw new Error("Model coloring is inconsistent. Either all vertices should have colors or none should.");
    }
    return model;
  }
  function parseSTL(model, buffer) {
    if (isBinary(buffer)) {
      parseBinarySTL(model, buffer);
    } else {
      const reader = new DataView(buffer);
      if (!("TextDecoder" in window)) {
        console.warn("Sorry, ASCII STL loading only works in browsers that support TextDecoder (https://caniuse.com/#feat=textencoder)");
        return model;
      }
      const decoder = new TextDecoder("utf-8");
      const lines = decoder.decode(reader);
      const lineArray = lines.split(`
`);
      parseASCIISTL(model, lineArray);
    }
    return model;
  }
  function isBinary(data3) {
    const reader = new DataView(data3);
    const solid = [115, 111, 108, 105, 100];
    for (let off = 0;off < 5; off++) {
      if (matchDataViewAt(solid, reader, off))
        return false;
    }
    return true;
  }
  function matchDataViewAt(query, reader, offset2) {
    for (let i2 = 0, il = query.length;i2 < il; i2++) {
      if (query[i2] !== reader.getUint8(offset2 + i2, false))
        return false;
    }
    return true;
  }
  function parseBinarySTL(model, buffer) {
    const reader = new DataView(buffer);
    const faces = reader.getUint32(80, true);
    let r, g2, b2, hasColors = false, colors;
    let defaultR, defaultG, defaultB;
    for (let index = 0;index < 80 - 10; index++) {
      if (reader.getUint32(index, false) === 1129270351 && reader.getUint8(index + 4) === 82 && reader.getUint8(index + 5) === 61) {
        hasColors = true;
        colors = [];
        defaultR = reader.getUint8(index + 6) / 255;
        defaultG = reader.getUint8(index + 7) / 255;
        defaultB = reader.getUint8(index + 8) / 255;
      }
    }
    const dataOffset = 84;
    const faceLength = 12 * 4 + 2;
    for (let face = 0;face < faces; face++) {
      const start = dataOffset + face * faceLength;
      const normalX = reader.getFloat32(start, true);
      const normalY = reader.getFloat32(start + 4, true);
      const normalZ = reader.getFloat32(start + 8, true);
      if (hasColors) {
        const packedColor = reader.getUint16(start + 48, true);
        if ((packedColor & 32768) === 0) {
          r = (packedColor & 31) / 31;
          g2 = (packedColor >> 5 & 31) / 31;
          b2 = (packedColor >> 10 & 31) / 31;
        } else {
          r = defaultR;
          g2 = defaultG;
          b2 = defaultB;
        }
      }
      const newNormal = new Vector(normalX, normalY, normalZ);
      for (let i2 = 1;i2 <= 3; i2++) {
        const vertexstart = start + i2 * 12;
        const newVertex = new Vector(reader.getFloat32(vertexstart, true), reader.getFloat32(vertexstart + 4, true), reader.getFloat32(vertexstart + 8, true));
        model.vertices.push(newVertex);
        model.vertexNormals.push(newNormal);
        if (hasColors) {
          colors.push(r, g2, b2);
        }
      }
      model.faces.push([3 * face, 3 * face + 1, 3 * face + 2]);
      model.uvs.push([0, 0], [0, 0], [0, 0]);
    }
    return model;
  }
  function parseASCIISTL(model, lines) {
    let state = "";
    let curVertexIndex = [];
    let newNormal, newVertex;
    for (let iterator = 0;iterator < lines.length; ++iterator) {
      const line = lines[iterator].trim();
      const parts = line.split(" ");
      for (let partsiterator = 0;partsiterator < parts.length; ++partsiterator) {
        if (parts[partsiterator] === "") {
          parts.splice(partsiterator, 1);
        }
      }
      if (parts.length === 0) {
        continue;
      }
      switch (state) {
        case "":
          if (parts[0] !== "solid") {
            console.error(line);
            console.error(`Invalid state "${parts[0]}", should be "solid"`);
            return;
          } else {
            state = "solid";
          }
          break;
        case "solid":
          if (parts[0] !== "facet" || parts[1] !== "normal") {
            console.error(line);
            console.error(`Invalid state "${parts[0]}", should be "facet normal"`);
            return;
          } else {
            newNormal = new Vector(parseFloat(parts[2]), parseFloat(parts[3]), parseFloat(parts[4]));
            model.vertexNormals.push(newNormal, newNormal, newNormal);
            state = "facet normal";
          }
          break;
        case "facet normal":
          if (parts[0] !== "outer" || parts[1] !== "loop") {
            console.error(line);
            console.error(`Invalid state "${parts[0]}", should be "outer loop"`);
            return;
          } else {
            state = "vertex";
          }
          break;
        case "vertex":
          if (parts[0] === "vertex") {
            newVertex = new Vector(parseFloat(parts[1]), parseFloat(parts[2]), parseFloat(parts[3]));
            model.vertices.push(newVertex);
            model.uvs.push([0, 0]);
            curVertexIndex.push(model.vertices.indexOf(newVertex));
          } else if (parts[0] === "endloop") {
            model.faces.push(curVertexIndex);
            curVertexIndex = [];
            state = "endloop";
          } else {
            console.error(line);
            console.error(`Invalid state "${parts[0]}", should be "vertex" or "endloop"`);
            return;
          }
          break;
        case "endloop":
          if (parts[0] !== "endfacet") {
            console.error(line);
            console.error(`Invalid state "${parts[0]}", should be "endfacet"`);
            return;
          } else {
            state = "endfacet";
          }
          break;
        case "endfacet":
          if (parts[0] === "endsolid")
            ;
          else if (parts[0] === "facet" && parts[1] === "normal") {
            newNormal = new Vector(parseFloat(parts[2]), parseFloat(parts[3]), parseFloat(parts[4]));
            model.vertexNormals.push(newNormal, newNormal, newNormal);
            state = "facet normal";
          } else {
            console.error(line);
            console.error(`Invalid state "${parts[0]}", should be "endsolid" or "facet normal"`);
            return;
          }
          break;
        default:
          console.error(`Invalid state "${state}"`);
          break;
      }
    }
    return model;
  }
  fn2.model = function(model, count = 1) {
    this._assert3d("model");
    this._renderer.model(model, count);
  };
  let modelCounter = 0;
  fn2.createModel = function(modelString, fileType = " ", options2) {
    let normalize = false;
    let successCallback;
    let failureCallback;
    let flipU = false;
    let flipV = false;
    if (options2 && typeof options2 === "object") {
      normalize = options2.normalize || false;
      successCallback = options2.successCallback;
      failureCallback = options2.failureCallback;
      flipU = options2.flipU || false;
      flipV = options2.flipV || false;
    } else if (typeof options2 === "boolean") {
      normalize = options2;
      successCallback = arguments[3];
      failureCallback = arguments[4];
    } else {
      successCallback = typeof arguments[2] === "function" ? arguments[2] : undefined;
      failureCallback = arguments[3];
    }
    const model = new p53.Geometry;
    model.gid = `${fileType}|${normalize}|${modelCounter++}`;
    if (fileType.match(/\.stl$/i)) {
      try {
        let uint8array = new TextEncoder().encode(modelString);
        let arrayBuffer = uint8array.buffer;
        parseSTL(model, arrayBuffer);
      } catch (error41) {
        if (failureCallback) {
          failureCallback(error41);
        } else {
          p53._friendlyError("Error during parsing: " + error41.message);
        }
        return;
      }
    } else if (fileType.match(/\.obj$/i)) {
      try {
        const lines = modelString.split(`
`);
        parseObj(model, lines);
      } catch (error41) {
        if (failureCallback) {
          failureCallback(error41);
        } else {
          p53._friendlyError("Error during parsing: " + error41.message);
        }
        return;
      }
    } else {
      p53._friendlyFileLoadError(3, modelString);
      if (failureCallback) {
        failureCallback();
      } else {
        p53._friendlyError("Sorry, the file type is invalid. Only OBJ and STL files are supported.");
      }
    }
    if (normalize) {
      model.normalize();
    }
    if (flipU) {
      model.flipU();
    }
    if (flipV) {
      model.flipV();
    }
    model._makeTriangleEdges();
    if (typeof successCallback === "function") {
      successCallback(model);
    }
    return model;
  };
}
if (typeof p5 !== "undefined") {
  loading2(p5, p5.prototype);
}

// node_modules/p5/dist/type/textCore.js
var import_file_saver11 = __toESM(require_FileSaver(), 1);
var textCoreConstants = {
  IDEOGRAPHIC: "ideographic",
  RIGHT_TO_LEFT: "rtl",
  LEFT_TO_RIGHT: "ltr",
  _CTX_MIDDLE: "middle",
  _TEXT_BOUNDS: "_textBoundsSingle",
  _FONT_BOUNDS: "_fontBoundsSingle",
  HANGING: "hanging",
  START: "start",
  END: "end"
};
function textCore(p53, fn2) {
  const LeadingScale = 1.275;
  const DefaultFill = "#000000";
  const LinebreakRe = /\r?\n/g;
  const CommaDelimRe = /,\s+/;
  const QuotedRe = /^".*"$/;
  const TabsRe = /\t/g;
  const FontVariationSettings = "fontVariationSettings";
  const VariableAxes = ["wght", "wdth", "ital", "slnt", "opsz"];
  const VariableAxesRe = new RegExp(`(?:${VariableAxes.join("|")})`);
  const textFunctions = [
    "text",
    "textAlign",
    "textAscent",
    "textDescent",
    "textLeading",
    "textMode",
    "textFont",
    "textSize",
    "textStyle",
    "textWidth",
    "textWrap",
    "textBounds",
    "textDirection",
    "textProperty",
    "textProperties",
    "fontBounds",
    "fontWidth",
    "fontAscent",
    "fontDescent",
    "textWeight"
  ];
  textFunctions.forEach((func) => {
    fn2[func] = function(...args) {
      if (!(func in Renderer.prototype)) {
        throw Error(`Renderer2D.prototype.${func} is not defined.`);
      }
      return this._renderer[func](...args);
    };
    p53.Graphics.prototype[func] = function(...args) {
      return this._renderer[func](...args);
    };
  });
  const RendererTextProps = {
    textAlign: { default: fn2.LEFT, type: "Context2d" },
    textBaseline: { default: fn2.BASELINE, type: "Context2d" },
    textFont: { default: { family: "sans-serif" } },
    textLeading: { default: 15 },
    textSize: { default: 12 },
    textWrap: { default: fn2.WORD },
    fontStretch: { default: fn2.NORMAL, isShorthand: true },
    fontWeight: { default: fn2.NORMAL, isShorthand: true },
    lineHeight: { default: fn2.NORMAL, isShorthand: true },
    fontVariant: { default: fn2.NORMAL, isShorthand: true },
    fontStyle: { default: fn2.NORMAL, isShorthand: true },
    direction: { default: "inherit" }
  };
  const ContextTextProps = ["font", "direction", "fontKerning", "fontStretch", "fontVariantCaps", "letterSpacing", "textAlign", "textBaseline", "textRendering", "wordSpacing"];
  const ShorthandFontProps = Object.keys(RendererTextProps).filter((p2) => RendererTextProps[p2].isShorthand);
  const FontStretchKeys = ["ultra-condensed", "extra-condensed", "condensed", "semi-condensed", "normal", "semi-expanded", "expanded", "extra-expanded", "ultra-expanded"];
  let contextQueue, cachedDiv;
  Renderer.prototype.text = function(str, x, y, width, height) {
    let setBaseline = this.textDrawingContext().textBaseline;
    ({ x, y, width, height } = this._handleRectMode(x, y, width, height));
    let lines = this._processLines(str, width, height);
    lines = this._positionLines(x, y, width, height, lines);
    lines.forEach((line) => this._renderText(line.text, line.x, line.y));
    this.textDrawingContext().textBaseline = setBaseline;
  };
  Renderer.prototype.textBounds = function(str, x, y, width, height) {
    return this._computeBounds(textCoreConstants._TEXT_BOUNDS, str, x, y, width, height).bounds;
  };
  Renderer.prototype.fontBounds = function(str, x, y, width, height) {
    return this._computeBounds(textCoreConstants._FONT_BOUNDS, str, x, y, width, height).bounds;
  };
  Renderer.prototype.textWidth = function(theText) {
    let lines = this._processLines(theText);
    return Math.max(...lines.map((l) => this._textWidthSingle(l)));
  };
  Renderer.prototype.fontWidth = function(theText) {
    let lines = this._processLines(theText);
    return Math.max(...lines.map((l) => this._fontWidthSingle(l)));
  };
  Renderer.prototype.textAscent = function(txt = "") {
    if (!txt.length)
      return this.fontAscent();
    return this.textDrawingContext().measureText(txt).actualBoundingBoxAscent;
  };
  Renderer.prototype.fontAscent = function() {
    return this.textDrawingContext().measureText("_").fontBoundingBoxAscent;
  };
  Renderer.prototype.textDescent = function(txt = "") {
    if (!txt.length)
      return this.fontDescent();
    return this.textDrawingContext().measureText(txt).actualBoundingBoxDescent;
  };
  Renderer.prototype.fontDescent = function() {
    return this.textDrawingContext().measureText("_").fontBoundingBoxDescent;
  };
  Renderer.prototype.textAlign = function(h, v) {
    if (typeof h !== "undefined") {
      this.states.setValue("textAlign", h);
      if (typeof v !== "undefined") {
        if (v === fn2.CENTER) {
          v = textCoreConstants._CTX_MIDDLE;
        }
        this.states.setValue("textBaseline", v);
      }
      return this._applyTextProperties();
    }
    return {
      horizontal: this.states.textAlign,
      vertical: this.states.textBaseline
    };
  };
  Renderer.prototype._currentTextFont = function() {
    return this.states.textFont.font || this.states.textFont.family;
  };
  Renderer.prototype.textFont = function(font, size, options2) {
    if (arguments.length === 0) {
      return this._currentTextFont();
    }
    let family = font;
    if (font instanceof p53.Font) {
      family = font.face.family;
    } else if (font.data instanceof Uint8Array) {
      family = font.name.fontFamily;
      if (font.name?.fontSubfamily) {
        family += "-" + font.name.fontSubfamily;
      }
    } else if (typeof font === "string") {
      if (typeof size === "undefined" && /[.0-9]+(%|em|p[xt])/.test(family)) {
        ({ family, size } = this._directSetFontString(family));
      }
    }
    if (typeof family !== "string")
      throw Error("null font in textFont()");
    if (arguments.length === 2 && typeof size === "object") {
      options2 = size;
      size = undefined;
    }
    this.states.setValue("textFont", { font, family, size });
    if (typeof size !== "undefined") {
      this._setTextSize(size);
    }
    if (typeof options2 === "object") {
      this.textProperties(options2);
    }
    return this._applyTextProperties();
  };
  Renderer.prototype._directSetFontString = function(font, debug = 0) {
    if (debug)
      console.log('_directSetFontString"' + font + '"');
    let defaults2 = ShorthandFontProps.reduce((props, p2) => {
      props[p2] = RendererTextProps[p2].default;
      return props;
    }, {});
    let el = this._cachedDiv(defaults2);
    el.style.font = font;
    let style = getComputedStyle(el);
    ShorthandFontProps.forEach((prop) => {
      this.states[prop] = style[prop];
      if (debug)
        console.log("  this.states." + prop + '="' + style[prop] + '"');
    });
    return { family: style.fontFamily, size: style.fontSize };
  };
  Renderer.prototype.textLeading = function(leading) {
    if (typeof leading === "number") {
      this.states.setValue("leadingSet", true);
      this.states.setValue("textLeading", leading);
      return this._applyTextProperties();
    }
    return this.states.textLeading;
  };
  Renderer.prototype.textWeight = function(weight) {
    if (typeof weight === "number") {
      this.states.setValue("fontWeight", weight);
      this._applyTextProperties();
      if (!p53.prototype._isSafari()) {
        this._setCanvasStyleProperty("font-variation-settings", `"wght" ${weight}`);
      }
      return;
    }
    return this.states.fontWeight;
  };
  Renderer.prototype.textSize = function(size) {
    if (typeof size !== "undefined") {
      this._setTextSize(size);
      return this._applyTextProperties();
    }
    return this.states.textSize;
  };
  Renderer.prototype.textStyle = function(style) {
    if (typeof style !== "undefined") {
      this.states.setValue("fontStyle", style);
      return this._applyTextProperties();
    }
    return this.states.fontStyle;
  };
  Renderer.prototype.textWrap = function(wrapStyle) {
    if (wrapStyle === fn2.WORD || wrapStyle === fn2.CHAR) {
      this.states.setValue("textWrap", wrapStyle);
      return this._pInst;
    }
    return this.states.textWrap;
  };
  Renderer.prototype.textDirection = function(direction) {
    if (typeof direction !== "undefined") {
      this.states.setValue("direction", direction);
      return this._applyTextProperties();
    }
    return this.states.direction;
  };
  Renderer.prototype.textProperty = function(prop, value, opts) {
    let modified = false, debug = opts?.debug || false;
    if (typeof value === "undefined") {
      let props = this.textProperties();
      if (prop in props)
        return props[prop];
      throw Error('Unknown text option "' + prop + '"');
    }
    if (prop in this.states && this.states[prop] !== value) {
      this.states[prop] = value;
      modified = true;
      if (debug) {
        console.log("this.states." + prop + '="' + options[prop] + '"');
      }
    } else if (prop in this.textDrawingContext()) {
      this._setContextProperty(prop, value, debug);
      modified = true;
    } else if (prop in this.textCanvas().style) {
      this._setCanvasStyleProperty(prop, value, debug);
      modified = true;
    } else {
      console.warn('Ignoring unknown text option: "' + prop + `"
`);
    }
    return modified ? this._applyTextProperties() : this._pInst;
  };
  Renderer.prototype.textProperties = function(properties) {
    if (typeof properties !== "undefined") {
      Object.keys(properties).forEach((opt) => {
        this.textProperty(opt, properties[opt]);
      });
      return this._pInst;
    }
    let context = this.textDrawingContext();
    properties = ContextTextProps.reduce((props, p2) => {
      props[p2] = context[p2];
      return props;
    }, {});
    Object.keys(RendererTextProps).forEach((p2) => {
      if (RendererTextProps[p2]?.type === "Context2d") {
        properties[p2] = context[p2];
      } else {
        if (p2 === "textFont") {
          let current2 = this._currentTextFont();
          if (typeof current2 === "object" && "_pInst" in current2) {
            current2 = Object.assign({}, current2);
            delete current2._pInst;
          }
          properties[p2] = current2;
        } else {
          properties[p2] = this.states[p2];
        }
      }
    });
    return properties;
  };
  Renderer.prototype.textMode = function() {};
  Renderer.prototype._currentTextFont = function() {
    return this.states.textFont.font || this.states.textFont.family;
  };
  Renderer.prototype._computeBounds = function(type2, str, x, y, width, height, opts) {
    let context = this.textDrawingContext();
    let setBaseline = context.textBaseline;
    let { textLeading, textAlign } = this.states;
    ({ width, height } = this._rectModeAdjust(x, y, width, height));
    let lines = this._processLines(str, width, height);
    let boxes = lines.map((line, i2) => this[type2].bind(this)(line, x, y + i2 * textLeading));
    if (lines.length > 1) {
      const maxWidth = boxes.reduce((m, b2) => Math.max(m, b2.w || 0), 0);
      boxes.forEach((bb) => {
        const w = width ?? maxWidth;
        bb.x += p53.Renderer2D.prototype._xAlignOffset.call(this, textAlign, w);
      });
    }
    if (typeof height !== "undefined") {
      p53.Renderer2D.prototype._yAlignOffset.call(this, boxes, height);
    }
    let bounds = boxes[0];
    if (lines.length > 1) {
      bounds = this._aggregateBounds(boxes);
      if (!opts?.ignoreRectMode) {
        this._rectModeAlign(bounds, width || 0, height || 0);
      }
    }
    context.textBaseline = setBaseline;
    return { bounds, lines };
  };
  Renderer.prototype._rectModeAdjust = function(x, y, width, height) {
    if (typeof width !== "undefined") {
      switch (this.states.rectMode) {
        case fn2.CENTER:
          break;
        case fn2.CORNERS:
          width -= x;
          height -= y;
          break;
        case fn2.RADIUS:
          width *= 2;
          height *= 2;
          break;
      }
    }
    return { x, y, width, height };
  };
  Renderer.prototype._setCanvasStyleProperty = function(opt, val, debug) {
    let value = val.toString();
    if (debug)
      console.log("canvas.style." + opt + '="' + value + '"');
    if (opt === FontVariationSettings) {
      this._handleFontVariationSettings(value);
    }
    this.textCanvas().style[opt] = value;
    if (this.textCanvas().style[opt] !== value)
      ;
  };
  Renderer.prototype._handleFontVariationSettings = function(value, debug = false) {
    if (typeof value === "object") {
      value = Object.keys(value).map((k) => k + " " + value[k]).join(", ");
    }
    let values = value.split(CommaDelimRe);
    values.forEach((v) => {
      v = v.replace(/["']/g, "");
      let matches = VariableAxesRe.exec(v);
      if (matches && matches.length) {
        let axis = matches[0];
        let val = parseFloat(parseFloat(v.replace(axis, "").trim()).toFixed(3));
        switch (axis) {
          case "wght":
            if (debug)
              console.log("setting font-weight=" + val);
            if (this.states.fontWeight !== val)
              this.textWeight(val);
            return val;
          case "wdth":
            break;
          case "ital":
            if (debug)
              console.log("setting font-style=" + (val ? "italic" : "normal"));
            break;
          case "slnt":
            if (debug)
              console.log("setting font-style=" + (val ? "oblique" : "normal"));
            break;
          case "opsz":
            if (debug)
              console.log("setting font-optical-size=" + val);
            break;
        }
      }
    });
  };
  Renderer.prototype._setContextProperty = function(prop, val, debug = false) {
    if (this.textDrawingContext()[prop] === val) {
      return this._pInst;
    }
    (contextQueue ??= []).push([prop, val]);
    if (debug)
      console.log("queued context2d." + prop + '="' + val + '"');
  };
  Renderer.prototype._handleRectMode = function(x, y, width, height) {
    let rectMode = this.states.rectMode;
    if (typeof width !== "undefined") {
      switch (rectMode) {
        case fn2.RADIUS:
          width *= 2;
          x -= width / 2;
          if (typeof height !== "undefined") {
            height *= 2;
            y -= height / 2;
          }
          break;
        case fn2.CENTER:
          x -= width / 2;
          if (typeof height !== "undefined") {
            y -= height / 2;
          }
          break;
        case fn2.CORNERS:
          width -= x;
          if (typeof height !== "undefined") {
            height -= y;
          }
          break;
      }
    }
    return { x, y, width, height };
  };
  Renderer.prototype._fontSizePx = function(theSize, { family } = this.states.textFont) {
    const isNumString = (num) => !isNaN(num) && num.trim() !== "";
    if (isNumString(theSize)) {
      return parseFloat(theSize);
    }
    let ele = this._cachedDiv({ fontSize: theSize });
    ele.style.fontSize = theSize;
    ele.style.fontFamily = family;
    let fontSizeStr = getComputedStyle(ele).fontSize;
    let fontSize = parseFloat(fontSizeStr);
    if (typeof fontSize !== "number") {
      throw Error("textSize: invalid font-size");
    }
    return fontSize;
  };
  Renderer.prototype._cachedDiv = function(props) {
    if (typeof cachedDiv === "undefined") {
      let ele = document.createElement("div");
      ele.ariaHidden = "true";
      ele.style.display = "none";
      Object.entries(props).forEach(([prop, val]) => {
        ele.style[prop] = val;
      });
      this.textCanvas().appendChild(ele);
      cachedDiv = ele;
    }
    return cachedDiv;
  };
  Renderer.prototype._aggregateBounds = function(bboxes) {
    let minX = Math.min(...bboxes.map((b2) => b2.x));
    let minY = Math.min(...bboxes.map((b2) => b2.y));
    let maxY = Math.max(...bboxes.map((b2) => b2.y + b2.h));
    let maxX = Math.max(...bboxes.map((b2) => b2.x + b2.w));
    return { x: minX, y: minY, w: maxX - minX, h: maxY - minY };
  };
  Renderer.prototype._processLines = function(str, width, height) {
    if (typeof width !== "undefined") {
      let drawingContext = this.textDrawingContext();
      if (drawingContext.textBaseline === fn2.BASELINE) {
        this.drawingContext.textBaseline = fn2.TOP;
      }
    }
    let lines = this._splitOnBreaks(str.toString());
    let hasLineBreaks = lines.length > 1;
    let hasWidth = typeof width !== "undefined";
    let exceedsWidth = hasWidth && lines.some((l) => this._textWidthSingle(l) > width);
    let { textLeading: leading, textWrap } = this.states;
    if (hasLineBreaks || exceedsWidth) {
      if (hasWidth)
        lines = this._lineate(textWrap, lines, width);
    }
    if (hasWidth && typeof height !== "undefined") {
      if (typeof leading === "undefined") {
        throw Error("leading is required if height is specified");
      }
      for (let i2 = 0;i2 < lines.length; i2++) {
        let lh = leading * (i2 + 1);
        if (lh > height) {
          lines = lines.slice(0, i2);
          break;
        }
      }
    }
    return lines;
  };
  Renderer.prototype._xAlignOffset = function(textAlign, width) {
    switch (textAlign) {
      case fn2.LEFT:
        return 0;
      case fn2.CENTER:
        return width / 2;
      case fn2.RIGHT:
        return width;
      case textCoreConstants.START:
        return 0;
      case textCoreConstants.END:
        throw new Error("textBounds: END not yet supported for textAlign");
      default:
        return 0;
    }
  };
  Renderer.prototype._rectModeAlign = function(bb, width, height) {
    if (typeof width !== "undefined") {
      switch (this.states.rectMode) {
        case fn2.CENTER:
          bb.x -= (width - bb.w) / 2;
          bb.y -= (height - bb.h) / 2;
          break;
        case fn2.CORNERS:
          bb.w += bb.x;
          bb.h += bb.y;
          break;
        case fn2.RADIUS:
          bb.x -= (width - bb.w) / 2;
          bb.y -= (height - bb.h) / 2;
          bb.w /= 2;
          bb.h /= 2;
          break;
      }
      return bb;
    }
  };
  Renderer.prototype._rectModeAlignRevert = function(bb, width, height) {
    if (typeof width !== "undefined") {
      switch (this.states.rectMode) {
        case fn2.CENTER:
          bb.x += (width - bb.w) / 2;
          bb.y += (height - bb.h) / 2;
          break;
        case fn2.CORNERS:
          bb.w -= bb.x;
          bb.h -= bb.y;
          break;
        case fn2.RADIUS:
          bb.x += (width - bb.w) / 2;
          bb.y += (height - bb.h) / 2;
          bb.w *= 2;
          bb.h *= 2;
          break;
      }
      return bb;
    }
  };
  Renderer.prototype._textWidthSingle = function(s) {
    let metrics = this.textDrawingContext().measureText(s);
    let abl = metrics.actualBoundingBoxLeft;
    let abr = metrics.actualBoundingBoxRight;
    return abr + abl;
  };
  Renderer.prototype._fontWidthSingle = function(s) {
    return this.textDrawingContext().measureText(s).width;
  };
  Renderer.prototype._textBoundsSingle = function(s, x = 0, y = 0) {
    let metrics = this.textDrawingContext().measureText(s);
    let asc = metrics.actualBoundingBoxAscent;
    let desc = metrics.actualBoundingBoxDescent;
    let abl = metrics.actualBoundingBoxLeft;
    let abr = metrics.actualBoundingBoxRight;
    return { x: x - abl, y: y - asc, w: abr + abl, h: asc + desc };
  };
  Renderer.prototype._fontBoundsSingle = function(s, x = 0, y = 0) {
    let metrics = this.textDrawingContext().measureText(s);
    let asc = metrics.fontBoundingBoxAscent;
    let desc = metrics.fontBoundingBoxDescent;
    x -= this._xAlignOffset(this.states.textAlign, metrics.width);
    return { x, y: y - asc, w: metrics.width, h: asc + desc };
  };
  Renderer.prototype._setTextSize = function(theSize) {
    if (typeof theSize === "string") {
      theSize = this._fontSizePx(theSize);
    }
    if (typeof theSize === "number") {
      if (this.states.textSize !== theSize) {
        this.states.setValue("textSize", theSize);
        if (!this.states.leadingSet) {
          this.states.setValue("textLeading", this.states.textSize * LeadingScale);
        }
        return true;
      }
    } else {
      console.warn("textSize: invalid size: " + theSize);
    }
    return false;
  };
  Renderer.prototype._lineate = function(textWrap, lines, maxWidth = Infinity, opts = {}) {
    let splitter = opts.splitChar ?? (textWrap === fn2.WORD ? " " : "");
    let line, testLine, testWidth, words, newLines = [];
    for (let lidx = 0;lidx < lines.length; lidx++) {
      line = "";
      words = lines[lidx].split(splitter);
      for (let widx = 0;widx < words.length; widx++) {
        testLine = `${line + words[widx]}` + splitter;
        testWidth = this._textWidthSingle(testLine);
        if (line.length > 0 && testWidth > maxWidth) {
          newLines.push(line.trim());
          line = `${words[widx]}` + splitter;
        } else {
          line = testLine;
        }
      }
      newLines.push(line.trim());
    }
    return newLines;
  };
  Renderer.prototype._splitOnBreaks = function(s) {
    if (!s || s.length === 0)
      return [""];
    return s.replace(TabsRe, "  ").split(LinebreakRe);
  };
  Renderer.prototype._parseFontFamily = function(familyStr) {
    let parts = familyStr.split(CommaDelimRe);
    let family = parts.map((part) => {
      part = part.trim();
      if (part.indexOf(" ") > -1 && !QuotedRe.test(part)) {
        part = `"${part}"`;
      }
      return part;
    }).join(", ");
    return family;
  };
  Renderer.prototype._applyFontString = function() {
    let {
      textFont,
      textSize,
      lineHeight,
      fontStyle,
      fontWeight,
      fontVariant
    } = this.states;
    let drawingContext = this.textDrawingContext();
    let family = this._parseFontFamily(textFont.family);
    let style = fontStyle !== fn2.NORMAL ? `${fontStyle} ` : "";
    let weight = fontWeight !== fn2.NORMAL ? `${fontWeight} ` : "";
    let variant = fontVariant !== fn2.NORMAL ? `${fontVariant} ` : "";
    let fsize = `${textSize}px` + (lineHeight !== fn2.NORMAL ? `/${lineHeight} ` : " ");
    let fontString = `${style}${variant}${weight}${fsize}${family}`.trim();
    drawingContext.font = fontString;
    if (drawingContext.font !== fontString) {
      let expected = fontString;
      let actual = drawingContext.font;
      if (expected !== actual) {
        return false;
      }
    }
    return true;
  };
  Renderer.prototype._applyTextProperties = function(debug = false) {
    this._applyFontString();
    let context = this.textDrawingContext();
    context.direction = this.states.direction;
    context.textAlign = this.states.textAlign;
    context.textBaseline = this.states.textBaseline;
    let stretch = this.states.fontStretch;
    if (FontStretchKeys.includes(stretch) && context.fontStretch !== stretch) {
      context.fontStretch = stretch;
    }
    while (contextQueue?.length) {
      let [prop, val] = contextQueue.shift();
      if (debug)
        console.log('apply context property "' + prop + '" = "' + val + '"');
      context[prop] = val;
      if (context[prop] !== val) {
        console.warn(`Unable to set '${prop}' property on context2d. It may not be supported.`);
        console.log('Expected "' + val + '" but got: "' + context[prop] + '"');
      }
    }
    return this._pInst;
  };
  if (p53.Renderer2D) {
    p53.Renderer2D.prototype.textCanvas = function() {
      return this.canvas;
    };
    p53.Renderer2D.prototype.textDrawingContext = function() {
      return this.drawingContext;
    };
    p53.Renderer2D.prototype._renderText = function(text, x, y, maxY, minY) {
      let states = this.states;
      let context = this.textDrawingContext();
      if (y < minY || y >= maxY) {
        return;
      }
      this.push();
      if (states.strokeColor && states.strokeSet) {
        context.strokeText(text, x, y);
      }
      if (!this._clipping && states.fillColor) {
        if (!states.fillSet) {
          this._setFill(DefaultFill);
        }
        context.fillText(text, x, y);
      }
      this.pop();
    };
    p53.Renderer2D.prototype._positionLines = function(x, y, width, height, lines) {
      let { textLeading, textAlign } = this.states;
      let adjustedX, lineData = new Array(lines.length);
      let adjustedW = typeof width === "undefined" ? 0 : width;
      let adjustedH = typeof height === "undefined" ? 0 : height;
      for (let i2 = 0;i2 < lines.length; i2++) {
        switch (textAlign) {
          case textCoreConstants.START:
            throw new Error("textBounds: START not yet supported for textAlign");
          case fn2.LEFT:
            adjustedX = x;
            break;
          case fn2.CENTER:
            adjustedX = x + adjustedW / 2;
            break;
          case fn2.RIGHT:
            adjustedX = x + adjustedW;
            break;
          case textCoreConstants.END:
            throw new Error("textBounds: END not yet supported for textAlign");
        }
        lineData[i2] = { text: lines[i2], x: adjustedX, y: y + i2 * textLeading };
      }
      return this._yAlignOffset(lineData, adjustedH);
    };
    p53.Renderer2D.prototype._yAlignOffset = function(dataArr, height) {
      if (typeof height === "undefined") {
        throw Error("_yAlignOffset: height is required");
      }
      let { textLeading, textBaseline } = this.states;
      let yOff = 0, numLines = dataArr.length;
      let ydiff = height - textLeading * (numLines - 1);
      switch (textBaseline) {
        case fn2.TOP:
          break;
        case fn2.BASELINE:
          break;
        case textCoreConstants._CTX_MIDDLE:
          yOff = ydiff / 2;
          break;
        case fn2.BOTTOM:
          yOff = ydiff;
          break;
        case textCoreConstants.IDEOGRAPHIC:
          console.warn("textBounds: IDEOGRAPHIC not yet supported for textBaseline");
          break;
        case textCoreConstants.HANGING:
          console.warn("textBounds: HANGING not yet supported for textBaseline");
          break;
      }
      dataArr.forEach((ele) => ele.y += yOff);
      return dataArr;
    };
  }
  if (p53.RendererGL) {
    p53.RendererGL.prototype.textCanvas = function() {
      if (!this._textCanvas) {
        this._textCanvas = document.createElement("canvas");
        this._textCanvas.width = 1;
        this._textCanvas.height = 1;
        this._textCanvas.style.display = "none";
        this.canvas.parentElement.insertBefore(this._textCanvas, this.canvas);
      }
      return this._textCanvas;
    };
    p53.RendererGL.prototype.textDrawingContext = function() {
      if (!this._textDrawingContext) {
        const textCanvas = this.textCanvas();
        this._textDrawingContext = textCanvas.getContext("2d");
      }
      return this._textDrawingContext;
    };
    const oldRemove = p53.RendererGL.prototype.remove;
    p53.RendererGL.prototype.remove = function() {
      if (this._textCanvas) {
        this._textCanvas.parentElement.removeChild(this._textCanvas);
      }
      oldRemove.call(this);
    };
    p53.RendererGL.prototype._positionLines = function(x, y, width, height, lines) {
      let { textLeading, textAlign } = this.states;
      const widths = lines.map((line) => this._fontWidthSingle(line));
      let adjustedX, lineData = new Array(lines.length);
      let adjustedW = typeof width === "undefined" ? Math.max(0, ...widths) : width;
      let adjustedH = typeof height === "undefined" ? 0 : height;
      for (let i2 = 0;i2 < lines.length; i2++) {
        switch (textAlign) {
          case textCoreConstants.START:
            throw new Error("textBounds: START not yet supported for textAlign");
          case fn2.LEFT:
            adjustedX = x;
            break;
          case fn2.CENTER:
            adjustedX = x + (adjustedW - widths[i2]) / 2 - adjustedW / 2 + (width || 0) / 2;
            break;
          case fn2.RIGHT:
            adjustedX = x + adjustedW - widths[i2] - adjustedW + (width || 0);
            break;
          case textCoreConstants.END:
            throw new Error("textBounds: END not yet supported for textAlign");
        }
        lineData[i2] = { text: lines[i2], x: adjustedX, y: y + i2 * textLeading };
      }
      return this._yAlignOffset(lineData, adjustedH);
    };
    p53.RendererGL.prototype._yAlignOffset = function(dataArr, height) {
      if (typeof height === "undefined") {
        throw Error("_yAlignOffset: height is required");
      }
      let { textLeading, textBaseline, textSize, textFont } = this.states;
      let yOff = 0, numLines = dataArr.length;
      let totalHeight = textSize * numLines + (textLeading - textSize) * (numLines - 1);
      switch (textBaseline) {
        case fn2.TOP:
          yOff = textSize;
          break;
        case fn2.BASELINE:
          break;
        case textCoreConstants._CTX_MIDDLE:
          yOff = -totalHeight / 2 + textSize + (height || 0) / 2;
          break;
        case fn2.BOTTOM:
          yOff = -(totalHeight - textSize) + (height || 0);
          break;
        default:
          console.warn(`${textBaseline} is not supported in WebGL mode.`);
          break;
      }
      yOff += this.states.textFont.font?._verticalAlign(textSize) || 0;
      dataArr.forEach((ele) => ele.y += yOff);
      return dataArr;
    };
  }
}
if (typeof p5 !== "undefined") {
  textCore(p5, p5.prototype);
}

// node_modules/p5/dist/type/p5.Font.js
var import_unicode_range = __toESM(require_lib(), 1);

// node_modules/p5/dist/type/unicodeRanges.js
var unicodeRanges = [
  {
    category: "control character",
    hexrange: ["0000", "001f"]
  },
  {
    category: "basic latin",
    hexrange: ["0000", "007f"]
  },
  {
    category: "latin-1 supplement",
    hexrange: ["0080", "00ff"]
  },
  {
    category: "latin extended-a",
    hexrange: ["0100", "017f"]
  },
  {
    category: "latin extended-b",
    hexrange: ["0180", "024f"]
  },
  {
    category: "ipa extensions",
    hexrange: ["0250", "02af"]
  },
  {
    category: "spacing modifier letters",
    hexrange: ["02b0", "02ff"]
  },
  {
    category: "combining diacritical marks",
    hexrange: ["0300", "036f"]
  },
  {
    category: "greek and coptic",
    hexrange: ["0370", "03ff"]
  },
  {
    category: "cyrillic",
    hexrange: ["0400", "04ff"]
  },
  {
    category: "cyrillic supplement",
    hexrange: ["0500", "052f"]
  },
  {
    category: "armenian",
    hexrange: ["0530", "058f"]
  },
  {
    category: "hebrew",
    hexrange: ["0590", "05ff"]
  },
  {
    category: "arabic",
    hexrange: ["0600", "06ff"]
  },
  {
    category: "syriac",
    hexrange: ["0700", "074f"]
  },
  {
    category: "arabic supplement",
    hexrange: ["0750", "077f"]
  },
  {
    category: "thaana",
    hexrange: ["0780", "07bf"]
  },
  {
    category: "nko",
    hexrange: ["07c0", "07ff"]
  },
  {
    category: "samaritan",
    hexrange: ["0800", "083f"]
  },
  {
    category: "mandaic",
    hexrange: ["0840", "085f"]
  },
  {
    category: "syriac supplement",
    hexrange: ["0860", "086f"]
  },
  {
    category: "arabic extended-b",
    hexrange: ["0870", "089f"]
  },
  {
    category: "arabic extended-a",
    hexrange: ["08a0", "08ff"]
  },
  {
    category: "devanagari",
    hexrange: ["0900", "097f"]
  },
  {
    category: "bengali",
    hexrange: ["0980", "09ff"]
  },
  {
    category: "gurmukhi",
    hexrange: ["0a00", "0a7f"]
  },
  {
    category: "gujarati",
    hexrange: ["0a80", "0aff"]
  },
  {
    category: "oriya",
    hexrange: ["0b00", "0b7f"]
  },
  {
    category: "tamil",
    hexrange: ["0b80", "0bff"]
  },
  {
    category: "telugu",
    hexrange: ["0c00", "0c7f"]
  },
  {
    category: "kannada",
    hexrange: ["0c80", "0cff"]
  },
  {
    category: "malayalam",
    hexrange: ["0d00", "0d7f"]
  },
  {
    category: "sinhala",
    hexrange: ["0d80", "0dff"]
  },
  {
    category: "thai",
    hexrange: ["0e00", "0e7f"]
  },
  {
    category: "lao",
    hexrange: ["0e80", "0eff"]
  },
  {
    category: "tibetan",
    hexrange: ["0f00", "0fff"]
  },
  {
    category: "myanmar",
    hexrange: ["1000", "109f"]
  },
  {
    category: "georgian",
    hexrange: ["10a0", "10ff"]
  },
  {
    category: "hangul jamo",
    hexrange: ["1100", "11ff"]
  },
  {
    category: "ethiopic",
    hexrange: ["1200", "137f"]
  },
  {
    category: "ethiopic supplement",
    hexrange: ["1380", "139f"]
  },
  {
    category: "cherokee",
    hexrange: ["13a0", "13ff"]
  },
  {
    category: "unified canadian aboriginal syllabics",
    hexrange: ["1400", "167f"]
  },
  {
    category: "ogham",
    hexrange: ["1680", "169f"]
  },
  {
    category: "runic",
    hexrange: ["16a0", "16ff"]
  },
  {
    category: "tagalog",
    hexrange: ["1700", "171f"]
  },
  {
    category: "hanunoo",
    hexrange: ["1720", "173f"]
  },
  {
    category: "buhid",
    hexrange: ["1740", "175f"]
  },
  {
    category: "tagbanwa",
    hexrange: ["1760", "177f"]
  },
  {
    category: "khmer",
    hexrange: ["1780", "17ff"]
  },
  {
    category: "mongolian",
    hexrange: ["1800", "18af"]
  },
  {
    category: "unified canadian aboriginal syllabics extended",
    hexrange: ["18b0", "18ff"]
  },
  {
    category: "limbu",
    hexrange: ["1900", "194f"]
  },
  {
    category: "tai le",
    hexrange: ["1950", "197f"]
  },
  {
    category: "new tai lue",
    hexrange: ["1980", "19df"]
  },
  {
    category: "khmer symbols",
    hexrange: ["19e0", "19ff"]
  },
  {
    category: "buginese",
    hexrange: ["1a00", "1a1f"]
  },
  {
    category: "tai tham",
    hexrange: ["1a20", "1aaf"]
  },
  {
    category: "combining diacritical marks extended",
    hexrange: ["1ab0", "1aff"]
  },
  {
    category: "balinese",
    hexrange: ["1b00", "1b7f"]
  },
  {
    category: "sundanese",
    hexrange: ["1b80", "1bbf"]
  },
  {
    category: "batak",
    hexrange: ["1bc0", "1bff"]
  },
  {
    category: "lepcha",
    hexrange: ["1c00", "1c4f"]
  },
  {
    category: "ol chiki",
    hexrange: ["1c50", "1c7f"]
  },
  {
    category: "cyrillic extended-c",
    hexrange: ["1c80", "1c8f"]
  },
  {
    category: "georgian extended",
    hexrange: ["1c90", "1cbf"]
  },
  {
    category: "sundanese supplement",
    hexrange: ["1cc0", "1ccf"]
  },
  {
    category: "vedic extensions",
    hexrange: ["1cd0", "1cff"]
  },
  {
    category: "phonetic extensions",
    hexrange: ["1d00", "1d7f"]
  },
  {
    category: "phonetic extensions supplement",
    hexrange: ["1d80", "1dbf"]
  },
  {
    category: "combining diacritical marks supplement",
    hexrange: ["1dc0", "1dff"]
  },
  {
    category: "latin extended additional",
    hexrange: ["1e00", "1eff"]
  },
  {
    category: "greek extended",
    hexrange: ["1f00", "1fff"]
  },
  {
    category: "general punctuation",
    hexrange: ["2000", "206f"]
  },
  {
    category: "superscripts and subscripts",
    hexrange: ["2070", "209f"]
  },
  {
    category: "currency symbols",
    hexrange: ["20a0", "20cf"]
  },
  {
    category: "combining diacritical marks for symbols",
    hexrange: ["20d0", "20ff"]
  },
  {
    category: "letterlike symbols",
    hexrange: ["2100", "214f"]
  },
  {
    category: "number forms",
    hexrange: ["2150", "218f"]
  },
  {
    category: "arrows",
    hexrange: ["2190", "21ff"]
  },
  {
    category: "mathematical operators",
    hexrange: ["2200", "22ff"]
  },
  {
    category: "miscellaneous technical",
    hexrange: ["2300", "23ff"]
  },
  {
    category: "control pictures",
    hexrange: ["2400", "243f"]
  },
  {
    category: "optical character recognition",
    hexrange: ["2440", "245f"]
  },
  {
    category: "enclosed alphanumerics",
    hexrange: ["2460", "24ff"]
  },
  {
    category: "box drawing",
    hexrange: ["2500", "257f"]
  },
  {
    category: "block elements",
    hexrange: ["2580", "259f"]
  },
  {
    category: "geometric shapes",
    hexrange: ["25a0", "25ff"]
  },
  {
    category: "miscellaneous symbols",
    hexrange: ["2600", "26ff"]
  },
  {
    category: "dingbats",
    hexrange: ["2700", "27bf"]
  },
  {
    category: "miscellaneous mathematical symbols-a",
    hexrange: ["27c0", "27ef"]
  },
  {
    category: "supplemental arrows-a",
    hexrange: ["27f0", "27ff"]
  },
  {
    category: "braille patterns",
    hexrange: ["2800", "28ff"]
  },
  {
    category: "supplemental arrows-b",
    hexrange: ["2900", "297f"]
  },
  {
    category: "miscellaneous mathematical symbols-b",
    hexrange: ["2980", "29ff"]
  },
  {
    category: "supplemental mathematical operators",
    hexrange: ["2a00", "2aff"]
  },
  {
    category: "miscellaneous symbols and arrows",
    hexrange: ["2b00", "2bff"]
  },
  {
    category: "glagolitic",
    hexrange: ["2c00", "2c5f"]
  },
  {
    category: "latin extended-c",
    hexrange: ["2c60", "2c7f"]
  },
  {
    category: "coptic",
    hexrange: ["2c80", "2cff"]
  },
  {
    category: "georgian supplement",
    hexrange: ["2d00", "2d2f"]
  },
  {
    category: "tifinagh",
    hexrange: ["2d30", "2d7f"]
  },
  {
    category: "ethiopic extended",
    hexrange: ["2d80", "2ddf"]
  },
  {
    category: "cyrillic extended-a",
    hexrange: ["2de0", "2dff"]
  },
  {
    category: "supplemental punctuation",
    hexrange: ["2e00", "2e7f"]
  },
  {
    category: "cjk radicals supplement",
    hexrange: ["2e80", "2eff"]
  },
  {
    category: "kangxi radicals",
    hexrange: ["2f00", "2fdf"]
  },
  {
    category: "ideographic description characters",
    hexrange: ["2ff0", "2fff"]
  },
  {
    category: "cjk symbols and punctuation",
    hexrange: ["3000", "303f"]
  },
  {
    category: "hiragana",
    hexrange: ["3040", "309f"]
  },
  {
    category: "katakana",
    hexrange: ["30a0", "30ff"]
  },
  {
    category: "bopomofo",
    hexrange: ["3100", "312f"]
  },
  {
    category: "hangul compatibility jamo",
    hexrange: ["3130", "318f"]
  },
  {
    category: "kanbun",
    hexrange: ["3190", "319f"]
  },
  {
    category: "bopomofo extended",
    hexrange: ["31a0", "31bf"]
  },
  {
    category: "cjk strokes",
    hexrange: ["31c0", "31ef"]
  },
  {
    category: "katakana phonetic extensions",
    hexrange: ["31f0", "31ff"]
  },
  {
    category: "enclosed cjk letters and months",
    hexrange: ["3200", "32ff"]
  },
  {
    category: "cjk compatibility",
    hexrange: ["3300", "33ff"]
  },
  {
    category: "cjk unified ideographs extension a",
    hexrange: ["3400", "4dbf"]
  },
  {
    category: "yijing hexagram symbols",
    hexrange: ["4dc0", "4dff"]
  },
  {
    category: "cjk unified ideographs",
    hexrange: ["4e00", "9fff"]
  },
  {
    category: "yi syllables",
    hexrange: ["a000", "a48f"]
  },
  {
    category: "yi radicals",
    hexrange: ["a490", "a4cf"]
  },
  {
    category: "lisu",
    hexrange: ["a4d0", "a4ff"]
  },
  {
    category: "vai",
    hexrange: ["a500", "a63f"]
  },
  {
    category: "cyrillic extended-b",
    hexrange: ["a640", "a69f"]
  },
  {
    category: "bamum",
    hexrange: ["a6a0", "a6ff"]
  },
  {
    category: "modifier tone letters",
    hexrange: ["a700", "a71f"]
  },
  {
    category: "latin extended-d",
    hexrange: ["a720", "a7ff"]
  },
  {
    category: "syloti nagri",
    hexrange: ["a800", "a82f"]
  },
  {
    category: "common indic number forms",
    hexrange: ["a830", "a83f"]
  },
  {
    category: "phags-pa",
    hexrange: ["a840", "a87f"]
  },
  {
    category: "saurashtra",
    hexrange: ["a880", "a8df"]
  },
  {
    category: "devanagari extended",
    hexrange: ["a8e0", "a8ff"]
  },
  {
    category: "kayah li",
    hexrange: ["a900", "a92f"]
  },
  {
    category: "rejang",
    hexrange: ["a930", "a95f"]
  },
  {
    category: "hangul jamo extended-a",
    hexrange: ["a960", "a97f"]
  },
  {
    category: "javanese",
    hexrange: ["a980", "a9df"]
  },
  {
    category: "myanmar extended-b",
    hexrange: ["a9e0", "a9ff"]
  },
  {
    category: "cham",
    hexrange: ["aa00", "aa5f"]
  },
  {
    category: "myanmar extended-a",
    hexrange: ["aa60", "aa7f"]
  },
  {
    category: "tai viet",
    hexrange: ["aa80", "aadf"]
  },
  {
    category: "meetei mayek extensions",
    hexrange: ["aae0", "aaff"]
  },
  {
    category: "ethiopic extended-a",
    hexrange: ["ab00", "ab2f"]
  },
  {
    category: "latin extended-e",
    hexrange: ["ab30", "ab6f"]
  },
  {
    category: "cherokee supplement",
    hexrange: ["ab70", "abbf"]
  },
  {
    category: "meetei mayek",
    hexrange: ["abc0", "abff"]
  },
  {
    category: "hangul syllables",
    hexrange: ["ac00", "d7af"]
  },
  {
    category: "hangul jamo extended-b",
    hexrange: ["d7b0", "d7ff"]
  },
  {
    category: "high surrogates",
    hexrange: ["d800", "db7f"]
  },
  {
    category: "high private use surrogates",
    hexrange: ["db80", "dbff"]
  },
  {
    category: "low surrogates",
    hexrange: ["dc00", "dfff"]
  },
  {
    category: "private use area",
    hexrange: ["e000", "f8ff"]
  },
  {
    category: "cjk compatibility ideographs",
    hexrange: ["f900", "faff"]
  },
  {
    category: "alphabetic presentation forms",
    hexrange: ["fb00", "fb4f"]
  },
  {
    category: "arabic presentation forms-a",
    hexrange: ["fb50", "fdff"]
  },
  {
    category: "variation selectors",
    hexrange: ["fe00", "fe0f"]
  },
  {
    category: "vertical forms",
    hexrange: ["fe10", "fe1f"]
  },
  {
    category: "combining half marks",
    hexrange: ["fe20", "fe2f"]
  },
  {
    category: "cjk compatibility forms",
    hexrange: ["fe30", "fe4f"]
  },
  {
    category: "small form variants",
    hexrange: ["fe50", "fe6f"]
  },
  {
    category: "arabic presentation forms-b",
    hexrange: ["fe70", "feff"]
  },
  {
    category: "halfwidth and fullwidth forms",
    hexrange: ["ff00", "ffef"]
  },
  {
    category: "specials",
    hexrange: ["fff0", "ffff"]
  },
  {
    category: "linear b syllabary",
    hexrange: ["10000", "1007f"]
  },
  {
    category: "linear b ideograms",
    hexrange: ["10080", "100ff"]
  },
  {
    category: "aegean numbers",
    hexrange: ["10100", "1013f"]
  },
  {
    category: "ancient greek numbers",
    hexrange: ["10140", "1018f"]
  },
  {
    category: "ancient symbols",
    hexrange: ["10190", "101cf"]
  },
  {
    category: "phaistos disc",
    hexrange: ["101d0", "101ff"]
  },
  {
    category: "lycian",
    hexrange: ["10280", "1029f"]
  },
  {
    category: "carian",
    hexrange: ["102a0", "102df"]
  },
  {
    category: "coptic epact numbers",
    hexrange: ["102e0", "102ff"]
  },
  {
    category: "old italic",
    hexrange: ["10300", "1032f"]
  },
  {
    category: "gothic",
    hexrange: ["10330", "1034f"]
  },
  {
    category: "old permic",
    hexrange: ["10350", "1037f"]
  },
  {
    category: "ugaritic",
    hexrange: ["10380", "1039f"]
  },
  {
    category: "old persian",
    hexrange: ["103a0", "103df"]
  },
  {
    category: "deseret",
    hexrange: ["10400", "1044f"]
  },
  {
    category: "shavian",
    hexrange: ["10450", "1047f"]
  },
  {
    category: "osmanya",
    hexrange: ["10480", "104af"]
  },
  {
    category: "osage",
    hexrange: ["104b0", "104ff"]
  },
  {
    category: "elbasan",
    hexrange: ["10500", "1052f"]
  },
  {
    category: "caucasian albanian",
    hexrange: ["10530", "1056f"]
  },
  {
    category: "vithkuqi",
    hexrange: ["10570", "105bf"]
  },
  {
    category: "linear a",
    hexrange: ["10600", "1077f"]
  },
  {
    category: "latin extended-f",
    hexrange: ["10780", "107bf"]
  },
  {
    category: "cypriot syllabary",
    hexrange: ["10800", "1083f"]
  },
  {
    category: "imperial aramaic",
    hexrange: ["10840", "1085f"]
  },
  {
    category: "palmyrene",
    hexrange: ["10860", "1087f"]
  },
  {
    category: "nabataean",
    hexrange: ["10880", "108af"]
  },
  {
    category: "hatran",
    hexrange: ["108e0", "108ff"]
  },
  {
    category: "phoenician",
    hexrange: ["10900", "1091f"]
  },
  {
    category: "lydian",
    hexrange: ["10920", "1093f"]
  },
  {
    category: "meroitic hieroglyphs",
    hexrange: ["10980", "1099f"]
  },
  {
    category: "meroitic cursive",
    hexrange: ["109a0", "109ff"]
  },
  {
    category: "kharoshthi",
    hexrange: ["10a00", "10a5f"]
  },
  {
    category: "old south arabian",
    hexrange: ["10a60", "10a7f"]
  },
  {
    category: "old north arabian",
    hexrange: ["10a80", "10a9f"]
  },
  {
    category: "manichaean",
    hexrange: ["10ac0", "10aff"]
  },
  {
    category: "avestan",
    hexrange: ["10b00", "10b3f"]
  },
  {
    category: "inscriptional parthian",
    hexrange: ["10b40", "10b5f"]
  },
  {
    category: "inscriptional pahlavi",
    hexrange: ["10b60", "10b7f"]
  },
  {
    category: "psalter pahlavi",
    hexrange: ["10b80", "10baf"]
  },
  {
    category: "old turkic",
    hexrange: ["10c00", "10c4f"]
  },
  {
    category: "old hungarian",
    hexrange: ["10c80", "10cff"]
  },
  {
    category: "hanifi rohingya",
    hexrange: ["10d00", "10d3f"]
  },
  {
    category: "rumi numeral symbols",
    hexrange: ["10e60", "10e7f"]
  },
  {
    category: "yezidi",
    hexrange: ["10e80", "10ebf"]
  },
  {
    category: "arabic extended-c",
    hexrange: ["10ec0", "10eff"]
  },
  {
    category: "old sogdian",
    hexrange: ["10f00", "10f2f"]
  },
  {
    category: "sogdian",
    hexrange: ["10f30", "10f6f"]
  },
  {
    category: "old uyghur",
    hexrange: ["10f70", "10faf"]
  },
  {
    category: "chorasmian",
    hexrange: ["10fb0", "10fdf"]
  },
  {
    category: "elymaic",
    hexrange: ["10fe0", "10fff"]
  },
  {
    category: "brahmi",
    hexrange: ["11000", "1107f"]
  },
  {
    category: "kaithi",
    hexrange: ["11080", "110cf"]
  },
  {
    category: "sora sompeng",
    hexrange: ["110d0", "110ff"]
  },
  {
    category: "chakma",
    hexrange: ["11100", "1114f"]
  },
  {
    category: "mahajani",
    hexrange: ["11150", "1117f"]
  },
  {
    category: "sharada",
    hexrange: ["11180", "111df"]
  },
  {
    category: "sinhala archaic numbers",
    hexrange: ["111e0", "111ff"]
  },
  {
    category: "khojki",
    hexrange: ["11200", "1124f"]
  },
  {
    category: "multani",
    hexrange: ["11280", "112af"]
  },
  {
    category: "khudawadi",
    hexrange: ["112b0", "112ff"]
  },
  {
    category: "grantha",
    hexrange: ["11300", "1137f"]
  },
  {
    category: "newa",
    hexrange: ["11400", "1147f"]
  },
  {
    category: "tirhuta",
    hexrange: ["11480", "114df"]
  },
  {
    category: "siddham",
    hexrange: ["11580", "115ff"]
  },
  {
    category: "modi",
    hexrange: ["11600", "1165f"]
  },
  {
    category: "mongolian supplement",
    hexrange: ["11660", "1167f"]
  },
  {
    category: "takri",
    hexrange: ["11680", "116cf"]
  },
  {
    category: "ahom",
    hexrange: ["11700", "1174f"]
  },
  {
    category: "dogra",
    hexrange: ["11800", "1184f"]
  },
  {
    category: "warang citi",
    hexrange: ["118a0", "118ff"]
  },
  {
    category: "dives akuru",
    hexrange: ["11900", "1195f"]
  },
  {
    category: "nandinagari",
    hexrange: ["119a0", "119ff"]
  },
  {
    category: "zanabazar square",
    hexrange: ["11a00", "11a4f"]
  },
  {
    category: "soyombo",
    hexrange: ["11a50", "11aaf"]
  },
  {
    category: "unified canadian aboriginal syllabics extended-a",
    hexrange: ["11ab0", "11abf"]
  },
  {
    category: "pau cin hau",
    hexrange: ["11ac0", "11aff"]
  },
  {
    category: "devanagari extended-a",
    hexrange: ["11b00", "11b5f"]
  },
  {
    category: "bhaiksuki",
    hexrange: ["11c00", "11c6f"]
  },
  {
    category: "marchen",
    hexrange: ["11c70", "11cbf"]
  },
  {
    category: "masaram gondi",
    hexrange: ["11d00", "11d5f"]
  },
  {
    category: "gunjala gondi",
    hexrange: ["11d60", "11daf"]
  },
  {
    category: "makasar",
    hexrange: ["11ee0", "11eff"]
  },
  {
    category: "kawi",
    hexrange: ["11f00", "11f5f"]
  },
  {
    category: "lisu supplement",
    hexrange: ["11fb0", "11fbf"]
  },
  {
    category: "tamil supplement",
    hexrange: ["11fc0", "11fff"]
  },
  {
    category: "cuneiform",
    hexrange: ["12000", "123ff"]
  },
  {
    category: "cuneiform numbers and punctuation",
    hexrange: ["12400", "1247f"]
  },
  {
    category: "early dynastic cuneiform",
    hexrange: ["12480", "1254f"]
  },
  {
    category: "cypro-minoan",
    hexrange: ["12f90", "12fff"]
  },
  {
    category: "egyptian hieroglyphs",
    hexrange: ["13000", "1342f"]
  },
  {
    category: "egyptian hieroglyph format controls",
    hexrange: ["13430", "1345f"]
  },
  {
    category: "anatolian hieroglyphs",
    hexrange: ["14400", "1467f"]
  },
  {
    category: "bamum supplement",
    hexrange: ["16800", "16a3f"]
  },
  {
    category: "mro",
    hexrange: ["16a40", "16a6f"]
  },
  {
    category: "tangsa",
    hexrange: ["16a70", "16acf"]
  },
  {
    category: "bassa vah",
    hexrange: ["16ad0", "16aff"]
  },
  {
    category: "pahawh hmong",
    hexrange: ["16b00", "16b8f"]
  },
  {
    category: "medefaidrin",
    hexrange: ["16e40", "16e9f"]
  },
  {
    category: "miao",
    hexrange: ["16f00", "16f9f"]
  },
  {
    category: "ideographic symbols and punctuation",
    hexrange: ["16fe0", "16fff"]
  },
  {
    category: "tangut",
    hexrange: ["17000", "187ff"]
  },
  {
    category: "tangut components",
    hexrange: ["18800", "18aff"]
  },
  {
    category: "khitan small script",
    hexrange: ["18b00", "18cff"]
  },
  {
    category: "tangut supplement",
    hexrange: ["18d00", "18d7f"]
  },
  {
    category: "kana extended-b",
    hexrange: ["1aff0", "1afff"]
  },
  {
    category: "kana supplement",
    hexrange: ["1b000", "1b0ff"]
  },
  {
    category: "kana extended-a",
    hexrange: ["1b100", "1b12f"]
  },
  {
    category: "small kana extension",
    hexrange: ["1b130", "1b16f"]
  },
  {
    category: "nushu",
    hexrange: ["1b170", "1b2ff"]
  },
  {
    category: "duployan",
    hexrange: ["1bc00", "1bc9f"]
  },
  {
    category: "shorthand format controls",
    hexrange: ["1bca0", "1bcaf"]
  },
  {
    category: "znamenny musical notation",
    hexrange: ["1cf00", "1cfcf"]
  },
  {
    category: "byzantine musical symbols",
    hexrange: ["1d000", "1d0ff"]
  },
  {
    category: "musical symbols",
    hexrange: ["1d100", "1d1ff"]
  },
  {
    category: "ancient greek musical notation",
    hexrange: ["1d200", "1d24f"]
  },
  {
    category: "kaktovik numerals",
    hexrange: ["1d2c0", "1d2df"]
  },
  {
    category: "mayan numerals",
    hexrange: ["1d2e0", "1d2ff"]
  },
  {
    category: "tai xuan jing symbols",
    hexrange: ["1d300", "1d35f"]
  },
  {
    category: "counting rod numerals",
    hexrange: ["1d360", "1d37f"]
  },
  {
    category: "mathematical alphanumeric symbols",
    hexrange: ["1d400", "1d7ff"]
  },
  {
    category: "sutton signwriting",
    hexrange: ["1d800", "1daaf"]
  },
  {
    category: "latin extended-g",
    hexrange: ["1df00", "1dfff"]
  },
  {
    category: "glagolitic supplement",
    hexrange: ["1e000", "1e02f"]
  },
  {
    category: "cyrillic extended-d",
    hexrange: ["1e030", "1e08f"]
  },
  {
    category: "nyiakeng puachue hmong",
    hexrange: ["1e100", "1e14f"]
  },
  {
    category: "toto",
    hexrange: ["1e290", "1e2bf"]
  },
  {
    category: "wancho",
    hexrange: ["1e2c0", "1e2ff"]
  },
  {
    category: "nag mundari",
    hexrange: ["1e4d0", "1e4ff"]
  },
  {
    category: "ethiopic extended-b",
    hexrange: ["1e7e0", "1e7ff"]
  },
  {
    category: "mende kikakui",
    hexrange: ["1e800", "1e8df"]
  },
  {
    category: "adlam",
    hexrange: ["1e900", "1e95f"]
  },
  {
    category: "indic siyaq numbers",
    hexrange: ["1ec70", "1ecbf"]
  },
  {
    category: "ottoman siyaq numbers",
    hexrange: ["1ed00", "1ed4f"]
  },
  {
    category: "arabic mathematical alphabetic symbols",
    hexrange: ["1ee00", "1eeff"]
  },
  {
    category: "mahjong tiles",
    hexrange: ["1f000", "1f02f"]
  },
  {
    category: "domino tiles",
    hexrange: ["1f030", "1f09f"]
  },
  {
    category: "playing cards",
    hexrange: ["1f0a0", "1f0ff"]
  },
  {
    category: "enclosed alphanumeric supplement",
    hexrange: ["1f100", "1f1ff"]
  },
  {
    category: "enclosed ideographic supplement",
    hexrange: ["1f200", "1f2ff"]
  },
  {
    category: "miscellaneous symbols and pictographs",
    hexrange: ["1f300", "1f5ff"]
  },
  {
    category: "emoticons (emoji)",
    hexrange: ["1f600", "1f64f"]
  },
  {
    category: "ornamental dingbats",
    hexrange: ["1f650", "1f67f"]
  },
  {
    category: "transport and map symbols",
    hexrange: ["1f680", "1f6ff"]
  },
  {
    category: "alchemical symbols",
    hexrange: ["1f700", "1f77f"]
  },
  {
    category: "geometric shapes extended",
    hexrange: ["1f780", "1f7ff"]
  },
  {
    category: "supplemental arrows-c",
    hexrange: ["1f800", "1f8ff"]
  },
  {
    category: "supplemental symbols and pictographs",
    hexrange: ["1f900", "1f9ff"]
  },
  {
    category: "chess symbols",
    hexrange: ["1fa00", "1fa6f"]
  },
  {
    category: "symbols and pictographs extended-a",
    hexrange: ["1fa70", "1faff"]
  },
  {
    category: "symbols for legacy computing",
    hexrange: ["1fb00", "1fbff"]
  },
  {
    category: "cjk unified ideographs extension b",
    hexrange: ["20000", "2a6df"]
  },
  {
    category: "cjk unified ideographs extension c",
    hexrange: ["2a700", "2b73f"]
  },
  {
    category: "cjk unified ideographs extension d",
    hexrange: ["2b740", "2b81f"]
  },
  {
    category: "cjk unified ideographs extension e",
    hexrange: ["2b820", "2ceaf"]
  },
  {
    category: "cjk unified ideographs extension f",
    hexrange: ["2ceb0", "2ebef"]
  },
  {
    category: "cjk unified ideographs extension i",
    hexrange: ["2ebf0", "2ee5f"]
  },
  {
    category: "cjk compatibility ideographs supplement",
    hexrange: ["2f800", "2fa1f"]
  },
  {
    category: "cjk unified ideographs extension g",
    hexrange: ["30000", "3134f"]
  },
  {
    category: "cjk unified ideographs extension h",
    hexrange: ["31350", "323af"]
  },
  {
    category: "tags",
    hexrange: ["e0000", "e007f"]
  },
  {
    category: "variation selectors supplement",
    hexrange: ["e0100", "e01ef"]
  },
  {
    category: "supplementary private use area-a",
    hexrange: ["f0000", "fffff"]
  },
  {
    category: "supplementary private use area-b",
    hexrange: ["100000", "10ffff"]
  }
];

// node_modules/pako/dist/pako.esm.mjs
/*! pako 2.1.0 https://github.com/nodeca/pako @license (MIT AND Zlib) */
var Z_FIXED$1 = 4;
var Z_BINARY = 0;
var Z_TEXT = 1;
var Z_UNKNOWN$1 = 2;
function zero$1(buf) {
  let len = buf.length;
  while (--len >= 0) {
    buf[len] = 0;
  }
}
var STORED_BLOCK = 0;
var STATIC_TREES = 1;
var DYN_TREES = 2;
var MIN_MATCH$1 = 3;
var MAX_MATCH$1 = 258;
var LENGTH_CODES$1 = 29;
var LITERALS$1 = 256;
var L_CODES$1 = LITERALS$1 + 1 + LENGTH_CODES$1;
var D_CODES$1 = 30;
var BL_CODES$1 = 19;
var HEAP_SIZE$1 = 2 * L_CODES$1 + 1;
var MAX_BITS$1 = 15;
var Buf_size = 16;
var MAX_BL_BITS = 7;
var END_BLOCK = 256;
var REP_3_6 = 16;
var REPZ_3_10 = 17;
var REPZ_11_138 = 18;
var extra_lbits = new Uint8Array([0, 0, 0, 0, 0, 0, 0, 0, 1, 1, 1, 1, 2, 2, 2, 2, 3, 3, 3, 3, 4, 4, 4, 4, 5, 5, 5, 5, 0]);
var extra_dbits = new Uint8Array([0, 0, 0, 0, 1, 1, 2, 2, 3, 3, 4, 4, 5, 5, 6, 6, 7, 7, 8, 8, 9, 9, 10, 10, 11, 11, 12, 12, 13, 13]);
var extra_blbits = new Uint8Array([0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 2, 3, 7]);
var bl_order = new Uint8Array([16, 17, 18, 0, 8, 7, 9, 6, 10, 5, 11, 4, 12, 3, 13, 2, 14, 1, 15]);
var DIST_CODE_LEN = 512;
var static_ltree = new Array((L_CODES$1 + 2) * 2);
zero$1(static_ltree);
var static_dtree = new Array(D_CODES$1 * 2);
zero$1(static_dtree);
var _dist_code = new Array(DIST_CODE_LEN);
zero$1(_dist_code);
var _length_code = new Array(MAX_MATCH$1 - MIN_MATCH$1 + 1);
zero$1(_length_code);
var base_length = new Array(LENGTH_CODES$1);
zero$1(base_length);
var base_dist = new Array(D_CODES$1);
zero$1(base_dist);
function StaticTreeDesc(static_tree, extra_bits, extra_base, elems, max_length) {
  this.static_tree = static_tree;
  this.extra_bits = extra_bits;
  this.extra_base = extra_base;
  this.elems = elems;
  this.max_length = max_length;
  this.has_stree = static_tree && static_tree.length;
}
var static_l_desc;
var static_d_desc;
var static_bl_desc;
function TreeDesc(dyn_tree, stat_desc) {
  this.dyn_tree = dyn_tree;
  this.max_code = 0;
  this.stat_desc = stat_desc;
}
var d_code = (dist) => {
  return dist < 256 ? _dist_code[dist] : _dist_code[256 + (dist >>> 7)];
};
var put_short = (s, w) => {
  s.pending_buf[s.pending++] = w & 255;
  s.pending_buf[s.pending++] = w >>> 8 & 255;
};
var send_bits = (s, value, length) => {
  if (s.bi_valid > Buf_size - length) {
    s.bi_buf |= value << s.bi_valid & 65535;
    put_short(s, s.bi_buf);
    s.bi_buf = value >> Buf_size - s.bi_valid;
    s.bi_valid += length - Buf_size;
  } else {
    s.bi_buf |= value << s.bi_valid & 65535;
    s.bi_valid += length;
  }
};
var send_code = (s, c, tree) => {
  send_bits(s, tree[c * 2], tree[c * 2 + 1]);
};
var bi_reverse = (code, len) => {
  let res = 0;
  do {
    res |= code & 1;
    code >>>= 1;
    res <<= 1;
  } while (--len > 0);
  return res >>> 1;
};
var bi_flush = (s) => {
  if (s.bi_valid === 16) {
    put_short(s, s.bi_buf);
    s.bi_buf = 0;
    s.bi_valid = 0;
  } else if (s.bi_valid >= 8) {
    s.pending_buf[s.pending++] = s.bi_buf & 255;
    s.bi_buf >>= 8;
    s.bi_valid -= 8;
  }
};
var gen_bitlen = (s, desc) => {
  const tree = desc.dyn_tree;
  const max_code = desc.max_code;
  const stree = desc.stat_desc.static_tree;
  const has_stree = desc.stat_desc.has_stree;
  const extra = desc.stat_desc.extra_bits;
  const base2 = desc.stat_desc.extra_base;
  const max_length = desc.stat_desc.max_length;
  let h;
  let n2, m;
  let bits;
  let xbits;
  let f;
  let overflow = 0;
  for (bits = 0;bits <= MAX_BITS$1; bits++) {
    s.bl_count[bits] = 0;
  }
  tree[s.heap[s.heap_max] * 2 + 1] = 0;
  for (h = s.heap_max + 1;h < HEAP_SIZE$1; h++) {
    n2 = s.heap[h];
    bits = tree[tree[n2 * 2 + 1] * 2 + 1] + 1;
    if (bits > max_length) {
      bits = max_length;
      overflow++;
    }
    tree[n2 * 2 + 1] = bits;
    if (n2 > max_code) {
      continue;
    }
    s.bl_count[bits]++;
    xbits = 0;
    if (n2 >= base2) {
      xbits = extra[n2 - base2];
    }
    f = tree[n2 * 2];
    s.opt_len += f * (bits + xbits);
    if (has_stree) {
      s.static_len += f * (stree[n2 * 2 + 1] + xbits);
    }
  }
  if (overflow === 0) {
    return;
  }
  do {
    bits = max_length - 1;
    while (s.bl_count[bits] === 0) {
      bits--;
    }
    s.bl_count[bits]--;
    s.bl_count[bits + 1] += 2;
    s.bl_count[max_length]--;
    overflow -= 2;
  } while (overflow > 0);
  for (bits = max_length;bits !== 0; bits--) {
    n2 = s.bl_count[bits];
    while (n2 !== 0) {
      m = s.heap[--h];
      if (m > max_code) {
        continue;
      }
      if (tree[m * 2 + 1] !== bits) {
        s.opt_len += (bits - tree[m * 2 + 1]) * tree[m * 2];
        tree[m * 2 + 1] = bits;
      }
      n2--;
    }
  }
};
var gen_codes = (tree, max_code, bl_count) => {
  const next_code = new Array(MAX_BITS$1 + 1);
  let code = 0;
  let bits;
  let n2;
  for (bits = 1;bits <= MAX_BITS$1; bits++) {
    code = code + bl_count[bits - 1] << 1;
    next_code[bits] = code;
  }
  for (n2 = 0;n2 <= max_code; n2++) {
    let len = tree[n2 * 2 + 1];
    if (len === 0) {
      continue;
    }
    tree[n2 * 2] = bi_reverse(next_code[len]++, len);
  }
};
var tr_static_init = () => {
  let n2;
  let bits;
  let length;
  let code;
  let dist;
  const bl_count = new Array(MAX_BITS$1 + 1);
  length = 0;
  for (code = 0;code < LENGTH_CODES$1 - 1; code++) {
    base_length[code] = length;
    for (n2 = 0;n2 < 1 << extra_lbits[code]; n2++) {
      _length_code[length++] = code;
    }
  }
  _length_code[length - 1] = code;
  dist = 0;
  for (code = 0;code < 16; code++) {
    base_dist[code] = dist;
    for (n2 = 0;n2 < 1 << extra_dbits[code]; n2++) {
      _dist_code[dist++] = code;
    }
  }
  dist >>= 7;
  for (;code < D_CODES$1; code++) {
    base_dist[code] = dist << 7;
    for (n2 = 0;n2 < 1 << extra_dbits[code] - 7; n2++) {
      _dist_code[256 + dist++] = code;
    }
  }
  for (bits = 0;bits <= MAX_BITS$1; bits++) {
    bl_count[bits] = 0;
  }
  n2 = 0;
  while (n2 <= 143) {
    static_ltree[n2 * 2 + 1] = 8;
    n2++;
    bl_count[8]++;
  }
  while (n2 <= 255) {
    static_ltree[n2 * 2 + 1] = 9;
    n2++;
    bl_count[9]++;
  }
  while (n2 <= 279) {
    static_ltree[n2 * 2 + 1] = 7;
    n2++;
    bl_count[7]++;
  }
  while (n2 <= 287) {
    static_ltree[n2 * 2 + 1] = 8;
    n2++;
    bl_count[8]++;
  }
  gen_codes(static_ltree, L_CODES$1 + 1, bl_count);
  for (n2 = 0;n2 < D_CODES$1; n2++) {
    static_dtree[n2 * 2 + 1] = 5;
    static_dtree[n2 * 2] = bi_reverse(n2, 5);
  }
  static_l_desc = new StaticTreeDesc(static_ltree, extra_lbits, LITERALS$1 + 1, L_CODES$1, MAX_BITS$1);
  static_d_desc = new StaticTreeDesc(static_dtree, extra_dbits, 0, D_CODES$1, MAX_BITS$1);
  static_bl_desc = new StaticTreeDesc(new Array(0), extra_blbits, 0, BL_CODES$1, MAX_BL_BITS);
};
var init_block = (s) => {
  let n2;
  for (n2 = 0;n2 < L_CODES$1; n2++) {
    s.dyn_ltree[n2 * 2] = 0;
  }
  for (n2 = 0;n2 < D_CODES$1; n2++) {
    s.dyn_dtree[n2 * 2] = 0;
  }
  for (n2 = 0;n2 < BL_CODES$1; n2++) {
    s.bl_tree[n2 * 2] = 0;
  }
  s.dyn_ltree[END_BLOCK * 2] = 1;
  s.opt_len = s.static_len = 0;
  s.sym_next = s.matches = 0;
};
var bi_windup = (s) => {
  if (s.bi_valid > 8) {
    put_short(s, s.bi_buf);
  } else if (s.bi_valid > 0) {
    s.pending_buf[s.pending++] = s.bi_buf;
  }
  s.bi_buf = 0;
  s.bi_valid = 0;
};
var smaller = (tree, n2, m, depth) => {
  const _n2 = n2 * 2;
  const _m2 = m * 2;
  return tree[_n2] < tree[_m2] || tree[_n2] === tree[_m2] && depth[n2] <= depth[m];
};
var pqdownheap = (s, tree, k) => {
  const v = s.heap[k];
  let j = k << 1;
  while (j <= s.heap_len) {
    if (j < s.heap_len && smaller(tree, s.heap[j + 1], s.heap[j], s.depth)) {
      j++;
    }
    if (smaller(tree, v, s.heap[j], s.depth)) {
      break;
    }
    s.heap[k] = s.heap[j];
    k = j;
    j <<= 1;
  }
  s.heap[k] = v;
};
var compress_block = (s, ltree, dtree) => {
  let dist;
  let lc;
  let sx = 0;
  let code;
  let extra;
  if (s.sym_next !== 0) {
    do {
      dist = s.pending_buf[s.sym_buf + sx++] & 255;
      dist += (s.pending_buf[s.sym_buf + sx++] & 255) << 8;
      lc = s.pending_buf[s.sym_buf + sx++];
      if (dist === 0) {
        send_code(s, lc, ltree);
      } else {
        code = _length_code[lc];
        send_code(s, code + LITERALS$1 + 1, ltree);
        extra = extra_lbits[code];
        if (extra !== 0) {
          lc -= base_length[code];
          send_bits(s, lc, extra);
        }
        dist--;
        code = d_code(dist);
        send_code(s, code, dtree);
        extra = extra_dbits[code];
        if (extra !== 0) {
          dist -= base_dist[code];
          send_bits(s, dist, extra);
        }
      }
    } while (sx < s.sym_next);
  }
  send_code(s, END_BLOCK, ltree);
};
var build_tree = (s, desc) => {
  const tree = desc.dyn_tree;
  const stree = desc.stat_desc.static_tree;
  const has_stree = desc.stat_desc.has_stree;
  const elems = desc.stat_desc.elems;
  let n2, m;
  let max_code = -1;
  let node;
  s.heap_len = 0;
  s.heap_max = HEAP_SIZE$1;
  for (n2 = 0;n2 < elems; n2++) {
    if (tree[n2 * 2] !== 0) {
      s.heap[++s.heap_len] = max_code = n2;
      s.depth[n2] = 0;
    } else {
      tree[n2 * 2 + 1] = 0;
    }
  }
  while (s.heap_len < 2) {
    node = s.heap[++s.heap_len] = max_code < 2 ? ++max_code : 0;
    tree[node * 2] = 1;
    s.depth[node] = 0;
    s.opt_len--;
    if (has_stree) {
      s.static_len -= stree[node * 2 + 1];
    }
  }
  desc.max_code = max_code;
  for (n2 = s.heap_len >> 1;n2 >= 1; n2--) {
    pqdownheap(s, tree, n2);
  }
  node = elems;
  do {
    n2 = s.heap[1];
    s.heap[1] = s.heap[s.heap_len--];
    pqdownheap(s, tree, 1);
    m = s.heap[1];
    s.heap[--s.heap_max] = n2;
    s.heap[--s.heap_max] = m;
    tree[node * 2] = tree[n2 * 2] + tree[m * 2];
    s.depth[node] = (s.depth[n2] >= s.depth[m] ? s.depth[n2] : s.depth[m]) + 1;
    tree[n2 * 2 + 1] = tree[m * 2 + 1] = node;
    s.heap[1] = node++;
    pqdownheap(s, tree, 1);
  } while (s.heap_len >= 2);
  s.heap[--s.heap_max] = s.heap[1];
  gen_bitlen(s, desc);
  gen_codes(tree, max_code, s.bl_count);
};
var scan_tree = (s, tree, max_code) => {
  let n2;
  let prevlen = -1;
  let curlen;
  let nextlen = tree[0 * 2 + 1];
  let count = 0;
  let max_count = 7;
  let min_count = 4;
  if (nextlen === 0) {
    max_count = 138;
    min_count = 3;
  }
  tree[(max_code + 1) * 2 + 1] = 65535;
  for (n2 = 0;n2 <= max_code; n2++) {
    curlen = nextlen;
    nextlen = tree[(n2 + 1) * 2 + 1];
    if (++count < max_count && curlen === nextlen) {
      continue;
    } else if (count < min_count) {
      s.bl_tree[curlen * 2] += count;
    } else if (curlen !== 0) {
      if (curlen !== prevlen) {
        s.bl_tree[curlen * 2]++;
      }
      s.bl_tree[REP_3_6 * 2]++;
    } else if (count <= 10) {
      s.bl_tree[REPZ_3_10 * 2]++;
    } else {
      s.bl_tree[REPZ_11_138 * 2]++;
    }
    count = 0;
    prevlen = curlen;
    if (nextlen === 0) {
      max_count = 138;
      min_count = 3;
    } else if (curlen === nextlen) {
      max_count = 6;
      min_count = 3;
    } else {
      max_count = 7;
      min_count = 4;
    }
  }
};
var send_tree = (s, tree, max_code) => {
  let n2;
  let prevlen = -1;
  let curlen;
  let nextlen = tree[0 * 2 + 1];
  let count = 0;
  let max_count = 7;
  let min_count = 4;
  if (nextlen === 0) {
    max_count = 138;
    min_count = 3;
  }
  for (n2 = 0;n2 <= max_code; n2++) {
    curlen = nextlen;
    nextlen = tree[(n2 + 1) * 2 + 1];
    if (++count < max_count && curlen === nextlen) {
      continue;
    } else if (count < min_count) {
      do {
        send_code(s, curlen, s.bl_tree);
      } while (--count !== 0);
    } else if (curlen !== 0) {
      if (curlen !== prevlen) {
        send_code(s, curlen, s.bl_tree);
        count--;
      }
      send_code(s, REP_3_6, s.bl_tree);
      send_bits(s, count - 3, 2);
    } else if (count <= 10) {
      send_code(s, REPZ_3_10, s.bl_tree);
      send_bits(s, count - 3, 3);
    } else {
      send_code(s, REPZ_11_138, s.bl_tree);
      send_bits(s, count - 11, 7);
    }
    count = 0;
    prevlen = curlen;
    if (nextlen === 0) {
      max_count = 138;
      min_count = 3;
    } else if (curlen === nextlen) {
      max_count = 6;
      min_count = 3;
    } else {
      max_count = 7;
      min_count = 4;
    }
  }
};
var build_bl_tree = (s) => {
  let max_blindex;
  scan_tree(s, s.dyn_ltree, s.l_desc.max_code);
  scan_tree(s, s.dyn_dtree, s.d_desc.max_code);
  build_tree(s, s.bl_desc);
  for (max_blindex = BL_CODES$1 - 1;max_blindex >= 3; max_blindex--) {
    if (s.bl_tree[bl_order[max_blindex] * 2 + 1] !== 0) {
      break;
    }
  }
  s.opt_len += 3 * (max_blindex + 1) + 5 + 5 + 4;
  return max_blindex;
};
var send_all_trees = (s, lcodes, dcodes, blcodes) => {
  let rank;
  send_bits(s, lcodes - 257, 5);
  send_bits(s, dcodes - 1, 5);
  send_bits(s, blcodes - 4, 4);
  for (rank = 0;rank < blcodes; rank++) {
    send_bits(s, s.bl_tree[bl_order[rank] * 2 + 1], 3);
  }
  send_tree(s, s.dyn_ltree, lcodes - 1);
  send_tree(s, s.dyn_dtree, dcodes - 1);
};
var detect_data_type = (s) => {
  let block_mask = 4093624447;
  let n2;
  for (n2 = 0;n2 <= 31; n2++, block_mask >>>= 1) {
    if (block_mask & 1 && s.dyn_ltree[n2 * 2] !== 0) {
      return Z_BINARY;
    }
  }
  if (s.dyn_ltree[9 * 2] !== 0 || s.dyn_ltree[10 * 2] !== 0 || s.dyn_ltree[13 * 2] !== 0) {
    return Z_TEXT;
  }
  for (n2 = 32;n2 < LITERALS$1; n2++) {
    if (s.dyn_ltree[n2 * 2] !== 0) {
      return Z_TEXT;
    }
  }
  return Z_BINARY;
};
var static_init_done = false;
var _tr_init$1 = (s) => {
  if (!static_init_done) {
    tr_static_init();
    static_init_done = true;
  }
  s.l_desc = new TreeDesc(s.dyn_ltree, static_l_desc);
  s.d_desc = new TreeDesc(s.dyn_dtree, static_d_desc);
  s.bl_desc = new TreeDesc(s.bl_tree, static_bl_desc);
  s.bi_buf = 0;
  s.bi_valid = 0;
  init_block(s);
};
var _tr_stored_block$1 = (s, buf, stored_len, last2) => {
  send_bits(s, (STORED_BLOCK << 1) + (last2 ? 1 : 0), 3);
  bi_windup(s);
  put_short(s, stored_len);
  put_short(s, ~stored_len);
  if (stored_len) {
    s.pending_buf.set(s.window.subarray(buf, buf + stored_len), s.pending);
  }
  s.pending += stored_len;
};
var _tr_align$1 = (s) => {
  send_bits(s, STATIC_TREES << 1, 3);
  send_code(s, END_BLOCK, static_ltree);
  bi_flush(s);
};
var _tr_flush_block$1 = (s, buf, stored_len, last2) => {
  let opt_lenb, static_lenb;
  let max_blindex = 0;
  if (s.level > 0) {
    if (s.strm.data_type === Z_UNKNOWN$1) {
      s.strm.data_type = detect_data_type(s);
    }
    build_tree(s, s.l_desc);
    build_tree(s, s.d_desc);
    max_blindex = build_bl_tree(s);
    opt_lenb = s.opt_len + 3 + 7 >>> 3;
    static_lenb = s.static_len + 3 + 7 >>> 3;
    if (static_lenb <= opt_lenb) {
      opt_lenb = static_lenb;
    }
  } else {
    opt_lenb = static_lenb = stored_len + 5;
  }
  if (stored_len + 4 <= opt_lenb && buf !== -1) {
    _tr_stored_block$1(s, buf, stored_len, last2);
  } else if (s.strategy === Z_FIXED$1 || static_lenb === opt_lenb) {
    send_bits(s, (STATIC_TREES << 1) + (last2 ? 1 : 0), 3);
    compress_block(s, static_ltree, static_dtree);
  } else {
    send_bits(s, (DYN_TREES << 1) + (last2 ? 1 : 0), 3);
    send_all_trees(s, s.l_desc.max_code + 1, s.d_desc.max_code + 1, max_blindex + 1);
    compress_block(s, s.dyn_ltree, s.dyn_dtree);
  }
  init_block(s);
  if (last2) {
    bi_windup(s);
  }
};
var _tr_tally$1 = (s, dist, lc) => {
  s.pending_buf[s.sym_buf + s.sym_next++] = dist;
  s.pending_buf[s.sym_buf + s.sym_next++] = dist >> 8;
  s.pending_buf[s.sym_buf + s.sym_next++] = lc;
  if (dist === 0) {
    s.dyn_ltree[lc * 2]++;
  } else {
    s.matches++;
    dist--;
    s.dyn_ltree[(_length_code[lc] + LITERALS$1 + 1) * 2]++;
    s.dyn_dtree[d_code(dist) * 2]++;
  }
  return s.sym_next === s.sym_end;
};
var _tr_init_1 = _tr_init$1;
var _tr_stored_block_1 = _tr_stored_block$1;
var _tr_flush_block_1 = _tr_flush_block$1;
var _tr_tally_1 = _tr_tally$1;
var _tr_align_1 = _tr_align$1;
var trees = {
  _tr_init: _tr_init_1,
  _tr_stored_block: _tr_stored_block_1,
  _tr_flush_block: _tr_flush_block_1,
  _tr_tally: _tr_tally_1,
  _tr_align: _tr_align_1
};
var adler32 = (adler, buf, len, pos) => {
  let s1 = adler & 65535 | 0, s2 = adler >>> 16 & 65535 | 0, n2 = 0;
  while (len !== 0) {
    n2 = len > 2000 ? 2000 : len;
    len -= n2;
    do {
      s1 = s1 + buf[pos++] | 0;
      s2 = s2 + s1 | 0;
    } while (--n2);
    s1 %= 65521;
    s2 %= 65521;
  }
  return s1 | s2 << 16 | 0;
};
var adler32_1 = adler32;
var makeTable = () => {
  let c, table2 = [];
  for (var n2 = 0;n2 < 256; n2++) {
    c = n2;
    for (var k = 0;k < 8; k++) {
      c = c & 1 ? 3988292384 ^ c >>> 1 : c >>> 1;
    }
    table2[n2] = c;
  }
  return table2;
};
var crcTable = new Uint32Array(makeTable());
var crc32 = (crc, buf, len, pos) => {
  const t = crcTable;
  const end = pos + len;
  crc ^= -1;
  for (let i2 = pos;i2 < end; i2++) {
    crc = crc >>> 8 ^ t[(crc ^ buf[i2]) & 255];
  }
  return crc ^ -1;
};
var crc32_1 = crc32;
var messages = {
  2: "need dictionary",
  1: "stream end",
  0: "",
  "-1": "file error",
  "-2": "stream error",
  "-3": "data error",
  "-4": "insufficient memory",
  "-5": "buffer error",
  "-6": "incompatible version"
};
var constants$2 = {
  Z_NO_FLUSH: 0,
  Z_PARTIAL_FLUSH: 1,
  Z_SYNC_FLUSH: 2,
  Z_FULL_FLUSH: 3,
  Z_FINISH: 4,
  Z_BLOCK: 5,
  Z_TREES: 6,
  Z_OK: 0,
  Z_STREAM_END: 1,
  Z_NEED_DICT: 2,
  Z_ERRNO: -1,
  Z_STREAM_ERROR: -2,
  Z_DATA_ERROR: -3,
  Z_MEM_ERROR: -4,
  Z_BUF_ERROR: -5,
  Z_NO_COMPRESSION: 0,
  Z_BEST_SPEED: 1,
  Z_BEST_COMPRESSION: 9,
  Z_DEFAULT_COMPRESSION: -1,
  Z_FILTERED: 1,
  Z_HUFFMAN_ONLY: 2,
  Z_RLE: 3,
  Z_FIXED: 4,
  Z_DEFAULT_STRATEGY: 0,
  Z_BINARY: 0,
  Z_TEXT: 1,
  Z_UNKNOWN: 2,
  Z_DEFLATED: 8
};
var { _tr_init, _tr_stored_block, _tr_flush_block, _tr_tally, _tr_align } = trees;
var {
  Z_NO_FLUSH: Z_NO_FLUSH$2,
  Z_PARTIAL_FLUSH,
  Z_FULL_FLUSH: Z_FULL_FLUSH$1,
  Z_FINISH: Z_FINISH$3,
  Z_BLOCK: Z_BLOCK$1,
  Z_OK: Z_OK$3,
  Z_STREAM_END: Z_STREAM_END$3,
  Z_STREAM_ERROR: Z_STREAM_ERROR$2,
  Z_DATA_ERROR: Z_DATA_ERROR$2,
  Z_BUF_ERROR: Z_BUF_ERROR$1,
  Z_DEFAULT_COMPRESSION: Z_DEFAULT_COMPRESSION$1,
  Z_FILTERED,
  Z_HUFFMAN_ONLY,
  Z_RLE,
  Z_FIXED,
  Z_DEFAULT_STRATEGY: Z_DEFAULT_STRATEGY$1,
  Z_UNKNOWN,
  Z_DEFLATED: Z_DEFLATED$2
} = constants$2;
var MAX_MEM_LEVEL = 9;
var MAX_WBITS$1 = 15;
var DEF_MEM_LEVEL = 8;
var LENGTH_CODES = 29;
var LITERALS = 256;
var L_CODES = LITERALS + 1 + LENGTH_CODES;
var D_CODES = 30;
var BL_CODES = 19;
var HEAP_SIZE = 2 * L_CODES + 1;
var MAX_BITS = 15;
var MIN_MATCH = 3;
var MAX_MATCH = 258;
var MIN_LOOKAHEAD = MAX_MATCH + MIN_MATCH + 1;
var PRESET_DICT = 32;
var INIT_STATE = 42;
var GZIP_STATE = 57;
var EXTRA_STATE = 69;
var NAME_STATE = 73;
var COMMENT_STATE = 91;
var HCRC_STATE = 103;
var BUSY_STATE = 113;
var FINISH_STATE = 666;
var BS_NEED_MORE = 1;
var BS_BLOCK_DONE = 2;
var BS_FINISH_STARTED = 3;
var BS_FINISH_DONE = 4;
var OS_CODE = 3;
var err = (strm, errorCode) => {
  strm.msg = messages[errorCode];
  return errorCode;
};
var rank = (f) => {
  return f * 2 - (f > 4 ? 9 : 0);
};
var zero = (buf) => {
  let len = buf.length;
  while (--len >= 0) {
    buf[len] = 0;
  }
};
var slide_hash = (s) => {
  let n2, m;
  let p2;
  let wsize = s.w_size;
  n2 = s.hash_size;
  p2 = n2;
  do {
    m = s.head[--p2];
    s.head[p2] = m >= wsize ? m - wsize : 0;
  } while (--n2);
  n2 = wsize;
  p2 = n2;
  do {
    m = s.prev[--p2];
    s.prev[p2] = m >= wsize ? m - wsize : 0;
  } while (--n2);
};
var HASH_ZLIB = (s, prev, data3) => (prev << s.hash_shift ^ data3) & s.hash_mask;
var HASH = HASH_ZLIB;
var flush_pending = (strm) => {
  const s = strm.state;
  let len = s.pending;
  if (len > strm.avail_out) {
    len = strm.avail_out;
  }
  if (len === 0) {
    return;
  }
  strm.output.set(s.pending_buf.subarray(s.pending_out, s.pending_out + len), strm.next_out);
  strm.next_out += len;
  s.pending_out += len;
  strm.total_out += len;
  strm.avail_out -= len;
  s.pending -= len;
  if (s.pending === 0) {
    s.pending_out = 0;
  }
};
var flush_block_only = (s, last2) => {
  _tr_flush_block(s, s.block_start >= 0 ? s.block_start : -1, s.strstart - s.block_start, last2);
  s.block_start = s.strstart;
  flush_pending(s.strm);
};
var put_byte = (s, b2) => {
  s.pending_buf[s.pending++] = b2;
};
var putShortMSB = (s, b2) => {
  s.pending_buf[s.pending++] = b2 >>> 8 & 255;
  s.pending_buf[s.pending++] = b2 & 255;
};
var read_buf = (strm, buf, start, size) => {
  let len = strm.avail_in;
  if (len > size) {
    len = size;
  }
  if (len === 0) {
    return 0;
  }
  strm.avail_in -= len;
  buf.set(strm.input.subarray(strm.next_in, strm.next_in + len), start);
  if (strm.state.wrap === 1) {
    strm.adler = adler32_1(strm.adler, buf, len, start);
  } else if (strm.state.wrap === 2) {
    strm.adler = crc32_1(strm.adler, buf, len, start);
  }
  strm.next_in += len;
  strm.total_in += len;
  return len;
};
var longest_match = (s, cur_match) => {
  let chain_length = s.max_chain_length;
  let scan = s.strstart;
  let match;
  let len;
  let best_len = s.prev_length;
  let nice_match = s.nice_match;
  const limit = s.strstart > s.w_size - MIN_LOOKAHEAD ? s.strstart - (s.w_size - MIN_LOOKAHEAD) : 0;
  const _win = s.window;
  const wmask = s.w_mask;
  const prev = s.prev;
  const strend = s.strstart + MAX_MATCH;
  let scan_end1 = _win[scan + best_len - 1];
  let scan_end = _win[scan + best_len];
  if (s.prev_length >= s.good_match) {
    chain_length >>= 2;
  }
  if (nice_match > s.lookahead) {
    nice_match = s.lookahead;
  }
  do {
    match = cur_match;
    if (_win[match + best_len] !== scan_end || _win[match + best_len - 1] !== scan_end1 || _win[match] !== _win[scan] || _win[++match] !== _win[scan + 1]) {
      continue;
    }
    scan += 2;
    match++;
    do {} while (_win[++scan] === _win[++match] && _win[++scan] === _win[++match] && _win[++scan] === _win[++match] && _win[++scan] === _win[++match] && _win[++scan] === _win[++match] && _win[++scan] === _win[++match] && _win[++scan] === _win[++match] && _win[++scan] === _win[++match] && scan < strend);
    len = MAX_MATCH - (strend - scan);
    scan = strend - MAX_MATCH;
    if (len > best_len) {
      s.match_start = cur_match;
      best_len = len;
      if (len >= nice_match) {
        break;
      }
      scan_end1 = _win[scan + best_len - 1];
      scan_end = _win[scan + best_len];
    }
  } while ((cur_match = prev[cur_match & wmask]) > limit && --chain_length !== 0);
  if (best_len <= s.lookahead) {
    return best_len;
  }
  return s.lookahead;
};
var fill_window = (s) => {
  const _w_size = s.w_size;
  let n2, more, str;
  do {
    more = s.window_size - s.lookahead - s.strstart;
    if (s.strstart >= _w_size + (_w_size - MIN_LOOKAHEAD)) {
      s.window.set(s.window.subarray(_w_size, _w_size + _w_size - more), 0);
      s.match_start -= _w_size;
      s.strstart -= _w_size;
      s.block_start -= _w_size;
      if (s.insert > s.strstart) {
        s.insert = s.strstart;
      }
      slide_hash(s);
      more += _w_size;
    }
    if (s.strm.avail_in === 0) {
      break;
    }
    n2 = read_buf(s.strm, s.window, s.strstart + s.lookahead, more);
    s.lookahead += n2;
    if (s.lookahead + s.insert >= MIN_MATCH) {
      str = s.strstart - s.insert;
      s.ins_h = s.window[str];
      s.ins_h = HASH(s, s.ins_h, s.window[str + 1]);
      while (s.insert) {
        s.ins_h = HASH(s, s.ins_h, s.window[str + MIN_MATCH - 1]);
        s.prev[str & s.w_mask] = s.head[s.ins_h];
        s.head[s.ins_h] = str;
        str++;
        s.insert--;
        if (s.lookahead + s.insert < MIN_MATCH) {
          break;
        }
      }
    }
  } while (s.lookahead < MIN_LOOKAHEAD && s.strm.avail_in !== 0);
};
var deflate_stored = (s, flush) => {
  let min_block = s.pending_buf_size - 5 > s.w_size ? s.w_size : s.pending_buf_size - 5;
  let len, left, have, last2 = 0;
  let used = s.strm.avail_in;
  do {
    len = 65535;
    have = s.bi_valid + 42 >> 3;
    if (s.strm.avail_out < have) {
      break;
    }
    have = s.strm.avail_out - have;
    left = s.strstart - s.block_start;
    if (len > left + s.strm.avail_in) {
      len = left + s.strm.avail_in;
    }
    if (len > have) {
      len = have;
    }
    if (len < min_block && (len === 0 && flush !== Z_FINISH$3 || flush === Z_NO_FLUSH$2 || len !== left + s.strm.avail_in)) {
      break;
    }
    last2 = flush === Z_FINISH$3 && len === left + s.strm.avail_in ? 1 : 0;
    _tr_stored_block(s, 0, 0, last2);
    s.pending_buf[s.pending - 4] = len;
    s.pending_buf[s.pending - 3] = len >> 8;
    s.pending_buf[s.pending - 2] = ~len;
    s.pending_buf[s.pending - 1] = ~len >> 8;
    flush_pending(s.strm);
    if (left) {
      if (left > len) {
        left = len;
      }
      s.strm.output.set(s.window.subarray(s.block_start, s.block_start + left), s.strm.next_out);
      s.strm.next_out += left;
      s.strm.avail_out -= left;
      s.strm.total_out += left;
      s.block_start += left;
      len -= left;
    }
    if (len) {
      read_buf(s.strm, s.strm.output, s.strm.next_out, len);
      s.strm.next_out += len;
      s.strm.avail_out -= len;
      s.strm.total_out += len;
    }
  } while (last2 === 0);
  used -= s.strm.avail_in;
  if (used) {
    if (used >= s.w_size) {
      s.matches = 2;
      s.window.set(s.strm.input.subarray(s.strm.next_in - s.w_size, s.strm.next_in), 0);
      s.strstart = s.w_size;
      s.insert = s.strstart;
    } else {
      if (s.window_size - s.strstart <= used) {
        s.strstart -= s.w_size;
        s.window.set(s.window.subarray(s.w_size, s.w_size + s.strstart), 0);
        if (s.matches < 2) {
          s.matches++;
        }
        if (s.insert > s.strstart) {
          s.insert = s.strstart;
        }
      }
      s.window.set(s.strm.input.subarray(s.strm.next_in - used, s.strm.next_in), s.strstart);
      s.strstart += used;
      s.insert += used > s.w_size - s.insert ? s.w_size - s.insert : used;
    }
    s.block_start = s.strstart;
  }
  if (s.high_water < s.strstart) {
    s.high_water = s.strstart;
  }
  if (last2) {
    return BS_FINISH_DONE;
  }
  if (flush !== Z_NO_FLUSH$2 && flush !== Z_FINISH$3 && s.strm.avail_in === 0 && s.strstart === s.block_start) {
    return BS_BLOCK_DONE;
  }
  have = s.window_size - s.strstart;
  if (s.strm.avail_in > have && s.block_start >= s.w_size) {
    s.block_start -= s.w_size;
    s.strstart -= s.w_size;
    s.window.set(s.window.subarray(s.w_size, s.w_size + s.strstart), 0);
    if (s.matches < 2) {
      s.matches++;
    }
    have += s.w_size;
    if (s.insert > s.strstart) {
      s.insert = s.strstart;
    }
  }
  if (have > s.strm.avail_in) {
    have = s.strm.avail_in;
  }
  if (have) {
    read_buf(s.strm, s.window, s.strstart, have);
    s.strstart += have;
    s.insert += have > s.w_size - s.insert ? s.w_size - s.insert : have;
  }
  if (s.high_water < s.strstart) {
    s.high_water = s.strstart;
  }
  have = s.bi_valid + 42 >> 3;
  have = s.pending_buf_size - have > 65535 ? 65535 : s.pending_buf_size - have;
  min_block = have > s.w_size ? s.w_size : have;
  left = s.strstart - s.block_start;
  if (left >= min_block || (left || flush === Z_FINISH$3) && flush !== Z_NO_FLUSH$2 && s.strm.avail_in === 0 && left <= have) {
    len = left > have ? have : left;
    last2 = flush === Z_FINISH$3 && s.strm.avail_in === 0 && len === left ? 1 : 0;
    _tr_stored_block(s, s.block_start, len, last2);
    s.block_start += len;
    flush_pending(s.strm);
  }
  return last2 ? BS_FINISH_STARTED : BS_NEED_MORE;
};
var deflate_fast = (s, flush) => {
  let hash_head;
  let bflush;
  for (;; ) {
    if (s.lookahead < MIN_LOOKAHEAD) {
      fill_window(s);
      if (s.lookahead < MIN_LOOKAHEAD && flush === Z_NO_FLUSH$2) {
        return BS_NEED_MORE;
      }
      if (s.lookahead === 0) {
        break;
      }
    }
    hash_head = 0;
    if (s.lookahead >= MIN_MATCH) {
      s.ins_h = HASH(s, s.ins_h, s.window[s.strstart + MIN_MATCH - 1]);
      hash_head = s.prev[s.strstart & s.w_mask] = s.head[s.ins_h];
      s.head[s.ins_h] = s.strstart;
    }
    if (hash_head !== 0 && s.strstart - hash_head <= s.w_size - MIN_LOOKAHEAD) {
      s.match_length = longest_match(s, hash_head);
    }
    if (s.match_length >= MIN_MATCH) {
      bflush = _tr_tally(s, s.strstart - s.match_start, s.match_length - MIN_MATCH);
      s.lookahead -= s.match_length;
      if (s.match_length <= s.max_lazy_match && s.lookahead >= MIN_MATCH) {
        s.match_length--;
        do {
          s.strstart++;
          s.ins_h = HASH(s, s.ins_h, s.window[s.strstart + MIN_MATCH - 1]);
          hash_head = s.prev[s.strstart & s.w_mask] = s.head[s.ins_h];
          s.head[s.ins_h] = s.strstart;
        } while (--s.match_length !== 0);
        s.strstart++;
      } else {
        s.strstart += s.match_length;
        s.match_length = 0;
        s.ins_h = s.window[s.strstart];
        s.ins_h = HASH(s, s.ins_h, s.window[s.strstart + 1]);
      }
    } else {
      bflush = _tr_tally(s, 0, s.window[s.strstart]);
      s.lookahead--;
      s.strstart++;
    }
    if (bflush) {
      flush_block_only(s, false);
      if (s.strm.avail_out === 0) {
        return BS_NEED_MORE;
      }
    }
  }
  s.insert = s.strstart < MIN_MATCH - 1 ? s.strstart : MIN_MATCH - 1;
  if (flush === Z_FINISH$3) {
    flush_block_only(s, true);
    if (s.strm.avail_out === 0) {
      return BS_FINISH_STARTED;
    }
    return BS_FINISH_DONE;
  }
  if (s.sym_next) {
    flush_block_only(s, false);
    if (s.strm.avail_out === 0) {
      return BS_NEED_MORE;
    }
  }
  return BS_BLOCK_DONE;
};
var deflate_slow = (s, flush) => {
  let hash_head;
  let bflush;
  let max_insert;
  for (;; ) {
    if (s.lookahead < MIN_LOOKAHEAD) {
      fill_window(s);
      if (s.lookahead < MIN_LOOKAHEAD && flush === Z_NO_FLUSH$2) {
        return BS_NEED_MORE;
      }
      if (s.lookahead === 0) {
        break;
      }
    }
    hash_head = 0;
    if (s.lookahead >= MIN_MATCH) {
      s.ins_h = HASH(s, s.ins_h, s.window[s.strstart + MIN_MATCH - 1]);
      hash_head = s.prev[s.strstart & s.w_mask] = s.head[s.ins_h];
      s.head[s.ins_h] = s.strstart;
    }
    s.prev_length = s.match_length;
    s.prev_match = s.match_start;
    s.match_length = MIN_MATCH - 1;
    if (hash_head !== 0 && s.prev_length < s.max_lazy_match && s.strstart - hash_head <= s.w_size - MIN_LOOKAHEAD) {
      s.match_length = longest_match(s, hash_head);
      if (s.match_length <= 5 && (s.strategy === Z_FILTERED || s.match_length === MIN_MATCH && s.strstart - s.match_start > 4096)) {
        s.match_length = MIN_MATCH - 1;
      }
    }
    if (s.prev_length >= MIN_MATCH && s.match_length <= s.prev_length) {
      max_insert = s.strstart + s.lookahead - MIN_MATCH;
      bflush = _tr_tally(s, s.strstart - 1 - s.prev_match, s.prev_length - MIN_MATCH);
      s.lookahead -= s.prev_length - 1;
      s.prev_length -= 2;
      do {
        if (++s.strstart <= max_insert) {
          s.ins_h = HASH(s, s.ins_h, s.window[s.strstart + MIN_MATCH - 1]);
          hash_head = s.prev[s.strstart & s.w_mask] = s.head[s.ins_h];
          s.head[s.ins_h] = s.strstart;
        }
      } while (--s.prev_length !== 0);
      s.match_available = 0;
      s.match_length = MIN_MATCH - 1;
      s.strstart++;
      if (bflush) {
        flush_block_only(s, false);
        if (s.strm.avail_out === 0) {
          return BS_NEED_MORE;
        }
      }
    } else if (s.match_available) {
      bflush = _tr_tally(s, 0, s.window[s.strstart - 1]);
      if (bflush) {
        flush_block_only(s, false);
      }
      s.strstart++;
      s.lookahead--;
      if (s.strm.avail_out === 0) {
        return BS_NEED_MORE;
      }
    } else {
      s.match_available = 1;
      s.strstart++;
      s.lookahead--;
    }
  }
  if (s.match_available) {
    bflush = _tr_tally(s, 0, s.window[s.strstart - 1]);
    s.match_available = 0;
  }
  s.insert = s.strstart < MIN_MATCH - 1 ? s.strstart : MIN_MATCH - 1;
  if (flush === Z_FINISH$3) {
    flush_block_only(s, true);
    if (s.strm.avail_out === 0) {
      return BS_FINISH_STARTED;
    }
    return BS_FINISH_DONE;
  }
  if (s.sym_next) {
    flush_block_only(s, false);
    if (s.strm.avail_out === 0) {
      return BS_NEED_MORE;
    }
  }
  return BS_BLOCK_DONE;
};
var deflate_rle = (s, flush) => {
  let bflush;
  let prev;
  let scan, strend;
  const _win = s.window;
  for (;; ) {
    if (s.lookahead <= MAX_MATCH) {
      fill_window(s);
      if (s.lookahead <= MAX_MATCH && flush === Z_NO_FLUSH$2) {
        return BS_NEED_MORE;
      }
      if (s.lookahead === 0) {
        break;
      }
    }
    s.match_length = 0;
    if (s.lookahead >= MIN_MATCH && s.strstart > 0) {
      scan = s.strstart - 1;
      prev = _win[scan];
      if (prev === _win[++scan] && prev === _win[++scan] && prev === _win[++scan]) {
        strend = s.strstart + MAX_MATCH;
        do {} while (prev === _win[++scan] && prev === _win[++scan] && prev === _win[++scan] && prev === _win[++scan] && prev === _win[++scan] && prev === _win[++scan] && prev === _win[++scan] && prev === _win[++scan] && scan < strend);
        s.match_length = MAX_MATCH - (strend - scan);
        if (s.match_length > s.lookahead) {
          s.match_length = s.lookahead;
        }
      }
    }
    if (s.match_length >= MIN_MATCH) {
      bflush = _tr_tally(s, 1, s.match_length - MIN_MATCH);
      s.lookahead -= s.match_length;
      s.strstart += s.match_length;
      s.match_length = 0;
    } else {
      bflush = _tr_tally(s, 0, s.window[s.strstart]);
      s.lookahead--;
      s.strstart++;
    }
    if (bflush) {
      flush_block_only(s, false);
      if (s.strm.avail_out === 0) {
        return BS_NEED_MORE;
      }
    }
  }
  s.insert = 0;
  if (flush === Z_FINISH$3) {
    flush_block_only(s, true);
    if (s.strm.avail_out === 0) {
      return BS_FINISH_STARTED;
    }
    return BS_FINISH_DONE;
  }
  if (s.sym_next) {
    flush_block_only(s, false);
    if (s.strm.avail_out === 0) {
      return BS_NEED_MORE;
    }
  }
  return BS_BLOCK_DONE;
};
var deflate_huff = (s, flush) => {
  let bflush;
  for (;; ) {
    if (s.lookahead === 0) {
      fill_window(s);
      if (s.lookahead === 0) {
        if (flush === Z_NO_FLUSH$2) {
          return BS_NEED_MORE;
        }
        break;
      }
    }
    s.match_length = 0;
    bflush = _tr_tally(s, 0, s.window[s.strstart]);
    s.lookahead--;
    s.strstart++;
    if (bflush) {
      flush_block_only(s, false);
      if (s.strm.avail_out === 0) {
        return BS_NEED_MORE;
      }
    }
  }
  s.insert = 0;
  if (flush === Z_FINISH$3) {
    flush_block_only(s, true);
    if (s.strm.avail_out === 0) {
      return BS_FINISH_STARTED;
    }
    return BS_FINISH_DONE;
  }
  if (s.sym_next) {
    flush_block_only(s, false);
    if (s.strm.avail_out === 0) {
      return BS_NEED_MORE;
    }
  }
  return BS_BLOCK_DONE;
};
function Config(good_length, max_lazy, nice_length, max_chain, func) {
  this.good_length = good_length;
  this.max_lazy = max_lazy;
  this.nice_length = nice_length;
  this.max_chain = max_chain;
  this.func = func;
}
var configuration_table = [
  new Config(0, 0, 0, 0, deflate_stored),
  new Config(4, 4, 8, 4, deflate_fast),
  new Config(4, 5, 16, 8, deflate_fast),
  new Config(4, 6, 32, 32, deflate_fast),
  new Config(4, 4, 16, 16, deflate_slow),
  new Config(8, 16, 32, 32, deflate_slow),
  new Config(8, 16, 128, 128, deflate_slow),
  new Config(8, 32, 128, 256, deflate_slow),
  new Config(32, 128, 258, 1024, deflate_slow),
  new Config(32, 258, 258, 4096, deflate_slow)
];
var lm_init = (s) => {
  s.window_size = 2 * s.w_size;
  zero(s.head);
  s.max_lazy_match = configuration_table[s.level].max_lazy;
  s.good_match = configuration_table[s.level].good_length;
  s.nice_match = configuration_table[s.level].nice_length;
  s.max_chain_length = configuration_table[s.level].max_chain;
  s.strstart = 0;
  s.block_start = 0;
  s.lookahead = 0;
  s.insert = 0;
  s.match_length = s.prev_length = MIN_MATCH - 1;
  s.match_available = 0;
  s.ins_h = 0;
};
function DeflateState() {
  this.strm = null;
  this.status = 0;
  this.pending_buf = null;
  this.pending_buf_size = 0;
  this.pending_out = 0;
  this.pending = 0;
  this.wrap = 0;
  this.gzhead = null;
  this.gzindex = 0;
  this.method = Z_DEFLATED$2;
  this.last_flush = -1;
  this.w_size = 0;
  this.w_bits = 0;
  this.w_mask = 0;
  this.window = null;
  this.window_size = 0;
  this.prev = null;
  this.head = null;
  this.ins_h = 0;
  this.hash_size = 0;
  this.hash_bits = 0;
  this.hash_mask = 0;
  this.hash_shift = 0;
  this.block_start = 0;
  this.match_length = 0;
  this.prev_match = 0;
  this.match_available = 0;
  this.strstart = 0;
  this.match_start = 0;
  this.lookahead = 0;
  this.prev_length = 0;
  this.max_chain_length = 0;
  this.max_lazy_match = 0;
  this.level = 0;
  this.strategy = 0;
  this.good_match = 0;
  this.nice_match = 0;
  this.dyn_ltree = new Uint16Array(HEAP_SIZE * 2);
  this.dyn_dtree = new Uint16Array((2 * D_CODES + 1) * 2);
  this.bl_tree = new Uint16Array((2 * BL_CODES + 1) * 2);
  zero(this.dyn_ltree);
  zero(this.dyn_dtree);
  zero(this.bl_tree);
  this.l_desc = null;
  this.d_desc = null;
  this.bl_desc = null;
  this.bl_count = new Uint16Array(MAX_BITS + 1);
  this.heap = new Uint16Array(2 * L_CODES + 1);
  zero(this.heap);
  this.heap_len = 0;
  this.heap_max = 0;
  this.depth = new Uint16Array(2 * L_CODES + 1);
  zero(this.depth);
  this.sym_buf = 0;
  this.lit_bufsize = 0;
  this.sym_next = 0;
  this.sym_end = 0;
  this.opt_len = 0;
  this.static_len = 0;
  this.matches = 0;
  this.insert = 0;
  this.bi_buf = 0;
  this.bi_valid = 0;
}
var deflateStateCheck = (strm) => {
  if (!strm) {
    return 1;
  }
  const s = strm.state;
  if (!s || s.strm !== strm || s.status !== INIT_STATE && s.status !== GZIP_STATE && s.status !== EXTRA_STATE && s.status !== NAME_STATE && s.status !== COMMENT_STATE && s.status !== HCRC_STATE && s.status !== BUSY_STATE && s.status !== FINISH_STATE) {
    return 1;
  }
  return 0;
};
var deflateResetKeep = (strm) => {
  if (deflateStateCheck(strm)) {
    return err(strm, Z_STREAM_ERROR$2);
  }
  strm.total_in = strm.total_out = 0;
  strm.data_type = Z_UNKNOWN;
  const s = strm.state;
  s.pending = 0;
  s.pending_out = 0;
  if (s.wrap < 0) {
    s.wrap = -s.wrap;
  }
  s.status = s.wrap === 2 ? GZIP_STATE : s.wrap ? INIT_STATE : BUSY_STATE;
  strm.adler = s.wrap === 2 ? 0 : 1;
  s.last_flush = -2;
  _tr_init(s);
  return Z_OK$3;
};
var deflateReset = (strm) => {
  const ret = deflateResetKeep(strm);
  if (ret === Z_OK$3) {
    lm_init(strm.state);
  }
  return ret;
};
var deflateSetHeader = (strm, head) => {
  if (deflateStateCheck(strm) || strm.state.wrap !== 2) {
    return Z_STREAM_ERROR$2;
  }
  strm.state.gzhead = head;
  return Z_OK$3;
};
var deflateInit2 = (strm, level, method, windowBits, memLevel, strategy) => {
  if (!strm) {
    return Z_STREAM_ERROR$2;
  }
  let wrap = 1;
  if (level === Z_DEFAULT_COMPRESSION$1) {
    level = 6;
  }
  if (windowBits < 0) {
    wrap = 0;
    windowBits = -windowBits;
  } else if (windowBits > 15) {
    wrap = 2;
    windowBits -= 16;
  }
  if (memLevel < 1 || memLevel > MAX_MEM_LEVEL || method !== Z_DEFLATED$2 || windowBits < 8 || windowBits > 15 || level < 0 || level > 9 || strategy < 0 || strategy > Z_FIXED || windowBits === 8 && wrap !== 1) {
    return err(strm, Z_STREAM_ERROR$2);
  }
  if (windowBits === 8) {
    windowBits = 9;
  }
  const s = new DeflateState;
  strm.state = s;
  s.strm = strm;
  s.status = INIT_STATE;
  s.wrap = wrap;
  s.gzhead = null;
  s.w_bits = windowBits;
  s.w_size = 1 << s.w_bits;
  s.w_mask = s.w_size - 1;
  s.hash_bits = memLevel + 7;
  s.hash_size = 1 << s.hash_bits;
  s.hash_mask = s.hash_size - 1;
  s.hash_shift = ~~((s.hash_bits + MIN_MATCH - 1) / MIN_MATCH);
  s.window = new Uint8Array(s.w_size * 2);
  s.head = new Uint16Array(s.hash_size);
  s.prev = new Uint16Array(s.w_size);
  s.lit_bufsize = 1 << memLevel + 6;
  s.pending_buf_size = s.lit_bufsize * 4;
  s.pending_buf = new Uint8Array(s.pending_buf_size);
  s.sym_buf = s.lit_bufsize;
  s.sym_end = (s.lit_bufsize - 1) * 3;
  s.level = level;
  s.strategy = strategy;
  s.method = method;
  return deflateReset(strm);
};
var deflateInit = (strm, level) => {
  return deflateInit2(strm, level, Z_DEFLATED$2, MAX_WBITS$1, DEF_MEM_LEVEL, Z_DEFAULT_STRATEGY$1);
};
var deflate$2 = (strm, flush) => {
  if (deflateStateCheck(strm) || flush > Z_BLOCK$1 || flush < 0) {
    return strm ? err(strm, Z_STREAM_ERROR$2) : Z_STREAM_ERROR$2;
  }
  const s = strm.state;
  if (!strm.output || strm.avail_in !== 0 && !strm.input || s.status === FINISH_STATE && flush !== Z_FINISH$3) {
    return err(strm, strm.avail_out === 0 ? Z_BUF_ERROR$1 : Z_STREAM_ERROR$2);
  }
  const old_flush = s.last_flush;
  s.last_flush = flush;
  if (s.pending !== 0) {
    flush_pending(strm);
    if (strm.avail_out === 0) {
      s.last_flush = -1;
      return Z_OK$3;
    }
  } else if (strm.avail_in === 0 && rank(flush) <= rank(old_flush) && flush !== Z_FINISH$3) {
    return err(strm, Z_BUF_ERROR$1);
  }
  if (s.status === FINISH_STATE && strm.avail_in !== 0) {
    return err(strm, Z_BUF_ERROR$1);
  }
  if (s.status === INIT_STATE && s.wrap === 0) {
    s.status = BUSY_STATE;
  }
  if (s.status === INIT_STATE) {
    let header = Z_DEFLATED$2 + (s.w_bits - 8 << 4) << 8;
    let level_flags = -1;
    if (s.strategy >= Z_HUFFMAN_ONLY || s.level < 2) {
      level_flags = 0;
    } else if (s.level < 6) {
      level_flags = 1;
    } else if (s.level === 6) {
      level_flags = 2;
    } else {
      level_flags = 3;
    }
    header |= level_flags << 6;
    if (s.strstart !== 0) {
      header |= PRESET_DICT;
    }
    header += 31 - header % 31;
    putShortMSB(s, header);
    if (s.strstart !== 0) {
      putShortMSB(s, strm.adler >>> 16);
      putShortMSB(s, strm.adler & 65535);
    }
    strm.adler = 1;
    s.status = BUSY_STATE;
    flush_pending(strm);
    if (s.pending !== 0) {
      s.last_flush = -1;
      return Z_OK$3;
    }
  }
  if (s.status === GZIP_STATE) {
    strm.adler = 0;
    put_byte(s, 31);
    put_byte(s, 139);
    put_byte(s, 8);
    if (!s.gzhead) {
      put_byte(s, 0);
      put_byte(s, 0);
      put_byte(s, 0);
      put_byte(s, 0);
      put_byte(s, 0);
      put_byte(s, s.level === 9 ? 2 : s.strategy >= Z_HUFFMAN_ONLY || s.level < 2 ? 4 : 0);
      put_byte(s, OS_CODE);
      s.status = BUSY_STATE;
      flush_pending(strm);
      if (s.pending !== 0) {
        s.last_flush = -1;
        return Z_OK$3;
      }
    } else {
      put_byte(s, (s.gzhead.text ? 1 : 0) + (s.gzhead.hcrc ? 2 : 0) + (!s.gzhead.extra ? 0 : 4) + (!s.gzhead.name ? 0 : 8) + (!s.gzhead.comment ? 0 : 16));
      put_byte(s, s.gzhead.time & 255);
      put_byte(s, s.gzhead.time >> 8 & 255);
      put_byte(s, s.gzhead.time >> 16 & 255);
      put_byte(s, s.gzhead.time >> 24 & 255);
      put_byte(s, s.level === 9 ? 2 : s.strategy >= Z_HUFFMAN_ONLY || s.level < 2 ? 4 : 0);
      put_byte(s, s.gzhead.os & 255);
      if (s.gzhead.extra && s.gzhead.extra.length) {
        put_byte(s, s.gzhead.extra.length & 255);
        put_byte(s, s.gzhead.extra.length >> 8 & 255);
      }
      if (s.gzhead.hcrc) {
        strm.adler = crc32_1(strm.adler, s.pending_buf, s.pending, 0);
      }
      s.gzindex = 0;
      s.status = EXTRA_STATE;
    }
  }
  if (s.status === EXTRA_STATE) {
    if (s.gzhead.extra) {
      let beg = s.pending;
      let left = (s.gzhead.extra.length & 65535) - s.gzindex;
      while (s.pending + left > s.pending_buf_size) {
        let copy2 = s.pending_buf_size - s.pending;
        s.pending_buf.set(s.gzhead.extra.subarray(s.gzindex, s.gzindex + copy2), s.pending);
        s.pending = s.pending_buf_size;
        if (s.gzhead.hcrc && s.pending > beg) {
          strm.adler = crc32_1(strm.adler, s.pending_buf, s.pending - beg, beg);
        }
        s.gzindex += copy2;
        flush_pending(strm);
        if (s.pending !== 0) {
          s.last_flush = -1;
          return Z_OK$3;
        }
        beg = 0;
        left -= copy2;
      }
      let gzhead_extra = new Uint8Array(s.gzhead.extra);
      s.pending_buf.set(gzhead_extra.subarray(s.gzindex, s.gzindex + left), s.pending);
      s.pending += left;
      if (s.gzhead.hcrc && s.pending > beg) {
        strm.adler = crc32_1(strm.adler, s.pending_buf, s.pending - beg, beg);
      }
      s.gzindex = 0;
    }
    s.status = NAME_STATE;
  }
  if (s.status === NAME_STATE) {
    if (s.gzhead.name) {
      let beg = s.pending;
      let val;
      do {
        if (s.pending === s.pending_buf_size) {
          if (s.gzhead.hcrc && s.pending > beg) {
            strm.adler = crc32_1(strm.adler, s.pending_buf, s.pending - beg, beg);
          }
          flush_pending(strm);
          if (s.pending !== 0) {
            s.last_flush = -1;
            return Z_OK$3;
          }
          beg = 0;
        }
        if (s.gzindex < s.gzhead.name.length) {
          val = s.gzhead.name.charCodeAt(s.gzindex++) & 255;
        } else {
          val = 0;
        }
        put_byte(s, val);
      } while (val !== 0);
      if (s.gzhead.hcrc && s.pending > beg) {
        strm.adler = crc32_1(strm.adler, s.pending_buf, s.pending - beg, beg);
      }
      s.gzindex = 0;
    }
    s.status = COMMENT_STATE;
  }
  if (s.status === COMMENT_STATE) {
    if (s.gzhead.comment) {
      let beg = s.pending;
      let val;
      do {
        if (s.pending === s.pending_buf_size) {
          if (s.gzhead.hcrc && s.pending > beg) {
            strm.adler = crc32_1(strm.adler, s.pending_buf, s.pending - beg, beg);
          }
          flush_pending(strm);
          if (s.pending !== 0) {
            s.last_flush = -1;
            return Z_OK$3;
          }
          beg = 0;
        }
        if (s.gzindex < s.gzhead.comment.length) {
          val = s.gzhead.comment.charCodeAt(s.gzindex++) & 255;
        } else {
          val = 0;
        }
        put_byte(s, val);
      } while (val !== 0);
      if (s.gzhead.hcrc && s.pending > beg) {
        strm.adler = crc32_1(strm.adler, s.pending_buf, s.pending - beg, beg);
      }
    }
    s.status = HCRC_STATE;
  }
  if (s.status === HCRC_STATE) {
    if (s.gzhead.hcrc) {
      if (s.pending + 2 > s.pending_buf_size) {
        flush_pending(strm);
        if (s.pending !== 0) {
          s.last_flush = -1;
          return Z_OK$3;
        }
      }
      put_byte(s, strm.adler & 255);
      put_byte(s, strm.adler >> 8 & 255);
      strm.adler = 0;
    }
    s.status = BUSY_STATE;
    flush_pending(strm);
    if (s.pending !== 0) {
      s.last_flush = -1;
      return Z_OK$3;
    }
  }
  if (strm.avail_in !== 0 || s.lookahead !== 0 || flush !== Z_NO_FLUSH$2 && s.status !== FINISH_STATE) {
    let bstate = s.level === 0 ? deflate_stored(s, flush) : s.strategy === Z_HUFFMAN_ONLY ? deflate_huff(s, flush) : s.strategy === Z_RLE ? deflate_rle(s, flush) : configuration_table[s.level].func(s, flush);
    if (bstate === BS_FINISH_STARTED || bstate === BS_FINISH_DONE) {
      s.status = FINISH_STATE;
    }
    if (bstate === BS_NEED_MORE || bstate === BS_FINISH_STARTED) {
      if (strm.avail_out === 0) {
        s.last_flush = -1;
      }
      return Z_OK$3;
    }
    if (bstate === BS_BLOCK_DONE) {
      if (flush === Z_PARTIAL_FLUSH) {
        _tr_align(s);
      } else if (flush !== Z_BLOCK$1) {
        _tr_stored_block(s, 0, 0, false);
        if (flush === Z_FULL_FLUSH$1) {
          zero(s.head);
          if (s.lookahead === 0) {
            s.strstart = 0;
            s.block_start = 0;
            s.insert = 0;
          }
        }
      }
      flush_pending(strm);
      if (strm.avail_out === 0) {
        s.last_flush = -1;
        return Z_OK$3;
      }
    }
  }
  if (flush !== Z_FINISH$3) {
    return Z_OK$3;
  }
  if (s.wrap <= 0) {
    return Z_STREAM_END$3;
  }
  if (s.wrap === 2) {
    put_byte(s, strm.adler & 255);
    put_byte(s, strm.adler >> 8 & 255);
    put_byte(s, strm.adler >> 16 & 255);
    put_byte(s, strm.adler >> 24 & 255);
    put_byte(s, strm.total_in & 255);
    put_byte(s, strm.total_in >> 8 & 255);
    put_byte(s, strm.total_in >> 16 & 255);
    put_byte(s, strm.total_in >> 24 & 255);
  } else {
    putShortMSB(s, strm.adler >>> 16);
    putShortMSB(s, strm.adler & 65535);
  }
  flush_pending(strm);
  if (s.wrap > 0) {
    s.wrap = -s.wrap;
  }
  return s.pending !== 0 ? Z_OK$3 : Z_STREAM_END$3;
};
var deflateEnd = (strm) => {
  if (deflateStateCheck(strm)) {
    return Z_STREAM_ERROR$2;
  }
  const status = strm.state.status;
  strm.state = null;
  return status === BUSY_STATE ? err(strm, Z_DATA_ERROR$2) : Z_OK$3;
};
var deflateSetDictionary = (strm, dictionary) => {
  let dictLength = dictionary.length;
  if (deflateStateCheck(strm)) {
    return Z_STREAM_ERROR$2;
  }
  const s = strm.state;
  const wrap = s.wrap;
  if (wrap === 2 || wrap === 1 && s.status !== INIT_STATE || s.lookahead) {
    return Z_STREAM_ERROR$2;
  }
  if (wrap === 1) {
    strm.adler = adler32_1(strm.adler, dictionary, dictLength, 0);
  }
  s.wrap = 0;
  if (dictLength >= s.w_size) {
    if (wrap === 0) {
      zero(s.head);
      s.strstart = 0;
      s.block_start = 0;
      s.insert = 0;
    }
    let tmpDict = new Uint8Array(s.w_size);
    tmpDict.set(dictionary.subarray(dictLength - s.w_size, dictLength), 0);
    dictionary = tmpDict;
    dictLength = s.w_size;
  }
  const avail = strm.avail_in;
  const next = strm.next_in;
  const input = strm.input;
  strm.avail_in = dictLength;
  strm.next_in = 0;
  strm.input = dictionary;
  fill_window(s);
  while (s.lookahead >= MIN_MATCH) {
    let str = s.strstart;
    let n2 = s.lookahead - (MIN_MATCH - 1);
    do {
      s.ins_h = HASH(s, s.ins_h, s.window[str + MIN_MATCH - 1]);
      s.prev[str & s.w_mask] = s.head[s.ins_h];
      s.head[s.ins_h] = str;
      str++;
    } while (--n2);
    s.strstart = str;
    s.lookahead = MIN_MATCH - 1;
    fill_window(s);
  }
  s.strstart += s.lookahead;
  s.block_start = s.strstart;
  s.insert = s.lookahead;
  s.lookahead = 0;
  s.match_length = s.prev_length = MIN_MATCH - 1;
  s.match_available = 0;
  strm.next_in = next;
  strm.input = input;
  strm.avail_in = avail;
  s.wrap = wrap;
  return Z_OK$3;
};
var deflateInit_1 = deflateInit;
var deflateInit2_1 = deflateInit2;
var deflateReset_1 = deflateReset;
var deflateResetKeep_1 = deflateResetKeep;
var deflateSetHeader_1 = deflateSetHeader;
var deflate_2$1 = deflate$2;
var deflateEnd_1 = deflateEnd;
var deflateSetDictionary_1 = deflateSetDictionary;
var deflateInfo = "pako deflate (from Nodeca project)";
var deflate_1$2 = {
  deflateInit: deflateInit_1,
  deflateInit2: deflateInit2_1,
  deflateReset: deflateReset_1,
  deflateResetKeep: deflateResetKeep_1,
  deflateSetHeader: deflateSetHeader_1,
  deflate: deflate_2$1,
  deflateEnd: deflateEnd_1,
  deflateSetDictionary: deflateSetDictionary_1,
  deflateInfo
};
var _has = (obj, key) => {
  return Object.prototype.hasOwnProperty.call(obj, key);
};
var assign = function(obj) {
  const sources = Array.prototype.slice.call(arguments, 1);
  while (sources.length) {
    const source = sources.shift();
    if (!source) {
      continue;
    }
    if (typeof source !== "object") {
      throw new TypeError(source + "must be non-object");
    }
    for (const p2 in source) {
      if (_has(source, p2)) {
        obj[p2] = source[p2];
      }
    }
  }
  return obj;
};
var flattenChunks = (chunks) => {
  let len = 0;
  for (let i2 = 0, l = chunks.length;i2 < l; i2++) {
    len += chunks[i2].length;
  }
  const result = new Uint8Array(len);
  for (let i2 = 0, pos = 0, l = chunks.length;i2 < l; i2++) {
    let chunk = chunks[i2];
    result.set(chunk, pos);
    pos += chunk.length;
  }
  return result;
};
var common = {
  assign,
  flattenChunks
};
var STR_APPLY_UIA_OK = true;
try {
  String.fromCharCode.apply(null, new Uint8Array(1));
} catch (__) {
  STR_APPLY_UIA_OK = false;
}
var _utf8len = new Uint8Array(256);
for (let q = 0;q < 256; q++) {
  _utf8len[q] = q >= 252 ? 6 : q >= 248 ? 5 : q >= 240 ? 4 : q >= 224 ? 3 : q >= 192 ? 2 : 1;
}
_utf8len[254] = _utf8len[254] = 1;
var string2buf = (str) => {
  if (typeof TextEncoder === "function" && TextEncoder.prototype.encode) {
    return new TextEncoder().encode(str);
  }
  let buf, c, c23, m_pos, i2, str_len = str.length, buf_len = 0;
  for (m_pos = 0;m_pos < str_len; m_pos++) {
    c = str.charCodeAt(m_pos);
    if ((c & 64512) === 55296 && m_pos + 1 < str_len) {
      c23 = str.charCodeAt(m_pos + 1);
      if ((c23 & 64512) === 56320) {
        c = 65536 + (c - 55296 << 10) + (c23 - 56320);
        m_pos++;
      }
    }
    buf_len += c < 128 ? 1 : c < 2048 ? 2 : c < 65536 ? 3 : 4;
  }
  buf = new Uint8Array(buf_len);
  for (i2 = 0, m_pos = 0;i2 < buf_len; m_pos++) {
    c = str.charCodeAt(m_pos);
    if ((c & 64512) === 55296 && m_pos + 1 < str_len) {
      c23 = str.charCodeAt(m_pos + 1);
      if ((c23 & 64512) === 56320) {
        c = 65536 + (c - 55296 << 10) + (c23 - 56320);
        m_pos++;
      }
    }
    if (c < 128) {
      buf[i2++] = c;
    } else if (c < 2048) {
      buf[i2++] = 192 | c >>> 6;
      buf[i2++] = 128 | c & 63;
    } else if (c < 65536) {
      buf[i2++] = 224 | c >>> 12;
      buf[i2++] = 128 | c >>> 6 & 63;
      buf[i2++] = 128 | c & 63;
    } else {
      buf[i2++] = 240 | c >>> 18;
      buf[i2++] = 128 | c >>> 12 & 63;
      buf[i2++] = 128 | c >>> 6 & 63;
      buf[i2++] = 128 | c & 63;
    }
  }
  return buf;
};
var buf2binstring = (buf, len) => {
  if (len < 65534) {
    if (buf.subarray && STR_APPLY_UIA_OK) {
      return String.fromCharCode.apply(null, buf.length === len ? buf : buf.subarray(0, len));
    }
  }
  let result = "";
  for (let i2 = 0;i2 < len; i2++) {
    result += String.fromCharCode(buf[i2]);
  }
  return result;
};
var buf2string = (buf, max) => {
  const len = max || buf.length;
  if (typeof TextDecoder === "function" && TextDecoder.prototype.decode) {
    return new TextDecoder().decode(buf.subarray(0, max));
  }
  let i2, out;
  const utf16buf = new Array(len * 2);
  for (out = 0, i2 = 0;i2 < len; ) {
    let c = buf[i2++];
    if (c < 128) {
      utf16buf[out++] = c;
      continue;
    }
    let c_len = _utf8len[c];
    if (c_len > 4) {
      utf16buf[out++] = 65533;
      i2 += c_len - 1;
      continue;
    }
    c &= c_len === 2 ? 31 : c_len === 3 ? 15 : 7;
    while (c_len > 1 && i2 < len) {
      c = c << 6 | buf[i2++] & 63;
      c_len--;
    }
    if (c_len > 1) {
      utf16buf[out++] = 65533;
      continue;
    }
    if (c < 65536) {
      utf16buf[out++] = c;
    } else {
      c -= 65536;
      utf16buf[out++] = 55296 | c >> 10 & 1023;
      utf16buf[out++] = 56320 | c & 1023;
    }
  }
  return buf2binstring(utf16buf, out);
};
var utf8border = (buf, max) => {
  max = max || buf.length;
  if (max > buf.length) {
    max = buf.length;
  }
  let pos = max - 1;
  while (pos >= 0 && (buf[pos] & 192) === 128) {
    pos--;
  }
  if (pos < 0) {
    return max;
  }
  if (pos === 0) {
    return max;
  }
  return pos + _utf8len[buf[pos]] > max ? pos : max;
};
var strings2 = {
  string2buf,
  buf2string,
  utf8border
};
function ZStream() {
  this.input = null;
  this.next_in = 0;
  this.avail_in = 0;
  this.total_in = 0;
  this.output = null;
  this.next_out = 0;
  this.avail_out = 0;
  this.total_out = 0;
  this.msg = "";
  this.state = null;
  this.data_type = 2;
  this.adler = 0;
}
var zstream = ZStream;
var toString$1 = Object.prototype.toString;
var {
  Z_NO_FLUSH: Z_NO_FLUSH$1,
  Z_SYNC_FLUSH,
  Z_FULL_FLUSH,
  Z_FINISH: Z_FINISH$2,
  Z_OK: Z_OK$2,
  Z_STREAM_END: Z_STREAM_END$2,
  Z_DEFAULT_COMPRESSION,
  Z_DEFAULT_STRATEGY,
  Z_DEFLATED: Z_DEFLATED$1
} = constants$2;
function Deflate$1(options2) {
  this.options = common.assign({
    level: Z_DEFAULT_COMPRESSION,
    method: Z_DEFLATED$1,
    chunkSize: 16384,
    windowBits: 15,
    memLevel: 8,
    strategy: Z_DEFAULT_STRATEGY
  }, options2 || {});
  let opt = this.options;
  if (opt.raw && opt.windowBits > 0) {
    opt.windowBits = -opt.windowBits;
  } else if (opt.gzip && opt.windowBits > 0 && opt.windowBits < 16) {
    opt.windowBits += 16;
  }
  this.err = 0;
  this.msg = "";
  this.ended = false;
  this.chunks = [];
  this.strm = new zstream;
  this.strm.avail_out = 0;
  let status = deflate_1$2.deflateInit2(this.strm, opt.level, opt.method, opt.windowBits, opt.memLevel, opt.strategy);
  if (status !== Z_OK$2) {
    throw new Error(messages[status]);
  }
  if (opt.header) {
    deflate_1$2.deflateSetHeader(this.strm, opt.header);
  }
  if (opt.dictionary) {
    let dict;
    if (typeof opt.dictionary === "string") {
      dict = strings2.string2buf(opt.dictionary);
    } else if (toString$1.call(opt.dictionary) === "[object ArrayBuffer]") {
      dict = new Uint8Array(opt.dictionary);
    } else {
      dict = opt.dictionary;
    }
    status = deflate_1$2.deflateSetDictionary(this.strm, dict);
    if (status !== Z_OK$2) {
      throw new Error(messages[status]);
    }
    this._dict_set = true;
  }
}
Deflate$1.prototype.push = function(data3, flush_mode) {
  const strm = this.strm;
  const chunkSize = this.options.chunkSize;
  let status, _flush_mode;
  if (this.ended) {
    return false;
  }
  if (flush_mode === ~~flush_mode)
    _flush_mode = flush_mode;
  else
    _flush_mode = flush_mode === true ? Z_FINISH$2 : Z_NO_FLUSH$1;
  if (typeof data3 === "string") {
    strm.input = strings2.string2buf(data3);
  } else if (toString$1.call(data3) === "[object ArrayBuffer]") {
    strm.input = new Uint8Array(data3);
  } else {
    strm.input = data3;
  }
  strm.next_in = 0;
  strm.avail_in = strm.input.length;
  for (;; ) {
    if (strm.avail_out === 0) {
      strm.output = new Uint8Array(chunkSize);
      strm.next_out = 0;
      strm.avail_out = chunkSize;
    }
    if ((_flush_mode === Z_SYNC_FLUSH || _flush_mode === Z_FULL_FLUSH) && strm.avail_out <= 6) {
      this.onData(strm.output.subarray(0, strm.next_out));
      strm.avail_out = 0;
      continue;
    }
    status = deflate_1$2.deflate(strm, _flush_mode);
    if (status === Z_STREAM_END$2) {
      if (strm.next_out > 0) {
        this.onData(strm.output.subarray(0, strm.next_out));
      }
      status = deflate_1$2.deflateEnd(this.strm);
      this.onEnd(status);
      this.ended = true;
      return status === Z_OK$2;
    }
    if (strm.avail_out === 0) {
      this.onData(strm.output);
      continue;
    }
    if (_flush_mode > 0 && strm.next_out > 0) {
      this.onData(strm.output.subarray(0, strm.next_out));
      strm.avail_out = 0;
      continue;
    }
    if (strm.avail_in === 0)
      break;
  }
  return true;
};
Deflate$1.prototype.onData = function(chunk) {
  this.chunks.push(chunk);
};
Deflate$1.prototype.onEnd = function(status) {
  if (status === Z_OK$2) {
    this.result = common.flattenChunks(this.chunks);
  }
  this.chunks = [];
  this.err = status;
  this.msg = this.strm.msg;
};
var BAD$1 = 16209;
var TYPE$1 = 16191;
var inffast = function inflate_fast(strm, start) {
  let _in;
  let last2;
  let _out;
  let beg;
  let end;
  let dmax;
  let wsize;
  let whave;
  let wnext;
  let s_window;
  let hold;
  let bits;
  let lcode;
  let dcode;
  let lmask;
  let dmask;
  let here;
  let op;
  let len;
  let dist;
  let from;
  let from_source;
  let input, output2;
  const state = strm.state;
  _in = strm.next_in;
  input = strm.input;
  last2 = _in + (strm.avail_in - 5);
  _out = strm.next_out;
  output2 = strm.output;
  beg = _out - (start - strm.avail_out);
  end = _out + (strm.avail_out - 257);
  dmax = state.dmax;
  wsize = state.wsize;
  whave = state.whave;
  wnext = state.wnext;
  s_window = state.window;
  hold = state.hold;
  bits = state.bits;
  lcode = state.lencode;
  dcode = state.distcode;
  lmask = (1 << state.lenbits) - 1;
  dmask = (1 << state.distbits) - 1;
  top:
    do {
      if (bits < 15) {
        hold += input[_in++] << bits;
        bits += 8;
        hold += input[_in++] << bits;
        bits += 8;
      }
      here = lcode[hold & lmask];
      dolen:
        for (;; ) {
          op = here >>> 24;
          hold >>>= op;
          bits -= op;
          op = here >>> 16 & 255;
          if (op === 0) {
            output2[_out++] = here & 65535;
          } else if (op & 16) {
            len = here & 65535;
            op &= 15;
            if (op) {
              if (bits < op) {
                hold += input[_in++] << bits;
                bits += 8;
              }
              len += hold & (1 << op) - 1;
              hold >>>= op;
              bits -= op;
            }
            if (bits < 15) {
              hold += input[_in++] << bits;
              bits += 8;
              hold += input[_in++] << bits;
              bits += 8;
            }
            here = dcode[hold & dmask];
            dodist:
              for (;; ) {
                op = here >>> 24;
                hold >>>= op;
                bits -= op;
                op = here >>> 16 & 255;
                if (op & 16) {
                  dist = here & 65535;
                  op &= 15;
                  if (bits < op) {
                    hold += input[_in++] << bits;
                    bits += 8;
                    if (bits < op) {
                      hold += input[_in++] << bits;
                      bits += 8;
                    }
                  }
                  dist += hold & (1 << op) - 1;
                  if (dist > dmax) {
                    strm.msg = "invalid distance too far back";
                    state.mode = BAD$1;
                    break top;
                  }
                  hold >>>= op;
                  bits -= op;
                  op = _out - beg;
                  if (dist > op) {
                    op = dist - op;
                    if (op > whave) {
                      if (state.sane) {
                        strm.msg = "invalid distance too far back";
                        state.mode = BAD$1;
                        break top;
                      }
                    }
                    from = 0;
                    from_source = s_window;
                    if (wnext === 0) {
                      from += wsize - op;
                      if (op < len) {
                        len -= op;
                        do {
                          output2[_out++] = s_window[from++];
                        } while (--op);
                        from = _out - dist;
                        from_source = output2;
                      }
                    } else if (wnext < op) {
                      from += wsize + wnext - op;
                      op -= wnext;
                      if (op < len) {
                        len -= op;
                        do {
                          output2[_out++] = s_window[from++];
                        } while (--op);
                        from = 0;
                        if (wnext < len) {
                          op = wnext;
                          len -= op;
                          do {
                            output2[_out++] = s_window[from++];
                          } while (--op);
                          from = _out - dist;
                          from_source = output2;
                        }
                      }
                    } else {
                      from += wnext - op;
                      if (op < len) {
                        len -= op;
                        do {
                          output2[_out++] = s_window[from++];
                        } while (--op);
                        from = _out - dist;
                        from_source = output2;
                      }
                    }
                    while (len > 2) {
                      output2[_out++] = from_source[from++];
                      output2[_out++] = from_source[from++];
                      output2[_out++] = from_source[from++];
                      len -= 3;
                    }
                    if (len) {
                      output2[_out++] = from_source[from++];
                      if (len > 1) {
                        output2[_out++] = from_source[from++];
                      }
                    }
                  } else {
                    from = _out - dist;
                    do {
                      output2[_out++] = output2[from++];
                      output2[_out++] = output2[from++];
                      output2[_out++] = output2[from++];
                      len -= 3;
                    } while (len > 2);
                    if (len) {
                      output2[_out++] = output2[from++];
                      if (len > 1) {
                        output2[_out++] = output2[from++];
                      }
                    }
                  }
                } else if ((op & 64) === 0) {
                  here = dcode[(here & 65535) + (hold & (1 << op) - 1)];
                  continue dodist;
                } else {
                  strm.msg = "invalid distance code";
                  state.mode = BAD$1;
                  break top;
                }
                break;
              }
          } else if ((op & 64) === 0) {
            here = lcode[(here & 65535) + (hold & (1 << op) - 1)];
            continue dolen;
          } else if (op & 32) {
            state.mode = TYPE$1;
            break top;
          } else {
            strm.msg = "invalid literal/length code";
            state.mode = BAD$1;
            break top;
          }
          break;
        }
    } while (_in < last2 && _out < end);
  len = bits >> 3;
  _in -= len;
  bits -= len << 3;
  hold &= (1 << bits) - 1;
  strm.next_in = _in;
  strm.next_out = _out;
  strm.avail_in = _in < last2 ? 5 + (last2 - _in) : 5 - (_in - last2);
  strm.avail_out = _out < end ? 257 + (end - _out) : 257 - (_out - end);
  state.hold = hold;
  state.bits = bits;
  return;
};
var MAXBITS = 15;
var ENOUGH_LENS$1 = 852;
var ENOUGH_DISTS$1 = 592;
var CODES$1 = 0;
var LENS$1 = 1;
var DISTS$1 = 2;
var lbase = new Uint16Array([
  3,
  4,
  5,
  6,
  7,
  8,
  9,
  10,
  11,
  13,
  15,
  17,
  19,
  23,
  27,
  31,
  35,
  43,
  51,
  59,
  67,
  83,
  99,
  115,
  131,
  163,
  195,
  227,
  258,
  0,
  0
]);
var lext = new Uint8Array([
  16,
  16,
  16,
  16,
  16,
  16,
  16,
  16,
  17,
  17,
  17,
  17,
  18,
  18,
  18,
  18,
  19,
  19,
  19,
  19,
  20,
  20,
  20,
  20,
  21,
  21,
  21,
  21,
  16,
  72,
  78
]);
var dbase = new Uint16Array([
  1,
  2,
  3,
  4,
  5,
  7,
  9,
  13,
  17,
  25,
  33,
  49,
  65,
  97,
  129,
  193,
  257,
  385,
  513,
  769,
  1025,
  1537,
  2049,
  3073,
  4097,
  6145,
  8193,
  12289,
  16385,
  24577,
  0,
  0
]);
var dext = new Uint8Array([
  16,
  16,
  16,
  16,
  17,
  17,
  18,
  18,
  19,
  19,
  20,
  20,
  21,
  21,
  22,
  22,
  23,
  23,
  24,
  24,
  25,
  25,
  26,
  26,
  27,
  27,
  28,
  28,
  29,
  29,
  64,
  64
]);
var inflate_table = (type2, lens, lens_index, codes, table2, table_index, work, opts) => {
  const bits = opts.bits;
  let len = 0;
  let sym = 0;
  let min = 0, max = 0;
  let root = 0;
  let curr = 0;
  let drop = 0;
  let left = 0;
  let used = 0;
  let huff = 0;
  let incr;
  let fill;
  let low;
  let mask;
  let next;
  let base2 = null;
  let match;
  const count = new Uint16Array(MAXBITS + 1);
  const offs = new Uint16Array(MAXBITS + 1);
  let extra = null;
  let here_bits, here_op, here_val;
  for (len = 0;len <= MAXBITS; len++) {
    count[len] = 0;
  }
  for (sym = 0;sym < codes; sym++) {
    count[lens[lens_index + sym]]++;
  }
  root = bits;
  for (max = MAXBITS;max >= 1; max--) {
    if (count[max] !== 0) {
      break;
    }
  }
  if (root > max) {
    root = max;
  }
  if (max === 0) {
    table2[table_index++] = 1 << 24 | 64 << 16 | 0;
    table2[table_index++] = 1 << 24 | 64 << 16 | 0;
    opts.bits = 1;
    return 0;
  }
  for (min = 1;min < max; min++) {
    if (count[min] !== 0) {
      break;
    }
  }
  if (root < min) {
    root = min;
  }
  left = 1;
  for (len = 1;len <= MAXBITS; len++) {
    left <<= 1;
    left -= count[len];
    if (left < 0) {
      return -1;
    }
  }
  if (left > 0 && (type2 === CODES$1 || max !== 1)) {
    return -1;
  }
  offs[1] = 0;
  for (len = 1;len < MAXBITS; len++) {
    offs[len + 1] = offs[len] + count[len];
  }
  for (sym = 0;sym < codes; sym++) {
    if (lens[lens_index + sym] !== 0) {
      work[offs[lens[lens_index + sym]]++] = sym;
    }
  }
  if (type2 === CODES$1) {
    base2 = extra = work;
    match = 20;
  } else if (type2 === LENS$1) {
    base2 = lbase;
    extra = lext;
    match = 257;
  } else {
    base2 = dbase;
    extra = dext;
    match = 0;
  }
  huff = 0;
  sym = 0;
  len = min;
  next = table_index;
  curr = root;
  drop = 0;
  low = -1;
  used = 1 << root;
  mask = used - 1;
  if (type2 === LENS$1 && used > ENOUGH_LENS$1 || type2 === DISTS$1 && used > ENOUGH_DISTS$1) {
    return 1;
  }
  for (;; ) {
    here_bits = len - drop;
    if (work[sym] + 1 < match) {
      here_op = 0;
      here_val = work[sym];
    } else if (work[sym] >= match) {
      here_op = extra[work[sym] - match];
      here_val = base2[work[sym] - match];
    } else {
      here_op = 32 + 64;
      here_val = 0;
    }
    incr = 1 << len - drop;
    fill = 1 << curr;
    min = fill;
    do {
      fill -= incr;
      table2[next + (huff >> drop) + fill] = here_bits << 24 | here_op << 16 | here_val | 0;
    } while (fill !== 0);
    incr = 1 << len - 1;
    while (huff & incr) {
      incr >>= 1;
    }
    if (incr !== 0) {
      huff &= incr - 1;
      huff += incr;
    } else {
      huff = 0;
    }
    sym++;
    if (--count[len] === 0) {
      if (len === max) {
        break;
      }
      len = lens[lens_index + work[sym]];
    }
    if (len > root && (huff & mask) !== low) {
      if (drop === 0) {
        drop = root;
      }
      next += min;
      curr = len - drop;
      left = 1 << curr;
      while (curr + drop < max) {
        left -= count[curr + drop];
        if (left <= 0) {
          break;
        }
        curr++;
        left <<= 1;
      }
      used += 1 << curr;
      if (type2 === LENS$1 && used > ENOUGH_LENS$1 || type2 === DISTS$1 && used > ENOUGH_DISTS$1) {
        return 1;
      }
      low = huff & mask;
      table2[low] = root << 24 | curr << 16 | next - table_index | 0;
    }
  }
  if (huff !== 0) {
    table2[next + huff] = len - drop << 24 | 64 << 16 | 0;
  }
  opts.bits = root;
  return 0;
};
var inftrees = inflate_table;
var CODES = 0;
var LENS = 1;
var DISTS = 2;
var {
  Z_FINISH: Z_FINISH$1,
  Z_BLOCK,
  Z_TREES,
  Z_OK: Z_OK$1,
  Z_STREAM_END: Z_STREAM_END$1,
  Z_NEED_DICT: Z_NEED_DICT$1,
  Z_STREAM_ERROR: Z_STREAM_ERROR$1,
  Z_DATA_ERROR: Z_DATA_ERROR$1,
  Z_MEM_ERROR: Z_MEM_ERROR$1,
  Z_BUF_ERROR,
  Z_DEFLATED
} = constants$2;
var HEAD = 16180;
var FLAGS = 16181;
var TIME = 16182;
var OS = 16183;
var EXLEN = 16184;
var EXTRA = 16185;
var NAME = 16186;
var COMMENT = 16187;
var HCRC = 16188;
var DICTID = 16189;
var DICT = 16190;
var TYPE = 16191;
var TYPEDO = 16192;
var STORED = 16193;
var COPY_ = 16194;
var COPY = 16195;
var TABLE = 16196;
var LENLENS = 16197;
var CODELENS = 16198;
var LEN_ = 16199;
var LEN = 16200;
var LENEXT = 16201;
var DIST = 16202;
var DISTEXT = 16203;
var MATCH = 16204;
var LIT = 16205;
var CHECK = 16206;
var LENGTH = 16207;
var DONE = 16208;
var BAD = 16209;
var MEM = 16210;
var SYNC = 16211;
var ENOUGH_LENS = 852;
var ENOUGH_DISTS = 592;
var MAX_WBITS = 15;
var DEF_WBITS = MAX_WBITS;
var zswap32 = (q) => {
  return (q >>> 24 & 255) + (q >>> 8 & 65280) + ((q & 65280) << 8) + ((q & 255) << 24);
};
function InflateState() {
  this.strm = null;
  this.mode = 0;
  this.last = false;
  this.wrap = 0;
  this.havedict = false;
  this.flags = 0;
  this.dmax = 0;
  this.check = 0;
  this.total = 0;
  this.head = null;
  this.wbits = 0;
  this.wsize = 0;
  this.whave = 0;
  this.wnext = 0;
  this.window = null;
  this.hold = 0;
  this.bits = 0;
  this.length = 0;
  this.offset = 0;
  this.extra = 0;
  this.lencode = null;
  this.distcode = null;
  this.lenbits = 0;
  this.distbits = 0;
  this.ncode = 0;
  this.nlen = 0;
  this.ndist = 0;
  this.have = 0;
  this.next = null;
  this.lens = new Uint16Array(320);
  this.work = new Uint16Array(288);
  this.lendyn = null;
  this.distdyn = null;
  this.sane = 0;
  this.back = 0;
  this.was = 0;
}
var inflateStateCheck = (strm) => {
  if (!strm) {
    return 1;
  }
  const state = strm.state;
  if (!state || state.strm !== strm || state.mode < HEAD || state.mode > SYNC) {
    return 1;
  }
  return 0;
};
var inflateResetKeep = (strm) => {
  if (inflateStateCheck(strm)) {
    return Z_STREAM_ERROR$1;
  }
  const state = strm.state;
  strm.total_in = strm.total_out = state.total = 0;
  strm.msg = "";
  if (state.wrap) {
    strm.adler = state.wrap & 1;
  }
  state.mode = HEAD;
  state.last = 0;
  state.havedict = 0;
  state.flags = -1;
  state.dmax = 32768;
  state.head = null;
  state.hold = 0;
  state.bits = 0;
  state.lencode = state.lendyn = new Int32Array(ENOUGH_LENS);
  state.distcode = state.distdyn = new Int32Array(ENOUGH_DISTS);
  state.sane = 1;
  state.back = -1;
  return Z_OK$1;
};
var inflateReset = (strm) => {
  if (inflateStateCheck(strm)) {
    return Z_STREAM_ERROR$1;
  }
  const state = strm.state;
  state.wsize = 0;
  state.whave = 0;
  state.wnext = 0;
  return inflateResetKeep(strm);
};
var inflateReset2 = (strm, windowBits) => {
  let wrap;
  if (inflateStateCheck(strm)) {
    return Z_STREAM_ERROR$1;
  }
  const state = strm.state;
  if (windowBits < 0) {
    wrap = 0;
    windowBits = -windowBits;
  } else {
    wrap = (windowBits >> 4) + 5;
    if (windowBits < 48) {
      windowBits &= 15;
    }
  }
  if (windowBits && (windowBits < 8 || windowBits > 15)) {
    return Z_STREAM_ERROR$1;
  }
  if (state.window !== null && state.wbits !== windowBits) {
    state.window = null;
  }
  state.wrap = wrap;
  state.wbits = windowBits;
  return inflateReset(strm);
};
var inflateInit2 = (strm, windowBits) => {
  if (!strm) {
    return Z_STREAM_ERROR$1;
  }
  const state = new InflateState;
  strm.state = state;
  state.strm = strm;
  state.window = null;
  state.mode = HEAD;
  const ret = inflateReset2(strm, windowBits);
  if (ret !== Z_OK$1) {
    strm.state = null;
  }
  return ret;
};
var inflateInit = (strm) => {
  return inflateInit2(strm, DEF_WBITS);
};
var virgin = true;
var lenfix;
var distfix;
var fixedtables = (state) => {
  if (virgin) {
    lenfix = new Int32Array(512);
    distfix = new Int32Array(32);
    let sym = 0;
    while (sym < 144) {
      state.lens[sym++] = 8;
    }
    while (sym < 256) {
      state.lens[sym++] = 9;
    }
    while (sym < 280) {
      state.lens[sym++] = 7;
    }
    while (sym < 288) {
      state.lens[sym++] = 8;
    }
    inftrees(LENS, state.lens, 0, 288, lenfix, 0, state.work, { bits: 9 });
    sym = 0;
    while (sym < 32) {
      state.lens[sym++] = 5;
    }
    inftrees(DISTS, state.lens, 0, 32, distfix, 0, state.work, { bits: 5 });
    virgin = false;
  }
  state.lencode = lenfix;
  state.lenbits = 9;
  state.distcode = distfix;
  state.distbits = 5;
};
var updatewindow = (strm, src, end, copy2) => {
  let dist;
  const state = strm.state;
  if (state.window === null) {
    state.wsize = 1 << state.wbits;
    state.wnext = 0;
    state.whave = 0;
    state.window = new Uint8Array(state.wsize);
  }
  if (copy2 >= state.wsize) {
    state.window.set(src.subarray(end - state.wsize, end), 0);
    state.wnext = 0;
    state.whave = state.wsize;
  } else {
    dist = state.wsize - state.wnext;
    if (dist > copy2) {
      dist = copy2;
    }
    state.window.set(src.subarray(end - copy2, end - copy2 + dist), state.wnext);
    copy2 -= dist;
    if (copy2) {
      state.window.set(src.subarray(end - copy2, end), 0);
      state.wnext = copy2;
      state.whave = state.wsize;
    } else {
      state.wnext += dist;
      if (state.wnext === state.wsize) {
        state.wnext = 0;
      }
      if (state.whave < state.wsize) {
        state.whave += dist;
      }
    }
  }
  return 0;
};
var inflate$2 = (strm, flush) => {
  let state;
  let input, output2;
  let next;
  let put;
  let have, left;
  let hold;
  let bits;
  let _in, _out;
  let copy2;
  let from;
  let from_source;
  let here = 0;
  let here_bits, here_op, here_val;
  let last_bits, last_op, last_val;
  let len;
  let ret;
  const hbuf = new Uint8Array(4);
  let opts;
  let n2;
  const order = new Uint8Array([16, 17, 18, 0, 8, 7, 9, 6, 10, 5, 11, 4, 12, 3, 13, 2, 14, 1, 15]);
  if (inflateStateCheck(strm) || !strm.output || !strm.input && strm.avail_in !== 0) {
    return Z_STREAM_ERROR$1;
  }
  state = strm.state;
  if (state.mode === TYPE) {
    state.mode = TYPEDO;
  }
  put = strm.next_out;
  output2 = strm.output;
  left = strm.avail_out;
  next = strm.next_in;
  input = strm.input;
  have = strm.avail_in;
  hold = state.hold;
  bits = state.bits;
  _in = have;
  _out = left;
  ret = Z_OK$1;
  inf_leave:
    for (;; ) {
      switch (state.mode) {
        case HEAD:
          if (state.wrap === 0) {
            state.mode = TYPEDO;
            break;
          }
          while (bits < 16) {
            if (have === 0) {
              break inf_leave;
            }
            have--;
            hold += input[next++] << bits;
            bits += 8;
          }
          if (state.wrap & 2 && hold === 35615) {
            if (state.wbits === 0) {
              state.wbits = 15;
            }
            state.check = 0;
            hbuf[0] = hold & 255;
            hbuf[1] = hold >>> 8 & 255;
            state.check = crc32_1(state.check, hbuf, 2, 0);
            hold = 0;
            bits = 0;
            state.mode = FLAGS;
            break;
          }
          if (state.head) {
            state.head.done = false;
          }
          if (!(state.wrap & 1) || (((hold & 255) << 8) + (hold >> 8)) % 31) {
            strm.msg = "incorrect header check";
            state.mode = BAD;
            break;
          }
          if ((hold & 15) !== Z_DEFLATED) {
            strm.msg = "unknown compression method";
            state.mode = BAD;
            break;
          }
          hold >>>= 4;
          bits -= 4;
          len = (hold & 15) + 8;
          if (state.wbits === 0) {
            state.wbits = len;
          }
          if (len > 15 || len > state.wbits) {
            strm.msg = "invalid window size";
            state.mode = BAD;
            break;
          }
          state.dmax = 1 << state.wbits;
          state.flags = 0;
          strm.adler = state.check = 1;
          state.mode = hold & 512 ? DICTID : TYPE;
          hold = 0;
          bits = 0;
          break;
        case FLAGS:
          while (bits < 16) {
            if (have === 0) {
              break inf_leave;
            }
            have--;
            hold += input[next++] << bits;
            bits += 8;
          }
          state.flags = hold;
          if ((state.flags & 255) !== Z_DEFLATED) {
            strm.msg = "unknown compression method";
            state.mode = BAD;
            break;
          }
          if (state.flags & 57344) {
            strm.msg = "unknown header flags set";
            state.mode = BAD;
            break;
          }
          if (state.head) {
            state.head.text = hold >> 8 & 1;
          }
          if (state.flags & 512 && state.wrap & 4) {
            hbuf[0] = hold & 255;
            hbuf[1] = hold >>> 8 & 255;
            state.check = crc32_1(state.check, hbuf, 2, 0);
          }
          hold = 0;
          bits = 0;
          state.mode = TIME;
        case TIME:
          while (bits < 32) {
            if (have === 0) {
              break inf_leave;
            }
            have--;
            hold += input[next++] << bits;
            bits += 8;
          }
          if (state.head) {
            state.head.time = hold;
          }
          if (state.flags & 512 && state.wrap & 4) {
            hbuf[0] = hold & 255;
            hbuf[1] = hold >>> 8 & 255;
            hbuf[2] = hold >>> 16 & 255;
            hbuf[3] = hold >>> 24 & 255;
            state.check = crc32_1(state.check, hbuf, 4, 0);
          }
          hold = 0;
          bits = 0;
          state.mode = OS;
        case OS:
          while (bits < 16) {
            if (have === 0) {
              break inf_leave;
            }
            have--;
            hold += input[next++] << bits;
            bits += 8;
          }
          if (state.head) {
            state.head.xflags = hold & 255;
            state.head.os = hold >> 8;
          }
          if (state.flags & 512 && state.wrap & 4) {
            hbuf[0] = hold & 255;
            hbuf[1] = hold >>> 8 & 255;
            state.check = crc32_1(state.check, hbuf, 2, 0);
          }
          hold = 0;
          bits = 0;
          state.mode = EXLEN;
        case EXLEN:
          if (state.flags & 1024) {
            while (bits < 16) {
              if (have === 0) {
                break inf_leave;
              }
              have--;
              hold += input[next++] << bits;
              bits += 8;
            }
            state.length = hold;
            if (state.head) {
              state.head.extra_len = hold;
            }
            if (state.flags & 512 && state.wrap & 4) {
              hbuf[0] = hold & 255;
              hbuf[1] = hold >>> 8 & 255;
              state.check = crc32_1(state.check, hbuf, 2, 0);
            }
            hold = 0;
            bits = 0;
          } else if (state.head) {
            state.head.extra = null;
          }
          state.mode = EXTRA;
        case EXTRA:
          if (state.flags & 1024) {
            copy2 = state.length;
            if (copy2 > have) {
              copy2 = have;
            }
            if (copy2) {
              if (state.head) {
                len = state.head.extra_len - state.length;
                if (!state.head.extra) {
                  state.head.extra = new Uint8Array(state.head.extra_len);
                }
                state.head.extra.set(input.subarray(next, next + copy2), len);
              }
              if (state.flags & 512 && state.wrap & 4) {
                state.check = crc32_1(state.check, input, copy2, next);
              }
              have -= copy2;
              next += copy2;
              state.length -= copy2;
            }
            if (state.length) {
              break inf_leave;
            }
          }
          state.length = 0;
          state.mode = NAME;
        case NAME:
          if (state.flags & 2048) {
            if (have === 0) {
              break inf_leave;
            }
            copy2 = 0;
            do {
              len = input[next + copy2++];
              if (state.head && len && state.length < 65536) {
                state.head.name += String.fromCharCode(len);
              }
            } while (len && copy2 < have);
            if (state.flags & 512 && state.wrap & 4) {
              state.check = crc32_1(state.check, input, copy2, next);
            }
            have -= copy2;
            next += copy2;
            if (len) {
              break inf_leave;
            }
          } else if (state.head) {
            state.head.name = null;
          }
          state.length = 0;
          state.mode = COMMENT;
        case COMMENT:
          if (state.flags & 4096) {
            if (have === 0) {
              break inf_leave;
            }
            copy2 = 0;
            do {
              len = input[next + copy2++];
              if (state.head && len && state.length < 65536) {
                state.head.comment += String.fromCharCode(len);
              }
            } while (len && copy2 < have);
            if (state.flags & 512 && state.wrap & 4) {
              state.check = crc32_1(state.check, input, copy2, next);
            }
            have -= copy2;
            next += copy2;
            if (len) {
              break inf_leave;
            }
          } else if (state.head) {
            state.head.comment = null;
          }
          state.mode = HCRC;
        case HCRC:
          if (state.flags & 512) {
            while (bits < 16) {
              if (have === 0) {
                break inf_leave;
              }
              have--;
              hold += input[next++] << bits;
              bits += 8;
            }
            if (state.wrap & 4 && hold !== (state.check & 65535)) {
              strm.msg = "header crc mismatch";
              state.mode = BAD;
              break;
            }
            hold = 0;
            bits = 0;
          }
          if (state.head) {
            state.head.hcrc = state.flags >> 9 & 1;
            state.head.done = true;
          }
          strm.adler = state.check = 0;
          state.mode = TYPE;
          break;
        case DICTID:
          while (bits < 32) {
            if (have === 0) {
              break inf_leave;
            }
            have--;
            hold += input[next++] << bits;
            bits += 8;
          }
          strm.adler = state.check = zswap32(hold);
          hold = 0;
          bits = 0;
          state.mode = DICT;
        case DICT:
          if (state.havedict === 0) {
            strm.next_out = put;
            strm.avail_out = left;
            strm.next_in = next;
            strm.avail_in = have;
            state.hold = hold;
            state.bits = bits;
            return Z_NEED_DICT$1;
          }
          strm.adler = state.check = 1;
          state.mode = TYPE;
        case TYPE:
          if (flush === Z_BLOCK || flush === Z_TREES) {
            break inf_leave;
          }
        case TYPEDO:
          if (state.last) {
            hold >>>= bits & 7;
            bits -= bits & 7;
            state.mode = CHECK;
            break;
          }
          while (bits < 3) {
            if (have === 0) {
              break inf_leave;
            }
            have--;
            hold += input[next++] << bits;
            bits += 8;
          }
          state.last = hold & 1;
          hold >>>= 1;
          bits -= 1;
          switch (hold & 3) {
            case 0:
              state.mode = STORED;
              break;
            case 1:
              fixedtables(state);
              state.mode = LEN_;
              if (flush === Z_TREES) {
                hold >>>= 2;
                bits -= 2;
                break inf_leave;
              }
              break;
            case 2:
              state.mode = TABLE;
              break;
            case 3:
              strm.msg = "invalid block type";
              state.mode = BAD;
          }
          hold >>>= 2;
          bits -= 2;
          break;
        case STORED:
          hold >>>= bits & 7;
          bits -= bits & 7;
          while (bits < 32) {
            if (have === 0) {
              break inf_leave;
            }
            have--;
            hold += input[next++] << bits;
            bits += 8;
          }
          if ((hold & 65535) !== (hold >>> 16 ^ 65535)) {
            strm.msg = "invalid stored block lengths";
            state.mode = BAD;
            break;
          }
          state.length = hold & 65535;
          hold = 0;
          bits = 0;
          state.mode = COPY_;
          if (flush === Z_TREES) {
            break inf_leave;
          }
        case COPY_:
          state.mode = COPY;
        case COPY:
          copy2 = state.length;
          if (copy2) {
            if (copy2 > have) {
              copy2 = have;
            }
            if (copy2 > left) {
              copy2 = left;
            }
            if (copy2 === 0) {
              break inf_leave;
            }
            output2.set(input.subarray(next, next + copy2), put);
            have -= copy2;
            next += copy2;
            left -= copy2;
            put += copy2;
            state.length -= copy2;
            break;
          }
          state.mode = TYPE;
          break;
        case TABLE:
          while (bits < 14) {
            if (have === 0) {
              break inf_leave;
            }
            have--;
            hold += input[next++] << bits;
            bits += 8;
          }
          state.nlen = (hold & 31) + 257;
          hold >>>= 5;
          bits -= 5;
          state.ndist = (hold & 31) + 1;
          hold >>>= 5;
          bits -= 5;
          state.ncode = (hold & 15) + 4;
          hold >>>= 4;
          bits -= 4;
          if (state.nlen > 286 || state.ndist > 30) {
            strm.msg = "too many length or distance symbols";
            state.mode = BAD;
            break;
          }
          state.have = 0;
          state.mode = LENLENS;
        case LENLENS:
          while (state.have < state.ncode) {
            while (bits < 3) {
              if (have === 0) {
                break inf_leave;
              }
              have--;
              hold += input[next++] << bits;
              bits += 8;
            }
            state.lens[order[state.have++]] = hold & 7;
            hold >>>= 3;
            bits -= 3;
          }
          while (state.have < 19) {
            state.lens[order[state.have++]] = 0;
          }
          state.lencode = state.lendyn;
          state.lenbits = 7;
          opts = { bits: state.lenbits };
          ret = inftrees(CODES, state.lens, 0, 19, state.lencode, 0, state.work, opts);
          state.lenbits = opts.bits;
          if (ret) {
            strm.msg = "invalid code lengths set";
            state.mode = BAD;
            break;
          }
          state.have = 0;
          state.mode = CODELENS;
        case CODELENS:
          while (state.have < state.nlen + state.ndist) {
            for (;; ) {
              here = state.lencode[hold & (1 << state.lenbits) - 1];
              here_bits = here >>> 24;
              here_op = here >>> 16 & 255;
              here_val = here & 65535;
              if (here_bits <= bits) {
                break;
              }
              if (have === 0) {
                break inf_leave;
              }
              have--;
              hold += input[next++] << bits;
              bits += 8;
            }
            if (here_val < 16) {
              hold >>>= here_bits;
              bits -= here_bits;
              state.lens[state.have++] = here_val;
            } else {
              if (here_val === 16) {
                n2 = here_bits + 2;
                while (bits < n2) {
                  if (have === 0) {
                    break inf_leave;
                  }
                  have--;
                  hold += input[next++] << bits;
                  bits += 8;
                }
                hold >>>= here_bits;
                bits -= here_bits;
                if (state.have === 0) {
                  strm.msg = "invalid bit length repeat";
                  state.mode = BAD;
                  break;
                }
                len = state.lens[state.have - 1];
                copy2 = 3 + (hold & 3);
                hold >>>= 2;
                bits -= 2;
              } else if (here_val === 17) {
                n2 = here_bits + 3;
                while (bits < n2) {
                  if (have === 0) {
                    break inf_leave;
                  }
                  have--;
                  hold += input[next++] << bits;
                  bits += 8;
                }
                hold >>>= here_bits;
                bits -= here_bits;
                len = 0;
                copy2 = 3 + (hold & 7);
                hold >>>= 3;
                bits -= 3;
              } else {
                n2 = here_bits + 7;
                while (bits < n2) {
                  if (have === 0) {
                    break inf_leave;
                  }
                  have--;
                  hold += input[next++] << bits;
                  bits += 8;
                }
                hold >>>= here_bits;
                bits -= here_bits;
                len = 0;
                copy2 = 11 + (hold & 127);
                hold >>>= 7;
                bits -= 7;
              }
              if (state.have + copy2 > state.nlen + state.ndist) {
                strm.msg = "invalid bit length repeat";
                state.mode = BAD;
                break;
              }
              while (copy2--) {
                state.lens[state.have++] = len;
              }
            }
          }
          if (state.mode === BAD) {
            break;
          }
          if (state.lens[256] === 0) {
            strm.msg = "invalid code -- missing end-of-block";
            state.mode = BAD;
            break;
          }
          state.lenbits = 9;
          opts = { bits: state.lenbits };
          ret = inftrees(LENS, state.lens, 0, state.nlen, state.lencode, 0, state.work, opts);
          state.lenbits = opts.bits;
          if (ret) {
            strm.msg = "invalid literal/lengths set";
            state.mode = BAD;
            break;
          }
          state.distbits = 6;
          state.distcode = state.distdyn;
          opts = { bits: state.distbits };
          ret = inftrees(DISTS, state.lens, state.nlen, state.ndist, state.distcode, 0, state.work, opts);
          state.distbits = opts.bits;
          if (ret) {
            strm.msg = "invalid distances set";
            state.mode = BAD;
            break;
          }
          state.mode = LEN_;
          if (flush === Z_TREES) {
            break inf_leave;
          }
        case LEN_:
          state.mode = LEN;
        case LEN:
          if (have >= 6 && left >= 258) {
            strm.next_out = put;
            strm.avail_out = left;
            strm.next_in = next;
            strm.avail_in = have;
            state.hold = hold;
            state.bits = bits;
            inffast(strm, _out);
            put = strm.next_out;
            output2 = strm.output;
            left = strm.avail_out;
            next = strm.next_in;
            input = strm.input;
            have = strm.avail_in;
            hold = state.hold;
            bits = state.bits;
            if (state.mode === TYPE) {
              state.back = -1;
            }
            break;
          }
          state.back = 0;
          for (;; ) {
            here = state.lencode[hold & (1 << state.lenbits) - 1];
            here_bits = here >>> 24;
            here_op = here >>> 16 & 255;
            here_val = here & 65535;
            if (here_bits <= bits) {
              break;
            }
            if (have === 0) {
              break inf_leave;
            }
            have--;
            hold += input[next++] << bits;
            bits += 8;
          }
          if (here_op && (here_op & 240) === 0) {
            last_bits = here_bits;
            last_op = here_op;
            last_val = here_val;
            for (;; ) {
              here = state.lencode[last_val + ((hold & (1 << last_bits + last_op) - 1) >> last_bits)];
              here_bits = here >>> 24;
              here_op = here >>> 16 & 255;
              here_val = here & 65535;
              if (last_bits + here_bits <= bits) {
                break;
              }
              if (have === 0) {
                break inf_leave;
              }
              have--;
              hold += input[next++] << bits;
              bits += 8;
            }
            hold >>>= last_bits;
            bits -= last_bits;
            state.back += last_bits;
          }
          hold >>>= here_bits;
          bits -= here_bits;
          state.back += here_bits;
          state.length = here_val;
          if (here_op === 0) {
            state.mode = LIT;
            break;
          }
          if (here_op & 32) {
            state.back = -1;
            state.mode = TYPE;
            break;
          }
          if (here_op & 64) {
            strm.msg = "invalid literal/length code";
            state.mode = BAD;
            break;
          }
          state.extra = here_op & 15;
          state.mode = LENEXT;
        case LENEXT:
          if (state.extra) {
            n2 = state.extra;
            while (bits < n2) {
              if (have === 0) {
                break inf_leave;
              }
              have--;
              hold += input[next++] << bits;
              bits += 8;
            }
            state.length += hold & (1 << state.extra) - 1;
            hold >>>= state.extra;
            bits -= state.extra;
            state.back += state.extra;
          }
          state.was = state.length;
          state.mode = DIST;
        case DIST:
          for (;; ) {
            here = state.distcode[hold & (1 << state.distbits) - 1];
            here_bits = here >>> 24;
            here_op = here >>> 16 & 255;
            here_val = here & 65535;
            if (here_bits <= bits) {
              break;
            }
            if (have === 0) {
              break inf_leave;
            }
            have--;
            hold += input[next++] << bits;
            bits += 8;
          }
          if ((here_op & 240) === 0) {
            last_bits = here_bits;
            last_op = here_op;
            last_val = here_val;
            for (;; ) {
              here = state.distcode[last_val + ((hold & (1 << last_bits + last_op) - 1) >> last_bits)];
              here_bits = here >>> 24;
              here_op = here >>> 16 & 255;
              here_val = here & 65535;
              if (last_bits + here_bits <= bits) {
                break;
              }
              if (have === 0) {
                break inf_leave;
              }
              have--;
              hold += input[next++] << bits;
              bits += 8;
            }
            hold >>>= last_bits;
            bits -= last_bits;
            state.back += last_bits;
          }
          hold >>>= here_bits;
          bits -= here_bits;
          state.back += here_bits;
          if (here_op & 64) {
            strm.msg = "invalid distance code";
            state.mode = BAD;
            break;
          }
          state.offset = here_val;
          state.extra = here_op & 15;
          state.mode = DISTEXT;
        case DISTEXT:
          if (state.extra) {
            n2 = state.extra;
            while (bits < n2) {
              if (have === 0) {
                break inf_leave;
              }
              have--;
              hold += input[next++] << bits;
              bits += 8;
            }
            state.offset += hold & (1 << state.extra) - 1;
            hold >>>= state.extra;
            bits -= state.extra;
            state.back += state.extra;
          }
          if (state.offset > state.dmax) {
            strm.msg = "invalid distance too far back";
            state.mode = BAD;
            break;
          }
          state.mode = MATCH;
        case MATCH:
          if (left === 0) {
            break inf_leave;
          }
          copy2 = _out - left;
          if (state.offset > copy2) {
            copy2 = state.offset - copy2;
            if (copy2 > state.whave) {
              if (state.sane) {
                strm.msg = "invalid distance too far back";
                state.mode = BAD;
                break;
              }
            }
            if (copy2 > state.wnext) {
              copy2 -= state.wnext;
              from = state.wsize - copy2;
            } else {
              from = state.wnext - copy2;
            }
            if (copy2 > state.length) {
              copy2 = state.length;
            }
            from_source = state.window;
          } else {
            from_source = output2;
            from = put - state.offset;
            copy2 = state.length;
          }
          if (copy2 > left) {
            copy2 = left;
          }
          left -= copy2;
          state.length -= copy2;
          do {
            output2[put++] = from_source[from++];
          } while (--copy2);
          if (state.length === 0) {
            state.mode = LEN;
          }
          break;
        case LIT:
          if (left === 0) {
            break inf_leave;
          }
          output2[put++] = state.length;
          left--;
          state.mode = LEN;
          break;
        case CHECK:
          if (state.wrap) {
            while (bits < 32) {
              if (have === 0) {
                break inf_leave;
              }
              have--;
              hold |= input[next++] << bits;
              bits += 8;
            }
            _out -= left;
            strm.total_out += _out;
            state.total += _out;
            if (state.wrap & 4 && _out) {
              strm.adler = state.check = state.flags ? crc32_1(state.check, output2, _out, put - _out) : adler32_1(state.check, output2, _out, put - _out);
            }
            _out = left;
            if (state.wrap & 4 && (state.flags ? hold : zswap32(hold)) !== state.check) {
              strm.msg = "incorrect data check";
              state.mode = BAD;
              break;
            }
            hold = 0;
            bits = 0;
          }
          state.mode = LENGTH;
        case LENGTH:
          if (state.wrap && state.flags) {
            while (bits < 32) {
              if (have === 0) {
                break inf_leave;
              }
              have--;
              hold += input[next++] << bits;
              bits += 8;
            }
            if (state.wrap & 4 && hold !== (state.total & 4294967295)) {
              strm.msg = "incorrect length check";
              state.mode = BAD;
              break;
            }
            hold = 0;
            bits = 0;
          }
          state.mode = DONE;
        case DONE:
          ret = Z_STREAM_END$1;
          break inf_leave;
        case BAD:
          ret = Z_DATA_ERROR$1;
          break inf_leave;
        case MEM:
          return Z_MEM_ERROR$1;
        case SYNC:
        default:
          return Z_STREAM_ERROR$1;
      }
    }
  strm.next_out = put;
  strm.avail_out = left;
  strm.next_in = next;
  strm.avail_in = have;
  state.hold = hold;
  state.bits = bits;
  if (state.wsize || _out !== strm.avail_out && state.mode < BAD && (state.mode < CHECK || flush !== Z_FINISH$1)) {
    if (updatewindow(strm, strm.output, strm.next_out, _out - strm.avail_out))
      ;
  }
  _in -= strm.avail_in;
  _out -= strm.avail_out;
  strm.total_in += _in;
  strm.total_out += _out;
  state.total += _out;
  if (state.wrap & 4 && _out) {
    strm.adler = state.check = state.flags ? crc32_1(state.check, output2, _out, strm.next_out - _out) : adler32_1(state.check, output2, _out, strm.next_out - _out);
  }
  strm.data_type = state.bits + (state.last ? 64 : 0) + (state.mode === TYPE ? 128 : 0) + (state.mode === LEN_ || state.mode === COPY_ ? 256 : 0);
  if ((_in === 0 && _out === 0 || flush === Z_FINISH$1) && ret === Z_OK$1) {
    ret = Z_BUF_ERROR;
  }
  return ret;
};
var inflateEnd = (strm) => {
  if (inflateStateCheck(strm)) {
    return Z_STREAM_ERROR$1;
  }
  let state = strm.state;
  if (state.window) {
    state.window = null;
  }
  strm.state = null;
  return Z_OK$1;
};
var inflateGetHeader = (strm, head) => {
  if (inflateStateCheck(strm)) {
    return Z_STREAM_ERROR$1;
  }
  const state = strm.state;
  if ((state.wrap & 2) === 0) {
    return Z_STREAM_ERROR$1;
  }
  state.head = head;
  head.done = false;
  return Z_OK$1;
};
var inflateSetDictionary = (strm, dictionary) => {
  const dictLength = dictionary.length;
  let state;
  let dictid;
  let ret;
  if (inflateStateCheck(strm)) {
    return Z_STREAM_ERROR$1;
  }
  state = strm.state;
  if (state.wrap !== 0 && state.mode !== DICT) {
    return Z_STREAM_ERROR$1;
  }
  if (state.mode === DICT) {
    dictid = 1;
    dictid = adler32_1(dictid, dictionary, dictLength, 0);
    if (dictid !== state.check) {
      return Z_DATA_ERROR$1;
    }
  }
  ret = updatewindow(strm, dictionary, dictLength, dictLength);
  if (ret) {
    state.mode = MEM;
    return Z_MEM_ERROR$1;
  }
  state.havedict = 1;
  return Z_OK$1;
};
var inflateReset_1 = inflateReset;
var inflateReset2_1 = inflateReset2;
var inflateResetKeep_1 = inflateResetKeep;
var inflateInit_1 = inflateInit;
var inflateInit2_1 = inflateInit2;
var inflate_2$1 = inflate$2;
var inflateEnd_1 = inflateEnd;
var inflateGetHeader_1 = inflateGetHeader;
var inflateSetDictionary_1 = inflateSetDictionary;
var inflateInfo = "pako inflate (from Nodeca project)";
var inflate_1$2 = {
  inflateReset: inflateReset_1,
  inflateReset2: inflateReset2_1,
  inflateResetKeep: inflateResetKeep_1,
  inflateInit: inflateInit_1,
  inflateInit2: inflateInit2_1,
  inflate: inflate_2$1,
  inflateEnd: inflateEnd_1,
  inflateGetHeader: inflateGetHeader_1,
  inflateSetDictionary: inflateSetDictionary_1,
  inflateInfo
};
function GZheader() {
  this.text = 0;
  this.time = 0;
  this.xflags = 0;
  this.os = 0;
  this.extra = null;
  this.extra_len = 0;
  this.name = "";
  this.comment = "";
  this.hcrc = 0;
  this.done = false;
}
var gzheader = GZheader;
var toString2 = Object.prototype.toString;
var {
  Z_NO_FLUSH,
  Z_FINISH,
  Z_OK,
  Z_STREAM_END,
  Z_NEED_DICT,
  Z_STREAM_ERROR,
  Z_DATA_ERROR,
  Z_MEM_ERROR
} = constants$2;
function Inflate$1(options2) {
  this.options = common.assign({
    chunkSize: 1024 * 64,
    windowBits: 15,
    to: ""
  }, options2 || {});
  const opt = this.options;
  if (opt.raw && opt.windowBits >= 0 && opt.windowBits < 16) {
    opt.windowBits = -opt.windowBits;
    if (opt.windowBits === 0) {
      opt.windowBits = -15;
    }
  }
  if (opt.windowBits >= 0 && opt.windowBits < 16 && !(options2 && options2.windowBits)) {
    opt.windowBits += 32;
  }
  if (opt.windowBits > 15 && opt.windowBits < 48) {
    if ((opt.windowBits & 15) === 0) {
      opt.windowBits |= 15;
    }
  }
  this.err = 0;
  this.msg = "";
  this.ended = false;
  this.chunks = [];
  this.strm = new zstream;
  this.strm.avail_out = 0;
  let status = inflate_1$2.inflateInit2(this.strm, opt.windowBits);
  if (status !== Z_OK) {
    throw new Error(messages[status]);
  }
  this.header = new gzheader;
  inflate_1$2.inflateGetHeader(this.strm, this.header);
  if (opt.dictionary) {
    if (typeof opt.dictionary === "string") {
      opt.dictionary = strings2.string2buf(opt.dictionary);
    } else if (toString2.call(opt.dictionary) === "[object ArrayBuffer]") {
      opt.dictionary = new Uint8Array(opt.dictionary);
    }
    if (opt.raw) {
      status = inflate_1$2.inflateSetDictionary(this.strm, opt.dictionary);
      if (status !== Z_OK) {
        throw new Error(messages[status]);
      }
    }
  }
}
Inflate$1.prototype.push = function(data3, flush_mode) {
  const strm = this.strm;
  const chunkSize = this.options.chunkSize;
  const dictionary = this.options.dictionary;
  let status, _flush_mode, last_avail_out;
  if (this.ended)
    return false;
  if (flush_mode === ~~flush_mode)
    _flush_mode = flush_mode;
  else
    _flush_mode = flush_mode === true ? Z_FINISH : Z_NO_FLUSH;
  if (toString2.call(data3) === "[object ArrayBuffer]") {
    strm.input = new Uint8Array(data3);
  } else {
    strm.input = data3;
  }
  strm.next_in = 0;
  strm.avail_in = strm.input.length;
  for (;; ) {
    if (strm.avail_out === 0) {
      strm.output = new Uint8Array(chunkSize);
      strm.next_out = 0;
      strm.avail_out = chunkSize;
    }
    status = inflate_1$2.inflate(strm, _flush_mode);
    if (status === Z_NEED_DICT && dictionary) {
      status = inflate_1$2.inflateSetDictionary(strm, dictionary);
      if (status === Z_OK) {
        status = inflate_1$2.inflate(strm, _flush_mode);
      } else if (status === Z_DATA_ERROR) {
        status = Z_NEED_DICT;
      }
    }
    while (strm.avail_in > 0 && status === Z_STREAM_END && strm.state.wrap > 0 && data3[strm.next_in] !== 0) {
      inflate_1$2.inflateReset(strm);
      status = inflate_1$2.inflate(strm, _flush_mode);
    }
    switch (status) {
      case Z_STREAM_ERROR:
      case Z_DATA_ERROR:
      case Z_NEED_DICT:
      case Z_MEM_ERROR:
        this.onEnd(status);
        this.ended = true;
        return false;
    }
    last_avail_out = strm.avail_out;
    if (strm.next_out) {
      if (strm.avail_out === 0 || status === Z_STREAM_END) {
        if (this.options.to === "string") {
          let next_out_utf8 = strings2.utf8border(strm.output, strm.next_out);
          let tail = strm.next_out - next_out_utf8;
          let utf8str = strings2.buf2string(strm.output, next_out_utf8);
          strm.next_out = tail;
          strm.avail_out = chunkSize - tail;
          if (tail)
            strm.output.set(strm.output.subarray(next_out_utf8, next_out_utf8 + tail), 0);
          this.onData(utf8str);
        } else {
          this.onData(strm.output.length === strm.next_out ? strm.output : strm.output.subarray(0, strm.next_out));
        }
      }
    }
    if (status === Z_OK && last_avail_out === 0)
      continue;
    if (status === Z_STREAM_END) {
      status = inflate_1$2.inflateEnd(this.strm);
      this.onEnd(status);
      this.ended = true;
      return true;
    }
    if (strm.avail_in === 0)
      break;
  }
  return true;
};
Inflate$1.prototype.onData = function(chunk) {
  this.chunks.push(chunk);
};
Inflate$1.prototype.onEnd = function(status) {
  if (status === Z_OK) {
    if (this.options.to === "string") {
      this.result = this.chunks.join("");
    } else {
      this.result = common.flattenChunks(this.chunks);
    }
  }
  this.chunks = [];
  this.err = status;
  this.msg = this.strm.msg;
};
function inflate$1(input, options2) {
  const inflator = new Inflate$1(options2);
  inflator.push(input);
  if (inflator.err)
    throw inflator.msg || messages[inflator.err];
  return inflator.result;
}
function inflateRaw$1(input, options2) {
  options2 = options2 || {};
  options2.raw = true;
  return inflate$1(input, options2);
}
var Inflate_1$1 = Inflate$1;
var inflate_2 = inflate$1;
var inflateRaw_1$1 = inflateRaw$1;
var ungzip$1 = inflate$1;
var constants2 = constants$2;
var inflate_1$1 = {
  Inflate: Inflate_1$1,
  inflate: inflate_2,
  inflateRaw: inflateRaw_1$1,
  ungzip: ungzip$1,
  constants: constants2
};
var { Inflate, inflate, inflateRaw, ungzip } = inflate_1$1;
var inflate_1 = inflate;

// node_modules/p5/dist/type/lib/Typr.js
var pako = { inflate: inflate_1 };
var Typr = {};
Typr["parse"] = function(buff) {
  var bin = Typr["B"];
  var readFont = function(data4, idx, offset3, tmap2) {
    var T = Typr["T"];
    var prsr = {
      cmap: T.cmap,
      head: T.head,
      hhea: T.hhea,
      maxp: T.maxp,
      hmtx: T.hmtx,
      name: T.name,
      "OS/2": T.OS2,
      post: T.post,
      loca: T.loca,
      kern: T.kern,
      glyf: T.glyf,
      "CFF ": T.CFF,
      GSUB: T.GSUB,
      CBLC: T.CBLC,
      CBDT: T.CBDT,
      "SVG ": T.SVG,
      COLR: T.colr,
      CPAL: T.cpal,
      sbix: T.sbix,
      fvar: T.fvar,
      gvar: T.gvar,
      avar: T.avar,
      HVAR: T.HVAR
    };
    var obj2 = { _data: data4, _index: idx, _offset: offset3 };
    for (var t in prsr) {
      var tab = Typr["findTable"](data4, t, offset3);
      if (tab) {
        var off = tab[0], tobj = tmap2[off];
        if (tobj == null)
          tobj = prsr[t].parseTab(data4, off, tab[1], obj2);
        obj2[t] = tmap2[off] = tobj;
      }
    }
    return obj2;
  };
  function woffToOtf(data4) {
    var numTables = bin.readUshort(data4, 12);
    var totalSize = bin.readUint(data4, 16);
    var otf = new Uint8Array(totalSize), toff = 12 + numTables * 16;
    bin.writeASCII(otf, 0, "OTTO");
    bin.writeUshort(otf, 4, numTables);
    var off = 44;
    for (var i3 = 0;i3 < numTables; i3++) {
      var tag2 = bin.readASCII(data4, off, 4);
      var tof = bin.readUint(data4, off + 4);
      var cLe = bin.readUint(data4, off + 8);
      var oLe = bin.readUint(data4, off + 12);
      off += 20;
      var tab = data4.slice(tof, tof + cLe);
      if (cLe != oLe)
        tab = pako["inflate"](tab);
      var to2 = 12 + i3 * 16;
      bin.writeASCII(otf, to2, tag2);
      bin.writeUint(otf, to2 + 8, toff);
      bin.writeUint(otf, to2 + 12, oLe);
      otf.set(tab, toff);
      toff += oLe;
    }
    return otf;
  }
  var data3 = new Uint8Array(buff);
  let compressedData;
  if (data3[0] == 119) {
    compressedData = data3;
    data3 = woffToOtf(data3);
  }
  var tmap = {};
  var tag = bin.readASCII(data3, 0, 4);
  if (tag == "ttcf") {
    var offset2 = 4;
    bin.readUshort(data3, offset2);
    offset2 += 2;
    bin.readUshort(data3, offset2);
    offset2 += 2;
    var numF = bin.readUint(data3, offset2);
    offset2 += 4;
    var fnts = [];
    for (var i2 = 0;i2 < numF; i2++) {
      var foff = bin.readUint(data3, offset2);
      offset2 += 4;
      fnts.push(readFont(data3, i2, foff, tmap));
    }
    return fnts;
  }
  var fnt = readFont(data3, 0, 0, tmap);
  fnt._compressedData = compressedData;
  var fvar = fnt["fvar"];
  if (fvar) {
    var out = [fnt];
    for (var i2 = 0;i2 < fvar[1].length; i2++) {
      var fv = fvar[1][i2];
      var obj = {};
      out.push(obj);
      for (var p2 in fnt)
        obj[p2] = fnt[p2];
      obj["_index"] = i2;
      var name = obj["name"] = JSON.parse(JSON.stringify(obj["name"]));
      name["fontSubfamily"] = fv[0];
      if (fv[3] == null)
        fv[3] = (name["fontFamily"] + "-" + name["fontSubfamily"])["replaceAll"](" ", "");
      name["postScriptName"] = fv[3];
    }
    return out;
  }
  return [fnt];
};
Typr["findTable"] = function(data3, tab, foff) {
  var bin = Typr["B"];
  var numTables = bin.readUshort(data3, foff + 4);
  var offset2 = foff + 12;
  for (var i2 = 0;i2 < numTables; i2++) {
    var tag = bin.readASCII(data3, offset2, 4);
    bin.readUint(data3, offset2 + 4);
    var toffset = bin.readUint(data3, offset2 + 8);
    var length = bin.readUint(data3, offset2 + 12);
    if (tag == tab)
      return [toffset, length];
    offset2 += 16;
  }
  return null;
};
Typr["T"] = {};
Typr["B"] = {
  readFixed: function(data3, o) {
    return (data3[o] << 8 | data3[o + 1]) + (data3[o + 2] << 8 | data3[o + 3]) / (256 * 256 + 4);
  },
  readF2dot14: function(data3, o) {
    var num = Typr["B"].readShort(data3, o);
    return num / 16384;
  },
  readInt: function(buff, p2) {
    var a = Typr["B"].t.uint8;
    a[0] = buff[p2 + 3];
    a[1] = buff[p2 + 2];
    a[2] = buff[p2 + 1];
    a[3] = buff[p2];
    return Typr["B"].t.int32[0];
  },
  readInt8: function(buff, p2) {
    var a = Typr["B"].t.uint8;
    a[0] = buff[p2];
    return Typr["B"].t.int8[0];
  },
  readShort: function(buff, p2) {
    var a = Typr["B"].t.uint16;
    a[0] = buff[p2] << 8 | buff[p2 + 1];
    return Typr["B"].t.int16[0];
  },
  readUshort: function(buff, p2) {
    return buff[p2] << 8 | buff[p2 + 1];
  },
  writeUshort: function(buff, p2, n2) {
    buff[p2] = n2 >> 8 & 255;
    buff[p2 + 1] = n2 & 255;
  },
  readUshorts: function(buff, p2, len) {
    var arr2 = [];
    for (var i2 = 0;i2 < len; i2++) {
      var v = Typr["B"].readUshort(buff, p2 + i2 * 2);
      arr2.push(v);
    }
    return arr2;
  },
  readUint: function(buff, p2) {
    var a = Typr["B"].t.uint8;
    a[3] = buff[p2];
    a[2] = buff[p2 + 1];
    a[1] = buff[p2 + 2];
    a[0] = buff[p2 + 3];
    return Typr["B"].t.uint32[0];
  },
  writeUint: function(buff, p2, n2) {
    buff[p2] = n2 >> 24 & 255;
    buff[p2 + 1] = n2 >> 16 & 255;
    buff[p2 + 2] = n2 >> 8 & 255;
    buff[p2 + 3] = n2 >> 0 & 255;
  },
  readUint64: function(buff, p2) {
    return Typr["B"].readUint(buff, p2) * (4294967295 + 1) + Typr["B"].readUint(buff, p2 + 4);
  },
  readASCII: function(buff, p2, l) {
    var s = "";
    for (var i2 = 0;i2 < l; i2++)
      s += String.fromCharCode(buff[p2 + i2]);
    return s;
  },
  writeASCII: function(buff, p2, s) {
    for (var i2 = 0;i2 < s.length; i2++)
      buff[p2 + i2] = s.charCodeAt(i2);
  },
  readUnicode: function(buff, p2, l) {
    var s = "";
    for (var i2 = 0;i2 < l; i2++) {
      var c = buff[p2++] << 8 | buff[p2++];
      s += String.fromCharCode(c);
    }
    return s;
  },
  _tdec: window["TextDecoder"] ? new window["TextDecoder"] : null,
  readUTF8: function(buff, p2, l) {
    var tdec = Typr["B"]._tdec;
    if (tdec && p2 == 0 && l == buff.length)
      return tdec["decode"](buff);
    return Typr["B"].readASCII(buff, p2, l);
  },
  readBytes: function(buff, p2, l) {
    var arr2 = [];
    for (var i2 = 0;i2 < l; i2++)
      arr2.push(buff[p2 + i2]);
    return arr2;
  },
  readASCIIArray: function(buff, p2, l) {
    var s = [];
    for (var i2 = 0;i2 < l; i2++)
      s.push(String.fromCharCode(buff[p2 + i2]));
    return s;
  },
  t: function() {
    var ab = new ArrayBuffer(8);
    return {
      buff: ab,
      int8: new Int8Array(ab),
      uint8: new Uint8Array(ab),
      int16: new Int16Array(ab),
      uint16: new Uint16Array(ab),
      int32: new Int32Array(ab),
      uint32: new Uint32Array(ab)
    };
  }()
};
Typr["T"].CFF = {
  parseTab: function(data3, offset2, length) {
    var bin = Typr["B"];
    var CFF = Typr["T"].CFF;
    data3 = new Uint8Array(data3.buffer, offset2, length);
    offset2 = 0;
    data3[offset2];
    offset2++;
    data3[offset2];
    offset2++;
    data3[offset2];
    offset2++;
    data3[offset2];
    offset2++;
    var ninds = [];
    offset2 = CFF.readIndex(data3, offset2, ninds);
    var names = [];
    for (var i2 = 0;i2 < ninds.length - 1; i2++)
      names.push(bin.readASCII(data3, offset2 + ninds[i2], ninds[i2 + 1] - ninds[i2]));
    offset2 += ninds[ninds.length - 1];
    var tdinds = [];
    offset2 = CFF.readIndex(data3, offset2, tdinds);
    var topDicts = [];
    for (var i2 = 0;i2 < tdinds.length - 1; i2++)
      topDicts.push(CFF.readDict(data3, offset2 + tdinds[i2], offset2 + tdinds[i2 + 1]));
    offset2 += tdinds[tdinds.length - 1];
    var topdict = topDicts[0];
    var sinds = [];
    offset2 = CFF.readIndex(data3, offset2, sinds);
    var strings3 = [];
    for (var i2 = 0;i2 < sinds.length - 1; i2++)
      strings3.push(bin.readASCII(data3, offset2 + sinds[i2], sinds[i2 + 1] - sinds[i2]));
    offset2 += sinds[sinds.length - 1];
    CFF.readSubrs(data3, offset2, topdict);
    if (topdict["CharStrings"])
      topdict["CharStrings"] = CFF.readBytes(data3, topdict["CharStrings"]);
    if (topdict["ROS"]) {
      offset2 = topdict["FDArray"];
      var fdind = [];
      offset2 = CFF.readIndex(data3, offset2, fdind);
      topdict["FDArray"] = [];
      for (var i2 = 0;i2 < fdind.length - 1; i2++) {
        var dict = CFF.readDict(data3, offset2 + fdind[i2], offset2 + fdind[i2 + 1]);
        CFF._readFDict(data3, dict, strings3);
        topdict["FDArray"].push(dict);
      }
      offset2 += fdind[fdind.length - 1];
      offset2 = topdict["FDSelect"];
      topdict["FDSelect"] = [];
      var fmt = data3[offset2];
      offset2++;
      if (fmt == 3) {
        var rns = bin.readUshort(data3, offset2);
        offset2 += 2;
        for (var i2 = 0;i2 < rns + 1; i2++) {
          topdict["FDSelect"].push(bin.readUshort(data3, offset2), data3[offset2 + 2]);
          offset2 += 3;
        }
      } else
        throw fmt;
    }
    if (topdict["charset"])
      topdict["charset"] = CFF.readCharset(data3, topdict["charset"], topdict["CharStrings"].length);
    CFF._readFDict(data3, topdict, strings3);
    return topdict;
  },
  _readFDict: function(data3, dict, ss) {
    var CFF = Typr["T"].CFF;
    var offset2;
    if (dict["Private"]) {
      offset2 = dict["Private"][1];
      dict["Private"] = CFF.readDict(data3, offset2, offset2 + dict["Private"][0]);
      if (dict["Private"]["Subrs"])
        CFF.readSubrs(data3, offset2 + dict["Private"]["Subrs"], dict["Private"]);
    }
    for (var p2 in dict)
      if (["FamilyName", "FontName", "FullName", "Notice", "version", "Copyright"].indexOf(p2) != -1)
        dict[p2] = ss[dict[p2] - 426 + 35];
  },
  readSubrs: function(data3, offset2, obj) {
    obj["Subrs"] = Typr["T"].CFF.readBytes(data3, offset2);
    var bias, nSubrs = obj["Subrs"].length + 1;
    if (nSubrs < 1240)
      bias = 107;
    else if (nSubrs < 33900)
      bias = 1131;
    else
      bias = 32768;
    obj["Bias"] = bias;
  },
  readBytes: function(data3, offset2) {
    Typr["B"];
    var arr2 = [];
    offset2 = Typr["T"].CFF.readIndex(data3, offset2, arr2);
    var subrs = [], arl = arr2.length - 1, no = data3.byteOffset + offset2;
    for (var i2 = 0;i2 < arl; i2++) {
      var ari = arr2[i2];
      subrs.push(new Uint8Array(data3.buffer, no + ari, arr2[i2 + 1] - ari));
    }
    return subrs;
  },
  tableSE: [
    0,
    0,
    0,
    0,
    0,
    0,
    0,
    0,
    0,
    0,
    0,
    0,
    0,
    0,
    0,
    0,
    0,
    0,
    0,
    0,
    0,
    0,
    0,
    0,
    0,
    0,
    0,
    0,
    0,
    0,
    0,
    0,
    1,
    2,
    3,
    4,
    5,
    6,
    7,
    8,
    9,
    10,
    11,
    12,
    13,
    14,
    15,
    16,
    17,
    18,
    19,
    20,
    21,
    22,
    23,
    24,
    25,
    26,
    27,
    28,
    29,
    30,
    31,
    32,
    33,
    34,
    35,
    36,
    37,
    38,
    39,
    40,
    41,
    42,
    43,
    44,
    45,
    46,
    47,
    48,
    49,
    50,
    51,
    52,
    53,
    54,
    55,
    56,
    57,
    58,
    59,
    60,
    61,
    62,
    63,
    64,
    65,
    66,
    67,
    68,
    69,
    70,
    71,
    72,
    73,
    74,
    75,
    76,
    77,
    78,
    79,
    80,
    81,
    82,
    83,
    84,
    85,
    86,
    87,
    88,
    89,
    90,
    91,
    92,
    93,
    94,
    95,
    0,
    0,
    0,
    0,
    0,
    0,
    0,
    0,
    0,
    0,
    0,
    0,
    0,
    0,
    0,
    0,
    0,
    0,
    0,
    0,
    0,
    0,
    0,
    0,
    0,
    0,
    0,
    0,
    0,
    0,
    0,
    0,
    0,
    0,
    96,
    97,
    98,
    99,
    100,
    101,
    102,
    103,
    104,
    105,
    106,
    107,
    108,
    109,
    110,
    0,
    111,
    112,
    113,
    114,
    0,
    115,
    116,
    117,
    118,
    119,
    120,
    121,
    122,
    0,
    123,
    0,
    124,
    125,
    126,
    127,
    128,
    129,
    130,
    131,
    0,
    132,
    133,
    0,
    134,
    135,
    136,
    137,
    0,
    0,
    0,
    0,
    0,
    0,
    0,
    0,
    0,
    0,
    0,
    0,
    0,
    0,
    0,
    0,
    138,
    0,
    139,
    0,
    0,
    0,
    0,
    140,
    141,
    142,
    143,
    0,
    0,
    0,
    0,
    0,
    144,
    0,
    0,
    0,
    145,
    0,
    0,
    146,
    147,
    148,
    149,
    0,
    0,
    0,
    0
  ],
  glyphByUnicode: function(cff, code) {
    for (var i2 = 0;i2 < cff["charset"].length; i2++)
      if (cff["charset"][i2] == code)
        return i2;
    return -1;
  },
  glyphBySE: function(cff, charcode) {
    if (charcode < 0 || charcode > 255)
      return -1;
    return Typr["T"].CFF.glyphByUnicode(cff, Typr["T"].CFF.tableSE[charcode]);
  },
  readCharset: function(data3, offset2, num) {
    var bin = Typr["B"];
    var charset = [".notdef"];
    var format = data3[offset2];
    offset2++;
    if (format == 0) {
      for (var i2 = 0;i2 < num; i2++) {
        var first = bin.readUshort(data3, offset2);
        offset2 += 2;
        charset.push(first);
      }
    } else if (format == 1 || format == 2) {
      while (charset.length < num) {
        var first = bin.readUshort(data3, offset2);
        offset2 += 2;
        var nLeft = 0;
        if (format == 1) {
          nLeft = data3[offset2];
          offset2++;
        } else {
          nLeft = bin.readUshort(data3, offset2);
          offset2 += 2;
        }
        for (var i2 = 0;i2 <= nLeft; i2++) {
          charset.push(first);
          first++;
        }
      }
    } else
      throw "error: format: " + format;
    return charset;
  },
  readIndex: function(data3, offset2, inds) {
    var bin = Typr["B"];
    var count = bin.readUshort(data3, offset2) + 1;
    offset2 += 2;
    var offsize = data3[offset2];
    offset2++;
    if (offsize == 1)
      for (var i2 = 0;i2 < count; i2++)
        inds.push(data3[offset2 + i2]);
    else if (offsize == 2)
      for (var i2 = 0;i2 < count; i2++)
        inds.push(bin.readUshort(data3, offset2 + i2 * 2));
    else if (offsize == 3)
      for (var i2 = 0;i2 < count; i2++)
        inds.push(bin.readUint(data3, offset2 + i2 * 3 - 1) & 16777215);
    else if (offsize == 4)
      for (var i2 = 0;i2 < count; i2++)
        inds.push(bin.readUint(data3, offset2 + i2 * 4));
    else if (count != 1)
      throw "unsupported offset size: " + offsize + ", count: " + count;
    offset2 += count * offsize;
    return offset2 - 1;
  },
  getCharString: function(data3, offset2, o) {
    var bin = Typr["B"];
    var b0 = data3[offset2], b1 = data3[offset2 + 1];
    data3[offset2 + 2];
    data3[offset2 + 3];
    data3[offset2 + 4];
    var vs = 1;
    var op = null, val = null;
    if (b0 <= 20) {
      op = b0;
      vs = 1;
    }
    if (b0 == 12) {
      op = b0 * 100 + b1;
      vs = 2;
    }
    if (21 <= b0 && b0 <= 27) {
      op = b0;
      vs = 1;
    }
    if (b0 == 28) {
      val = bin.readShort(data3, offset2 + 1);
      vs = 3;
    }
    if (29 <= b0 && b0 <= 31) {
      op = b0;
      vs = 1;
    }
    if (32 <= b0 && b0 <= 246) {
      val = b0 - 139;
      vs = 1;
    }
    if (247 <= b0 && b0 <= 250) {
      val = (b0 - 247) * 256 + b1 + 108;
      vs = 2;
    }
    if (251 <= b0 && b0 <= 254) {
      val = -(b0 - 251) * 256 - b1 - 108;
      vs = 2;
    }
    if (b0 == 255) {
      val = bin.readInt(data3, offset2 + 1) / 65535;
      vs = 5;
    }
    o.val = val != null ? val : "o" + op;
    o.size = vs;
  },
  readCharString: function(data3, offset2, length) {
    var end = offset2 + length;
    var bin = Typr["B"];
    var arr2 = [];
    while (offset2 < end) {
      var b0 = data3[offset2], b1 = data3[offset2 + 1];
      data3[offset2 + 2];
      data3[offset2 + 3];
      data3[offset2 + 4];
      var vs = 1;
      var op = null, val = null;
      if (b0 <= 20) {
        op = b0;
        vs = 1;
      }
      if (b0 == 12) {
        op = b0 * 100 + b1;
        vs = 2;
      }
      if (b0 == 19 || b0 == 20) {
        op = b0;
        vs = 2;
      }
      if (21 <= b0 && b0 <= 27) {
        op = b0;
        vs = 1;
      }
      if (b0 == 28) {
        val = bin.readShort(data3, offset2 + 1);
        vs = 3;
      }
      if (29 <= b0 && b0 <= 31) {
        op = b0;
        vs = 1;
      }
      if (32 <= b0 && b0 <= 246) {
        val = b0 - 139;
        vs = 1;
      }
      if (247 <= b0 && b0 <= 250) {
        val = (b0 - 247) * 256 + b1 + 108;
        vs = 2;
      }
      if (251 <= b0 && b0 <= 254) {
        val = -(b0 - 251) * 256 - b1 - 108;
        vs = 2;
      }
      if (b0 == 255) {
        val = bin.readInt(data3, offset2 + 1) / 65535;
        vs = 5;
      }
      arr2.push(val != null ? val : "o" + op);
      offset2 += vs;
    }
    return arr2;
  },
  readDict: function(data3, offset2, end) {
    var bin = Typr["B"];
    var dict = {};
    var carr = [];
    while (offset2 < end) {
      var b0 = data3[offset2], b1 = data3[offset2 + 1];
      data3[offset2 + 2];
      data3[offset2 + 3];
      data3[offset2 + 4];
      var vs = 1;
      var key = null, val = null;
      if (b0 == 28) {
        val = bin.readShort(data3, offset2 + 1);
        vs = 3;
      }
      if (b0 == 29) {
        val = bin.readInt(data3, offset2 + 1);
        vs = 5;
      }
      if (32 <= b0 && b0 <= 246) {
        val = b0 - 139;
        vs = 1;
      }
      if (247 <= b0 && b0 <= 250) {
        val = (b0 - 247) * 256 + b1 + 108;
        vs = 2;
      }
      if (251 <= b0 && b0 <= 254) {
        val = -(b0 - 251) * 256 - b1 - 108;
        vs = 2;
      }
      if (b0 == 255) {
        val = bin.readInt(data3, offset2 + 1) / 65535;
        vs = 5;
        throw "unknown number";
      }
      if (b0 == 30) {
        var nibs = [];
        vs = 1;
        while (true) {
          var b2 = data3[offset2 + vs];
          vs++;
          var nib0 = b2 >> 4, nib1 = b2 & 15;
          if (nib0 != 15)
            nibs.push(nib0);
          if (nib1 != 15)
            nibs.push(nib1);
          if (nib1 == 15)
            break;
        }
        var s = "";
        var chars = [0, 1, 2, 3, 4, 5, 6, 7, 8, 9, ".", "e", "e-", "reserved", "-", "endOfNumber"];
        for (var i2 = 0;i2 < nibs.length; i2++)
          s += chars[nibs[i2]];
        val = parseFloat(s);
      }
      if (b0 <= 21) {
        var keys = [
          "version",
          "Notice",
          "FullName",
          "FamilyName",
          "Weight",
          "FontBBox",
          "BlueValues",
          "OtherBlues",
          "FamilyBlues",
          "FamilyOtherBlues",
          "StdHW",
          "StdVW",
          "escape",
          "UniqueID",
          "XUID",
          "charset",
          "Encoding",
          "CharStrings",
          "Private",
          "Subrs",
          "defaultWidthX",
          "nominalWidthX"
        ];
        key = keys[b0];
        vs = 1;
        if (b0 == 12) {
          var keys = [
            "Copyright",
            "isFixedPitch",
            "ItalicAngle",
            "UnderlinePosition",
            "UnderlineThickness",
            "PaintType",
            "CharstringType",
            "FontMatrix",
            "StrokeWidth",
            "BlueScale",
            "BlueShift",
            "BlueFuzz",
            "StemSnapH",
            "StemSnapV",
            "ForceBold",
            "",
            "",
            "LanguageGroup",
            "ExpansionFactor",
            "initialRandomSeed",
            "SyntheticBase",
            "PostScript",
            "BaseFontName",
            "BaseFontBlend",
            "",
            "",
            "",
            "",
            "",
            "",
            "ROS",
            "CIDFontVersion",
            "CIDFontRevision",
            "CIDFontType",
            "CIDCount",
            "UIDBase",
            "FDArray",
            "FDSelect",
            "FontName"
          ];
          key = keys[b1];
          vs = 2;
        }
      }
      if (key != null) {
        dict[key] = carr.length == 1 ? carr[0] : carr;
        carr = [];
      } else
        carr.push(val);
      offset2 += vs;
    }
    return dict;
  }
};
Typr["T"].cmap = {
  parseTab: function(data3, offset2, length) {
    var obj = { tables: [], ids: {}, off: offset2 };
    data3 = new Uint8Array(data3.buffer, offset2, length);
    offset2 = 0;
    var bin = Typr["B"], rU = bin.readUshort, cmap = Typr["T"].cmap;
    rU(data3, offset2);
    offset2 += 2;
    var numTables = rU(data3, offset2);
    offset2 += 2;
    var offs = [];
    for (var i2 = 0;i2 < numTables; i2++) {
      var platformID = rU(data3, offset2);
      offset2 += 2;
      var encodingID = rU(data3, offset2);
      offset2 += 2;
      var noffset = bin.readUint(data3, offset2);
      offset2 += 4;
      var id = "p" + platformID + "e" + encodingID;
      var tind = offs.indexOf(noffset);
      if (tind == -1) {
        tind = obj.tables.length;
        var subt = {};
        offs.push(noffset);
        var format = subt.format = rU(data3, noffset);
        if (format == 0)
          subt = cmap.parse0(data3, noffset, subt);
        else if (format == 4)
          subt = cmap.parse4(data3, noffset, subt);
        else if (format == 6)
          subt = cmap.parse6(data3, noffset, subt);
        else if (format == 12)
          subt = cmap.parse12(data3, noffset, subt);
        obj.tables.push(subt);
      }
      if (obj.ids[id] != null)
        console.log("multiple tables for one platform+encoding: " + id);
      obj.ids[id] = tind;
    }
    return obj;
  },
  parse0: function(data3, offset2, obj) {
    var bin = Typr["B"];
    offset2 += 2;
    var len = bin.readUshort(data3, offset2);
    offset2 += 2;
    bin.readUshort(data3, offset2);
    offset2 += 2;
    obj.map = [];
    for (var i2 = 0;i2 < len - 6; i2++)
      obj.map.push(data3[offset2 + i2]);
    return obj;
  },
  parse4: function(data3, offset2, obj) {
    var bin = Typr["B"], rU = bin.readUshort, rUs = bin.readUshorts;
    var offset0 = offset2;
    offset2 += 2;
    var length = rU(data3, offset2);
    offset2 += 2;
    rU(data3, offset2);
    offset2 += 2;
    var segCountX2 = rU(data3, offset2);
    offset2 += 2;
    var segCount = segCountX2 >>> 1;
    obj.searchRange = rU(data3, offset2);
    offset2 += 2;
    obj.entrySelector = rU(data3, offset2);
    offset2 += 2;
    obj.rangeShift = rU(data3, offset2);
    offset2 += 2;
    obj.endCount = rUs(data3, offset2, segCount);
    offset2 += segCount * 2;
    offset2 += 2;
    obj.startCount = rUs(data3, offset2, segCount);
    offset2 += segCount * 2;
    obj.idDelta = [];
    for (var i2 = 0;i2 < segCount; i2++) {
      obj.idDelta.push(bin.readShort(data3, offset2));
      offset2 += 2;
    }
    obj.idRangeOffset = rUs(data3, offset2, segCount);
    offset2 += segCount * 2;
    obj.glyphIdArray = rUs(data3, offset2, offset0 + length - offset2 >> 1);
    return obj;
  },
  parse6: function(data3, offset2, obj) {
    var bin = Typr["B"];
    offset2 += 2;
    bin.readUshort(data3, offset2);
    offset2 += 2;
    bin.readUshort(data3, offset2);
    offset2 += 2;
    obj.firstCode = bin.readUshort(data3, offset2);
    offset2 += 2;
    var entryCount = bin.readUshort(data3, offset2);
    offset2 += 2;
    obj.glyphIdArray = [];
    for (var i2 = 0;i2 < entryCount; i2++) {
      obj.glyphIdArray.push(bin.readUshort(data3, offset2));
      offset2 += 2;
    }
    return obj;
  },
  parse12: function(data3, offset2, obj) {
    var bin = Typr["B"], rU = bin.readUint;
    offset2 += 4;
    rU(data3, offset2);
    offset2 += 4;
    rU(data3, offset2);
    offset2 += 4;
    var nGroups = rU(data3, offset2) * 3;
    offset2 += 4;
    var gps = obj.groups = new Uint32Array(nGroups);
    for (var i2 = 0;i2 < nGroups; i2 += 3) {
      gps[i2] = rU(data3, offset2 + (i2 << 2));
      gps[i2 + 1] = rU(data3, offset2 + (i2 << 2) + 4);
      gps[i2 + 2] = rU(data3, offset2 + (i2 << 2) + 8);
    }
    return obj;
  }
};
Typr["T"].CBLC = {
  parseTab: function(data3, offset2, length) {
    var bin = Typr["B"], ooff = offset2;
    bin.readUshort(data3, offset2);
    offset2 += 2;
    bin.readUshort(data3, offset2);
    offset2 += 2;
    var numSizes = bin.readUint(data3, offset2);
    offset2 += 4;
    var out = [];
    for (var i2 = 0;i2 < numSizes; i2++) {
      var off = bin.readUint(data3, offset2);
      offset2 += 4;
      bin.readUint(data3, offset2);
      offset2 += 4;
      bin.readUint(data3, offset2);
      offset2 += 4;
      offset2 += 4;
      offset2 += 2 * 12;
      bin.readUshort(data3, offset2);
      offset2 += 2;
      bin.readUshort(data3, offset2);
      offset2 += 2;
      offset2 += 4;
      var coff = ooff + off;
      for (var j = 0;j < 3; j++) {
        var fgI = bin.readUshort(data3, coff);
        coff += 2;
        var lgI = bin.readUshort(data3, coff);
        coff += 2;
        var nxt = bin.readUint(data3, coff);
        coff += 4;
        var gcnt = lgI - fgI + 1;
        var ioff = ooff + off + nxt;
        var inF = bin.readUshort(data3, ioff);
        ioff += 2;
        if (inF != 1)
          throw inF;
        var imF = bin.readUshort(data3, ioff);
        ioff += 2;
        var imgo = bin.readUint(data3, ioff);
        ioff += 4;
        var oarr = [];
        for (var gi = 0;gi < gcnt; gi++) {
          var sbitO = bin.readUint(data3, ioff + gi * 4);
          oarr.push(imgo + sbitO);
        }
        out.push([fgI, lgI, imF, oarr]);
      }
    }
    return out;
  }
};
Typr["T"].CBDT = {
  parseTab: function(data3, offset2, length) {
    Typr["B"];
    return new Uint8Array(data3.buffer, data3.byteOffset + offset2, length);
  }
};
Typr["T"].glyf = {
  parseTab: function(data3, offset2, length, font) {
    var obj = [], ng = font["maxp"]["numGlyphs"];
    for (var g2 = 0;g2 < ng; g2++)
      obj.push(null);
    return obj;
  },
  _parseGlyf: function(font, g2) {
    var bin = Typr["B"];
    var data3 = font["_data"], loca = font["loca"];
    if (loca[g2] == loca[g2 + 1])
      return null;
    var offset2 = Typr["findTable"](data3, "glyf", font["_offset"])[0] + loca[g2];
    var gl = {};
    gl.noc = bin.readShort(data3, offset2);
    offset2 += 2;
    gl.xMin = bin.readShort(data3, offset2);
    offset2 += 2;
    gl.yMin = bin.readShort(data3, offset2);
    offset2 += 2;
    gl.xMax = bin.readShort(data3, offset2);
    offset2 += 2;
    gl.yMax = bin.readShort(data3, offset2);
    offset2 += 2;
    if (gl.xMin >= gl.xMax || gl.yMin >= gl.yMax)
      return null;
    if (gl.noc > 0) {
      gl.endPts = [];
      for (var i2 = 0;i2 < gl.noc; i2++) {
        gl.endPts.push(bin.readUshort(data3, offset2));
        offset2 += 2;
      }
      var instructionLength = bin.readUshort(data3, offset2);
      offset2 += 2;
      if (data3.length - offset2 < instructionLength)
        return null;
      gl.instructions = bin.readBytes(data3, offset2, instructionLength);
      offset2 += instructionLength;
      var crdnum = gl.endPts[gl.noc - 1] + 1;
      gl.flags = [];
      for (var i2 = 0;i2 < crdnum; i2++) {
        var flag = data3[offset2];
        offset2++;
        gl.flags.push(flag);
        if ((flag & 8) != 0) {
          var rep = data3[offset2];
          offset2++;
          for (var j = 0;j < rep; j++) {
            gl.flags.push(flag);
            i2++;
          }
        }
      }
      gl.xs = [];
      for (var i2 = 0;i2 < crdnum; i2++) {
        var i8 = (gl.flags[i2] & 2) != 0, same = (gl.flags[i2] & 16) != 0;
        if (i8) {
          gl.xs.push(same ? data3[offset2] : -data3[offset2]);
          offset2++;
        } else {
          if (same)
            gl.xs.push(0);
          else {
            gl.xs.push(bin.readShort(data3, offset2));
            offset2 += 2;
          }
        }
      }
      gl.ys = [];
      for (var i2 = 0;i2 < crdnum; i2++) {
        var i8 = (gl.flags[i2] & 4) != 0, same = (gl.flags[i2] & 32) != 0;
        if (i8) {
          gl.ys.push(same ? data3[offset2] : -data3[offset2]);
          offset2++;
        } else {
          if (same)
            gl.ys.push(0);
          else {
            gl.ys.push(bin.readShort(data3, offset2));
            offset2 += 2;
          }
        }
      }
      var x = 0, y = 0;
      for (var i2 = 0;i2 < crdnum; i2++) {
        x += gl.xs[i2];
        y += gl.ys[i2];
        gl.xs[i2] = x;
        gl.ys[i2] = y;
      }
    } else {
      var ARG_1_AND_2_ARE_WORDS = 1 << 0;
      var ARGS_ARE_XY_VALUES = 1 << 1;
      var WE_HAVE_A_SCALE = 1 << 3;
      var MORE_COMPONENTS = 1 << 5;
      var WE_HAVE_AN_X_AND_Y_SCALE = 1 << 6;
      var WE_HAVE_A_TWO_BY_TWO = 1 << 7;
      var WE_HAVE_INSTRUCTIONS = 1 << 8;
      gl.parts = [];
      var flags;
      do {
        flags = bin.readUshort(data3, offset2);
        offset2 += 2;
        var part = { m: { a: 1, b: 0, c: 0, d: 1, tx: 0, ty: 0 }, p1: -1, p2: -1 };
        gl.parts.push(part);
        part.glyphIndex = bin.readUshort(data3, offset2);
        offset2 += 2;
        if (flags & ARG_1_AND_2_ARE_WORDS) {
          var arg1 = bin.readShort(data3, offset2);
          offset2 += 2;
          var arg2 = bin.readShort(data3, offset2);
          offset2 += 2;
        } else {
          var arg1 = bin.readInt8(data3, offset2);
          offset2++;
          var arg2 = bin.readInt8(data3, offset2);
          offset2++;
        }
        if (flags & ARGS_ARE_XY_VALUES) {
          part.m.tx = arg1;
          part.m.ty = arg2;
        } else {
          part.p1 = arg1;
          part.p2 = arg2;
        }
        if (flags & WE_HAVE_A_SCALE) {
          part.m.a = part.m.d = bin.readF2dot14(data3, offset2);
          offset2 += 2;
        } else if (flags & WE_HAVE_AN_X_AND_Y_SCALE) {
          part.m.a = bin.readF2dot14(data3, offset2);
          offset2 += 2;
          part.m.d = bin.readF2dot14(data3, offset2);
          offset2 += 2;
        } else if (flags & WE_HAVE_A_TWO_BY_TWO) {
          part.m.a = bin.readF2dot14(data3, offset2);
          offset2 += 2;
          part.m.b = bin.readF2dot14(data3, offset2);
          offset2 += 2;
          part.m.c = bin.readF2dot14(data3, offset2);
          offset2 += 2;
          part.m.d = bin.readF2dot14(data3, offset2);
          offset2 += 2;
        }
      } while (flags & MORE_COMPONENTS);
      if (flags & WE_HAVE_INSTRUCTIONS) {
        var numInstr = bin.readUshort(data3, offset2);
        offset2 += 2;
        gl.instr = [];
        for (var i2 = 0;i2 < numInstr; i2++) {
          gl.instr.push(data3[offset2]);
          offset2++;
        }
      }
    }
    return gl;
  }
};
Typr["T"].head = {
  parseTab: function(data3, offset2, length) {
    var bin = Typr["B"];
    var obj = {};
    bin.readFixed(data3, offset2);
    offset2 += 4;
    obj["fontRevision"] = bin.readFixed(data3, offset2);
    offset2 += 4;
    bin.readUint(data3, offset2);
    offset2 += 4;
    bin.readUint(data3, offset2);
    offset2 += 4;
    obj["flags"] = bin.readUshort(data3, offset2);
    offset2 += 2;
    obj["unitsPerEm"] = bin.readUshort(data3, offset2);
    offset2 += 2;
    obj["created"] = bin.readUint64(data3, offset2);
    offset2 += 8;
    obj["modified"] = bin.readUint64(data3, offset2);
    offset2 += 8;
    obj["xMin"] = bin.readShort(data3, offset2);
    offset2 += 2;
    obj["yMin"] = bin.readShort(data3, offset2);
    offset2 += 2;
    obj["xMax"] = bin.readShort(data3, offset2);
    offset2 += 2;
    obj["yMax"] = bin.readShort(data3, offset2);
    offset2 += 2;
    obj["macStyle"] = bin.readUshort(data3, offset2);
    offset2 += 2;
    obj["lowestRecPPEM"] = bin.readUshort(data3, offset2);
    offset2 += 2;
    obj["fontDirectionHint"] = bin.readShort(data3, offset2);
    offset2 += 2;
    obj["indexToLocFormat"] = bin.readShort(data3, offset2);
    offset2 += 2;
    obj["glyphDataFormat"] = bin.readShort(data3, offset2);
    offset2 += 2;
    return obj;
  }
};
Typr["T"].hhea = {
  parseTab: function(data3, offset2, length) {
    var bin = Typr["B"];
    var obj = {};
    bin.readFixed(data3, offset2);
    offset2 += 4;
    var keys = [
      "ascender",
      "descender",
      "lineGap",
      "advanceWidthMax",
      "minLeftSideBearing",
      "minRightSideBearing",
      "xMaxExtent",
      "caretSlopeRise",
      "caretSlopeRun",
      "caretOffset",
      "res0",
      "res1",
      "res2",
      "res3",
      "metricDataFormat",
      "numberOfHMetrics"
    ];
    for (var i2 = 0;i2 < keys.length; i2++) {
      var key = keys[i2];
      var func = key == "advanceWidthMax" || key == "numberOfHMetrics" ? bin.readUshort : bin.readShort;
      obj[key] = func(data3, offset2 + i2 * 2);
    }
    return obj;
  }
};
Typr["T"].hmtx = {
  parseTab: function(data3, offset2, length, font) {
    var bin = Typr["B"];
    var aWidth = [];
    var lsBearing = [];
    var nG = font["maxp"]["numGlyphs"], nH = font["hhea"]["numberOfHMetrics"];
    var aw = 0, lsb = 0, i2 = 0;
    while (i2 < nH) {
      aw = bin.readUshort(data3, offset2 + (i2 << 2));
      lsb = bin.readShort(data3, offset2 + (i2 << 2) + 2);
      aWidth.push(aw);
      lsBearing.push(lsb);
      i2++;
    }
    while (i2 < nG) {
      aWidth.push(aw);
      lsBearing.push(lsb);
      i2++;
    }
    return { aWidth, lsBearing };
  }
};
Typr["T"].kern = {
  parseTab: function(data3, offset2, length, font) {
    var bin = Typr["B"], kern = Typr["T"].kern;
    var version3 = bin.readUshort(data3, offset2);
    if (version3 == 1)
      return kern.parseV1(data3, offset2, length, font);
    var nTables = bin.readUshort(data3, offset2 + 2);
    offset2 += 4;
    var map3 = { glyph1: [], rval: [] };
    for (var i2 = 0;i2 < nTables; i2++) {
      offset2 += 2;
      var length = bin.readUshort(data3, offset2);
      offset2 += 2;
      var coverage = bin.readUshort(data3, offset2);
      offset2 += 2;
      var format = coverage >>> 8;
      format &= 15;
      if (format == 0)
        offset2 = kern.readFormat0(data3, offset2, map3);
    }
    return map3;
  },
  parseV1: function(data3, offset2, length, font) {
    var bin = Typr["B"], kern = Typr["T"].kern;
    bin.readFixed(data3, offset2);
    var nTables = bin.readUint(data3, offset2 + 4);
    offset2 += 8;
    var map3 = { glyph1: [], rval: [] };
    for (var i2 = 0;i2 < nTables; i2++) {
      bin.readUint(data3, offset2);
      offset2 += 4;
      var coverage = bin.readUshort(data3, offset2);
      offset2 += 2;
      bin.readUshort(data3, offset2);
      offset2 += 2;
      var format = coverage & 255;
      if (format == 0)
        offset2 = kern.readFormat0(data3, offset2, map3);
    }
    return map3;
  },
  readFormat0: function(data3, offset2, map3) {
    var bin = Typr["B"], rUs = bin.readUshort;
    var pleft = -1;
    var nPairs = rUs(data3, offset2);
    rUs(data3, offset2 + 2);
    rUs(data3, offset2 + 4);
    rUs(data3, offset2 + 6);
    offset2 += 8;
    for (var j = 0;j < nPairs; j++) {
      var left = rUs(data3, offset2);
      offset2 += 2;
      var right = rUs(data3, offset2);
      offset2 += 2;
      var value = bin.readShort(data3, offset2);
      offset2 += 2;
      if (left != pleft) {
        map3.glyph1.push(left);
        map3.rval.push({ glyph2: [], vals: [] });
      }
      var rval = map3.rval[map3.rval.length - 1];
      rval.glyph2.push(right);
      rval.vals.push(value);
      pleft = left;
    }
    return offset2;
  }
};
Typr["T"].loca = {
  parseTab: function(data3, offset2, length, font) {
    var bin = Typr["B"];
    var obj = [];
    var ver = font["head"]["indexToLocFormat"];
    var len = font["maxp"]["numGlyphs"] + 1;
    if (ver == 0)
      for (var i2 = 0;i2 < len; i2++)
        obj.push(bin.readUshort(data3, offset2 + (i2 << 1)) << 1);
    if (ver == 1)
      for (var i2 = 0;i2 < len; i2++)
        obj.push(bin.readUint(data3, offset2 + (i2 << 2)));
    return obj;
  }
};
Typr["T"].maxp = {
  parseTab: function(data3, offset2, length) {
    var bin = Typr["B"], rU = bin.readUshort;
    var obj = {};
    bin.readUint(data3, offset2);
    offset2 += 4;
    obj["numGlyphs"] = rU(data3, offset2);
    offset2 += 2;
    return obj;
  }
};
Typr["T"].name = {
  parseTab: function(data3, offset2, length) {
    var bin = Typr["B"];
    var obj = {};
    bin.readUshort(data3, offset2);
    offset2 += 2;
    var count = bin.readUshort(data3, offset2);
    offset2 += 2;
    var stringOffset = bin.readUshort(data3, offset2);
    offset2 += 2;
    var ooo = offset2 - 6 + stringOffset;
    var names = [
      "copyright",
      "fontFamily",
      "fontSubfamily",
      "ID",
      "fullName",
      "version",
      "postScriptName",
      "trademark",
      "manufacturer",
      "designer",
      "description",
      "urlVendor",
      "urlDesigner",
      "licence",
      "licenceURL",
      "---",
      "typoFamilyName",
      "typoSubfamilyName",
      "compatibleFull",
      "sampleText",
      "postScriptCID",
      "wwsFamilyName",
      "wwsSubfamilyName",
      "lightPalette",
      "darkPalette"
    ];
    var rU = bin.readUshort;
    for (var i2 = 0;i2 < count; i2++) {
      var platformID = rU(data3, offset2);
      offset2 += 2;
      var encodingID = rU(data3, offset2);
      offset2 += 2;
      var languageID = rU(data3, offset2);
      offset2 += 2;
      var nameID = rU(data3, offset2);
      offset2 += 2;
      var slen = rU(data3, offset2);
      offset2 += 2;
      var noffset = rU(data3, offset2);
      offset2 += 2;
      var soff = ooo + noffset;
      var str;
      if (platformID == 0)
        str = bin.readUnicode(data3, soff, slen / 2);
      else if (platformID == 3 && encodingID == 0)
        str = bin.readUnicode(data3, soff, slen / 2);
      else if (platformID == 1 && encodingID == 25)
        str = bin.readUnicode(data3, soff, slen / 2);
      else if (encodingID == 0)
        str = bin.readASCII(data3, soff, slen);
      else if (encodingID == 1)
        str = bin.readUnicode(data3, soff, slen / 2);
      else if (encodingID == 3)
        str = bin.readUnicode(data3, soff, slen / 2);
      else if (encodingID == 4)
        str = bin.readUnicode(data3, soff, slen / 2);
      else if (encodingID == 5)
        str = bin.readUnicode(data3, soff, slen / 2);
      else if (encodingID == 10)
        str = bin.readUnicode(data3, soff, slen / 2);
      else if (platformID == 1) {
        str = bin.readASCII(data3, soff, slen);
        console.log("reading unknown MAC encoding " + encodingID + " as ASCII");
      } else {
        console.log("unknown encoding " + encodingID + ", platformID: " + platformID);
        str = bin.readASCII(data3, soff, slen);
      }
      var tid = "p" + platformID + "," + languageID.toString(16);
      if (obj[tid] == null)
        obj[tid] = {};
      var name = names[nameID];
      if (name == null)
        name = "_" + nameID;
      obj[tid][name] = str;
      obj[tid]["_lang"] = languageID;
    }
    var out = Typr["T"].name.selectOne(obj), ff = "fontFamily";
    if (out[ff] == null) {
      for (var p2 in obj)
        if (obj[p2][ff] != null)
          out[ff] = obj[p2][ff];
    }
    return out;
  },
  selectOne: function(obj) {
    var psn = "postScriptName";
    for (var p2 in obj)
      if (obj[p2][psn] != null && obj[p2]["_lang"] == 1033)
        return obj[p2];
    for (var p2 in obj)
      if (obj[p2][psn] != null && obj[p2]["_lang"] == 0)
        return obj[p2];
    for (var p2 in obj)
      if (obj[p2][psn] != null && obj[p2]["_lang"] == 3084)
        return obj[p2];
    for (var p2 in obj)
      if (obj[p2][psn] != null)
        return obj[p2];
    var out;
    for (var p2 in obj) {
      out = obj[p2];
      break;
    }
    console.log("returning name table with languageID " + out._lang);
    if (out[psn] == null && out["ID"] != null)
      out[psn] = out["ID"];
    return out;
  }
};
Typr["T"].OS2 = {
  parseTab: function(data3, offset2, length) {
    var bin = Typr["B"];
    var ver = bin.readUshort(data3, offset2);
    offset2 += 2;
    var OS2 = Typr["T"].OS2;
    var obj = {};
    if (ver == 0)
      OS2.version0(data3, offset2, obj);
    else if (ver == 1)
      OS2.version1(data3, offset2, obj);
    else if (ver == 2 || ver == 3 || ver == 4)
      OS2.version2(data3, offset2, obj);
    else if (ver == 5)
      OS2.version5(data3, offset2, obj);
    else
      throw "unknown OS/2 table version: " + ver;
    return obj;
  },
  version0: function(data3, offset2, obj) {
    var bin = Typr["B"];
    obj["xAvgCharWidth"] = bin.readShort(data3, offset2);
    offset2 += 2;
    obj["usWeightClass"] = bin.readUshort(data3, offset2);
    offset2 += 2;
    obj["usWidthClass"] = bin.readUshort(data3, offset2);
    offset2 += 2;
    obj["fsType"] = bin.readUshort(data3, offset2);
    offset2 += 2;
    obj["ySubscriptXSize"] = bin.readShort(data3, offset2);
    offset2 += 2;
    obj["ySubscriptYSize"] = bin.readShort(data3, offset2);
    offset2 += 2;
    obj["ySubscriptXOffset"] = bin.readShort(data3, offset2);
    offset2 += 2;
    obj["ySubscriptYOffset"] = bin.readShort(data3, offset2);
    offset2 += 2;
    obj["ySuperscriptXSize"] = bin.readShort(data3, offset2);
    offset2 += 2;
    obj["ySuperscriptYSize"] = bin.readShort(data3, offset2);
    offset2 += 2;
    obj["ySuperscriptXOffset"] = bin.readShort(data3, offset2);
    offset2 += 2;
    obj["ySuperscriptYOffset"] = bin.readShort(data3, offset2);
    offset2 += 2;
    obj["yStrikeoutSize"] = bin.readShort(data3, offset2);
    offset2 += 2;
    obj["yStrikeoutPosition"] = bin.readShort(data3, offset2);
    offset2 += 2;
    obj["sFamilyClass"] = bin.readShort(data3, offset2);
    offset2 += 2;
    obj["panose"] = bin.readBytes(data3, offset2, 10);
    offset2 += 10;
    obj["ulUnicodeRange1"] = bin.readUint(data3, offset2);
    offset2 += 4;
    obj["ulUnicodeRange2"] = bin.readUint(data3, offset2);
    offset2 += 4;
    obj["ulUnicodeRange3"] = bin.readUint(data3, offset2);
    offset2 += 4;
    obj["ulUnicodeRange4"] = bin.readUint(data3, offset2);
    offset2 += 4;
    obj["achVendID"] = bin.readASCII(data3, offset2, 4);
    offset2 += 4;
    obj["fsSelection"] = bin.readUshort(data3, offset2);
    offset2 += 2;
    obj["usFirstCharIndex"] = bin.readUshort(data3, offset2);
    offset2 += 2;
    obj["usLastCharIndex"] = bin.readUshort(data3, offset2);
    offset2 += 2;
    obj["sTypoAscender"] = bin.readShort(data3, offset2);
    offset2 += 2;
    obj["sTypoDescender"] = bin.readShort(data3, offset2);
    offset2 += 2;
    obj["sTypoLineGap"] = bin.readShort(data3, offset2);
    offset2 += 2;
    obj["usWinAscent"] = bin.readUshort(data3, offset2);
    offset2 += 2;
    obj["usWinDescent"] = bin.readUshort(data3, offset2);
    offset2 += 2;
    return offset2;
  },
  version1: function(data3, offset2, obj) {
    var bin = Typr["B"];
    offset2 = Typr["T"].OS2.version0(data3, offset2, obj);
    obj["ulCodePageRange1"] = bin.readUint(data3, offset2);
    offset2 += 4;
    obj["ulCodePageRange2"] = bin.readUint(data3, offset2);
    offset2 += 4;
    return offset2;
  },
  version2: function(data3, offset2, obj) {
    var bin = Typr["B"], rU = bin.readUshort;
    offset2 = Typr["T"].OS2.version1(data3, offset2, obj);
    obj["sxHeight"] = bin.readShort(data3, offset2);
    offset2 += 2;
    obj["sCapHeight"] = bin.readShort(data3, offset2);
    offset2 += 2;
    obj["usDefault"] = rU(data3, offset2);
    offset2 += 2;
    obj["usBreak"] = rU(data3, offset2);
    offset2 += 2;
    obj["usMaxContext"] = rU(data3, offset2);
    offset2 += 2;
    return offset2;
  },
  version5: function(data3, offset2, obj) {
    var rU = Typr["B"].readUshort;
    offset2 = Typr["T"].OS2.version2(data3, offset2, obj);
    obj["usLowerOpticalPointSize"] = rU(data3, offset2);
    offset2 += 2;
    obj["usUpperOpticalPointSize"] = rU(data3, offset2);
    offset2 += 2;
    return offset2;
  }
};
Typr["T"].post = {
  parseTab: function(data3, offset2, length) {
    var bin = Typr["B"];
    var obj = {};
    obj["version"] = bin.readFixed(data3, offset2);
    offset2 += 4;
    obj["italicAngle"] = bin.readFixed(data3, offset2);
    offset2 += 4;
    obj["underlinePosition"] = bin.readShort(data3, offset2);
    offset2 += 2;
    obj["underlineThickness"] = bin.readShort(data3, offset2);
    offset2 += 2;
    return obj;
  }
};
Typr["T"].SVG = {
  parseTab: function(data3, offset2, length) {
    var bin = Typr["B"];
    var obj = { entries: [], svgs: [] };
    var offset0 = offset2;
    bin.readUshort(data3, offset2);
    offset2 += 2;
    var svgDocIndexOffset = bin.readUint(data3, offset2);
    offset2 += 4;
    bin.readUint(data3, offset2);
    offset2 += 4;
    offset2 = svgDocIndexOffset + offset0;
    var numEntries = bin.readUshort(data3, offset2);
    offset2 += 2;
    for (var i2 = 0;i2 < numEntries; i2++) {
      var startGlyphID = bin.readUshort(data3, offset2);
      offset2 += 2;
      var endGlyphID = bin.readUshort(data3, offset2);
      offset2 += 2;
      var svgDocOffset = bin.readUint(data3, offset2);
      offset2 += 4;
      var svgDocLength = bin.readUint(data3, offset2);
      offset2 += 4;
      var sbuf = new Uint8Array(data3.buffer, offset0 + svgDocOffset + svgDocIndexOffset, svgDocLength);
      if (sbuf[0] == 31 && sbuf[1] == 139 && sbuf[2] == 8)
        sbuf = pako["inflate"](sbuf);
      var svg = bin.readUTF8(sbuf, 0, sbuf.length);
      for (var f = startGlyphID;f <= endGlyphID; f++) {
        obj.entries[f] = obj.svgs.length;
      }
      obj.svgs.push(svg);
    }
    return obj;
  }
};
Typr["T"].sbix = {
  parseTab: function(data3, offset2, length, obj) {
    var numGlyphs = obj["maxp"]["numGlyphs"];
    var ooff = offset2;
    var bin = Typr["B"];
    var numStrikes = bin.readUint(data3, offset2 + 4);
    var out = [];
    for (var si = numStrikes - 1;si < numStrikes; si++) {
      var off = ooff + bin.readUint(data3, offset2 + 8 + si * 4);
      for (var gi = 0;gi < numGlyphs; gi++) {
        var aoff = bin.readUint(data3, off + 4 + gi * 4);
        var noff = bin.readUint(data3, off + 4 + gi * 4 + 4);
        if (aoff == noff) {
          out[gi] = null;
          continue;
        }
        var go = off + aoff;
        var tag = bin.readASCII(data3, go + 4, 4);
        if (tag != "png ")
          throw tag;
        out[gi] = new Uint8Array(data3.buffer, data3.byteOffset + go + 8, noff - aoff - 8);
      }
    }
    return out;
  }
};
Typr["T"].colr = {
  parseTab: function(data3, offset2, length) {
    var bin = Typr["B"];
    var ooff = offset2;
    offset2 += 2;
    var num = bin.readUshort(data3, offset2);
    offset2 += 2;
    var boff = bin.readUint(data3, offset2);
    offset2 += 4;
    var loff = bin.readUint(data3, offset2);
    offset2 += 4;
    var lnum = bin.readUshort(data3, offset2);
    offset2 += 2;
    var base2 = {};
    var coff = ooff + boff;
    for (var i2 = 0;i2 < num; i2++) {
      base2["g" + bin.readUshort(data3, coff)] = [bin.readUshort(data3, coff + 2), bin.readUshort(data3, coff + 4)];
      coff += 6;
    }
    var lays = [];
    coff = ooff + loff;
    for (var i2 = 0;i2 < lnum; i2++) {
      lays.push(bin.readUshort(data3, coff), bin.readUshort(data3, coff + 2));
      coff += 4;
    }
    return [base2, lays];
  }
};
Typr["T"].cpal = {
  parseTab: function(data3, offset2, length) {
    var bin = Typr["B"];
    var ooff = offset2;
    var vsn = bin.readUshort(data3, offset2);
    offset2 += 2;
    if (vsn == 0) {
      bin.readUshort(data3, offset2);
      offset2 += 2;
      bin.readUshort(data3, offset2);
      offset2 += 2;
      var tot = bin.readUshort(data3, offset2);
      offset2 += 2;
      var fst = bin.readUint(data3, offset2);
      offset2 += 4;
      return new Uint8Array(data3.buffer, ooff + fst, tot * 4);
    } else
      throw vsn;
  }
};
Typr["T"].GSUB = {
  parseTab: function(data3, offset2, length, obj) {
    var bin = Typr["B"], rU = bin.readUshort;
    bin.readUint;
    var off = offset2;
    rU(data3, off);
    off += 2;
    rU(data3, off);
    off += 2;
    rU(data3, off);
    off += 2;
    var flO = rU(data3, off);
    off += 2;
    rU(data3, off);
    off += 2;
    off = offset2 + flO;
    var fmap = {};
    var cnt = rU(data3, off);
    off += 2;
    for (var i2 = 0;i2 < cnt; i2++) {
      var tag = bin.readASCII(data3, off, 4);
      off += 4;
      rU(data3, off);
      off += 2;
      fmap[tag] = true;
    }
    return fmap;
  }
};
Typr["T"].fvar = {
  parseTab: function(data3, offset2, length, obj) {
    var name = obj["name"];
    var off = offset2;
    var bin = Typr["B"];
    var axes = [], inst = [];
    off += 8;
    var acnt = bin.readUshort(data3, off);
    off += 2;
    off += 2;
    var icnt = bin.readUshort(data3, off);
    off += 2;
    var isiz = bin.readUshort(data3, off);
    off += 2;
    for (var i2 = 0;i2 < acnt; i2++) {
      var tag = bin.readASCII(data3, off, 4);
      var min = bin.readFixed(data3, off + 4);
      var def = bin.readFixed(data3, off + 8);
      var max = bin.readFixed(data3, off + 12);
      var flg = bin.readUshort(data3, off + 16);
      var nid = bin.readUshort(data3, off + 18);
      axes.push([tag, min, def, max, flg, name["_" + nid]]);
      off += 20;
    }
    for (var i2 = 0;i2 < icnt; i2++) {
      var snid = bin.readUshort(data3, off), pnid = null;
      var flg = bin.readUshort(data3, off + 2);
      var crd = [];
      for (var j = 0;j < acnt; j++)
        crd.push(bin.readFixed(data3, off + 4 + j * 4));
      off += 4 + acnt * 4;
      if ((isiz & 3) == 2) {
        pnid = bin.readUshort(data3, off);
        off += 2;
      }
      inst.push([name["_" + snid], flg, crd, pnid]);
    }
    return [axes, inst];
  }
};
Typr["T"].gvar = function() {
  var EMBEDDED_PEAK_TUPLE = 32768;
  var INTERMEDIATE_REGION = 16384;
  var PRIVATE_POINT_NUMBERS = 8192;
  var DELTAS_ARE_ZERO = 128;
  var DELTAS_ARE_WORDS = 64;
  var POINTS_ARE_WORDS = 128;
  var SHARED_POINT_NUMBERS = 32768;
  var bin = Typr["B"];
  function readTuple(data3, o, acnt) {
    var tup = [];
    for (var j = 0;j < acnt; j++)
      tup.push(bin.readF2dot14(data3, o + j * 2));
    return tup;
  }
  function readTupleVarHeader(data3, off, vcnt, acnt, eoff) {
    var out = [];
    for (var j = 0;j < vcnt; j++) {
      var dsiz = bin.readUshort(data3, off);
      off += 2;
      var tind = bin.readUshort(data3, off), flag = tind & 61440;
      tind = tind & 4095;
      off += 2;
      var peak = null, start = null, end = null;
      if (flag & EMBEDDED_PEAK_TUPLE) {
        peak = readTuple(data3, off, acnt);
        off += acnt * 2;
      }
      if (flag & INTERMEDIATE_REGION) {
        start = readTuple(data3, off, acnt);
        off += acnt * 2;
      }
      if (flag & INTERMEDIATE_REGION) {
        end = readTuple(data3, off, acnt);
        off += acnt * 2;
      }
      out.push([dsiz, tind, flag, start, peak, end]);
    }
    return out;
  }
  function readPointNumbers(data3, off, gid) {
    var cnt = data3[off];
    off++;
    if (cnt == 0)
      return [[], off];
    if (127 < cnt) {
      cnt = (cnt & 127) << 8 | data3[off++];
    }
    var pts = [], last2 = 0;
    while (pts.length < cnt) {
      var v = data3[off];
      off++;
      var wds = (v & POINTS_ARE_WORDS) != 0;
      v = (v & 127) + 1;
      for (var i2 = 0;i2 < v; i2++) {
        var dif = 0;
        if (wds) {
          dif = bin.readUshort(data3, off);
          off += 2;
        } else {
          dif = data3[off];
          off++;
        }
        last2 += dif;
        pts.push(last2);
      }
    }
    return [pts, off];
  }
  function parseTab(data3, offset2, length, obj) {
    var off = offset2 + 4;
    var acnt = bin.readUshort(data3, off);
    off += 2;
    var tcnt = bin.readUshort(data3, off);
    off += 2;
    var toff = bin.readUint(data3, off);
    off += 4;
    var gcnt = bin.readUshort(data3, off);
    off += 2;
    bin.readUshort(data3, off);
    off += 2;
    var goff = bin.readUint(data3, off);
    off += 4;
    var offs = [];
    for (var i2 = 0;i2 < gcnt + 1; i2++)
      offs.push(bin.readUint(data3, off + i2 * 4));
    var tups = [], mins = [], maxs = [];
    off = offset2 + toff;
    for (var i2 = 0;i2 < tcnt; i2++) {
      var peak = readTuple(data3, off + i2 * acnt * 2, acnt), imin = [], imax = [];
      tups.push(peak);
      mins.push(imin);
      maxs.push(imax);
      for (var k = 0;k < acnt; k++) {
        imin[k] = Math.min(peak[k], 0);
        imax[k] = Math.max(peak[k], 0);
      }
    }
    var i8 = new Int8Array(data3.buffer);
    var tabs = [];
    for (var i2 = 0;i2 < gcnt; i2++) {
      off = offset2 + goff + offs[i2];
      var vcnt = bin.readUshort(data3, off);
      off += 2;
      var snum = vcnt & SHARED_POINT_NUMBERS;
      vcnt &= 4095;
      var soff = bin.readUshort(data3, off);
      off += 2;
      var hdr = readTupleVarHeader(data3, off, vcnt, acnt);
      var tab = [];
      tabs.push(tab);
      off = offset2 + goff + offs[i2] + soff;
      var sind = null;
      if (snum) {
        var oo = readPointNumbers(data3, off);
        sind = oo[0];
        off = oo[1];
      }
      for (var j = 0;j < vcnt; j++) {
        var vr = hdr[j], end = off + vr[0];
        var ind = sind;
        if (vr[2] & PRIVATE_POINT_NUMBERS) {
          var oo = readPointNumbers(data3, off);
          ind = oo[0];
          off = oo[1];
        }
        var ds = [];
        while (off < end) {
          var cb = data3[off++];
          var cnt = (cb & 63) + 1;
          if (cb & DELTAS_ARE_ZERO) {
            for (var k = 0;k < cnt; k++)
              ds.push(0);
          } else if (cb & DELTAS_ARE_WORDS) {
            for (var k = 0;k < cnt; k++)
              ds.push(bin.readShort(data3, off + k * 2));
            off += cnt * 2;
          } else {
            for (var k = 0;k < cnt; k++)
              ds.push(i8[off + k]);
            off += cnt;
          }
        }
        var ti = vr[1];
        tab.push([[
          vr[3] ? vr[3] : mins[ti],
          vr[4] ? vr[4] : tups[ti],
          vr[5] ? vr[5] : maxs[ti]
        ], ds, ind.length == 0 ? null : ind]);
        if (ind.length != 0 && ind.length * 2 != ds.length)
          throw "e";
      }
    }
    return tabs;
  }
  return { parseTab };
}();
Typr["T"].avar = {
  parseTab: function(data3, offset2, length, obj) {
    var off = offset2;
    var bin = Typr["B"], out = [];
    off += 6;
    var acnt = bin.readUshort(data3, off);
    off += 2;
    for (var ai = 0;ai < acnt; ai++) {
      var cnt = bin.readUshort(data3, off);
      off += 2;
      var poly = [];
      out.push(poly);
      for (var i2 = 0;i2 < cnt; i2++) {
        var x = bin.readF2dot14(data3, off);
        var y = bin.readF2dot14(data3, off + 2);
        off += 4;
        poly.push(x, y);
      }
    }
    return out;
  }
};
Typr["T"].HVAR = {
  parseTab: function(data3, offset2, length, obj) {
    var off = offset2, oo = offset2;
    var bin = Typr["B"];
    off += 4;
    var varO = bin.readUint(data3, off);
    off += 4;
    var advO = bin.readUint(data3, off);
    off += 4;
    var lsbO = bin.readUint(data3, off);
    off += 4;
    var rsbO = bin.readUint(data3, off);
    off += 4;
    if (lsbO != 0 || rsbO != 0)
      throw lsbO;
    off = oo + varO;
    var ioff = off;
    var fmt = bin.readUshort(data3, off);
    off += 2;
    if (fmt != 1)
      throw "e";
    var vregO = bin.readUint(data3, off);
    off += 4;
    var vcnt = bin.readUshort(data3, off);
    off += 2;
    var offs = [];
    for (var i2 = 0;i2 < vcnt; i2++)
      offs.push(bin.readUint(data3, off + i2 * 4));
    off += vcnt * 4;
    off = ioff + vregO;
    var acnt = bin.readUshort(data3, off);
    off += 2;
    var rcnt = bin.readUshort(data3, off);
    off += 2;
    var regs = [];
    for (var i2 = 0;i2 < rcnt; i2++) {
      var crd = [[], [], []];
      regs.push(crd);
      for (var j = 0;j < acnt; j++) {
        crd[0].push(bin.readF2dot14(data3, off + 0));
        crd[1].push(bin.readF2dot14(data3, off + 2));
        crd[2].push(bin.readF2dot14(data3, off + 4));
        off += 6;
      }
    }
    var i8 = new Int8Array(data3.buffer);
    var varStore = [];
    for (var i2 = 0;i2 < offs.length; i2++) {
      off = oo + varO + offs[i2];
      var vdata = [];
      varStore.push(vdata);
      var icnt = bin.readUshort(data3, off);
      off += 2;
      var dcnt = bin.readUshort(data3, off);
      off += 2;
      if (dcnt & 32768)
        throw "e";
      var rcnt = bin.readUshort(data3, off);
      off += 2;
      var ixs = [];
      for (var j = 0;j < rcnt; j++)
        ixs.push(bin.readUshort(data3, off + j * 2));
      off += rcnt * 2;
      for (var k = 0;k < icnt; k++) {
        var deltaData = [];
        for (var ri = 0;ri < rcnt; ri++) {
          deltaData.push(ri < dcnt ? bin.readShort(data3, off) : i8[off]);
          off += ri < dcnt ? 2 : 1;
        }
        var dd = new Array(regs.length);
        dd.fill(0);
        vdata.push(dd);
        for (var j = 0;j < ixs.length; j++)
          dd[ixs[j]] = deltaData[j];
      }
    }
    off = oo + advO;
    var fmt = data3[off++];
    if (fmt != 0)
      throw "e";
    var entryFormat = data3[off++];
    var mapCount = bin.readUshort(data3, off);
    off += 2;
    var INNER_INDEX_BIT_COUNT_MASK = 15;
    var MAP_ENTRY_SIZE_MASK = 48;
    var entrySize = ((entryFormat & MAP_ENTRY_SIZE_MASK) >> 4) + 1;
    var dfs = [];
    for (var i2 = 0;i2 < mapCount; i2++) {
      var entry = 0;
      if (entrySize == 1)
        entry = data3[off++];
      else {
        entry = bin.readUshort(data3, off);
        off += 2;
      }
      var outerIndex = entry >> (entryFormat & INNER_INDEX_BIT_COUNT_MASK) + 1;
      var innerIndex = entry & (1 << (entryFormat & INNER_INDEX_BIT_COUNT_MASK) + 1) - 1;
      dfs.push(varStore[outerIndex][innerIndex]);
    }
    return [regs, dfs];
  }
};
Typr["U"] = function() {
  var P = {
    MoveTo: function(p2, x, y) {
      p2.cmds.push("M");
      p2.crds.push(x, y);
    },
    LineTo: function(p2, x, y) {
      p2.cmds.push("L");
      p2.crds.push(x, y);
    },
    CurveTo: function(p2, a, b2, c, d2, e2, f) {
      p2.cmds.push("C");
      p2.crds.push(a, b2, c, d2, e2, f);
    },
    qCurveTo: function(p2, a, b2, c, d2) {
      p2.cmds.push("Q");
      p2.crds.push(a, b2, c, d2);
    },
    ClosePath: function(p2) {
      p2.cmds.push("Z");
    }
  };
  function getGlyphPosition(font, gls, i1, ltr) {
    var g1 = gls[i1], g2 = gls[i1 + 1], kern = font["kern"];
    if (kern) {
      var ind1 = kern.glyph1.indexOf(g1);
      if (ind1 != -1) {
        var ind2 = kern.rval[ind1].glyph2.indexOf(g2);
        if (ind2 != -1)
          return [0, 0, kern.rval[ind1].vals[ind2], 0];
      }
    }
    return [0, 0, 0, 0];
  }
  function shape2(font, str, prm) {
    if (prm == null)
      prm = {};
    prm["ltr"];
    prm["fts"];
    var axs = prm["axs"];
    if (font["fvar"] && axs == null)
      axs = font["fvar"][1][font["_index"]][2];
    var HVAR = font["HVAR"];
    if (axs && HVAR) {
      axs = _normalizeAxis(font, axs);
    }
    var gls = [];
    for (var i3 = 0;i3 < str.length; i3++) {
      var cc = str.codePointAt(i3);
      if (cc > 65535)
        i3++;
      gls.push(codeToGlyph(font, cc));
    }
    var shape3 = [];
    for (var i3 = 0;i3 < gls.length; i3++) {
      var padj = getGlyphPosition(font, gls, i3);
      var gid = gls[i3];
      var ax = font["hmtx"].aWidth[gid] + padj[2];
      if (HVAR && HVAR[1][gid]) {
        var difs = HVAR[1][gid];
        for (var j = 0;j < HVAR[0].length; j++) {
          ax += _interpolate(HVAR[0][j], axs) * difs[j];
        }
      }
      shape3.push({ g: gid, cl: i3, dx: 0, dy: 0, ax, ay: 0 });
    }
    return shape3;
  }
  function shapeToPath(font, shape3, prm) {
    var tpath = { cmds: [], crds: [] };
    var x = 0, y = 0, clr, axs;
    if (prm) {
      clr = prm["clr"];
      axs = prm["axs"];
    }
    for (var i3 = 0;i3 < shape3.length; i3++) {
      var it = shape3[i3];
      var path2 = glyphToPath(font, it["g"], false, axs), crds = path2["crds"];
      for (var j = 0;j < crds.length; j += 2) {
        tpath.crds.push(crds[j] + x + it["dx"]);
        tpath.crds.push(crds[j + 1] + y + it["dy"]);
      }
      if (clr)
        tpath.cmds.push(clr);
      for (var j = 0;j < path2["cmds"].length; j++)
        tpath.cmds.push(path2["cmds"][j]);
      var clen = tpath.cmds.length;
      if (clr) {
        if (clen != 0 && tpath.cmds[clen - 1] != "X")
          tpath.cmds.push("X");
      }
      x += it["ax"];
      y += it["ay"];
    }
    return { cmds: tpath.cmds, crds: tpath.crds };
  }
  function arrSearch(arr2, k, v) {
    var l = 0, r = ~~(arr2.length / k);
    while (l + 1 != r) {
      var mid = l + (r - l >>> 1);
      if (arr2[mid * k] <= v)
        l = mid;
      else
        r = mid;
    }
    return l * k;
  }
  var wha = [9, 10, 11, 12, 13, 32, 133, 160, 5760, 6158, 8232, 8233, 8239, 8288, 12288, 65279], whm = {};
  for (var i2 = 0;i2 < wha.length; i2++)
    whm[wha[i2]] = 1;
  for (var i2 = 8192;i2 <= 8205; i2++)
    whm[i2] = 1;
  function codeToGlyph(font, code) {
    if (font["_ctab"] == null) {
      var cmap = font["cmap"];
      var tind = -1, pps = ["p3e10", "p0e4", "p3e1", "p1e0", "p0e3", "p0e1", "p3e0", "p3e5"];
      for (var i3 = 0;i3 < pps.length; i3++)
        if (cmap.ids[pps[i3]] != null) {
          tind = cmap.ids[pps[i3]];
          break;
        }
      if (tind == -1)
        throw "no familiar platform and encoding!";
      font["_ctab"] = cmap.tables[tind];
    }
    var tab = font["_ctab"], fmt = tab.format, gid = -1;
    if (fmt == 0) {
      if (code >= tab.map.length)
        gid = 0;
      else
        gid = tab.map[code];
    } else if (fmt == 4) {
      var ec = tab.endCount;
      gid = 0;
      if (code <= ec[ec.length - 1]) {
        var sind = arrSearch(ec, 1, code);
        if (ec[sind] < code)
          sind++;
        if (code >= tab.startCount[sind]) {
          var gli = 0;
          if (tab.idRangeOffset[sind] != 0)
            gli = tab.glyphIdArray[code - tab.startCount[sind] + (tab.idRangeOffset[sind] >> 1) - (tab.idRangeOffset.length - sind)];
          else
            gli = code + tab.idDelta[sind];
          gid = gli & 65535;
        }
      }
    } else if (fmt == 6) {
      var off = code - tab.firstCode, arr2 = tab.glyphIdArray;
      if (off < 0 || off >= arr2.length)
        gid = 0;
      else
        gid = arr2[off];
    } else if (fmt == 12) {
      var grp = tab.groups;
      gid = 0;
      if (code <= grp[grp.length - 2]) {
        var i3 = arrSearch(grp, 3, code);
        if (grp[i3] <= code && code <= grp[i3 + 1]) {
          gid = grp[i3 + 2] + (code - grp[i3]);
        }
      }
    } else
      throw "unknown cmap table format " + tab.format;
    var SVG = font["SVG "], loca = font["loca"];
    if (gid != 0 && font["CFF "] == null && (SVG == null || SVG.entries[gid] == null) && loca && loca[gid] == loca[gid + 1] && whm[code] == null)
      gid = 0;
    return gid;
  }
  function glyphToPath(font, gid, noColor, axs) {
    var path2 = { cmds: [], crds: [] };
    if (font["fvar"]) {
      if (axs == null)
        axs = font["fvar"][1][font["_index"]][2];
      axs = _normalizeAxis(font, axs);
    }
    var SVG = font["SVG "], CFF = font["CFF "], COLR = font["COLR"], CBLC = font["CBLC"], CBDT = font["CBDT"], sbix = font["sbix"], upng = window["UPNG"];
    var strike = null;
    if (CBLC && upng) {
      for (var i3 = 0;i3 < CBLC.length; i3++)
        if (CBLC[i3][0] <= gid && gid <= CBLC[i3][1])
          strike = CBLC[i3];
    }
    if (strike || sbix && sbix[gid]) {
      if (strike && strike[2] != 17)
        throw "not a PNG";
      if (font["__tmp"] == null)
        font["__tmp"] = {};
      var cmd = font["__tmp"]["g" + gid];
      if (cmd == null) {
        var bmp, len;
        if (sbix) {
          bmp = sbix[gid];
          len = bmp.length;
        } else {
          var boff = strike[3][gid - strike[0]] + 5;
          len = CBDT[boff + 1] << 16 | CBDT[boff + 2] << 8 | CBDT[boff + 3];
          boff += 4;
          bmp = new Uint8Array(CBDT.buffer, CBDT.byteOffset + boff, len);
        }
        var str = "";
        for (var i3 = 0;i3 < len; i3++)
          str += String.fromCharCode(bmp[i3]);
        cmd = font["__tmp"]["g" + gid] = "data:image/png;base64," + btoa(str);
      }
      path2.cmds.push(cmd);
      var upe = font["head"]["unitsPerEm"] * 1.15;
      var gw = Math.round(upe), gh = Math.round(upe), dy = Math.round(-gh * 0.15);
      path2.crds.push(0, gh + dy, gw, gh + dy, gw, dy, 0, dy);
    } else if (SVG && SVG.entries[gid]) {
      var p2 = SVG.entries[gid];
      if (p2 != null) {
        if (typeof p2 == "number") {
          var svg = SVG.svgs[p2];
          if (typeof svg == "string") {
            var prsr = new DOMParser;
            var doc2 = prsr["parseFromString"](svg, "image/svg+xml");
            svg = SVG.svgs[p2] = doc2.getElementsByTagName("svg")[0];
          }
          p2 = Typr["U"]["SVG"].toPath(svg, gid);
          SVG.entries[gid] = p2;
        }
        path2 = p2;
      }
    } else if (noColor != true && COLR && COLR[0]["g" + gid] && COLR[0]["g" + gid][1] > 1) {
      let toHex = function(n2) {
        var o = n2.toString(16);
        return (o.length == 1 ? "0" : "") + o;
      };
      var CPAL = font["CPAL"], gl = COLR[0]["g" + gid];
      for (var i3 = 0;i3 < gl[1]; i3++) {
        var lid = gl[0] + i3;
        var cgl = COLR[1][2 * lid], pid = COLR[1][2 * lid + 1] * 4;
        var pth = glyphToPath(font, cgl, cgl == gid);
        var col = "#" + toHex(CPAL[pid + 2]) + toHex(CPAL[pid + 1]) + toHex(CPAL[pid + 0]);
        path2.cmds.push(col);
        path2.cmds = path2.cmds.concat(pth["cmds"]);
        path2.crds = path2.crds.concat(pth["crds"]);
        path2.cmds.push("X");
      }
    } else if (CFF) {
      var pdct = CFF["Private"];
      var state = { x: 0, y: 0, stack: [], nStems: 0, haveWidth: false, width: pdct ? pdct["defaultWidthX"] : 0, open: false };
      if (CFF["ROS"]) {
        var gi = 0;
        while (CFF["FDSelect"][gi + 2] <= gid)
          gi += 2;
        pdct = CFF["FDArray"][CFF["FDSelect"][gi + 1]]["Private"];
      }
      _drawCFF(CFF["CharStrings"][gid], state, CFF, pdct, path2);
    } else if (font["glyf"]) {
      _drawGlyf(gid, font, path2, axs);
    }
    return { cmds: path2.cmds, crds: path2.crds };
  }
  function _drawGlyf(gid, font, path2, axs) {
    var gl = font["glyf"][gid];
    if (gl == null)
      gl = font["glyf"][gid] = Typr["T"].glyf._parseGlyf(font, gid);
    if (gl != null) {
      if (gl.noc > -1)
        _simpleGlyph(gl, font, gid, path2, axs);
      else
        _compoGlyph(gl, font, gid, path2, axs);
    }
  }
  function _interpolate(axs, v) {
    v.length;
    var S = 1;
    var s = axs[0];
    var p2 = axs[1];
    var e2 = axs[2];
    for (var i3 = 0;i3 < v.length; i3++) {
      var AS = 1;
      if (s[i3] > p2[i3] || p2[i3] > e2[i3])
        AS = 1;
      else if (s[i3] < 0 && e2[i3] > 0 && p2[i3] != 0)
        AS = 1;
      else if (p2[i3] == 0)
        AS = 1;
      else if (v[i3] < s[i3] || v[i3] > e2[i3])
        AS = 0;
      else {
        if (v[i3] == p2[i3])
          AS = 1;
        else if (v[i3] < p2[i3])
          AS = (v[i3] - s[i3]) / (p2[i3] - s[i3]);
        else
          AS = (e2[i3] - v[i3]) / (e2[i3] - p2[i3]);
      }
      S = S * AS;
    }
    return S;
  }
  function _normalizeAxis(font, vv) {
    var fvar = font["fvar"], avar = font["avar"];
    var fv = fvar ? fvar[0] : null;
    var nv = [];
    for (var i3 = 0;i3 < fv.length; i3++) {
      var min = fv[i3][1], def = fv[i3][2], max = fv[i3][3], v = Math.max(min, Math.min(max, vv[i3]));
      if (v < def)
        nv[i3] = (def - v) / (min - def);
      else if (v > def)
        nv[i3] = (v - def) / (max - def);
      else
        nv[i3] = 0;
      if (avar && nv[i3] != -1) {
        var av = avar[i3], j = 0;
        for (;j < av.length; j += 2)
          if (av[j] >= nv[i3])
            break;
        var f = (nv[i3] - av[j - 2]) / (av[j] - av[j - 2]);
        nv[i3] = f * av[j + 1] + (1 - f) * av[j - 1];
      }
    }
    return nv;
  }
  function interpolateDeltas(dfs, ind, xs, ys, endPts) {
    var N = xs.length, ndfs = new Array(N * 2 + 8);
    ndfs.fill(0);
    for (var i3 = 0;i3 < N; i3++) {
      var dx = 0, dy = 0, ii = ind.indexOf(i3);
      if (ii != -1) {
        dx = dfs[ii];
        dy = dfs[ind.length + ii];
      } else {
        var cmp = 0;
        while (endPts[cmp] < i3)
          cmp++;
        var cmp0 = cmp == 0 ? 0 : endPts[cmp - 1] + 1;
        var cmp1 = endPts[cmp];
        var i0 = -1, i1 = -1;
        for (var j = 0;j < ind.length; j++) {
          var v = ind[j];
          if (v < cmp0 || v > cmp1 || v >= N)
            continue;
          i0 = j;
          if (i1 == -1)
            i1 = j;
        }
        for (var j = 0;j < ind.length; j++) {
          var v = ind[j];
          if (v < cmp0 || v > cmp1 || v >= N)
            continue;
          if (v < i3)
            i0 = j;
          if (i3 < v) {
            i1 = j;
            break;
          }
        }
        for (var ax = 0;ax < 2; ax++) {
          var crd = ax == 0 ? xs : ys, ofs = ax * ind.length, dlt = 0;
          var c0 = crd[ind[i0]], c13 = crd[ind[i1]], cC = crd[i3];
          var d02 = dfs[ofs + i0], d1 = dfs[ofs + i1];
          if (c0 == c13) {
            if (d02 == d1)
              dlt = d02;
            else
              dlt = 0;
          } else {
            if (cC <= Math.min(c0, c13)) {
              if (c0 < c13)
                dlt = d02;
              else
                dlt = d1;
            } else if (Math.max(c0, c13) <= cC) {
              if (c0 < c13)
                dlt = d1;
              else
                dlt = d02;
            } else {
              var prop = (cC - c0) / (c13 - c0);
              dlt = prop * d1 + (1 - prop) * d02;
            }
          }
          if (ax == 0)
            dx = dlt;
          else
            dy = dlt;
        }
      }
      ndfs[i3] = dx;
      ndfs[N + 4 + i3] = dy;
    }
    return ndfs;
  }
  function _simpleGlyph(gl, font, gid, p2, axs) {
    var { xs, ys } = gl;
    if (font["fvar"] && axs) {
      xs = xs.slice(0);
      ys = ys.slice(0);
      var gvar = font["gvar"];
      var gv = gvar ? gvar[gid] : null;
      for (var vi = 0;vi < gv.length; vi++) {
        var axv = gv[vi][0];
        var S = _interpolate(axv, axs);
        if (S < 0.000000001)
          continue;
        var dfs = gv[vi][1], ind = gv[vi][2];
        if (ind) {
          dfs = gv[vi][1] = interpolateDeltas(dfs, ind, xs, ys, gl.endPts);
          gv[vi][2] = null;
        }
        if (dfs.length == xs.length * 2 + 8)
          for (var i3 = 0;i3 < xs.length; i3++) {
            xs[i3] += S * dfs[i3];
            ys[i3] += S * dfs[i3 + xs.length + 4];
          }
      }
    }
    for (var c = 0;c < gl.noc; c++) {
      var i0 = c == 0 ? 0 : gl.endPts[c - 1] + 1;
      var il = gl.endPts[c];
      for (var i3 = i0;i3 <= il; i3++) {
        var pr = i3 == i0 ? il : i3 - 1;
        var nx = i3 == il ? i0 : i3 + 1;
        var onCurve = gl.flags[i3] & 1;
        var prOnCurve = gl.flags[pr] & 1;
        var nxOnCurve = gl.flags[nx] & 1;
        var x = xs[i3], y = ys[i3];
        if (i3 == i0) {
          if (onCurve) {
            if (prOnCurve)
              P.MoveTo(p2, xs[pr], ys[pr]);
            else {
              P.MoveTo(p2, x, y);
              continue;
            }
          } else {
            if (prOnCurve)
              P.MoveTo(p2, xs[pr], ys[pr]);
            else
              P.MoveTo(p2, Math.floor((xs[pr] + x) * 0.5), Math.floor((ys[pr] + y) * 0.5));
          }
        }
        if (onCurve) {
          if (prOnCurve)
            P.LineTo(p2, x, y);
        } else {
          if (nxOnCurve)
            P.qCurveTo(p2, x, y, xs[nx], ys[nx]);
          else
            P.qCurveTo(p2, x, y, Math.floor((x + xs[nx]) * 0.5), Math.floor((y + ys[nx]) * 0.5));
        }
      }
      P.ClosePath(p2);
    }
  }
  function _compoGlyph(gl, font, gid, p2, axs) {
    var dx = [0, 0, 0, 0, 0, 0], dy = [0, 0, 0, 0, 0, 0], ccnt = gl.parts.length;
    if (font["fvar"] && axs) {
      var gvar = font["gvar"];
      var gv = gvar ? gvar[gid] : null;
      for (var vi = 0;vi < gv.length; vi++) {
        var axv = gv[vi][0];
        var S = _interpolate(axv, axs);
        if (S < 0.000001)
          continue;
        var dfs = gv[vi][1], ind = gv[vi][2];
        if (ind == null)
          for (var i3 = 0;i3 < ccnt; i3++) {
            dx[i3] += S * dfs[i3];
            dy[i3] += S * dfs[i3 + ccnt + 4];
          }
        else
          for (var j = 0;j < ind.length; j++) {
            var i3 = ind[j];
            dx[i3] += S * dfs[0];
            dy[i3] += S * dfs[0 + ccnt];
          }
      }
    }
    for (var j = 0;j < ccnt; j++) {
      var path2 = { cmds: [], crds: [] };
      var prt = gl.parts[j];
      _drawGlyf(prt.glyphIndex, font, path2, axs);
      var m = prt.m, tx = m.tx + dx[j], ty = m.ty + dy[j];
      for (var i3 = 0;i3 < path2.crds.length; i3 += 2) {
        var x = path2.crds[i3], y = path2.crds[i3 + 1];
        p2.crds.push(x * m.a + y * m.c + tx);
        p2.crds.push(x * m.b + y * m.d + ty);
      }
      for (var i3 = 0;i3 < path2.cmds.length; i3++)
        p2.cmds.push(path2.cmds[i3]);
    }
  }
  function pathToSVG(path2, prec) {
    var cmds = path2["cmds"], crds = path2["crds"];
    if (prec == null)
      prec = 5;
    function num(v) {
      return parseFloat(v.toFixed(prec));
    }
    function merge2(o) {
      var no = [], lstF = false, lstC = "";
      for (var i4 = 0;i4 < o.length; i4++) {
        var it = o[i4], isF = typeof it == "number";
        if (!isF) {
          if (it == lstC && it.length == 1 && it != "m")
            continue;
          lstC = it;
        }
        if (lstF && isF && it >= 0)
          no.push(" ");
        no.push(it);
        lstF = isF;
      }
      return no.join("");
    }
    var out = [], co = 0, lmap = { M: 2, L: 2, Q: 4, C: 6 };
    var x = 0, y = 0, ex = 0, ey = 0, mx = 0, my = 0;
    for (var i3 = 0;i3 < cmds.length; i3++) {
      var cmd = cmds[i3], cc = lmap[cmd] ? lmap[cmd] : 0;
      var o0 = [], dx, dy, rx, ry;
      if (cmd == "L") {
        dx = crds[co] - x;
        dy = crds[co + 1] - y;
        rx = num(dx + ex);
        ry = num(dy + ey);
        if (cmds[i3 + 1] == "Z" && crds[co] == mx && crds[co + 1] == my) {
          rx = dx;
          ry = dy;
        } else if (rx == 0 && ry == 0)
          ;
        else if (rx == 0)
          o0.push("v", ry);
        else if (ry == 0)
          o0.push("h", rx);
        else {
          o0.push("l", rx, ry);
        }
      } else {
        o0.push(cmd.toLowerCase());
        for (var j = 0;j < cc; j += 2) {
          dx = crds[co + j] - x;
          dy = crds[co + j + 1] - y;
          rx = num(dx + ex);
          ry = num(dy + ey);
          o0.push(rx, ry);
        }
      }
      if (cc != 0) {
        ex += dx - rx;
        ey += dy - ry;
      }
      var ou = o0;
      for (var j = 0;j < ou.length; j++)
        out.push(ou[j]);
      if (cc != 0) {
        co += cc;
        x = crds[co - 2];
        y = crds[co - 1];
      }
      if (cmd == "M") {
        mx = x;
        my = y;
      }
      if (cmd == "Z") {
        x = mx;
        y = my;
      }
    }
    return merge2(out);
  }
  function SVGToPath(d2) {
    var pth = { cmds: [], crds: [] };
    Typr["U"]["SVG"].svgToPath(d2, pth);
    return { cmds: pth.cmds, crds: pth.crds };
  }
  function mipmapB(buff, w, h, hlp) {
    var nw = w >> 1, nh = h >> 1;
    var nbuf = new Uint8Array(nw * nh * 4);
    var sb32 = new Uint32Array(buff.buffer), nb32 = new Uint32Array(nbuf.buffer);
    for (var y = 0;y < nh; y++)
      for (var x = 0;x < nw; x++) {
        var ti = y * nw + x, si = (y << 1) * w + (x << 1);
        var c0 = sb32[si], c13 = sb32[si + 1], c23 = sb32[si + w], c33 = sb32[si + w + 1];
        var a0 = c0 >>> 24, a1 = c13 >>> 24, a2 = c23 >>> 24, a3 = c33 >>> 24, a = a0 + a1 + a2 + a3;
        if (a == 1020) {
          var r = (c0 >>> 0 & 255) + (c13 >>> 0 & 255) + (c23 >>> 0 & 255) + (c33 >>> 0 & 255) + 2 >>> 2;
          var g2 = (c0 >>> 8 & 255) + (c13 >>> 8 & 255) + (c23 >>> 8 & 255) + (c33 >>> 8 & 255) + 2 >>> 2;
          var b2 = (c0 >>> 16 & 255) + (c13 >>> 16 & 255) + (c23 >>> 16 & 255) + (c33 >>> 16 & 255) + 2 >>> 2;
          nb32[ti] = 255 << 24 | b2 << 16 | g2 << 8 | r;
        } else if (a == 0)
          nb32[ti] = 0;
        else {
          var r = (c0 >>> 0 & 255) * a0 + (c13 >>> 0 & 255) * a1 + (c23 >>> 0 & 255) * a2 + (c33 >>> 0 & 255) * a3;
          var g2 = (c0 >>> 8 & 255) * a0 + (c13 >>> 8 & 255) * a1 + (c23 >>> 8 & 255) * a2 + (c33 >>> 8 & 255) * a3;
          var b2 = (c0 >>> 16 & 255) * a0 + (c13 >>> 16 & 255) * a1 + (c23 >>> 16 & 255) * a2 + (c33 >>> 16 & 255) * a3;
          var ia = 1 / a;
          r = ~~(r * ia + 0.5);
          g2 = ~~(g2 * ia + 0.5);
          b2 = ~~(b2 * ia + 0.5);
          nb32[ti] = a + 2 >>> 2 << 24 | b2 << 16 | g2 << 8 | r;
        }
      }
    return { buff: nbuf, w: nw, h: nh };
  }
  var __cnv, __ct;
  function pathToContext(path2, ctx) {
    var c = 0, cmds = path2["cmds"], crds = path2["crds"];
    for (var j = 0;j < cmds.length; j++) {
      var cmd = cmds[j];
      if (cmd == "M") {
        ctx.moveTo(crds[c], crds[c + 1]);
        c += 2;
      } else if (cmd == "L") {
        ctx.lineTo(crds[c], crds[c + 1]);
        c += 2;
      } else if (cmd == "C") {
        ctx.bezierCurveTo(crds[c], crds[c + 1], crds[c + 2], crds[c + 3], crds[c + 4], crds[c + 5]);
        c += 6;
      } else if (cmd == "Q") {
        ctx.quadraticCurveTo(crds[c], crds[c + 1], crds[c + 2], crds[c + 3]);
        c += 4;
      } else if (cmd[0] == "d") {
        var upng = window["UPNG"];
        var x0 = crds[c], y0 = crds[c + 1], x1 = crds[c + 2], y1 = crds[c + 3], x2 = crds[c + 4], y2 = crds[c + 5], x3 = crds[c + 6], y3 = crds[c + 7];
        c += 8;
        if (upng == null) {
          ctx.moveTo(x0, y0);
          ctx.lineTo(x1, y1);
          ctx.lineTo(x2, y2);
          ctx.lineTo(x3, y3);
          ctx.closePath();
          continue;
        }
        var dx0 = x1 - x0, dy0 = y1 - y0, dx1 = x3 - x0, dy1 = y3 - y0;
        var sbmp = atob(cmd.slice(22));
        var bmp = new Uint8Array(sbmp.length);
        for (var i3 = 0;i3 < sbmp.length; i3++)
          bmp[i3] = sbmp.charCodeAt(i3);
        var img = upng["decode"](bmp.buffer), w = img["width"], h = img["height"];
        var nbmp = new Uint8Array(upng["toRGBA8"](img)[0]);
        var tr = ctx["getTransform"]();
        var scl = Math.sqrt(Math.abs(tr["a"] * tr["d"] - tr["b"] * tr["c"])) * Math.sqrt(dx1 * dx1 + dy1 * dy1) / h;
        while (scl < 0.5) {
          var nd = mipmapB(nbmp, w, h);
          nbmp = nd.buff;
          w = nd.w;
          h = nd.h;
          scl *= 2;
        }
        if (__cnv == null) {
          __cnv = document.createElement("canvas");
          __ct = __cnv.getContext("2d");
        }
        if (__cnv.width != w || __cnv.height != h) {
          __cnv.width = w;
          __cnv.height = h;
        }
        __ct.putImageData(new ImageData(new Uint8ClampedArray(nbmp.buffer), w, h), 0, 0);
        ctx.save();
        ctx.transform(dx0, dy0, dx1, dy1, x0, y0);
        ctx.scale(1 / w, 1 / h);
        ctx.drawImage(__cnv, 0, 0);
        ctx.restore();
      } else if (cmd.charAt(0) == "#" || cmd.charAt(0) == "r") {
        ctx.beginPath();
        ctx.fillStyle = cmd;
      } else if (cmd.charAt(0) == "O" && cmd != "OX") {
        ctx.beginPath();
        var pts = cmd.split("-");
        ctx.lineWidth = parseFloat(pts[2]);
        ctx.lineCap = ["butt", "round", "square"][parseFloat(pts[3])];
        ctx.lineJoin = ["miter", "round", "bevel"][parseFloat(pts[4])];
        ctx.miterLimit = parseFloat(pts[5]);
        ctx.lineDashOffset = parseFloat(pts[6]);
        ctx.setLineDash(pts[7].split(",").map(parseFloat));
        ctx.strokeStyle = pts[1];
      } else if (cmd == "Z") {
        ctx.closePath();
      } else if (cmd == "X") {
        ctx.fill();
      } else if (cmd == "OX") {
        ctx.stroke();
      }
    }
  }
  function _drawCFF(cmds, state, font, pdct, p2) {
    var stack = state.stack;
    var { nStems, haveWidth, width, open } = state;
    var i3 = 0;
    var { x, y } = state, c1x = 0, c1y = 0, c2x = 0, c2y = 0, c3x = 0, c3y = 0, c4x = 0, c4y = 0, jpx = 0, jpy = 0;
    var CFF = Typr["T"].CFF;
    var nominalWidthX = pdct["nominalWidthX"];
    var o = { val: 0, size: 0 };
    while (i3 < cmds.length) {
      CFF.getCharString(cmds, i3, o);
      var v = o.val;
      i3 += o.size;
      if (v == "o1" || v == "o18") {
        var hasWidthArg;
        hasWidthArg = stack.length % 2 !== 0;
        if (hasWidthArg && !haveWidth) {
          width = stack.shift() + nominalWidthX;
        }
        nStems += stack.length >> 1;
        stack.length = 0;
        haveWidth = true;
      } else if (v == "o3" || v == "o23") {
        var hasWidthArg;
        hasWidthArg = stack.length % 2 !== 0;
        if (hasWidthArg && !haveWidth) {
          width = stack.shift() + nominalWidthX;
        }
        nStems += stack.length >> 1;
        stack.length = 0;
        haveWidth = true;
      } else if (v == "o4") {
        if (stack.length > 1 && !haveWidth) {
          width = stack.shift() + nominalWidthX;
          haveWidth = true;
        }
        if (open)
          P.ClosePath(p2);
        y += stack.pop();
        P.MoveTo(p2, x, y);
        open = true;
      } else if (v == "o5") {
        while (stack.length > 0) {
          x += stack.shift();
          y += stack.shift();
          P.LineTo(p2, x, y);
        }
      } else if (v == "o6" || v == "o7") {
        var count = stack.length;
        var isX = v == "o6";
        for (var j = 0;j < count; j++) {
          var sval = stack.shift();
          if (isX)
            x += sval;
          else
            y += sval;
          isX = !isX;
          P.LineTo(p2, x, y);
        }
      } else if (v == "o8" || v == "o24") {
        var count = stack.length;
        var index = 0;
        while (index + 6 <= count) {
          c1x = x + stack.shift();
          c1y = y + stack.shift();
          c2x = c1x + stack.shift();
          c2y = c1y + stack.shift();
          x = c2x + stack.shift();
          y = c2y + stack.shift();
          P.CurveTo(p2, c1x, c1y, c2x, c2y, x, y);
          index += 6;
        }
        if (v == "o24") {
          x += stack.shift();
          y += stack.shift();
          P.LineTo(p2, x, y);
        }
      } else if (v == "o11")
        break;
      else if (v == "o1234" || v == "o1235" || v == "o1236" || v == "o1237") {
        if (v == "o1234") {
          c1x = x + stack.shift();
          c1y = y;
          c2x = c1x + stack.shift();
          c2y = c1y + stack.shift();
          jpx = c2x + stack.shift();
          jpy = c2y;
          c3x = jpx + stack.shift();
          c3y = c2y;
          c4x = c3x + stack.shift();
          c4y = y;
          x = c4x + stack.shift();
          P.CurveTo(p2, c1x, c1y, c2x, c2y, jpx, jpy);
          P.CurveTo(p2, c3x, c3y, c4x, c4y, x, y);
        }
        if (v == "o1235") {
          c1x = x + stack.shift();
          c1y = y + stack.shift();
          c2x = c1x + stack.shift();
          c2y = c1y + stack.shift();
          jpx = c2x + stack.shift();
          jpy = c2y + stack.shift();
          c3x = jpx + stack.shift();
          c3y = jpy + stack.shift();
          c4x = c3x + stack.shift();
          c4y = c3y + stack.shift();
          x = c4x + stack.shift();
          y = c4y + stack.shift();
          stack.shift();
          P.CurveTo(p2, c1x, c1y, c2x, c2y, jpx, jpy);
          P.CurveTo(p2, c3x, c3y, c4x, c4y, x, y);
        }
        if (v == "o1236") {
          c1x = x + stack.shift();
          c1y = y + stack.shift();
          c2x = c1x + stack.shift();
          c2y = c1y + stack.shift();
          jpx = c2x + stack.shift();
          jpy = c2y;
          c3x = jpx + stack.shift();
          c3y = c2y;
          c4x = c3x + stack.shift();
          c4y = c3y + stack.shift();
          x = c4x + stack.shift();
          P.CurveTo(p2, c1x, c1y, c2x, c2y, jpx, jpy);
          P.CurveTo(p2, c3x, c3y, c4x, c4y, x, y);
        }
        if (v == "o1237") {
          c1x = x + stack.shift();
          c1y = y + stack.shift();
          c2x = c1x + stack.shift();
          c2y = c1y + stack.shift();
          jpx = c2x + stack.shift();
          jpy = c2y + stack.shift();
          c3x = jpx + stack.shift();
          c3y = jpy + stack.shift();
          c4x = c3x + stack.shift();
          c4y = c3y + stack.shift();
          if (Math.abs(c4x - x) > Math.abs(c4y - y)) {
            x = c4x + stack.shift();
          } else {
            y = c4y + stack.shift();
          }
          P.CurveTo(p2, c1x, c1y, c2x, c2y, jpx, jpy);
          P.CurveTo(p2, c3x, c3y, c4x, c4y, x, y);
        }
      } else if (v == "o14") {
        if (stack.length > 0 && stack.length != 4 && !haveWidth) {
          width = stack.shift() + font["nominalWidthX"];
          haveWidth = true;
        }
        if (stack.length == 4) {
          var adx = stack.shift();
          var ady = stack.shift();
          var bchar = stack.shift();
          var achar = stack.shift();
          var bind = CFF.glyphBySE(font, bchar);
          var aind = CFF.glyphBySE(font, achar);
          _drawCFF(font["CharStrings"][bind], state, font, pdct, p2);
          state.x = adx;
          state.y = ady;
          _drawCFF(font["CharStrings"][aind], state, font, pdct, p2);
        }
        if (open) {
          P.ClosePath(p2);
          open = false;
        }
      } else if (v == "o19" || v == "o20") {
        var hasWidthArg;
        hasWidthArg = stack.length % 2 !== 0;
        if (hasWidthArg && !haveWidth) {
          width = stack.shift() + nominalWidthX;
        }
        nStems += stack.length >> 1;
        stack.length = 0;
        haveWidth = true;
        i3 += nStems + 7 >> 3;
      } else if (v == "o21") {
        if (stack.length > 2 && !haveWidth) {
          width = stack.shift() + nominalWidthX;
          haveWidth = true;
        }
        y += stack.pop();
        x += stack.pop();
        if (open)
          P.ClosePath(p2);
        P.MoveTo(p2, x, y);
        open = true;
      } else if (v == "o22") {
        if (stack.length > 1 && !haveWidth) {
          width = stack.shift() + nominalWidthX;
          haveWidth = true;
        }
        x += stack.pop();
        if (open)
          P.ClosePath(p2);
        P.MoveTo(p2, x, y);
        open = true;
      } else if (v == "o25") {
        while (stack.length > 6) {
          x += stack.shift();
          y += stack.shift();
          P.LineTo(p2, x, y);
        }
        c1x = x + stack.shift();
        c1y = y + stack.shift();
        c2x = c1x + stack.shift();
        c2y = c1y + stack.shift();
        x = c2x + stack.shift();
        y = c2y + stack.shift();
        P.CurveTo(p2, c1x, c1y, c2x, c2y, x, y);
      } else if (v == "o26") {
        if (stack.length % 2) {
          x += stack.shift();
        }
        while (stack.length > 0) {
          c1x = x;
          c1y = y + stack.shift();
          c2x = c1x + stack.shift();
          c2y = c1y + stack.shift();
          x = c2x;
          y = c2y + stack.shift();
          P.CurveTo(p2, c1x, c1y, c2x, c2y, x, y);
        }
      } else if (v == "o27") {
        if (stack.length % 2) {
          y += stack.shift();
        }
        while (stack.length > 0) {
          c1x = x + stack.shift();
          c1y = y;
          c2x = c1x + stack.shift();
          c2y = c1y + stack.shift();
          x = c2x + stack.shift();
          y = c2y;
          P.CurveTo(p2, c1x, c1y, c2x, c2y, x, y);
        }
      } else if (v == "o10" || v == "o29") {
        var obj = v == "o10" ? pdct : font;
        if (stack.length == 0) {
          console.log("error: empty stack");
        } else {
          var ind = stack.pop();
          var subr = obj["Subrs"][ind + obj["Bias"]];
          state.x = x;
          state.y = y;
          state.nStems = nStems;
          state.haveWidth = haveWidth;
          state.width = width;
          state.open = open;
          _drawCFF(subr, state, font, pdct, p2);
          x = state.x;
          y = state.y;
          nStems = state.nStems;
          haveWidth = state.haveWidth;
          width = state.width;
          open = state.open;
        }
      } else if (v == "o30" || v == "o31") {
        var count, count1 = stack.length;
        var index = 0;
        var alternate = v == "o31";
        count = count1 & -3;
        index += count1 - count;
        while (index < count) {
          if (alternate) {
            c1x = x + stack.shift();
            c1y = y;
            c2x = c1x + stack.shift();
            c2y = c1y + stack.shift();
            y = c2y + stack.shift();
            if (count - index == 5) {
              x = c2x + stack.shift();
              index++;
            } else
              x = c2x;
            alternate = false;
          } else {
            c1x = x;
            c1y = y + stack.shift();
            c2x = c1x + stack.shift();
            c2y = c1y + stack.shift();
            x = c2x + stack.shift();
            if (count - index == 5) {
              y = c2y + stack.shift();
              index++;
            } else
              y = c2y;
            alternate = true;
          }
          P.CurveTo(p2, c1x, c1y, c2x, c2y, x, y);
          index += 4;
        }
      } else if ((v + "").charAt(0) == "o") {
        console.log("Unknown operation: " + v, cmds);
        throw v;
      } else
        stack.push(v);
    }
    state.x = x;
    state.y = y;
    state.nStems = nStems;
    state.haveWidth = haveWidth;
    state.width = width;
    state.open = open;
  }
  function initHB(hurl, resp) {
    var codeLength = function(code) {
      var len = 0;
      if ((code & 4294967295 - (1 << 7) + 1) == 0) {
        len = 1;
      } else if ((code & 4294967295 - (1 << 11) + 1) == 0) {
        len = 2;
      } else if ((code & 4294967295 - (1 << 16) + 1) == 0) {
        len = 3;
      } else if ((code & 4294967295 - (1 << 21) + 1) == 0) {
        len = 4;
      }
      return len;
    };
    fetch(hurl).then(function(x) {
      return x["arrayBuffer"]();
    }).then(function(ab) {
      return WebAssembly["instantiate"](ab);
    }).then(function(res) {
      console.log("HB ready");
      var exp = res["instance"]["exports"], mem = exp["memory"];
      var heapu8, u32, i32, f32;
      var __lastFnt, blob, blobPtr, face, font;
      Typr["U"]["shapeHB"] = function() {
        var toJson = function(ptr) {
          var length = exp["hb_buffer_get_length"](ptr);
          var result = [];
          var iPtr32 = exp["hb_buffer_get_glyph_infos"](ptr, 0) >>> 2;
          var pPtr32 = exp["hb_buffer_get_glyph_positions"](ptr, 0) >>> 2;
          for (var i3 = 0;i3 < length; ++i3) {
            var a = iPtr32 + i3 * 5, b2 = pPtr32 + i3 * 5;
            result.push({
              g: u32[a + 0],
              cl: u32[a + 2],
              ax: i32[b2 + 0],
              ay: i32[b2 + 1],
              dx: i32[b2 + 2],
              dy: i32[b2 + 3]
            });
          }
          return result;
        };
        var te;
        return function(fnt, str, prm) {
          var fdata = fnt["_data"], fn2 = fnt["name"]["postScriptName"];
          var ltr = prm["ltr"], fts = prm["fts"], axs = prm["axs"];
          if (fnt["fvar"] && axs == null)
            axs = fnt["fvar"][1][fnt["_index"]][2];
          heapu8 = new Uint8Array(mem.buffer);
          u32 = new Uint32Array(mem.buffer);
          i32 = new Int32Array(mem.buffer);
          f32 = new Float32Array(mem.buffer);
          if (__lastFnt != fn2) {
            if (blob != null) {
              exp["hb_blob_destroy"](blob);
              exp["free"](blobPtr);
              exp["hb_face_destroy"](face);
              exp["hb_font_destroy"](font);
            }
            blobPtr = exp["malloc"](fdata.byteLength);
            heapu8.set(fdata, blobPtr);
            blob = exp["hb_blob_create"](blobPtr, fdata.byteLength, 2, 0, 0);
            face = exp["hb_face_create"](blob, fnt["_index"]);
            font = exp["hb_font_create"](face);
            __lastFnt = fn2;
          }
          if (window["TextEncoder"] == null) {
            alert("Your browser is too old. Please, update it.");
            return;
          }
          if (te == null)
            te = new window["TextEncoder"]("utf8");
          var buffer = exp["hb_buffer_create"]();
          var bytes = te["encode"](str);
          var len = bytes.length, strp = exp["malloc"](len);
          heapu8.set(bytes, strp);
          exp["hb_buffer_add_utf8"](buffer, strp, len, 0, len);
          exp["free"](strp);
          var bin = Typr["B"];
          var feat = 0;
          if (fts) {
            feat = exp["malloc"](16 * fts.length);
            for (var i3 = 0;i3 < fts.length; i3++) {
              var fe = fts[i3];
              var off = feat + i3 * 16, qo = off >>> 2;
              bin.writeASCII(heapu8, off, fe[0].split("").reverse().join(""));
              u32[qo + 1] = fe[1];
              u32[qo + 2] = fe[2];
              u32[qo + 3] = fe[3];
            }
          }
          var vdat = 0;
          if (axs && fnt["fvar"]) {
            var axes = fnt["fvar"][0];
            vdat = exp["malloc"](8 * axs.length);
            for (var i3 = 0;i3 < axs.length; i3++) {
              var off = vdat + i3 * 8, qo = off >>> 2;
              bin.writeASCII(heapu8, off, axes[i3][0].split("").reverse().join(""));
              f32[qo + 1] = axs[i3];
            }
          }
          if (axs)
            exp["hb_font_set_variations"](font, vdat, axs.length);
          exp["hb_buffer_set_direction"](buffer, ltr ? 4 : 5);
          exp["hb_buffer_guess_segment_properties"](buffer);
          exp["hb_shape"](font, buffer, feat, fts ? fts.length : 0);
          var json2 = toJson(buffer);
          exp["hb_buffer_destroy"](buffer);
          if (fts)
            exp["free"](feat);
          if (axs)
            exp["free"](vdat);
          var arr2 = json2.slice(0);
          if (!ltr)
            arr2.reverse();
          var ci = 0, bi = 0;
          for (var i3 = 1;i3 < arr2.length; i3++) {
            var gl = arr2[i3], cl = gl["cl"];
            while (true) {
              var cpt = str.codePointAt(ci), cln = codeLength(cpt);
              if (bi + cln <= cl) {
                bi += cln;
                ci += cpt <= 65535 ? 1 : 2;
              } else
                break;
            }
            gl["cl"] = ci;
          }
          return json2;
        };
      }();
      resp();
    });
  }
  return { shape: shape2, shapeToPath, codeToGlyph, glyphToPath, pathToSVG, SVGToPath, pathToContext, initHB };
}();

// node_modules/p5/dist/type/p5.Font.js
var import_bezier_path = __toESM(require_bezier_path(), 1);
var import_file_saver12 = __toESM(require_FileSaver(), 1);
var pathArgCounts = { M: 2, L: 2, C: 6, Q: 4 };
var validFontTypes = ["ttf", "otf", "woff"];
var validFontTypesRe = new RegExp(`\\.(${validFontTypes.join("|")})`, "i");
var extractFontNameRe = new RegExp(`([^/]+)(\\.(?:${validFontTypes.join("|")}))`, "i");
var invalidFontError = "Sorry, only TTF, OTF and WOFF files are supported.";
var fontFaceVariations = ["weight", "stretch", "style"];

class Font {
  constructor(p2, fontFace, name, path2, data3) {
    if (!(fontFace instanceof FontFace)) {
      throw Error("FontFace is required");
    }
    this._pInst = p2;
    this.name = name;
    this.path = path2;
    this.data = data3;
    this.face = fontFace;
  }
  static hasGlyphData(textFont) {
    let { font } = textFont;
    return typeof font === "object" && typeof font.data !== "undefined";
  }
  fontBounds(str, x, y, width, height, options2) {
    ({ width, height, options: options2 } = this._parseArgs(width, height, options2));
    let renderer2 = options2?.graphics?._renderer || this._pInst._renderer;
    if (!renderer2)
      throw Error("p5 or graphics required for fontBounds()");
    return renderer2.fontBounds(str, x, y, width, height);
  }
  textBounds(str, x, y, width, height, options2) {
    ({ width, height, options: options2 } = this._parseArgs(width, height, options2));
    let renderer2 = options2?.graphics?._renderer || this._pInst._renderer;
    if (!renderer2)
      throw Error("p5 or graphics required for fontBounds()");
    return renderer2.textBounds(str, x, y, width, height);
  }
  textToPaths(str, x, y, width, height, options2) {
    ({ width, height, options: options2 } = this._parseArgs(width, height, options2));
    if (!this.data) {
      throw Error('No font data available for "' + this.name + `"
Try downloading a local copy of the font file`);
    }
    let lines = this._lineateAndPathify(str, x, y, width, height, options2);
    let glyphs = lines.map((o) => o.glyphs).flat();
    return glyphs.map((g2) => g2.path.commands).flat();
  }
  textToPoints(str, x, y, width, height, options2) {
    const contourPoints = this.textToContours(str, x, y, width, height, options2);
    return contourPoints.reduce((acc, next) => {
      acc.push(...next);
      return acc;
    }, []);
  }
  textToContours(str, x = 0, y = 0, width, height, options2) {
    ({ width, height, options: options2 } = this._parseArgs(width, height, options2));
    const cmds = this.textToPaths(str, x, y, width, height, options2);
    const cmdContours = [];
    for (const cmd of cmds) {
      if (cmd[0] === "M") {
        cmdContours.push([]);
      }
      cmdContours[cmdContours.length - 1].push(cmd);
    }
    return cmdContours.map((commands) => pathToPoints(commands, options2, this));
  }
  textToModel(str, x, y, width, height, options2) {
    ({ width, height, options: options2 } = this._parseArgs(width, height, options2));
    const extrude = options2?.extrude || 0;
    const contours = this.textToContours(str, x, y, width, height, options2);
    const geom = this._pInst.buildGeometry(() => {
      if (extrude === 0) {
        const prevValidateFaces = this._pInst._renderer._validateFaces;
        this._pInst._renderer._validateFaces = true;
        this._pInst.beginShape();
        this._pInst.normal(0, 0, 1);
        for (const contour of contours) {
          this._pInst.beginContour();
          for (const { x: x2, y: y2 } of contour) {
            this._pInst.vertex(x2, y2);
          }
          this._pInst.endContour(this._pInst.CLOSE);
        }
        this._pInst.endShape();
        this._pInst._renderer._validateFaces = prevValidateFaces;
      } else {
        const prevValidateFaces = this._pInst._renderer._validateFaces;
        this._pInst._renderer._validateFaces = true;
        for (const side of [1, -1]) {
          this._pInst.beginShape();
          for (const contour of contours) {
            this._pInst.beginContour();
            for (const { x: x2, y: y2 } of contour) {
              this._pInst.vertex(x2, y2, side * extrude * 0.5);
            }
            this._pInst.endContour(this._pInst.CLOSE);
          }
          this._pInst.endShape();
        }
        this._pInst._renderer._validateFaces = prevValidateFaces;
        for (const contour of contours) {
          this._pInst.beginShape(this._pInst.QUAD_STRIP);
          for (const v of contour) {
            for (const side of [-1, 1]) {
              this._pInst.vertex(v.x, v.y, side * extrude * 0.5);
            }
          }
          this._pInst.endShape();
        }
      }
    });
    if (extrude !== 0) {
      geom.computeNormals();
      for (const face of geom.faces) {
        if (face.every((idx) => geom.vertices[idx].z <= -extrude * 0.5 + 0.1)) {
          for (const idx of face)
            geom.vertexNormals[idx].set(0, 0, -1);
          face.reverse();
        }
      }
    }
    return geom;
  }
  variations() {
    let vars = {};
    if (this.data) {
      let axes = this.face?.axes;
      if (axes) {
        axes.forEach((ax) => {
          vars[ax.tag] = ax.value;
        });
      }
    }
    fontFaceVariations.forEach((v) => {
      let val = this.face[v];
      if (val !== "normal") {
        vars[v] = vars[v] || val;
      }
    });
    return vars;
  }
  metadata() {
    let meta = this.data?.name || {};
    for (let p2 in this.face) {
      if (!/^load/.test(p2)) {
        meta[p2] = meta[p2] || this.face[p2];
      }
    }
    return meta;
  }
  static async list(log2 = false) {
    if (log2) {
      console.log("There are", document.fonts.size, `font-faces
`);
      let loaded = 0;
      for (let fontFace of document.fonts.values()) {
        console.log("FontFace: {");
        for (let property in fontFace) {
          console.log("  " + property + ": " + fontFace[property]);
        }
        console.log(`}
`);
        if (fontFace.status === "loaded") {
          loaded++;
        }
      }
      console.log(loaded + " loaded");
    }
    return await Array.from(document.fonts);
  }
  _verticalAlign(size) {
    const { sCapHeight } = this.data?.["OS/2"] || {};
    const { unitsPerEm = 1000 } = this.data?.head || {};
    const { ascender = 0, descender = 0 } = this.data?.hhea || {};
    const current2 = ascender / 2;
    const target = (sCapHeight || ascender + descender) / 2;
    const offset2 = target - current2;
    return offset2 * size / unitsPerEm;
  }
  _lineateAndPathify(str, x, y, width, height, options2 = {}) {
    let renderer2 = options2?.graphics?._renderer || this._pInst._renderer;
    let setBaseline = renderer2.drawingContext.textBaseline;
    let { lines, bounds } = renderer2._computeBounds(textCoreConstants._FONT_BOUNDS, str, x, y, width, height, { ignoreRectMode: true, ...options2 });
    lines = this._position(renderer2, lines, bounds, width, height);
    let uPE = this.data?.head?.unitsPerEm || 1000;
    let scale = renderer2.states.textSize / uPE;
    const axs = this._currentAxes(renderer2);
    let pathsForLine = lines.map((l) => this._lineToGlyphs(l, { scale, axs }));
    renderer2.drawingContext.textBaseline = setBaseline;
    return pathsForLine;
  }
  _currentAxes(renderer2) {
    let axs;
    if ((this.data?.fvar?.length ?? 0) > 0) {
      const fontAxes = this.data.fvar[0];
      axs = fontAxes.map(([tag, minVal, defaultVal, maxVal, flags, name]) => {
        if (!renderer2)
          return defaultVal;
        if (tag === "wght") {
          return renderer2.states.fontWeight;
        } else if (tag === "wdth") {
          return 100;
        } else if (renderer2.textCanvas().style.fontVariationSettings) {
          const match = new RegExp(`\\b${tag}s+(d+)`).exec(renderer2.textCanvas().style.fontVariationSettings);
          if (match) {
            return parseInt(match[1]);
          } else {
            return defaultVal;
          }
        } else {
          return defaultVal;
        }
      });
    }
    return axs;
  }
  _textToPathPoints(str, x, y, width, height, options2) {
    ({ width, height, options: options2 } = this._parseArgs(width, height, options2));
    let cmds = this.textToPaths(str, x, y, width, height, options2);
    const subdivide = (pts2, pt1, pt2, md) => {
      if (fn.dist(pt1.x, pt1.y, pt2.x, pt2.y) > md) {
        let middle = { x: (pt1.x + pt2.x) / 2, y: (pt1.y + pt2.y) / 2 };
        pts2.push(middle);
        subdivide(pts2, pt1, middle, md);
        subdivide(pts2, middle, pt2, md);
      }
    };
    let pts = [];
    let { textSize } = this._pInst._renderer.states;
    let maxDist = textSize / this.data.head.unitsPerEm * 500;
    for (let i2 = 0;i2 < cmds.length; i2++) {
      let { type: type2, data: d2 } = cmds[i2];
      if (type2 !== "Z") {
        let pt = { x: d2[d2.length - 2], y: d2[d2.length - 1] };
        if (type2 === "L" && pts.length && !options2?.nodivide > 0) {
          subdivide(pts, pts[pts.length - 1], pt, maxDist);
        }
        pts.push(pt);
      }
    }
    return pts;
  }
  _parseArgs(width, height, options2 = {}) {
    if (typeof width === "object") {
      options2 = width;
      width = height = undefined;
    } else if (typeof height === "object") {
      options2 = height;
      height = undefined;
    }
    return { width, height, options: options2 };
  }
  _position(renderer2, lines, bounds, width, height) {
    let { textAlign, textLeading } = renderer2.states;
    let metrics = this._measureTextDefault(renderer2, "X");
    let ascent = metrics.fontBoundingBoxAscent;
    let coordify = (text, i2) => {
      let x = bounds.x;
      let y = bounds.y + i2 * textLeading + ascent;
      let lineWidth = renderer2._fontWidthSingle(text);
      if (textAlign === CENTER) {
        x += (bounds.w - lineWidth) / 2;
      } else if (textAlign === RIGHT) {
        x += bounds.w - lineWidth;
      }
      if (typeof width !== "undefined") {
        switch (renderer2.states.rectMode) {
          case CENTER:
            x -= width / 2;
            y -= height / 2;
            break;
          case RADIUS:
            x -= width;
            y -= height;
            break;
        }
      }
      return { text, x, y };
    };
    return lines.map(coordify);
  }
  _lineToGlyphs(line, { scale = 1, axs } = {}) {
    if (!this.data) {
      throw Error('No font data available for "' + this.name + `"
Try downloading a local copy of the font file`);
    }
    let glyphShapes = Typr.U.shape(this.data, line.text, { axs });
    line.glyphShapes = glyphShapes;
    line.glyphs = this._shapeToPaths(glyphShapes, line, { scale, axs });
    return line;
  }
  _positionGlyphs(text, options2) {
    let renderer2 = options2?.graphics?._renderer || this._pInst._renderer;
    const axs = this._currentAxes(renderer2);
    const glyphShapes = Typr.U.shape(this.data, text, { axs });
    const positionedGlyphs = [];
    let x = 0;
    for (const glyph of glyphShapes) {
      positionedGlyphs.push({ x, index: glyph.g, shape: glyph });
      x += glyph.ax;
    }
    return positionedGlyphs;
  }
  _singleShapeToPath(shape2, {
    scale = 1,
    x = 0,
    y = 0,
    lineX = 0,
    lineY = 0,
    axs
  } = {}) {
    let font = this.data;
    let crdIdx = 0;
    let { g: g2, ax, ay, dx, dy } = shape2;
    let { crds, cmds } = Typr.U.glyphToPath(font, g2, true, axs);
    let glyph = { path: { commands: [] } };
    for (let j = 0;j < cmds.length; j++) {
      let type2 = cmds[j], command = [type2];
      if (type2 in pathArgCounts) {
        let argCount = pathArgCounts[type2];
        for (let k = 0;k < argCount; k += 2) {
          let gx = crds[k + crdIdx] + x + dx;
          let gy = crds[k + crdIdx + 1] + y + dy;
          let fx = lineX + gx * scale;
          let fy = lineY + gy * -scale;
          command.push(fx);
          command.push(fy);
        }
        crdIdx += argCount;
      }
      glyph.path.commands.push(command);
    }
    return { glyph, ax, ay };
  }
  _shapeToPaths(glyphs, line, { scale = 1, axs } = {}) {
    let x = 0, y = 0, paths = [];
    if (glyphs.length !== line.text.length) {
      throw Error("Invalid shape data");
    }
    for (let i2 = 0;i2 < glyphs.length; i2++) {
      const { glyph, ax, ay } = this._singleShapeToPath(glyphs[i2], {
        scale,
        x,
        y,
        lineX: line.x,
        lineY: line.y,
        axs
      });
      paths.push(glyph);
      x += ax;
      y += ay;
    }
    return paths;
  }
  _measureTextDefault(renderer2, str) {
    let { textAlign, textBaseline } = renderer2.states;
    let ctx = renderer2.textDrawingContext();
    ctx.textAlign = "left";
    ctx.textBaseline = "alphabetic";
    let metrics = ctx.measureText(str);
    ctx.textAlign = textAlign;
    ctx.textBaseline = textBaseline;
    return metrics;
  }
  drawPaths(ctx, commands, opts) {
    ctx.strokeStyle = opts?.stroke || ctx.strokeStyle;
    ctx.fillStyle = opts?.fill || ctx.fillStyle;
    ctx.beginPath();
    commands.forEach(([type2, ...data3]) => {
      if (type2 === "M") {
        ctx.moveTo(...data3);
      } else if (type2 === "L") {
        ctx.lineTo(...data3);
      } else if (type2 === "C") {
        ctx.bezierCurveTo(...data3);
      } else if (type2 === "Q") {
        ctx.quadraticCurveTo(...data3);
      } else if (type2 === "Z") {
        ctx.closePath();
      }
    });
    if (opts?.fill)
      ctx.fill();
    if (opts?.stroke)
      ctx.stroke();
  }
  _pathsToCommands(paths, scale) {
    let commands = [];
    for (let i2 = 0;i2 < paths.length; i2++) {
      let pathData = paths[i2];
      let { x, y, path: path2 } = pathData;
      let { crds, cmds } = path2;
      for (let c = 0, j = 0;j < cmds.length; j++) {
        let cmd = cmds[j], obj = { type: cmd, data: [] };
        if (cmd === "M" || cmd === "L") {
          obj.data.push(x + crds[c] * scale, y + crds[c + 1] * -scale);
          c += 2;
        } else if (cmd === "C") {
          for (let i3 = 0;i3 < 6; i3 += 2) {
            obj.data.push(x + crds[c + i3] * scale, y + crds[c + i3 + 1] * -scale);
          }
          c += 6;
        } else if (cmd === "Q") {
          for (let i3 = 0;i3 < 4; i3 += 2) {
            obj.data.push(x + crds[c + i3] * scale, y + crds[c + i3 + 1] * -scale);
          }
          c += 4;
        }
        commands.push(obj);
      }
    }
    return commands;
  }
}
async function create2(pInst, name, path2, descriptors, rawFont) {
  let face = createFontFace(name, path2, descriptors, rawFont);
  if (face.status !== "loaded")
    await face.load();
  document.fonts.add(face);
  await document.fonts.ready;
  return new Font(pInst, face, name, path2, rawFont);
}
function sanitizeFontName(name) {
  if (!/^[A-Za-z][A-Za-z0-9_-]*$/.test(name)) {
    name = "'" + String(name).replace(/'/g, "\\'") + "'";
  }
  return name;
}
function createFontFace(name, path2, descriptors, rawFont) {
  name = sanitizeFontName(name);
  let fontArg = rawFont?._compressedData ?? rawFont?._data;
  if (!fontArg) {
    if (!validFontTypesRe.test(path2)) {
      throw Error(invalidFontError);
    }
    if (!path2.startsWith("url(")) {
      path2 = "url(" + path2 + ")";
    }
    fontArg = path2;
  }
  if ((rawFont?.fvar?.length ?? 0) > 0) {
    descriptors = descriptors || {};
    for (const [
      tag,
      minVal,
      defaultVal,
      maxVal,
      flags,
      name2
    ] of rawFont.fvar[0]) {
      if (tag === "wght") {
        descriptors.weight = `${minVal} ${maxVal}`;
      } else if (tag === "wdth") {
        descriptors.stretch = `${minVal}% ${maxVal}%`;
      }
    }
  }
  let face = new FontFace(name, fontArg, descriptors);
  if (face.status === "error") {
    throw Error('Failed to create FontFace for "' + name + '"');
  }
  return face;
}
function extractFontName(font, path2) {
  let result, meta = font?.name;
  if (meta) {
    if (meta.fullName) {
      return meta.fullName;
    }
    if (meta.familyName) {
      result = meta.familyName;
    }
  }
  if (!result) {
    let matches = extractFontNameRe.exec(path2);
    if (matches && matches.length >= 3) {
      result = matches[1];
    } else {
      result = path2;
    }
  }
  if (result.includes(" ")) {
    result = result.replace(/ /g, "_");
  }
  return result;
}
function pathToPoints(cmds, options2, font) {
  const parseOpts = (options3, defaults2) => {
    if (typeof options3 !== "object") {
      options3 = defaults2;
    } else {
      for (const key in defaults2) {
        if (typeof options3[key] === "undefined") {
          options3[key] = defaults2[key];
        }
      }
    }
    return options3;
  };
  const at2 = (v, i2) => {
    const s = v.length;
    return v[i2 < 0 ? i2 % s + s : i2 % s];
  };
  const simplify = (pts, angle) => {
    angle = angle || 0;
    let num = 0;
    for (let i2 = pts.length - 1;pts.length > 3 && i2 >= 0; --i2) {
      if (collinear(at2(pts, i2 - 1), at2(pts, i2), at2(pts, i2 + 1), angle)) {
        pts.splice(i2 % pts.length, 1);
        num++;
      }
    }
    return num;
  };
  const collinear = (a, b2, c, thresholdAngle) => {
    if (!thresholdAngle) {
      return areaTriangle(a, b2, c) === 0;
    }
    if (typeof collinear.tmpPoint1 === "undefined") {
      collinear.tmpPoint1 = [];
      collinear.tmpPoint2 = [];
    }
    const { tmpPoint1: ab, tmpPoint2: bc } = collinear;
    ab.x = b2.x - a.x;
    ab.y = b2.y - a.y;
    bc.x = c.x - b2.x;
    bc.y = c.y - b2.y;
    const dot = ab.x * bc.x + ab.y * bc.y, magA = Math.sqrt(ab.x * ab.x + ab.y * ab.y), magB = Math.sqrt(bc.x * bc.x + bc.y * bc.y), angle = Math.acos(dot / (magA * magB));
    return angle < thresholdAngle;
  };
  const areaTriangle = (a, b2, c) => {
    return (b2[0] - a[0]) * (c[1] - a[1]) - (c[0] - a[0]) * (b2[1] - a[1]);
  };
  const path2 = import_bezier_path.createFromCommands(arrayCommandsToObjects(cmds));
  let opts = parseOpts(options2, {
    sampleFactor: 0.1,
    simplifyThreshold: 0
  });
  const totalPoints = Math.max(1, Math.ceil(path2.getTotalLength() * opts.sampleFactor));
  let points = [];
  const mode = font._pInst.angleMode();
  const DEGREES = font._pInst.DEGREES;
  for (let i2 = 0;i2 < totalPoints; i2++) {
    const length = path2.getTotalLength() * (totalPoints === 1 ? 0 : i2 / (totalPoints - 1));
    points.push({
      ...path2.getPointAtLength(length),
      get angle() {
        const angle = path2.getAngleAtLength(length);
        if (mode === DEGREES) {
          return angle * 180 / Math.PI;
        } else {
          return angle;
        }
      },
      get alpha() {
        return this.angle;
      }
    });
  }
  if (opts.simplifyThreshold) {
    simplify(points, opts.simplifyThreshold);
  }
  return points;
}
function unquote(name) {
  if ((name.startsWith('"') || name.startsWith("'")) && name.at(0) === name.at(-1)) {
    return name.slice(1, -1).replace(/\/(['"])/g, "$1");
  }
  return name;
}
function parseCreateArgs(...args) {
  let path2 = args.shift();
  if (typeof path2 !== "string" || path2.length === 0) {
    p5._friendlyError(invalidFontError, "p5.loadFont");
  }
  let name;
  if (typeof args[0] === "string") {
    name = args.shift();
  }
  let success2, error41, options2;
  for (let i2 = 0;i2 < args.length; i2++) {
    const arg = args[i2];
    if (typeof arg === "function") {
      if (!success2) {
        success2 = arg;
      } else {
        error41 = arg;
      }
    } else if (typeof arg === "object") {
      options2 = arg;
    }
  }
  return { path: path2, name, success: success2, error: error41, options: options2 };
}
function font(p53, fn2) {
  p53.Font = Font;
  fn2.parseFontData = async function(pathOrData) {
    let result = pathOrData instanceof Uint8Array ? pathOrData : await fn2.loadBytes(pathOrData);
    if (!result) {
      throw Error("Failed to load font data");
    }
    let fonts = Typr.parse(result);
    if (fonts.length === 0 || fonts[0].cmap === undefined) {
      throw Error("parsing font data");
    }
    return fonts[0];
  };
  fn2.loadFont = async function(...args) {
    let {
      path: path2,
      name,
      success: success2,
      error: error41,
      options: { sets: sets2, ...descriptors } = {}
    } = parseCreateArgs(...args);
    let isCSS = path2.includes("@font-face");
    if (!isCSS) {
      const info = await fetch(path2, { method: "HEAD" });
      const isCSSFile = info.headers.get("content-type")?.startsWith("text/css");
      if (isCSSFile) {
        isCSS = true;
        path2 = await fetch(path2).then((res) => res.text());
      }
    }
    if (isCSS) {
      const stylesheet = new CSSStyleSheet;
      await stylesheet.replace(path2);
      const possibleFonts = [];
      for (const rule of stylesheet.cssRules) {
        if (rule instanceof CSSFontFaceRule) {
          const style = rule.style;
          let name2 = unquote(style.getPropertyValue("font-family"));
          const src = style.getPropertyValue("src");
          const fontDescriptors = { ...descriptors || {} };
          for (const key of style) {
            if (key === "font-family" || key === "src")
              continue;
            const camelCaseKey = key.replace(/^font-/, "").split("-").map((v, i2) => i2 === 0 ? v : `${v[0].toUpperCase()}${v.slice(1)}`).join("");
            fontDescriptors[camelCaseKey] = style.getPropertyValue(key);
          }
          possibleFonts.push({
            name: name2,
            src,
            fontDescriptors,
            loadWithData: async () => {
              let fontData;
              try {
                const urlMatch = /url\(([^\)]+)\)/.exec(src);
                if (urlMatch) {
                  let url2 = urlMatch[1];
                  if (/^['"]/.exec(url2) && url2.at(0) === url2.at(-1)) {
                    url2 = url2.slice(1, -1);
                  }
                  fontData = await fn2.parseFontData(url2);
                }
              } catch (_e) {}
              return create2(this, name2, src, fontDescriptors, fontData);
            },
            loadWithoutData: () => create2(this, name2, src, fontDescriptors)
          });
        }
      }
      sets2 = sets2 || ["latin"];
      const requestedGroups = (sets2 instanceof Array ? sets2 : [sets2]).map((s) => s.toLowerCase());
      const requestedCategories = unicodeRanges.filter((r) => requestedGroups.some((g2) => r.category.includes(g2) && r.category.includes("ext") === g2.includes("ext")));
      const requestedRanges = new Set(import_unicode_range.UnicodeRange.parse(requestedCategories.map((c) => `U+${c.hexrange[0]}-${c.hexrange[1]}`)));
      let closestRangeOverlap = 0;
      let closestDescriptorOverlap = 0;
      let closestMatch = undefined;
      for (const font2 of possibleFonts) {
        if (!font2.fontDescriptors.unicodeRange)
          continue;
        const fontRange = new Set(import_unicode_range.UnicodeRange.parse(font2.fontDescriptors.unicodeRange.split(/,\s*/g)));
        const rangeOverlap = [...fontRange.values()].filter((v) => requestedRanges.has(v)).length;
        const targetDescriptors = {
          style: "normal",
          weight: 400,
          ...descriptors
        };
        const descriptorOverlap = Object.keys(font2.fontDescriptors).filter((k) => font2.fontDescriptors[k] === targetDescriptors[k]).length;
        if (descriptorOverlap > closestDescriptorOverlap || descriptorOverlap === closestDescriptorOverlap && rangeOverlap >= closestRangeOverlap) {
          closestDescriptorOverlap = descriptorOverlap;
          closestRangeOverlap = rangeOverlap;
          closestMatch = font2;
        }
      }
      const picked = closestMatch || possibleFonts.at(-1);
      for (const font2 of possibleFonts) {
        if (font2 !== picked) {
          font2.loadWithoutData();
        }
      }
      return picked?.loadWithData();
    }
    let pfont;
    try {
      const fontData = await fn2.parseFontData(path2);
      name = name || extractFontName(fontData, path2);
      pfont = await create2(this, name, path2, descriptors, fontData);
    } catch (err2) {
      let ident = name || path2.substring(path2.lastIndexOf("/") + 1).replace(/\.[^/.]+$/, "");
      console.warn(`WARN: No glyph data for '${ident}', retrying as FontFace`);
      try {
        pfont = await create2(this, ident, path2, descriptors);
      } catch (err3) {
        if (error41)
          return error41(err3);
        throw err3;
      }
    }
    if (success2)
      return success2(pfont);
    return pfont;
  };
}
var arrayCommandsToObjects = (commands) => commands.map((command) => {
  const type2 = command[0];
  switch (type2) {
    case "Z": {
      return { type: type2 };
    }
    case "M":
    case "L": {
      const [, x, y] = command;
      return { type: type2, x, y };
    }
    case "Q": {
      const [, x1, y1, x, y] = command;
      return { type: type2, x1, y1, x, y };
    }
    case "C": {
      const [, x1, y1, x2, y2, x, y] = command;
      return { type: type2, x1, y1, x2, y2, x, y };
    }
    default: {
      throw new Error(`Unexpected path command: ${type2}`);
    }
  }
});
if (typeof p5 !== "undefined") {
  font(p5, p5.prototype);
}

// node_modules/p5/dist/webgl/text.js
var import_file_saver13 = __toESM(require_FileSaver(), 1);
var import_omggif8 = __toESM(require_omggif(), 1);
var import_gifenc9 = __toESM(require_gifenc(), 1);
var import_libtess9 = __toESM(require_libtess_min(), 1);
var import_unicode_range2 = __toESM(require_lib(), 1);
var import_bezier_path2 = __toESM(require_bezier_path(), 1);
function text(p53, fn2) {
  RendererGL.prototype.maxCachedGlyphs = function() {
    return 200;
  };
  Font.prototype._getFontInfo = function(axs) {
    this._fontInfos = this._fontInfos || {};
    const key = JSON.stringify(axs);
    if (this._fontInfos[key]) {
      const val = this._fontInfos[key];
      return val;
    } else {
      const val = new FontInfo(this, { axs });
      this._fontInfos[key] = val;
      return val;
    }
  };
  const charGridWidth = 9;
  const charGridHeight = charGridWidth;
  const strokeImageWidth = 64;
  const strokeImageHeight = 64;
  const gridImageWidth = 64;
  const gridImageHeight = 64;
  const cellImageWidth = 64;
  const cellImageHeight = 64;

  class ImageInfos {
    constructor(width, height) {
      this.width = width;
      this.height = height;
      this.infos = [];
    }
    findImage(space) {
      const imageSize = this.width * this.height;
      if (space > imageSize)
        throw new Error("font is too complex to render in 3D");
      let imageInfo, imageData;
      for (let ii = this.infos.length - 1;ii >= 0; --ii) {
        const imageInfoTest = this.infos[ii];
        if (imageInfoTest.index + space < imageSize) {
          imageInfo = imageInfoTest;
          imageData = imageInfoTest.imageData;
          break;
        }
      }
      if (!imageInfo) {
        try {
          imageData = new ImageData(this.width, this.height);
        } catch (err2) {
          let canvas2 = document.getElementsByTagName("canvas")[0];
          const created = !canvas2;
          if (!canvas2) {
            canvas2 = document.createElement("canvas");
            canvas2.style.display = "none";
            document.body.appendChild(canvas2);
          }
          const ctx = canvas2.getContext("2d");
          if (ctx) {
            imageData = ctx.createImageData(this.width, this.height);
          }
          if (created) {
            document.body.removeChild(canvas2);
          }
        }
        imageInfo = { index: 0, imageData };
        this.infos.push(imageInfo);
      }
      const index = imageInfo.index;
      imageInfo.index += space;
      imageData._dirty = true;
      return { imageData, index };
    }
  }
  function setPixel(imageInfo, r, g2, b2, a) {
    const imageData = imageInfo.imageData;
    const pixels2 = imageData.data;
    let index = imageInfo.index++ * 4;
    pixels2[index++] = r;
    pixels2[index++] = g2;
    pixels2[index++] = b2;
    pixels2[index++] = a;
  }
  const SQRT3 = Math.sqrt(3);

  class FontInfo {
    constructor(font2, { axs } = {}) {
      this.font = font2;
      this.axs = axs;
      this.strokeImageInfos = new ImageInfos(strokeImageWidth, strokeImageHeight);
      this.colDimImageInfos = new ImageInfos(gridImageWidth, gridImageHeight);
      this.rowDimImageInfos = new ImageInfos(gridImageWidth, gridImageHeight);
      this.colCellImageInfos = new ImageInfos(cellImageWidth, cellImageHeight);
      this.rowCellImageInfos = new ImageInfos(cellImageWidth, cellImageHeight);
      this.glyphInfos = {};
    }
    getGlyphInfo(glyph) {
      let gi = this.glyphInfos[glyph.index];
      if (gi)
        return gi;
      const axs = this.axs;
      const {
        glyph: {
          path: { commands }
        }
      } = this.font._singleShapeToPath(glyph.shape, { axs });
      let xMin = Infinity;
      let xMax = -Infinity;
      let yMin = Infinity;
      let yMax = -Infinity;
      for (const cmd of commands) {
        for (let i3 = 1;i3 < cmd.length; i3 += 2) {
          xMin = Math.min(xMin, cmd[i3]);
          xMax = Math.max(xMax, cmd[i3]);
          yMin = Math.min(yMin, cmd[i3 + 1]);
          yMax = Math.max(yMax, cmd[i3 + 1]);
        }
      }
      if (xMin >= xMax || yMin >= yMax || !commands.length) {
        return this.glyphInfos[glyph.index] = {};
      }
      const gWidth = xMax - xMin;
      const gHeight = yMax - yMin;
      const cmds = arrayCommandsToObjects(commands);
      let i2;
      const strokes = [];
      const rows = [];
      const cols = [];
      for (i2 = charGridWidth - 1;i2 >= 0; --i2)
        cols.push([]);
      for (i2 = charGridHeight - 1;i2 >= 0; --i2)
        rows.push([]);
      function push(xs2, ys2, v) {
        const index = strokes.length;
        strokes.push(v);
        function minMax(rg, min, max) {
          for (let i3 = rg.length;i3-- > 0; ) {
            const v2 = rg[i3];
            if (min > v2)
              min = v2;
            if (max < v2)
              max = v2;
          }
          return { min, max };
        }
        const cellOffset = 0.5;
        const mmX = minMax(xs2, 1, 0);
        const ixMin = Math.max(Math.floor(mmX.min * charGridWidth - cellOffset), 0);
        const ixMax = Math.min(Math.ceil(mmX.max * charGridWidth + cellOffset), charGridWidth);
        for (let iCol = ixMin;iCol < ixMax; ++iCol)
          cols[iCol].push(index);
        const mmY = minMax(ys2, 1, 0);
        const iyMin = Math.max(Math.floor(mmY.min * charGridHeight - cellOffset), 0);
        const iyMax = Math.min(Math.ceil(mmY.max * charGridHeight + cellOffset), charGridHeight);
        for (let iRow = iyMin;iRow < iyMax; ++iRow)
          rows[iRow].push(index);
      }
      function clamp2(v, min, max) {
        if (v < min)
          return min;
        if (v > max)
          return max;
        return v;
      }
      function byte(v) {
        return clamp2(255 * v, 0, 255);
      }

      class Cubic {
        constructor(p0, c0, c13, p1) {
          this.p0 = p0;
          this.c0 = c0;
          this.c1 = c13;
          this.p1 = p1;
        }
        toQuadratic() {
          return {
            x: this.p0.x,
            y: this.p0.y,
            x1: this.p1.x,
            y1: this.p1.y,
            cx: ((this.c0.x + this.c1.x) * 3 - (this.p0.x + this.p1.x)) / 4,
            cy: ((this.c0.y + this.c1.y) * 3 - (this.p0.y + this.p1.y)) / 4
          };
        }
        quadError() {
          return Vector.sub(Vector.sub(this.p1, this.p0), Vector.mult(Vector.sub(this.c1, this.c0), 3)).mag() / 2;
        }
        split(t) {
          const m13 = Vector.lerp(this.p0, this.c0, t);
          const m22 = Vector.lerp(this.c0, this.c1, t);
          const mm1 = Vector.lerp(m13, m22, t);
          this.c1 = Vector.lerp(this.c1, this.p1, t);
          this.c0 = Vector.lerp(m22, this.c1, t);
          const pt = Vector.lerp(mm1, this.c0, t);
          const part1 = new Cubic(this.p0, m13, mm1, pt);
          this.p0 = pt;
          return part1;
        }
        splitInflections() {
          const a = Vector.sub(this.c0, this.p0);
          const b2 = Vector.sub(Vector.sub(this.c1, this.c0), a);
          const c = Vector.sub(Vector.sub(Vector.sub(this.p1, this.c1), a), Vector.mult(b2, 2));
          const cubics = [];
          let A = b2.x * c.y - b2.y * c.x;
          if (A !== 0) {
            let B = a.x * c.y - a.y * c.x;
            let C = a.x * b2.y - a.y * b2.x;
            const disc = B * B - 4 * A * C;
            if (disc >= 0) {
              if (A < 0) {
                A = -A;
                B = -B;
                C = -C;
              }
              const Q = Math.sqrt(disc);
              const t0 = (-B - Q) / (2 * A);
              let t1 = (-B + Q) / (2 * A);
              if (t0 > 0 && t0 < 1) {
                cubics.push(this.split(t0));
                t1 = 1 - (1 - t1) / (1 - t0);
              }
              if (t1 > 0 && t1 < 1) {
                cubics.push(this.split(t1));
              }
            }
          }
          cubics.push(this);
          return cubics;
        }
      }
      function cubicToQuadratics(x02, y02, cx0, cy0, cx1, cy1, x1, y1) {
        const cubics = new Cubic(new Vector(x02, y02), new Vector(cx0, cy0), new Vector(cx1, cy1), new Vector(x1, y1)).splitInflections();
        const qs = [];
        const precision = 30 / SQRT3;
        for (let cubic of cubics) {
          const tail = [];
          let t3;
          for (;; ) {
            t3 = precision / cubic.quadError();
            if (t3 >= 0.5 * 0.5 * 0.5) {
              break;
            }
            const t = Math.pow(t3, 1 / 3);
            const start = cubic.split(t);
            const middle = cubic.split(1 - t / (1 - t));
            qs.push(start);
            tail.push(cubic);
            cubic = middle;
          }
          if (t3 < 1) {
            qs.push(cubic.split(0.5));
          }
          qs.push(cubic);
          Array.prototype.push.apply(qs, tail.reverse());
        }
        return qs;
      }
      function pushLine(x02, y02, x1, y1) {
        const mx = (x02 + x1) / 2;
        const my = (y02 + y1) / 2;
        push([x02, x1], [y02, y1], { x: x02, y: y02, cx: mx, cy: my });
      }
      function samePoint(x02, y02, x1, y1) {
        return Math.abs(x1 - x02) < 0.00001 && Math.abs(y1 - y02) < 0.00001;
      }
      let x0, y0, xs, ys;
      for (const cmd of cmds) {
        const x1 = (cmd.x - xMin) / gWidth;
        const y1 = (cmd.y - yMin) / gHeight;
        if (samePoint(x0, y0, x1, y1))
          continue;
        switch (cmd.type) {
          case "M": {
            xs = x1;
            ys = y1;
            break;
          }
          case "L": {
            pushLine(x0, y0, x1, y1);
            break;
          }
          case "Q": {
            const cx = (cmd.x1 - xMin) / gWidth;
            const cy = (cmd.y1 - yMin) / gHeight;
            push([x0, x1, cx], [y0, y1, cy], { x: x0, y: y0, cx, cy });
            break;
          }
          case "Z": {
            if (!samePoint(x0, y0, xs, ys)) {
              pushLine(x0, y0, xs, ys);
              strokes.push({ x: xs, y: ys });
            } else {
              strokes.push({ x: x0, y: y0 });
            }
            break;
          }
          case "C": {
            const cx1 = (cmd.x1 - xMin) / gWidth;
            const cy1 = (cmd.y1 - yMin) / gHeight;
            const cx2 = (cmd.x2 - xMin) / gWidth;
            const cy2 = (cmd.y2 - yMin) / gHeight;
            const qs = cubicToQuadratics(x0, y0, cx1, cy1, cx2, cy2, x1, y1);
            for (let iq = 0;iq < qs.length; iq++) {
              const q = qs[iq].toQuadratic();
              push([q.x, q.x1, q.cx], [q.y, q.y1, q.cy], q);
            }
            break;
          }
          default:
            throw new Error(`unknown command type: ${cmd.type}`);
        }
        x0 = x1;
        y0 = y1;
      }
      const strokeCount = strokes.length;
      const strokeImageInfo = this.strokeImageInfos.findImage(strokeCount);
      const strokeOffset = strokeImageInfo.index;
      for (let il = 0;il < strokeCount; ++il) {
        const s = strokes[il];
        setPixel(strokeImageInfo, byte(s.x), byte(s.y), byte(s.cx), byte(s.cy));
      }
      function layout(dim, dimImageInfos, cellImageInfos) {
        const dimLength = dim.length;
        const dimImageInfo = dimImageInfos.findImage(dimLength);
        const dimOffset = dimImageInfo.index;
        let totalStrokes = 0;
        for (let id = 0;id < dimLength; ++id) {
          totalStrokes += dim[id].length;
        }
        const cellImageInfo = cellImageInfos.findImage(totalStrokes);
        for (let i3 = 0;i3 < dimLength; ++i3) {
          const strokeIndices = dim[i3];
          const strokeCount2 = strokeIndices.length;
          const cellLineIndex = cellImageInfo.index;
          setPixel(dimImageInfo, cellLineIndex >> 7, cellLineIndex & 127, strokeCount2 >> 7, strokeCount2 & 127);
          for (let iil = 0;iil < strokeCount2; ++iil) {
            const strokeIndex = strokeIndices[iil] + strokeOffset;
            setPixel(cellImageInfo, strokeIndex >> 7, strokeIndex & 127, 0, 0);
          }
        }
        return {
          cellImageInfo,
          dimOffset,
          dimImageInfo
        };
      }
      gi = this.glyphInfos[glyph.index] = {
        glyph,
        uGlyphRect: [xMin, yMin, xMax, yMax],
        strokeImageInfo,
        strokes,
        colInfo: layout(cols, this.colDimImageInfos, this.colCellImageInfos),
        rowInfo: layout(rows, this.rowDimImageInfos, this.rowCellImageInfos)
      };
      gi.uGridOffset = [gi.colInfo.dimOffset, gi.rowInfo.dimOffset];
      return gi;
    }
  }
  RendererGL.prototype._renderText = function(line, x, y, maxY, minY) {
    if (!this.states.textFont || typeof this.states.textFont === "string") {
      console.log("WEBGL: you must load and set a font before drawing text. See `loadFont` and `textFont` for more details.");
      return;
    }
    if (y >= maxY || !this.states.fillColor) {
      return;
    }
    if (!p53.Font.hasGlyphData(this.states.textFont)) {
      console.log("WEBGL: only Opentype (.otf) and Truetype (.ttf) fonts with glyph data are supported");
      return;
    }
    this.push();
    const doStroke = this.states.strokeColor;
    const drawMode = this.states.drawMode;
    this.states.setValue("strokeColor", null);
    this.states.setValue("drawMode", TEXTURE);
    const { font: font2 } = this.states.textFont;
    if (!font2) {
      throw new Error("In WebGL mode, textFont() needs to be given the result of loadFont() instead of a font family name.");
    }
    const axs = font2._currentAxes(this);
    let fontInfo = font2._getFontInfo(axs);
    const pos = { x, y };
    const fontSize = this.states.textSize;
    const scale = fontSize / (font2.data?.head?.unitsPerEm || 1000);
    this.translate(pos.x, pos.y, 0);
    this.scale(scale, scale, 1);
    const gl = this.GL;
    const initializeShader = !this._defaultFontShader;
    const sh = this._getFontShader();
    sh.init();
    sh.bindShader();
    if (initializeShader) {
      sh.setUniform("uGridImageSize", [gridImageWidth, gridImageHeight]);
      sh.setUniform("uCellsImageSize", [cellImageWidth, cellImageHeight]);
      sh.setUniform("uStrokeImageSize", [strokeImageWidth, strokeImageHeight]);
      sh.setUniform("uGridSize", [charGridWidth, charGridHeight]);
    }
    const curFillColor = this.states.fillSet ? this.states.curFillColor : [0, 0, 0, 255];
    this._setGlobalUniforms(sh);
    this._applyColorBlend(curFillColor);
    let g2 = this.geometryBufferCache.getGeometryByID("glyph");
    if (!g2) {
      g2 = this._textGeom = new Geometry(1, 1, function() {
        for (let i2 = 0;i2 <= 1; i2++) {
          for (let j = 0;j <= 1; j++) {
            this.vertices.push(new Vector(j, i2, 0));
            this.uvs.push(j, i2);
          }
        }
      }, this);
      g2.gid = "glyph";
      g2.computeFaces().computeNormals();
      this.geometryBufferCache.ensureCached(g2);
    }
    for (const buff of this.buffers.text) {
      buff._prepareBuffer(g2, sh);
    }
    this._bindBuffer(this.geometryBufferCache.cache.glyph.indexBuffer, gl.ELEMENT_ARRAY_BUFFER);
    sh.setUniform("uMaterialColor", curFillColor);
    gl.pixelStorei(gl.UNPACK_PREMULTIPLY_ALPHA_WEBGL, false);
    this.glyphDataCache = this.glyphDataCache || new Set;
    try {
      const glyphs = font2._positionGlyphs(line);
      for (const glyph of glyphs) {
        const gi = fontInfo.getGlyphInfo(glyph);
        if (gi.uGlyphRect) {
          const rowInfo = gi.rowInfo;
          const colInfo = gi.colInfo;
          const glyphResources = [
            gi.strokeImageInfo.imageData,
            rowInfo.cellImageInfo.imageData,
            rowInfo.dimImageInfo.imageData,
            colInfo.cellImageInfo.imageData,
            colInfo.dimImageInfo.imageData
          ];
          for (const resource of glyphResources) {
            this.glyphDataCache.delete(resource);
            this.glyphDataCache.add(resource);
          }
          while (this.glyphDataCache.size > this.maxCachedGlyphs()) {
            const data3 = this.glyphDataCache.values().next().value;
            this.glyphDataCache.delete(data3);
            const tex = this.textures.get(data3);
            if (tex) {
              tex.remove();
              this.textures.delete(data3);
            }
          }
          sh.setUniform("uSamplerStrokes", gi.strokeImageInfo.imageData);
          sh.setUniform("uSamplerRowStrokes", rowInfo.cellImageInfo.imageData);
          sh.setUniform("uSamplerRows", rowInfo.dimImageInfo.imageData);
          sh.setUniform("uSamplerColStrokes", colInfo.cellImageInfo.imageData);
          sh.setUniform("uSamplerCols", colInfo.dimImageInfo.imageData);
          sh.setUniform("uGridOffset", gi.uGridOffset);
          sh.setUniform("uGlyphRect", gi.uGlyphRect);
          sh.setUniform("uGlyphOffset", glyph.x);
          sh.bindTextures();
          gl.drawElements(gl.TRIANGLES, 6, this.GL.UNSIGNED_SHORT, 0);
        }
      }
    } finally {
      sh.unbindShader();
      this.states.setValue("strokeColor", doStroke);
      this.states.setValue("drawMode", drawMode);
      gl.pixelStorei(gl.UNPACK_PREMULTIPLY_ALPHA_WEBGL, true);
      this.pop();
    }
  };
}

// node_modules/p5/dist/strands/ir_types.js
var NodeType = {
  OPERATION: "operation",
  LITERAL: "literal",
  VARIABLE: "variable",
  CONSTANT: "constant",
  STRUCT: "struct",
  PHI: "phi",
  STATEMENT: "statement",
  ASSIGNMENT: "assignment"
};
var NodeTypeToName = Object.fromEntries(Object.entries(NodeType).map(([key, val]) => [val, key]));
var NodeTypeRequiredFields = {
  [NodeType.OPERATION]: ["opCode", "dependsOn", "dimension", "baseType"],
  [NodeType.LITERAL]: ["value", "dimension", "baseType"],
  [NodeType.VARIABLE]: ["identifier", "dimension", "baseType"],
  [NodeType.CONSTANT]: ["value", "dimension", "baseType"],
  [NodeType.STRUCT]: [""],
  [NodeType.PHI]: ["dependsOn", "phiBlocks", "dimension", "baseType"],
  [NodeType.STATEMENT]: ["statementType"],
  [NodeType.ASSIGNMENT]: ["dependsOn"]
};
var StatementType = {
  DISCARD: "discard",
  BREAK: "break",
  EXPRESSION: "expression",
  EMPTY: "empty"
};
var BaseType = {
  FLOAT: "float",
  INT: "int",
  BOOL: "bool",
  MAT: "mat",
  DEFER: "defer",
  SAMPLER2D: "sampler2D"
};
var BasePriority = {
  [BaseType.FLOAT]: 3,
  [BaseType.INT]: 2,
  [BaseType.BOOL]: 1,
  [BaseType.MAT]: 0,
  [BaseType.DEFER]: -1,
  [BaseType.SAMPLER2D]: -10
};
var DataType = {
  float1: { fnName: "float", baseType: BaseType.FLOAT, dimension: 1, priority: 3 },
  float2: { fnName: "vec2", baseType: BaseType.FLOAT, dimension: 2, priority: 3 },
  float3: { fnName: "vec3", baseType: BaseType.FLOAT, dimension: 3, priority: 3 },
  float4: { fnName: "vec4", baseType: BaseType.FLOAT, dimension: 4, priority: 3 },
  int1: { fnName: "int", baseType: BaseType.INT, dimension: 1, priority: 2 },
  int2: { fnName: "ivec2", baseType: BaseType.INT, dimension: 2, priority: 2 },
  int3: { fnName: "ivec3", baseType: BaseType.INT, dimension: 3, priority: 2 },
  int4: { fnName: "ivec4", baseType: BaseType.INT, dimension: 4, priority: 2 },
  bool1: { fnName: "bool", baseType: BaseType.BOOL, dimension: 1, priority: 1 },
  bool2: { fnName: "bvec2", baseType: BaseType.BOOL, dimension: 2, priority: 1 },
  bool3: { fnName: "bvec3", baseType: BaseType.BOOL, dimension: 3, priority: 1 },
  bool4: { fnName: "bvec4", baseType: BaseType.BOOL, dimension: 4, priority: 1 },
  mat2: { fnName: "mat2x2", baseType: BaseType.MAT, dimension: 2, priority: 0 },
  mat3: { fnName: "mat3x3", baseType: BaseType.MAT, dimension: 3, priority: 0 },
  mat4: { fnName: "mat4x4", baseType: BaseType.MAT, dimension: 4, priority: 0 },
  defer: { fnName: null, baseType: BaseType.DEFER, dimension: null, priority: -1 },
  sampler2D: { fnName: "sampler2D", baseType: BaseType.SAMPLER2D, dimension: 1, priority: -10 }
};
var structType = function(hookType) {
  let T = hookType.type === undefined ? hookType : hookType.type;
  const structType2 = {
    name: hookType.name,
    properties: [],
    typeName: T.typeName
  };
  for (const prop of T.properties) {
    const propType = TypeInfoFromGLSLName[prop.type.typeName];
    structType2.properties.push({ name: prop.name, dataType: propType });
  }
  return structType2;
};
function isStructType(typeName) {
  return !isNativeType(typeName);
}
function isNativeType(typeName) {
  if (Object.keys(DataType).includes(typeName)) {
    return true;
  }
  const glslNativeTypes = {
    float: true,
    vec2: true,
    vec3: true,
    vec4: true,
    int: true,
    ivec2: true,
    ivec3: true,
    ivec4: true,
    bool: true,
    bvec2: true,
    bvec3: true,
    bvec4: true,
    mat2: true,
    mat3: true,
    mat4: true,
    sampler2D: true
  };
  return !!glslNativeTypes[typeName];
}
var GenType = {
  FLOAT: { baseType: BaseType.FLOAT, dimension: null, priority: 3 },
  INT: { baseType: BaseType.INT, dimension: null, priority: 2 },
  BOOL: { baseType: BaseType.BOOL, dimension: null, priority: 1 }
};
function typeEquals(nodeA, nodeB) {
  return nodeA.dimension === nodeB.dimension && nodeA.baseType === nodeB.baseType;
}
var TypeInfoFromGLSLName = Object.fromEntries(Object.values(DataType).filter((info) => info.fnName !== null).map((info) => [info.fnName, info]));
var OpCode = {
  Binary: {
    ADD: 0,
    SUBTRACT: 1,
    MULTIPLY: 2,
    DIVIDE: 3,
    MODULO: 4,
    EQUAL: 5,
    NOT_EQUAL: 6,
    GREATER_THAN: 7,
    GREATER_EQUAL: 8,
    LESS_THAN: 9,
    LESS_EQUAL: 10,
    LOGICAL_AND: 11,
    LOGICAL_OR: 12,
    MEMBER_ACCESS: 13
  },
  Unary: {
    LOGICAL_NOT: 100,
    NEGATE: 101,
    PLUS: 102,
    SWIZZLE: 103
  },
  Nary: {
    FUNCTION_CALL: 200,
    CONSTRUCTOR: 201
  },
  ControlFlow: {
    RETURN: 300,
    JUMP: 301,
    BRANCH_IF_FALSE: 302,
    DISCARD: 303,
    BREAK: 304
  }
};
var OperatorTable = [
  { arity: "unary", name: "not", symbol: "!", opCode: OpCode.Unary.LOGICAL_NOT },
  { arity: "unary", name: "neg", symbol: "-", opCode: OpCode.Unary.NEGATE },
  { arity: "unary", name: "plus", symbol: "+", opCode: OpCode.Unary.PLUS },
  { arity: "binary", name: "add", symbol: "+", opCode: OpCode.Binary.ADD },
  { arity: "binary", name: "sub", symbol: "-", opCode: OpCode.Binary.SUBTRACT },
  { arity: "binary", name: "mult", symbol: "*", opCode: OpCode.Binary.MULTIPLY },
  { arity: "binary", name: "div", symbol: "/", opCode: OpCode.Binary.DIVIDE },
  { arity: "binary", name: "mod", symbol: "%", opCode: OpCode.Binary.MODULO },
  { arity: "binary", name: "equalTo", symbol: "==", opCode: OpCode.Binary.EQUAL },
  { arity: "binary", name: "notEqual", symbol: "!=", opCode: OpCode.Binary.NOT_EQUAL },
  { arity: "binary", name: "greaterThan", symbol: ">", opCode: OpCode.Binary.GREATER_THAN },
  { arity: "binary", name: "greaterEqual", symbol: ">=", opCode: OpCode.Binary.GREATER_EQUAL },
  { arity: "binary", name: "lessThan", symbol: "<", opCode: OpCode.Binary.LESS_THAN },
  { arity: "binary", name: "lessEqual", symbol: "<=", opCode: OpCode.Binary.LESS_EQUAL },
  { arity: "binary", name: "and", symbol: "&&", opCode: OpCode.Binary.LOGICAL_AND },
  { arity: "binary", name: "or", symbol: "||", opCode: OpCode.Binary.LOGICAL_OR }
];
var ConstantFolding = {
  [OpCode.Binary.ADD]: (a, b2) => a + b2,
  [OpCode.Binary.SUBTRACT]: (a, b2) => a - b2,
  [OpCode.Binary.MULTIPLY]: (a, b2) => a * b2,
  [OpCode.Binary.DIVIDE]: (a, b2) => a / b2,
  [OpCode.Binary.MODULO]: (a, b2) => a % b2,
  [OpCode.Binary.EQUAL]: (a, b2) => a == b2,
  [OpCode.Binary.NOT_EQUAL]: (a, b2) => a != b2,
  [OpCode.Binary.GREATER_THAN]: (a, b2) => a > b2,
  [OpCode.Binary.GREATER_EQUAL]: (a, b2) => a >= b2,
  [OpCode.Binary.LESS_THAN]: (a, b2) => a < b2,
  [OpCode.Binary.LESS_EQUAL]: (a, b2) => a <= b2,
  [OpCode.Binary.LOGICAL_AND]: (a, b2) => a && b2,
  [OpCode.Binary.LOGICAL_OR]: (a, b2) => a || b2
};
var OpCodeToSymbol = {};
var UnarySymbolToName = {};
var BinarySymbolToName = {};
for (const { symbol: symbol2, opCode, name, arity } of OperatorTable) {
  OpCodeToSymbol[opCode] = symbol2;
  if (arity === "unary") {
    UnarySymbolToName[symbol2] = name;
  }
  if (arity === "binary") {
    BinarySymbolToName[symbol2] = name;
  }
}
var BlockType = {
  GLOBAL: "global",
  FUNCTION: "function",
  BRANCH: "branch",
  IF_COND: "if_cond",
  IF_BODY: "if_body",
  ELSE_COND: "else_cond",
  SCOPE_START: "scope_start",
  SCOPE_END: "scope_end",
  FOR: "for",
  MERGE: "merge",
  DEFAULT: "default"
};
var BlockTypeToName = Object.fromEntries(Object.entries(BlockType).map(([key, val]) => [val, key]));

// node_modules/p5/dist/strands/strands_FES.js
function internalError(errorMessage) {
  const prefixedMessage = `[p5.strands internal error]: ${errorMessage}`;
  throw new Error(prefixedMessage);
}
function userError(errorType, errorMessage) {
  const prefixedMessage = `[p5.strands ${errorType}]: ${errorMessage}`;
  throw new Error(prefixedMessage);
}

// node_modules/p5/dist/strands/ir_dag.js
function createDirectedAcyclicGraph() {
  const graph = {
    nextID: 0,
    cache: new Map,
    nodeTypes: [],
    baseTypes: [],
    dimensions: [],
    opCodes: [],
    values: [],
    identifiers: [],
    phiBlocks: [],
    dependsOn: [],
    usedBy: [],
    statementTypes: [],
    swizzles: []
  };
  return graph;
}
function getOrCreateNode(graph, node) {
  const id = createNode(graph, node);
  return id;
}
function createNodeData(data3 = {}) {
  const node = {
    nodeType: data3.nodeType ?? null,
    baseType: data3.baseType ?? null,
    dimension: data3.dimension ?? null,
    opCode: data3.opCode ?? null,
    value: data3.value ?? null,
    identifier: data3.identifier ?? null,
    statementType: data3.statementType ?? null,
    swizzle: data3.swizzle ?? null,
    dependsOn: Array.isArray(data3.dependsOn) ? data3.dependsOn : [],
    usedBy: Array.isArray(data3.usedBy) ? data3.usedBy : [],
    phiBlocks: Array.isArray(data3.phiBlocks) ? data3.phiBlocks : []
  };
  validateNode(node);
  return node;
}
function getNodeDataFromID(graph, id) {
  return {
    id,
    nodeType: graph.nodeTypes[id],
    opCode: graph.opCodes[id],
    value: graph.values[id],
    identifier: graph.identifiers[id],
    dependsOn: graph.dependsOn[id],
    usedBy: graph.usedBy[id],
    phiBlocks: graph.phiBlocks[id],
    dimension: graph.dimensions[id],
    baseType: graph.baseTypes[id],
    statementType: graph.statementTypes[id],
    swizzle: graph.swizzles[id]
  };
}
function extractNodeTypeInfo(dag, nodeID) {
  return {
    baseType: dag.baseTypes[nodeID],
    dimension: dag.dimensions[nodeID],
    priority: BasePriority[dag.baseTypes[nodeID]]
  };
}
function createNode(graph, node) {
  const id = graph.nextID++;
  graph.nodeTypes[id] = node.nodeType;
  graph.opCodes[id] = node.opCode;
  graph.values[id] = node.value;
  graph.identifiers[id] = node.identifier;
  graph.dependsOn[id] = node.dependsOn.slice();
  graph.usedBy[id] = node.usedBy;
  graph.phiBlocks[id] = node.phiBlocks.slice();
  graph.baseTypes[id] = node.baseType;
  graph.dimensions[id] = node.dimension;
  graph.statementTypes[id] = node.statementType;
  graph.swizzles[id] = node.swizzle;
  for (const dep of node.dependsOn) {
    if (!Array.isArray(graph.usedBy[dep])) {
      graph.usedBy[dep] = [];
    }
    graph.usedBy[dep].push(id);
  }
  return id;
}
function validateNode(node) {
  const nodeType = node.nodeType;
  const requiredFields = NodeTypeRequiredFields[nodeType];
  if (requiredFields.length === 2) {
    internalError(`Required fields for node type '${NodeTypeToName[nodeType]}' not defined. Please add them to the utils.js file in p5.strands!`);
  }
  const missingFields = [];
  for (const field of requiredFields) {
    if (node[field] === null) {
      missingFields.push(field);
    }
  }
  if (node.dependsOn?.some((v) => v === undefined)) {
    throw new Error("Undefined dependency!");
  }
  if (missingFields.length > 0) {
    internalError(`Missing fields ${missingFields.join(", ")} for a node type '${NodeTypeToName[nodeType]}'.`);
  }
}

// node_modules/p5/dist/strands/strands_glslBackend.js
function shouldCreateTemp(dag, nodeID) {
  const nodeType = dag.nodeTypes[nodeID];
  if (nodeType !== NodeType.OPERATION)
    return false;
  if (dag.baseTypes[nodeID] === BaseType.SAMPLER2D)
    return false;
  const uses = dag.usedBy[nodeID] || [];
  return uses.length > 1;
}
var TypeNames = {
  float1: "float",
  float2: "vec2",
  float3: "vec3",
  float4: "vec4",
  int1: "int",
  int2: "ivec2",
  int3: "ivec3",
  int4: "ivec4",
  bool1: "bool",
  bool2: "bvec2",
  bool3: "bvec3",
  bool4: "bvec4",
  mat2: "mat2x2",
  mat3: "mat3x3",
  mat4: "mat4x4"
};
var cfgHandlers = {
  [BlockType.DEFAULT]: (blockID, strandsContext, generationContext) => {
    const { dag, cfg } = strandsContext;
    const instructions = cfg.blockInstructions[blockID] || [];
    for (const nodeID of instructions) {
      const nodeType = dag.nodeTypes[nodeID];
      if (shouldCreateTemp(dag, nodeID)) {
        const declaration = glslBackend.generateDeclaration(generationContext, dag, nodeID);
        generationContext.write(declaration);
      }
      if (nodeType === NodeType.STATEMENT) {
        glslBackend.generateStatement(generationContext, dag, nodeID);
      }
      if (nodeType === NodeType.ASSIGNMENT) {
        glslBackend.generateAssignment(generationContext, dag, nodeID);
        generationContext.visitedNodes.add(nodeID);
      }
    }
  },
  [BlockType.BRANCH](blockID, strandsContext, generationContext) {
    const { dag, cfg } = strandsContext;
    const blockInstructions = cfg.blockInstructions[blockID] || [];
    for (const nodeID of blockInstructions) {
      const node = getNodeDataFromID(dag, nodeID);
      if (node.nodeType === NodeType.PHI) {
        const dependsOn = node.dependsOn || [];
        if (dependsOn.length > 0) {
          const firstDependency = dependsOn[0];
          const existingTempName = generationContext.tempNames[firstDependency];
          if (existingTempName) {
            generationContext.tempNames[nodeID] = existingTempName;
            continue;
          }
        }
        const tmp = `T${generationContext.nextTempID++}`;
        generationContext.tempNames[nodeID] = tmp;
        const T = extractNodeTypeInfo(dag, nodeID);
        const typeName = glslBackend.getTypeName(T.baseType, T.dimension);
        generationContext.write(`${typeName} ${tmp};`);
      }
    }
    this[BlockType.DEFAULT](blockID, strandsContext, generationContext);
  },
  [BlockType.IF_COND](blockID, strandsContext, generationContext) {
    const { dag, cfg } = strandsContext;
    const conditionID = cfg.blockConditions[blockID];
    const condExpr = glslBackend.generateExpression(generationContext, dag, conditionID);
    generationContext.write(`if (${condExpr})`);
    this[BlockType.DEFAULT](blockID, strandsContext, generationContext);
  },
  [BlockType.ELSE_COND](blockID, strandsContext, generationContext) {
    generationContext.write(`else`);
    this[BlockType.DEFAULT](blockID, strandsContext, generationContext);
  },
  [BlockType.IF_BODY](blockID, strandsContext, generationContext) {
    this[BlockType.DEFAULT](blockID, strandsContext, generationContext);
    this.assignPhiNodeValues(blockID, strandsContext, generationContext);
  },
  [BlockType.SCOPE_START](blockID, strandsContext, generationContext) {
    generationContext.write(`{`);
    generationContext.indent++;
  },
  [BlockType.SCOPE_END](blockID, strandsContext, generationContext) {
    generationContext.indent--;
    generationContext.write(`}`);
  },
  [BlockType.MERGE](blockID, strandsContext, generationContext) {
    this[BlockType.DEFAULT](blockID, strandsContext, generationContext);
  },
  [BlockType.FUNCTION](blockID, strandsContext, generationContext) {
    this[BlockType.DEFAULT](blockID, strandsContext, generationContext);
  },
  [BlockType.FOR](blockID, strandsContext, generationContext) {
    const { dag, cfg } = strandsContext;
    const instructions = cfg.blockInstructions[blockID] || [];
    generationContext.write(`for (`);
    const originalSuppressSemicolon = generationContext.suppressSemicolon;
    for (let i2 = 0;i2 < instructions.length; i2++) {
      const nodeID = instructions[i2];
      const node = getNodeDataFromID(dag, nodeID);
      const isLast = i2 === instructions.length - 1;
      generationContext.suppressSemicolon = isLast;
      if (shouldCreateTemp(dag, nodeID)) {
        const declaration = glslBackend.generateDeclaration(generationContext, dag, nodeID);
        generationContext.write(declaration);
      }
      if (node.nodeType === NodeType.STATEMENT) {
        glslBackend.generateStatement(generationContext, dag, nodeID);
      }
      if (node.nodeType === NodeType.ASSIGNMENT) {
        glslBackend.generateAssignment(generationContext, dag, nodeID);
        generationContext.visitedNodes.add(nodeID);
      }
    }
    generationContext.suppressSemicolon = originalSuppressSemicolon;
    generationContext.write(`)`);
  },
  assignPhiNodeValues(blockID, strandsContext, generationContext) {
    const { dag, cfg } = strandsContext;
    const successors = cfg.outgoingEdges[blockID] || [];
    for (const successorBlockID of successors) {
      const instructions = cfg.blockInstructions[successorBlockID] || [];
      for (const nodeID of instructions) {
        const node = getNodeDataFromID(dag, nodeID);
        if (node.nodeType === NodeType.PHI) {
          const branchIndex = node.phiBlocks?.indexOf(blockID);
          if (branchIndex !== -1 && branchIndex < node.dependsOn.length) {
            const sourceNodeID = node.dependsOn[branchIndex];
            const tempName = generationContext.tempNames[nodeID];
            if (tempName && sourceNodeID !== null) {
              const sourceExpr = glslBackend.generateExpression(generationContext, dag, sourceNodeID);
              generationContext.write(`${tempName} = ${sourceExpr};`);
            }
          }
        }
      }
    }
  }
};
var glslBackend = {
  hookEntry(hookType) {
    const firstLine = `(${hookType.parameters.flatMap((param) => {
      return `${param.qualifiers?.length ? param.qualifiers.join(" ") : ""}${param.type.typeName} ${param.name}`;
    }).join(", ")}) {`;
    return firstLine;
  },
  getTypeName(baseType, dimension) {
    const primitiveTypeName = TypeNames[baseType + dimension];
    if (!primitiveTypeName) {
      return baseType;
    }
    return primitiveTypeName;
  },
  generateUniformDeclaration(name, typeInfo) {
    return `${this.getTypeName(typeInfo.baseType, typeInfo.dimension)} ${name}`;
  },
  generateStatement(generationContext, dag, nodeID) {
    const node = getNodeDataFromID(dag, nodeID);
    const semicolon = generationContext.suppressSemicolon ? "" : ";";
    if (node.statementType === StatementType.DISCARD) {
      generationContext.write(`discard${semicolon}`);
    } else if (node.statementType === StatementType.BREAK) {
      generationContext.write(`break${semicolon}`);
    } else if (node.statementType === StatementType.EXPRESSION) {
      const exprNodeID = node.dependsOn[0];
      const expr = this.generateExpression(generationContext, dag, exprNodeID);
      generationContext.write(`${expr}${semicolon}`);
    } else if (node.statementType === StatementType.EMPTY) {
      generationContext.write(semicolon);
    }
  },
  generateAssignment(generationContext, dag, nodeID) {
    const node = getNodeDataFromID(dag, nodeID);
    const targetNodeID = node.dependsOn[0];
    const sourceNodeID = node.dependsOn[1];
    const targetExpr = this.generateExpression(generationContext, dag, targetNodeID);
    const sourceExpr = this.generateExpression(generationContext, dag, sourceNodeID);
    const semicolon = generationContext.suppressSemicolon ? "" : ";";
    if (targetExpr && sourceExpr && targetExpr !== sourceExpr) {
      generationContext.write(`${targetExpr} = ${sourceExpr}${semicolon}`);
    }
  },
  generateDeclaration(generationContext, dag, nodeID) {
    const expr = this.generateExpression(generationContext, dag, nodeID);
    const tmp = `T${generationContext.nextTempID++}`;
    generationContext.tempNames[nodeID] = tmp;
    const T = extractNodeTypeInfo(dag, nodeID);
    const typeName = this.getTypeName(T.baseType, T.dimension);
    return `${typeName} ${tmp} = ${expr};`;
  },
  generateReturnStatement(strandsContext, generationContext, rootNodeID, returnType) {
    const dag = strandsContext.dag;
    const rootNode = getNodeDataFromID(dag, rootNodeID);
    if (isStructType(rootNode.baseType)) {
      const structTypeInfo = returnType;
      for (let i2 = 0;i2 < structTypeInfo.properties.length; i2++) {
        const prop = structTypeInfo.properties[i2];
        const val = this.generateExpression(generationContext, dag, rootNode.dependsOn[i2]);
        if (prop.name !== val) {
          generationContext.write(`${rootNode.identifier}.${prop.name} = ${val};`);
        }
      }
    }
    generationContext.write(`return ${this.generateExpression(generationContext, dag, rootNodeID)};`);
  },
  generateExpression(generationContext, dag, nodeID) {
    const node = getNodeDataFromID(dag, nodeID);
    if (generationContext.tempNames?.[nodeID]) {
      return generationContext.tempNames[nodeID];
    }
    switch (node.nodeType) {
      case NodeType.LITERAL:
        if (node.baseType === BaseType.FLOAT) {
          return node.value.toFixed(4);
        } else {
          return node.value;
        }
      case NodeType.VARIABLE:
        if (generationContext.shaderContext && generationContext.strandsContext?.sharedVariables?.has(node.identifier)) {
          const sharedVar = generationContext.strandsContext.sharedVariables.get(node.identifier);
          if (generationContext.shaderContext === "vertex") {
            sharedVar.usedInVertex = true;
          } else if (generationContext.shaderContext === "fragment") {
            sharedVar.usedInFragment = true;
          }
        }
        return node.identifier;
      case NodeType.OPERATION:
        const useParantheses = node.usedBy.length > 0;
        if (node.opCode === OpCode.Nary.CONSTRUCTOR) {
          if (node.baseType === BaseType.SAMPLER2D) {
            return this.generateExpression(generationContext, dag, node.dependsOn[0]);
          }
          const T = this.getTypeName(node.baseType, node.dimension);
          const deps = node.dependsOn.map((dep) => this.generateExpression(generationContext, dag, dep));
          return `${T}(${deps.join(", ")})`;
        }
        if (node.opCode === OpCode.Nary.FUNCTION_CALL) {
          const functionArgs = node.dependsOn.map((arg) => this.generateExpression(generationContext, dag, arg));
          return `${node.identifier}(${functionArgs.join(", ")})`;
        }
        if (node.opCode === OpCode.Binary.MEMBER_ACCESS) {
          const [lID, rID] = node.dependsOn;
          const lName = this.generateExpression(generationContext, dag, lID);
          const rName = this.generateExpression(generationContext, dag, rID);
          return `${lName}.${rName}`;
        }
        if (node.opCode === OpCode.Unary.SWIZZLE) {
          const parentID = node.dependsOn[0];
          const parentExpr = this.generateExpression(generationContext, dag, parentID);
          return `${parentExpr}.${node.swizzle}`;
        }
        if (node.dependsOn.length === 2) {
          const [lID, rID] = node.dependsOn;
          const left = this.generateExpression(generationContext, dag, lID);
          const right = this.generateExpression(generationContext, dag, rID);
          if (node.opCode === OpCode.Binary.MODULO) {
            const leftNode = getNodeDataFromID(dag, lID);
            const rightNode = getNodeDataFromID(dag, rID);
            if (leftNode.baseType === BaseType.FLOAT || rightNode.baseType === BaseType.FLOAT) {
              return `mod(${left}, ${right})`;
            }
            return `(${left} % ${right})`;
          }
          const opSym = OpCodeToSymbol[node.opCode];
          if (useParantheses) {
            return `(${left} ${opSym} ${right})`;
          } else {
            return `${left} ${opSym} ${right}`;
          }
        }
        if (node.opCode === OpCode.Unary.LOGICAL_NOT || node.opCode === OpCode.Unary.NEGATE || node.opCode === OpCode.Unary.PLUS) {
          const [i2] = node.dependsOn;
          const val = this.generateExpression(generationContext, dag, i2);
          const sym = OpCodeToSymbol[node.opCode];
          return `${sym}${val}`;
        }
      case NodeType.PHI:
        if (node.identifier) {
          return node.identifier;
        }
        if (generationContext.tempNames?.[nodeID]) {
          return generationContext.tempNames[nodeID];
        } else {
          const validInputs = node.dependsOn.filter((id) => id !== null);
          if (validInputs.length > 0) {
            return this.generateExpression(generationContext, dag, validInputs[0]);
          } else {
            throw new Error(`No valid inputs for node`);
          }
        }
      case NodeType.ASSIGNMENT:
        internalError(`ASSIGNMENT nodes should not be used as expressions`);
      default:
        internalError(`${NodeTypeToName[node.nodeType]} code generation not implemented yet`);
    }
  },
  generateBlock(blockID, strandsContext, generationContext) {
    const type2 = strandsContext.cfg.blockTypes[blockID];
    const handler = cfgHandlers[type2] || cfgHandlers[BlockType.DEFAULT];
    handler.call(cfgHandlers, blockID, strandsContext, generationContext);
  }
};

// node_modules/p5/dist/strands/strands_transpiler.js
var import_escodegen = __toESM(require_escodegen(), 1);
var blockVarCounter = 0;
function replaceBinaryOperator(codeSource) {
  switch (codeSource) {
    case "+":
      return "add";
    case "-":
      return "sub";
    case "*":
      return "mult";
    case "/":
      return "div";
    case "%":
      return "mod";
    case "==":
    case "===":
      return "equalTo";
    case "!=":
    case "!==":
      return "notEqual";
    case ">":
      return "greaterThan";
    case ">=":
      return "greaterEqual";
    case "<":
      return "lessThan";
    case "<=":
      return "lessEqual";
    case "&&":
      return "and";
    case "||":
      return "or";
  }
}
function nodeIsUniform(ancestor2) {
  return ancestor2.type === "CallExpression" && (ancestor2.callee?.type === "Identifier" && ancestor2.callee?.name.startsWith("uniform") || ancestor2.callee?.type === "MemberExpression" && ancestor2.callee?.property.name.startsWith("uniform"));
}
function nodeIsVarying(node) {
  return node?.type === "CallExpression" && (node.callee?.type === "Identifier" && (node.callee?.name.startsWith("varying") || node.callee?.name.startsWith("shared")) || node.callee?.type === "MemberExpression" && (node.callee?.property.name.startsWith("varying") || node.callee?.property.name.startsWith("shared")));
}
var ASTCallbacks = {
  UnaryExpression(node, _state, ancestors) {
    if (ancestors.some(nodeIsUniform)) {
      return;
    }
    const unaryFnName = UnarySymbolToName[node.operator];
    const standardReplacement = (node2) => {
      node2.type = "CallExpression";
      node2.callee = {
        type: "Identifier",
        name: `__p5.${unaryFnName}`
      };
      node2.arguments = [node2.argument];
    };
    if (node.type === "MemberExpression") {
      const property = node.argument.property.name;
      const swizzleSets = [
        ["x", "y", "z", "w"],
        ["r", "g", "b", "a"],
        ["s", "t", "p", "q"]
      ];
      let isSwizzle = swizzleSets.some((set3) => [...property].every((char) => set3.includes(char))) && node.argument.type === "MemberExpression";
      if (isSwizzle) {
        node.type = "MemberExpression";
        node.object = {
          type: "CallExpression",
          callee: {
            type: "Identifier",
            name: `__p5.${unaryFnName}`
          },
          arguments: [node.argument.object]
        };
        node.property = {
          type: "Identifier",
          name: property
        };
      } else {
        standardReplacement(node);
      }
    } else {
      standardReplacement(node);
    }
    delete node.argument;
    delete node.operator;
  },
  BreakStatement(node, _state, ancestors) {
    if (ancestors.some(nodeIsUniform)) {
      return;
    }
    node.callee = {
      type: "Identifier",
      name: "__p5.break"
    };
    node.arguments = [];
    node.type = "CallExpression";
  },
  VariableDeclarator(node, _state, ancestors) {
    if (ancestors.some(nodeIsUniform)) {
      return;
    }
    if (nodeIsUniform(node.init)) {
      const uniformNameLiteral = {
        type: "Literal",
        value: node.id.name
      };
      node.init.arguments.unshift(uniformNameLiteral);
    }
    if (nodeIsVarying(node.init)) {
      const varyingNameLiteral = {
        type: "Literal",
        value: node.id.name
      };
      node.init.arguments.unshift(varyingNameLiteral);
      _state.varyings[node.id.name] = varyingNameLiteral;
    }
  },
  Identifier(node, _state, ancestors) {
    if (ancestors.some(nodeIsUniform)) {
      return;
    }
    if (_state.varyings[node.name] && !ancestors.some((a) => a.type === "AssignmentExpression" && a.left === node)) {
      node.type = "ExpressionStatement";
      node.expression = {
        type: "CallExpression",
        callee: {
          type: "MemberExpression",
          object: {
            type: "Identifier",
            name: node.name
          },
          property: {
            type: "Identifier",
            name: "getValue"
          }
        },
        arguments: []
      };
    }
  },
  ArrayExpression(node, _state, ancestors) {
    if (ancestors.some(nodeIsUniform)) {
      return;
    }
    const original = JSON.parse(JSON.stringify(node));
    node.type = "CallExpression";
    node.callee = {
      type: "Identifier",
      name: "__p5.strandsNode"
    };
    node.arguments = [original];
  },
  AssignmentExpression(node, _state, ancestors) {
    if (ancestors.some(nodeIsUniform)) {
      return;
    }
    if (node.operator !== "=") {
      const methodName = replaceBinaryOperator(node.operator.replace("=", ""));
      const rightReplacementNode = {
        type: "CallExpression",
        callee: {
          type: "MemberExpression",
          object: node.left,
          property: {
            type: "Identifier",
            name: methodName
          }
        },
        arguments: [node.right]
      };
      node.operator = "=";
      node.right = rightReplacementNode;
    }
    if (_state.varyings[node.left.name]) {
      node.type = "ExpressionStatement";
      node.expression = {
        type: "CallExpression",
        callee: {
          type: "MemberExpression",
          object: {
            type: "Identifier",
            name: node.left.name
          },
          property: {
            type: "Identifier",
            name: "bridge"
          }
        },
        arguments: [node.right]
      };
    } else if (node.left.type === "MemberExpression") {
      let varyingName = null;
      if (node.left.object.type === "Identifier" && _state.varyings[node.left.object.name]) {
        varyingName = node.left.object.name;
      } else if (node.left.object.type === "ExpressionStatement" && node.left.object.expression?.type === "CallExpression" && node.left.object.expression.callee?.type === "MemberExpression" && node.left.object.expression.callee.property?.name === "getValue" && node.left.object.expression.callee.object?.type === "Identifier" && _state.varyings[node.left.object.expression.callee.object.name]) {
        varyingName = node.left.object.expression.callee.object.name;
      }
      if (varyingName) {
        const swizzlePattern = node.left.property.name;
        node.type = "ExpressionStatement";
        node.expression = {
          type: "CallExpression",
          callee: {
            type: "MemberExpression",
            object: {
              type: "Identifier",
              name: varyingName
            },
            property: {
              type: "Identifier",
              name: "bridgeSwizzle"
            }
          },
          arguments: [
            {
              type: "Literal",
              value: swizzlePattern
            },
            node.right
          ]
        };
      }
    }
  },
  BinaryExpression(node, _state, ancestors) {
    if (ancestors.some(nodeIsUniform)) {
      return;
    }
    const unsafeTypes = ["Literal", "ArrayExpression", "Identifier"];
    if (unsafeTypes.includes(node.left.type)) {
      const leftReplacementNode = {
        type: "CallExpression",
        callee: {
          type: "Identifier",
          name: "__p5.strandsNode"
        },
        arguments: [node.left]
      };
      node.left = leftReplacementNode;
    }
    node.type = "CallExpression";
    node.callee = {
      type: "MemberExpression",
      object: node.left,
      property: {
        type: "Identifier",
        name: replaceBinaryOperator(node.operator)
      }
    };
    node.arguments = [node.right];
  },
  IfStatement(node, _state, ancestors) {
    if (ancestors.some(nodeIsUniform)) {
      return;
    }
    const condition = node.test;
    const thenFunction = {
      type: "ArrowFunctionExpression",
      params: [],
      body: node.consequent.type === "BlockStatement" ? node.consequent : {
        type: "BlockStatement",
        body: [node.consequent]
      }
    };
    let callExpression = {
      type: "CallExpression",
      callee: {
        type: "Identifier",
        name: "__p5.strandsIf"
      },
      arguments: [condition, thenFunction]
    };
    let elseFunction;
    if (node.alternate) {
      elseFunction = {
        type: "ArrowFunctionExpression",
        params: [],
        body: node.alternate.type === "BlockStatement" ? node.alternate : {
          type: "BlockStatement",
          body: [node.alternate]
        }
      };
    } else {
      elseFunction = {
        type: "ArrowFunctionExpression",
        params: [],
        body: {
          type: "BlockStatement",
          body: []
        }
      };
    }
    callExpression = {
      type: "CallExpression",
      callee: {
        type: "MemberExpression",
        object: callExpression,
        property: {
          type: "Identifier",
          name: "Else"
        }
      },
      arguments: [elseFunction]
    };
    const assignedVars = new Set;
    const analyzeBlock = (body) => {
      if (body.type !== "BlockStatement")
        return;
      const localVars = new Set;
      for (const stmt of body.body) {
        if (stmt.type === "VariableDeclaration") {
          for (const decl of stmt.declarations) {
            if (decl.id.type === "Identifier") {
              localVars.add(decl.id.name);
            }
          }
        }
      }
      for (const stmt of body.body) {
        if (stmt.type === "ExpressionStatement" && stmt.expression.type === "AssignmentExpression") {
          const left = stmt.expression.left;
          if (left.type === "Identifier") {
            if (!localVars.has(left.name)) {
              assignedVars.add(left.name);
            }
          } else if (left.type === "MemberExpression" && left.object.type === "Identifier") {
            if (!localVars.has(left.object.name)) {
              assignedVars.add(left.object.name);
            }
          }
        } else if (stmt.type === "BlockStatement") {
          analyzeBlock(stmt);
        }
      }
    };
    analyzeBlock(thenFunction.body);
    analyzeBlock(elseFunction.body);
    if (assignedVars.size > 0) {
      const addCopyingAndReturn = (functionBody, varsToReturn) => {
        if (functionBody.type === "BlockStatement") {
          const tempVarMap = new Map;
          const copyStatements = [];
          for (const varName of varsToReturn) {
            const tempName = `__copy_${varName}_${blockVarCounter++}`;
            tempVarMap.set(varName, tempName);
            copyStatements.push({
              type: "VariableDeclaration",
              declarations: [{
                type: "VariableDeclarator",
                id: { type: "Identifier", name: tempName },
                init: {
                  type: "CallExpression",
                  callee: {
                    type: "MemberExpression",
                    object: { type: "Identifier", name: varName },
                    property: { type: "Identifier", name: "copy" },
                    computed: false
                  },
                  arguments: []
                }
              }],
              kind: "let"
            });
          }
          const replaceReferences = (node2) => {
            if (!node2 || typeof node2 !== "object")
              return;
            if (node2.type === "Identifier" && tempVarMap.has(node2.name)) {
              node2.name = tempVarMap.get(node2.name);
            } else if (node2.type === "MemberExpression" && node2.object.type === "Identifier" && tempVarMap.has(node2.object.name)) {
              node2.object.name = tempVarMap.get(node2.object.name);
            }
            if (node2.type === "AssignmentExpression" && node2.left.type === "Identifier" && tempVarMap.has(node2.left.name) && (node2.right.type === "Literal" || node2.right.type === "ArrayExpression")) {
              node2.right = {
                type: "CallExpression",
                callee: {
                  type: "Identifier",
                  name: "__p5.strandsNode"
                },
                arguments: [node2.right]
              };
            }
            for (const key in node2) {
              if (node2.hasOwnProperty(key) && key !== "parent") {
                if (Array.isArray(node2[key])) {
                  node2[key].forEach(replaceReferences);
                } else if (typeof node2[key] === "object") {
                  replaceReferences(node2[key]);
                }
              }
            }
          };
          functionBody.body.forEach(replaceReferences);
          functionBody.body.unshift(...copyStatements);
          const returnObj = {
            type: "ObjectExpression",
            properties: Array.from(varsToReturn).map((varName) => ({
              type: "Property",
              key: { type: "Identifier", name: varName },
              value: { type: "Identifier", name: tempVarMap.get(varName) },
              kind: "init",
              computed: false,
              shorthand: false
            }))
          };
          functionBody.body.push({
            type: "ReturnStatement",
            argument: returnObj
          });
        }
      };
      addCopyingAndReturn(thenFunction.body, assignedVars);
      addCopyingAndReturn(elseFunction.body, assignedVars);
      const blockVar = `__block_${blockVarCounter++}`;
      const statements = [];
      for (const varName of assignedVars) {
        statements.push({
          type: "ExpressionStatement",
          expression: {
            type: "AssignmentExpression",
            operator: "=",
            left: { type: "Identifier", name: varName },
            right: {
              type: "CallExpression",
              callee: { type: "Identifier", name: "__p5.strandsNode" },
              arguments: [{ type: "Identifier", name: varName }]
            }
          }
        });
      }
      statements.push({
        type: "VariableDeclaration",
        declarations: [{
          type: "VariableDeclarator",
          id: { type: "Identifier", name: blockVar },
          init: callExpression
        }],
        kind: "const"
      });
      for (const varName of assignedVars) {
        statements.push({
          type: "ExpressionStatement",
          expression: {
            type: "AssignmentExpression",
            operator: "=",
            left: { type: "Identifier", name: varName },
            right: {
              type: "MemberExpression",
              object: { type: "Identifier", name: blockVar },
              property: { type: "Identifier", name: varName },
              computed: false
            }
          }
        });
      }
      node.type = "BlockStatement";
      node.body = statements;
    } else {
      node.type = "ExpressionStatement";
      node.expression = callExpression;
    }
    delete node.test;
    delete node.consequent;
    delete node.alternate;
  },
  UpdateExpression(node, _state, ancestors) {
    if (ancestors.some(nodeIsUniform)) {
      return;
    }
    let operator;
    if (node.operator === "++") {
      operator = "+";
    } else if (node.operator === "--") {
      operator = "-";
    } else {
      return;
    }
    const assignmentExpr = {
      type: "AssignmentExpression",
      operator: "=",
      left: node.argument,
      right: {
        type: "BinaryExpression",
        operator,
        left: node.argument,
        right: {
          type: "Literal",
          value: 1
        }
      }
    };
    Object.assign(node, assignmentExpr);
    delete node.prefix;
    this.BinaryExpression(node.right, _state, [...ancestors, node]);
    this.AssignmentExpression(node, _state, ancestors);
  },
  ForStatement(node, _state, ancestors) {
    if (ancestors.some(nodeIsUniform)) {
      return;
    }
    let initialFunction;
    if (node.init && node.init.type === "VariableDeclaration") {
      const declaration = node.init.declarations[0];
      let initValue = declaration.init;
      const initAst = { body: [{ type: "ExpressionStatement", expression: initValue }] };
      initValue = initAst.body[0].expression;
      initialFunction = {
        type: "ArrowFunctionExpression",
        params: [],
        body: {
          type: "BlockStatement",
          body: [{
            type: "ReturnStatement",
            argument: initValue
          }]
        }
      };
    } else {
      initialFunction = {
        type: "ArrowFunctionExpression",
        params: [],
        body: {
          type: "BlockStatement",
          body: [{
            type: "ReturnStatement",
            argument: {
              type: "Literal",
              value: 0
            }
          }]
        }
      };
    }
    let conditionBody = node.test || { type: "Literal", value: true };
    if (node.init?.type === "VariableDeclaration") {
      const loopVarName = node.init.declarations[0].id.name;
      conditionBody = this.replaceIdentifierReferences(conditionBody, loopVarName, "loopVar");
    }
    const conditionAst = { body: [{ type: "ExpressionStatement", expression: conditionBody }] };
    conditionBody = conditionAst.body[0].expression;
    const conditionFunction = {
      type: "ArrowFunctionExpression",
      params: [{ type: "Identifier", name: "loopVar" }],
      body: conditionBody
    };
    let updateFunction;
    if (node.update) {
      let updateExpr = node.update;
      if (node.init?.type === "VariableDeclaration") {
        const loopVarName = node.init.declarations[0].id.name;
        updateExpr = this.replaceIdentifierReferences(updateExpr, loopVarName, "loopVar");
      }
      const updateAst = { body: [{ type: "ExpressionStatement", expression: updateExpr }] };
      updateExpr = updateAst.body[0].expression;
      updateFunction = {
        type: "ArrowFunctionExpression",
        params: [{ type: "Identifier", name: "loopVar" }],
        body: {
          type: "BlockStatement",
          body: [{
            type: "ReturnStatement",
            argument: updateExpr
          }]
        }
      };
    } else {
      updateFunction = {
        type: "ArrowFunctionExpression",
        params: [{ type: "Identifier", name: "loopVar" }],
        body: {
          type: "BlockStatement",
          body: [{
            type: "ReturnStatement",
            argument: { type: "Identifier", name: "loopVar" }
          }]
        }
      };
    }
    let bodyBlock = node.body.type === "BlockStatement" ? node.body : {
      type: "BlockStatement",
      body: [node.body]
    };
    if (node.init?.type === "VariableDeclaration") {
      const loopVarName = node.init.declarations[0].id.name;
      bodyBlock = this.replaceIdentifierReferences(bodyBlock, loopVarName, "loopVar");
    }
    const bodyFunction = {
      type: "ArrowFunctionExpression",
      params: [
        { type: "Identifier", name: "loopVar" },
        { type: "Identifier", name: "vars" }
      ],
      body: bodyBlock
    };
    const assignedVars = new Set;
    const analyzeBlock = (body, parentLocalVars = new Set) => {
      if (body.type !== "BlockStatement")
        return;
      const localVars = new Set([...parentLocalVars]);
      for (const stmt of body.body) {
        if (stmt.type === "VariableDeclaration") {
          for (const decl of stmt.declarations) {
            if (decl.id.type === "Identifier") {
              localVars.add(decl.id.name);
            }
          }
        }
      }
      for (const stmt of body.body) {
        if (stmt.type === "ExpressionStatement" && stmt.expression.type === "AssignmentExpression") {
          const left = stmt.expression.left;
          if (left.type === "Identifier") {
            if (!localVars.has(left.name)) {
              assignedVars.add(left.name);
            }
          } else if (left.type === "MemberExpression" && left.object.type === "Identifier") {
            if (!localVars.has(left.object.name)) {
              assignedVars.add(left.object.name);
            }
          }
        } else if (stmt.type === "BlockStatement") {
          analyzeBlock(stmt, localVars);
        }
      }
    };
    analyzeBlock(bodyFunction.body);
    if (assignedVars.size > 0) {
      const addCopyingAndReturn = (functionBody, varsToReturn) => {
        if (functionBody.type === "BlockStatement") {
          const tempVarMap = new Map;
          const copyStatements = [];
          for (const varName of varsToReturn) {
            const tempName = `__copy_${varName}_${blockVarCounter++}`;
            tempVarMap.set(varName, tempName);
            copyStatements.push({
              type: "VariableDeclaration",
              declarations: [{
                type: "VariableDeclarator",
                id: { type: "Identifier", name: tempName },
                init: {
                  type: "CallExpression",
                  callee: {
                    type: "MemberExpression",
                    object: {
                      type: "MemberExpression",
                      object: { type: "Identifier", name: "vars" },
                      property: { type: "Identifier", name: varName },
                      computed: false
                    },
                    property: { type: "Identifier", name: "copy" },
                    computed: false
                  },
                  arguments: []
                }
              }],
              kind: "let"
            });
          }
          const replaceReferences = (node2) => {
            if (!node2 || typeof node2 !== "object")
              return;
            if (node2.type === "Identifier" && tempVarMap.has(node2.name)) {
              node2.name = tempVarMap.get(node2.name);
            }
            for (const key in node2) {
              if (node2.hasOwnProperty(key) && key !== "parent") {
                if (Array.isArray(node2[key])) {
                  node2[key].forEach(replaceReferences);
                } else if (typeof node2[key] === "object") {
                  replaceReferences(node2[key]);
                }
              }
            }
          };
          functionBody.body.forEach(replaceReferences);
          functionBody.body.unshift(...copyStatements);
          const returnObj = {
            type: "ObjectExpression",
            properties: Array.from(varsToReturn).map((varName) => ({
              type: "Property",
              key: { type: "Identifier", name: varName },
              value: { type: "Identifier", name: tempVarMap.get(varName) },
              kind: "init",
              computed: false,
              shorthand: false
            }))
          };
          functionBody.body.push({
            type: "ReturnStatement",
            argument: returnObj
          });
        }
      };
      addCopyingAndReturn(bodyFunction.body, assignedVars);
      const blockVar = `__block_${blockVarCounter++}`;
      const statements = [];
      const initialVarsProperties = [];
      for (const varName of assignedVars) {
        initialVarsProperties.push({
          type: "Property",
          key: { type: "Identifier", name: varName },
          value: {
            type: "CallExpression",
            callee: {
              type: "Identifier",
              name: "__p5.strandsNode"
            },
            arguments: [
              { type: "Identifier", name: varName }
            ]
          },
          kind: "init",
          method: false,
          shorthand: false,
          computed: false
        });
      }
      const initialVarsObject = {
        type: "ObjectExpression",
        properties: initialVarsProperties
      };
      const callExpression = {
        type: "CallExpression",
        callee: {
          type: "Identifier",
          name: "__p5.strandsFor"
        },
        arguments: [initialFunction, conditionFunction, updateFunction, bodyFunction, initialVarsObject]
      };
      statements.push({
        type: "VariableDeclaration",
        declarations: [{
          type: "VariableDeclarator",
          id: { type: "Identifier", name: blockVar },
          init: callExpression
        }],
        kind: "const"
      });
      for (const varName of assignedVars) {
        statements.push({
          type: "ExpressionStatement",
          expression: {
            type: "AssignmentExpression",
            operator: "=",
            left: { type: "Identifier", name: varName },
            right: {
              type: "MemberExpression",
              object: { type: "Identifier", name: blockVar },
              property: { type: "Identifier", name: varName },
              computed: false
            }
          }
        });
      }
      node.type = "BlockStatement";
      node.body = statements;
    } else {
      node.type = "ExpressionStatement";
      node.expression = {
        type: "CallExpression",
        callee: {
          type: "Identifier",
          name: "__p5.strandsFor"
        },
        arguments: [initialFunction, conditionFunction, updateFunction, bodyFunction, {
          type: "ObjectExpression",
          properties: []
        }]
      };
    }
    delete node.init;
    delete node.test;
    delete node.update;
  },
  replaceIdentifierReferences(node, oldName, newName) {
    if (!node || typeof node !== "object")
      return node;
    const replaceInNode = (n2) => {
      if (!n2 || typeof n2 !== "object")
        return n2;
      if (n2.type === "Identifier" && n2.name === oldName) {
        return { ...n2, name: newName };
      }
      const newNode = { ...n2 };
      for (const key in n2) {
        if (n2.hasOwnProperty(key) && key !== "parent") {
          if (Array.isArray(n2[key])) {
            newNode[key] = n2[key].map(replaceInNode);
          } else if (typeof n2[key] === "object") {
            newNode[key] = replaceInNode(n2[key]);
          }
        }
      }
      return newNode;
    };
    return replaceInNode(node);
  }
};
function transpileStrandsToJS(p53, sourceString, srcLocations, scope) {
  const ast = parse9(sourceString, {
    ecmaVersion: 2021,
    locations: srcLocations
  });
  const nonControlFlowCallbacks = { ...ASTCallbacks };
  delete nonControlFlowCallbacks.IfStatement;
  delete nonControlFlowCallbacks.ForStatement;
  ancestor(ast, nonControlFlowCallbacks, undefined, { varyings: {} });
  const postOrderControlFlowTransform = {
    IfStatement(node, state, c) {
      if (node.test)
        c(node.test, state);
      if (node.consequent)
        c(node.consequent, state);
      if (node.alternate)
        c(node.alternate, state);
      ASTCallbacks.IfStatement(node, state, []);
    },
    ForStatement(node, state, c) {
      if (node.init)
        c(node.init, state);
      if (node.test)
        c(node.test, state);
      if (node.update)
        c(node.update, state);
      if (node.body)
        c(node.body, state);
      ASTCallbacks.ForStatement(node, state, []);
    }
  };
  recursive(ast, { varyings: {} }, postOrderControlFlowTransform);
  const transpiledSource = import_escodegen.default.generate(ast);
  const scopeKeys = Object.keys(scope);
  const internalStrandsCallback = new Function("__p5", ...scopeKeys, transpiledSource.slice(transpiledSource.indexOf("{") + 1, transpiledSource.lastIndexOf("}")).replaceAll(";", ""));
  return () => internalStrandsCallback(p53, ...scopeKeys.map((key) => scope[key]));
}

// node_modules/p5/dist/strands/ir_cfg.js
function createControlFlowGraph() {
  return {
    blockTypes: [],
    incomingEdges: [],
    outgoingEdges: [],
    blockInstructions: [],
    nextID: 0,
    blockStack: [],
    blockOrder: [],
    blockConditions: {},
    currentBlock: -1
  };
}
function pushBlock(graph, blockID) {
  graph.blockStack.push(blockID);
  graph.blockOrder.push(blockID);
  graph.currentBlock = blockID;
}
function popBlock(graph) {
  graph.blockStack.pop();
  const len = graph.blockStack.length;
  graph.currentBlock = graph.blockStack[len - 1];
}
function pushBlockForModification(graph, blockID) {
  graph.blockStack.push(blockID);
  graph.currentBlock = blockID;
}
function createBasicBlock(graph, blockType) {
  const id = graph.nextID++;
  graph.blockTypes[id] = blockType;
  graph.incomingEdges[id] = [];
  graph.outgoingEdges[id] = [];
  graph.blockInstructions[id] = [];
  return id;
}
function addEdge(graph, from, to2) {
  graph.outgoingEdges[from].push(to2);
  graph.incomingEdges[to2].push(from);
}
function recordInBasicBlock(graph, blockID, nodeID) {
  if (nodeID === undefined) {
    internalError("undefined nodeID in `recordInBasicBlock()`");
  }
  if (blockID === undefined) {
    internalError("undefined blockID in `recordInBasicBlock()");
  }
  graph.blockInstructions[blockID] = graph.blockInstructions[blockID] || [];
  graph.blockInstructions[blockID].push(nodeID);
}
function sortCFG(adjacencyList, start) {
  const visited = new Set;
  const postOrder = [];
  function dfs(v) {
    if (visited.has(v)) {
      return;
    }
    visited.add(v);
    for (let w of adjacencyList[v].sort((a, b2) => b2 - a) || []) {
      dfs(w);
    }
    postOrder.push(v);
  }
  dfs(start);
  return postOrder.reverse();
}

// node_modules/p5/dist/strands/strands_codegen.js
function generateShaderCode(strandsContext) {
  const {
    cfg,
    backend,
    vertexDeclarations,
    fragmentDeclarations
  } = strandsContext;
  const hooksObj = {
    uniforms: {}
  };
  for (const { name, typeInfo, defaultValue } of strandsContext.uniforms) {
    const declaration = backend.generateUniformDeclaration(name, typeInfo);
    hooksObj.uniforms[declaration] = defaultValue;
  }
  for (const { hookType, rootNodeID, entryBlockID, shaderContext } of strandsContext.hooks) {
    const generationContext = {
      indent: 1,
      codeLines: [],
      write(line) {
        this.codeLines.push("  ".repeat(this.indent) + line);
      },
      tempNames: {},
      declarations: [],
      nextTempID: 0,
      visitedNodes: new Set,
      shaderContext,
      strandsContext
    };
    const blocks = sortCFG(cfg.outgoingEdges, entryBlockID);
    for (const blockID of blocks) {
      backend.generateBlock(blockID, strandsContext, generationContext);
    }
    for (const assignmentNodeID of strandsContext.globalAssignments) {
      if (!generationContext.visitedNodes.has(assignmentNodeID)) {
        backend.generateAssignment(generationContext, strandsContext.dag, assignmentNodeID);
        generationContext.visitedNodes.add(assignmentNodeID);
      }
    }
    strandsContext.globalAssignments = [];
    const firstLine = backend.hookEntry(hookType);
    let returnType = hookType.returnType.properties ? structType(hookType.returnType) : TypeInfoFromGLSLName[hookType.returnType.typeName];
    backend.generateReturnStatement(strandsContext, generationContext, rootNodeID, returnType);
    hooksObj[`${hookType.returnType.typeName} ${hookType.name}`] = [firstLine, ...generationContext.codeLines, "}"].join(`
`);
  }
  if (strandsContext.sharedVariables) {
    for (const [varName, varInfo] of strandsContext.sharedVariables) {
      if (varInfo.usedInVertex && varInfo.usedInFragment) {
        vertexDeclarations.add(`OUT ${varInfo.typeInfo.fnName} ${varName};`);
        fragmentDeclarations.add(`IN ${varInfo.typeInfo.fnName} ${varName};`);
      } else if (varInfo.usedInVertex) {
        vertexDeclarations.add(`${varInfo.typeInfo.fnName} ${varName};`);
      } else if (varInfo.usedInFragment) {
        fragmentDeclarations.add(`${varInfo.typeInfo.fnName} ${varName};`);
      }
    }
  }
  hooksObj.vertexDeclarations = [...vertexDeclarations].join(`
`);
  hooksObj.fragmentDeclarations = [...fragmentDeclarations].join(`
`);
  return hooksObj;
}

// node_modules/p5/dist/strands/strands_builtins.js
var builtInGLSLFunctions = {
  acos: [{ params: [GenType.FLOAT], returnType: GenType.FLOAT, isp5Function: true }],
  acosh: [{ params: [GenType.FLOAT], returnType: GenType.FLOAT, isp5Function: false }],
  asin: [{ params: [GenType.FLOAT], returnType: GenType.FLOAT, isp5Function: true }],
  asinh: [{ params: [GenType.FLOAT], returnType: GenType.FLOAT, isp5Function: false }],
  atan: [
    { params: [GenType.FLOAT], returnType: GenType.FLOAT, isp5Function: true },
    { params: [GenType.FLOAT, GenType.FLOAT], returnType: GenType.FLOAT, isp5Function: true }
  ],
  atanh: [{ params: [GenType.FLOAT], returnType: GenType.FLOAT, isp5Function: false }],
  cos: [{ params: [GenType.FLOAT], returnType: GenType.FLOAT, isp5Function: true }],
  cosh: [{ params: [GenType.FLOAT], returnType: GenType.FLOAT, isp5Function: false }],
  degrees: [{ params: [GenType.FLOAT], returnType: GenType.FLOAT, isp5Function: true }],
  radians: [{ params: [GenType.FLOAT], returnType: GenType.FLOAT, isp5Function: true }],
  sin: [{ params: [GenType.FLOAT], returnType: GenType.FLOAT, isp5Function: true }],
  sinh: [{ params: [GenType.FLOAT], returnType: GenType.FLOAT, isp5Function: false }],
  tan: [{ params: [GenType.FLOAT], returnType: GenType.FLOAT, isp5Function: true }],
  tanh: [{ params: [GenType.FLOAT], returnType: GenType.FLOAT, isp5Function: false }],
  abs: [
    { params: [GenType.FLOAT], returnType: GenType.FLOAT, isp5Function: true },
    { params: [GenType.FLOAT], returnType: GenType.INT, isp5Function: true }
  ],
  ceil: [{ params: [GenType.FLOAT], returnType: GenType.FLOAT, isp5Function: true }],
  clamp: [
    { params: [GenType.FLOAT, GenType.FLOAT, GenType.FLOAT], returnType: GenType.FLOAT, isp5Function: false },
    { params: [GenType.FLOAT, DataType.float1, DataType.float1], returnType: GenType.FLOAT, isp5Function: false },
    { params: [GenType.INT, GenType.INT, GenType.INT], returnType: GenType.INT, isp5Function: false },
    { params: [GenType.INT, DataType.int1, DataType.int1], returnType: GenType.INT, isp5Function: false }
  ],
  dFdx: [{ params: [GenType.FLOAT], returnType: GenType.FLOAT, isp5Function: false }],
  dFdy: [{ params: [GenType.FLOAT], returnType: GenType.FLOAT, isp5Function: false }],
  exp: [{ params: [GenType.FLOAT], returnType: GenType.FLOAT, isp5Function: true }],
  exp2: [{ params: [GenType.FLOAT], returnType: GenType.FLOAT, isp5Function: false }],
  floor: [{ params: [GenType.FLOAT], returnType: GenType.FLOAT, isp5Function: true }],
  fma: [{ params: [GenType.FLOAT, GenType.FLOAT, GenType.FLOAT], returnType: GenType.FLOAT, isp5Function: false }],
  fract: [{ params: [GenType.FLOAT], returnType: GenType.FLOAT, isp5Function: true }],
  fwidth: [{ params: [GenType.FLOAT], returnType: GenType.FLOAT, isp5Function: false }],
  inversesqrt: [{ params: [GenType.FLOAT], returnType: GenType.FLOAT, isp5Function: true }],
  log: [{ params: [GenType.FLOAT], returnType: GenType.FLOAT, isp5Function: true }],
  log2: [{ params: [GenType.FLOAT], returnType: GenType.FLOAT, isp5Function: false }],
  max: [
    { params: [GenType.FLOAT, GenType.FLOAT], returnType: GenType.FLOAT, isp5Function: true },
    { params: [GenType.FLOAT, DataType.float1], returnType: GenType.FLOAT, isp5Function: true },
    { params: [GenType.INT, GenType.INT], returnType: GenType.INT, isp5Function: true },
    { params: [GenType.INT, DataType.int1], returnType: GenType.INT, isp5Function: true }
  ],
  min: [
    { params: [GenType.FLOAT, GenType.FLOAT], returnType: GenType.FLOAT, isp5Function: true },
    { params: [GenType.FLOAT, DataType.float1], returnType: GenType.FLOAT, isp5Function: true },
    { params: [GenType.INT, GenType.INT], returnType: GenType.INT, isp5Function: true },
    { params: [GenType.INT, DataType.int1], returnType: GenType.INT, isp5Function: true }
  ],
  mix: [
    { params: [GenType.FLOAT, GenType.FLOAT, GenType.FLOAT], returnType: GenType.FLOAT, isp5Function: false },
    { params: [GenType.FLOAT, GenType.FLOAT, DataType.float1], returnType: GenType.FLOAT, isp5Function: false },
    { params: [GenType.FLOAT, GenType.FLOAT, GenType.BOOL], returnType: GenType.FLOAT, isp5Function: false }
  ],
  mod: [
    { params: [GenType.FLOAT, GenType.FLOAT], returnType: GenType.FLOAT, isp5Function: true },
    { params: [GenType.FLOAT, DataType.float1], returnType: GenType.FLOAT, isp5Function: true }
  ],
  pow: [{ params: [GenType.FLOAT, GenType.FLOAT], returnType: GenType.FLOAT, isp5Function: true }],
  round: [{ params: [GenType.FLOAT], returnType: GenType.FLOAT, isp5Function: true }],
  roundEven: [{ params: [GenType.FLOAT], returnType: GenType.FLOAT, isp5Function: false }],
  sign: [
    { params: [GenType.FLOAT], returnType: GenType.FLOAT, isp5Function: false },
    { params: [GenType.INT], returnType: GenType.INT, isp5Function: false }
  ],
  smoothstep: [
    { params: [GenType.FLOAT, GenType.FLOAT, GenType.FLOAT], returnType: GenType.FLOAT, isp5Function: false },
    { params: [DataType.float1, DataType.float1, GenType.FLOAT], returnType: GenType.FLOAT, isp5Function: false }
  ],
  sqrt: [{ params: [GenType.FLOAT], returnType: GenType.FLOAT, isp5Function: true }],
  step: [{ params: [GenType.FLOAT, GenType.FLOAT], returnType: GenType.FLOAT, isp5Function: false }],
  trunc: [{ params: [GenType.FLOAT], returnType: GenType.FLOAT, isp5Function: false }],
  cross: [{ params: [DataType.float3, DataType.float3], returnType: DataType.float3, isp5Function: true }],
  distance: [{ params: [GenType.FLOAT, GenType.FLOAT], returnType: DataType.float1, isp5Function: true }],
  dot: [{ params: [GenType.FLOAT, GenType.FLOAT], returnType: DataType.float1, isp5Function: true }],
  equal: [
    { params: [GenType.FLOAT, GenType.FLOAT], returnType: GenType.BOOL, isp5Function: false },
    { params: [GenType.INT, GenType.INT], returnType: GenType.BOOL, isp5Function: false },
    { params: [GenType.BOOL, GenType.BOOL], returnType: GenType.BOOL, isp5Function: false }
  ],
  faceforward: [{ params: [GenType.FLOAT, GenType.FLOAT, GenType.FLOAT], returnType: GenType.FLOAT, isp5Function: false }],
  length: [{ params: [GenType.FLOAT], returnType: DataType.float1, isp5Function: false }],
  normalize: [{ params: [GenType.FLOAT], returnType: GenType.FLOAT, isp5Function: true }],
  notEqual: [
    { params: [GenType.FLOAT, GenType.FLOAT], returnType: GenType.BOOL, isp5Function: false },
    { params: [GenType.INT, GenType.INT], returnType: GenType.BOOL, isp5Function: false },
    { params: [GenType.BOOL, GenType.BOOL], returnType: GenType.BOOL, isp5Function: false }
  ],
  reflect: [{ params: [GenType.FLOAT, GenType.FLOAT], returnType: GenType.FLOAT, isp5Function: false }],
  refract: [{ params: [GenType.FLOAT, GenType.FLOAT, DataType.float1], returnType: GenType.FLOAT, isp5Function: false }],
  texture: [{ params: [DataType.sampler2D, DataType.float2], returnType: DataType.float4, isp5Function: true }],
  getTexture: [{ params: [DataType.sampler2D, DataType.float2], returnType: DataType.float4, isp5Function: true }]
};
var strandsBuiltinFunctions = {
  ...builtInGLSLFunctions
};

// node_modules/p5/dist/ir_builders-CWOp5cp1.js
class StrandsNode {
  constructor(id, dimension, strandsContext) {
    this.id = id;
    this.strandsContext = strandsContext;
    this.dimension = dimension;
    const dag = this.strandsContext.dag;
    const nodeData = getNodeDataFromID(dag, this.id);
    if (nodeData && nodeData.identifier) {
      this._originalIdentifier = nodeData.identifier;
      this._originalBaseType = nodeData.baseType;
      this._originalDimension = nodeData.dimension;
    }
  }
  copy() {
    return createStrandsNode(this.id, this.dimension, this.strandsContext);
  }
  bridge(value) {
    const { dag, cfg } = this.strandsContext;
    const orig = getNodeDataFromID(dag, this.id);
    const baseType = orig?.baseType ?? BaseType.FLOAT;
    let newValueID;
    if (value instanceof StrandsNode) {
      newValueID = value.id;
    } else {
      const newVal = primitiveConstructorNode(this.strandsContext, { baseType, dimension: this.dimension }, value);
      newValueID = newVal.id;
    }
    if (this._originalIdentifier) {
      const { id: targetVarID } = variableNode(this.strandsContext, { baseType: this._originalBaseType, dimension: this._originalDimension }, this._originalIdentifier);
      const assignmentNode = createNodeData({
        nodeType: NodeType.ASSIGNMENT,
        dependsOn: [targetVarID, newValueID],
        phiBlocks: []
      });
      const assignmentID = getOrCreateNode(dag, assignmentNode);
      recordInBasicBlock(cfg, cfg.currentBlock, assignmentID);
      this.strandsContext.globalAssignments.push(assignmentID);
      const variableNodeData = createNodeData({
        nodeType: NodeType.VARIABLE,
        baseType: this._originalBaseType,
        dimension: this._originalDimension,
        identifier: this._originalIdentifier
      });
      const variableID = getOrCreateNode(dag, variableNodeData);
      this.id = variableID;
    } else {
      this.id = newValueID;
    }
    return this;
  }
  bridgeSwizzle(swizzlePattern, value) {
    const { dag, cfg } = this.strandsContext;
    const orig = getNodeDataFromID(dag, this.id);
    const baseType = orig?.baseType ?? BaseType.FLOAT;
    let newValueID;
    if (value instanceof StrandsNode) {
      newValueID = value.id;
    } else {
      const newVal = primitiveConstructorNode(this.strandsContext, { baseType, dimension: this.dimension }, value);
      newValueID = newVal.id;
    }
    if (this._originalIdentifier) {
      const { id: targetVarID } = variableNode(this.strandsContext, { baseType: this._originalBaseType, dimension: this._originalDimension }, this._originalIdentifier);
      const swizzleNode = createNodeData({
        nodeType: NodeType.OPERATION,
        opCode: OpCode.Unary.SWIZZLE,
        baseType: this._originalBaseType,
        dimension: swizzlePattern.length,
        swizzle: swizzlePattern,
        dependsOn: [targetVarID]
      });
      const swizzleID = getOrCreateNode(dag, swizzleNode);
      const assignmentNode = createNodeData({
        nodeType: NodeType.ASSIGNMENT,
        dependsOn: [swizzleID, newValueID],
        phiBlocks: []
      });
      const assignmentID = getOrCreateNode(dag, assignmentNode);
      recordInBasicBlock(cfg, cfg.currentBlock, assignmentID);
      this.strandsContext.globalAssignments.push(assignmentID);
      const variableNodeData = createNodeData({
        nodeType: NodeType.VARIABLE,
        baseType: this._originalBaseType,
        dimension: this._originalDimension,
        identifier: this._originalIdentifier
      });
      const variableID = getOrCreateNode(dag, variableNodeData);
      this.id = variableID;
    } else {
      this.id = newValueID;
    }
    return this;
  }
  getValue() {
    if (this._originalIdentifier) {
      const { id, dimension } = variableNode(this.strandsContext, { baseType: this._originalBaseType, dimension: this._originalDimension }, this._originalIdentifier);
      return createStrandsNode(id, dimension, this.strandsContext);
    }
    return this;
  }
}
function createStrandsNode(id, dimension, strandsContext, onRebind) {
  return new Proxy(new StrandsNode(id, dimension, strandsContext), swizzleTrap(id, dimension, strandsContext, onRebind));
}
function scalarLiteralNode(strandsContext, typeInfo, value) {
  const { cfg, dag } = strandsContext;
  let { dimension, baseType } = typeInfo;
  if (dimension !== 1) {
    internalError("Created a scalar literal node with dimension > 1.");
  }
  const nodeData = createNodeData({
    nodeType: NodeType.LITERAL,
    dimension,
    baseType,
    value
  });
  const id = getOrCreateNode(dag, nodeData);
  recordInBasicBlock(cfg, cfg.currentBlock, id);
  return { id, dimension };
}
function variableNode(strandsContext, typeInfo, identifier) {
  const { cfg, dag } = strandsContext;
  const { dimension, baseType } = typeInfo;
  const nodeData = createNodeData({
    nodeType: NodeType.VARIABLE,
    dimension,
    baseType,
    identifier
  });
  const id = getOrCreateNode(dag, nodeData);
  recordInBasicBlock(cfg, cfg.currentBlock, id);
  return { id, dimension };
}
function unaryOpNode(strandsContext, nodeOrValue, opCode) {
  const { dag, cfg } = strandsContext;
  let dependsOn;
  let node;
  if (nodeOrValue instanceof StrandsNode) {
    node = nodeOrValue;
  } else {
    const { id: id2, dimension } = primitiveConstructorNode(strandsContext, { baseType: BaseType.FLOAT, dimension: null }, nodeOrValue);
    node = createStrandsNode(id2, dimension, strandsContext);
  }
  dependsOn = [node.id];
  const nodeData = createNodeData({
    nodeType: NodeType.OPERATION,
    opCode,
    dependsOn,
    baseType: dag.baseTypes[node.id],
    dimension: node.dimension
  });
  const id = getOrCreateNode(dag, nodeData);
  recordInBasicBlock(cfg, cfg.currentBlock, id);
  return { id, dimension: node.dimension };
}
function binaryOpNode(strandsContext, leftStrandsNode, rightArg, opCode) {
  const { dag, cfg } = strandsContext;
  let rightStrandsNode;
  if (rightArg[0] instanceof StrandsNode && rightArg.length === 1) {
    rightStrandsNode = rightArg[0];
  } else {
    const { id: id2, dimension } = primitiveConstructorNode(strandsContext, { baseType: BaseType.FLOAT, dimension: null }, rightArg);
    rightStrandsNode = createStrandsNode(id2, dimension, strandsContext);
  }
  let finalLeftNodeID = leftStrandsNode.id;
  let finalRightNodeID = rightStrandsNode.id;
  const leftType = extractNodeTypeInfo(dag, leftStrandsNode.id);
  const rightType = extractNodeTypeInfo(dag, rightStrandsNode.id);
  const cast = { node: null, toType: leftType };
  const bothDeferred = leftType.baseType === rightType.baseType && leftType.baseType === BaseType.DEFER;
  if (bothDeferred) {
    cast.toType.baseType = BaseType.FLOAT;
    if (leftType.dimension === rightType.dimension) {
      cast.toType.dimension = leftType.dimension;
    } else if (leftType.dimension === 1 && rightType.dimension > 1) {
      cast.toType.dimension = rightType.dimension;
    } else if (rightType.dimension === 1 && leftType.dimension > 1) {
      cast.toType.dimension = leftType.dimension;
    } else {
      userError("type error", `You have tried to perform a binary operation:
` + `${leftType.baseType + leftType.dimension} ${OpCodeToSymbol[opCode]} ${rightType.baseType + rightType.dimension}
` + `It's only possible to operate on two nodes with the same dimension, or a scalar value and a vector.`);
    }
    const l = primitiveConstructorNode(strandsContext, cast.toType, leftStrandsNode);
    const r = primitiveConstructorNode(strandsContext, cast.toType, rightStrandsNode);
    finalLeftNodeID = l.id;
    finalRightNodeID = r.id;
  } else if (leftType.baseType !== rightType.baseType || leftType.dimension !== rightType.dimension) {
    if (leftType.dimension === 1 && rightType.dimension > 1) {
      cast.node = leftStrandsNode;
      cast.toType = rightType;
    } else if (rightType.dimension === 1 && leftType.dimension > 1) {
      cast.node = rightStrandsNode;
      cast.toType = leftType;
    } else if (leftType.priority > rightType.priority) {
      cast.node = rightStrandsNode;
      cast.toType = leftType;
    } else if (rightType.priority > leftType.priority) {
      cast.node = leftStrandsNode;
      cast.toType = rightType;
    } else {
      userError("type error", `A vector of length ${leftType.dimension} operated with a vector of length ${rightType.dimension} is not allowed.`);
    }
    const casted = primitiveConstructorNode(strandsContext, cast.toType, cast.node);
    if (cast.node === leftStrandsNode) {
      leftStrandsNode = createStrandsNode(casted.id, casted.dimension, strandsContext);
      finalLeftNodeID = leftStrandsNode.id;
    } else {
      rightStrandsNode = createStrandsNode(casted.id, casted.dimension, strandsContext);
      finalRightNodeID = rightStrandsNode.id;
    }
  }
  const nodeData = createNodeData({
    nodeType: NodeType.OPERATION,
    opCode,
    dependsOn: [finalLeftNodeID, finalRightNodeID],
    baseType: cast.toType.baseType,
    dimension: cast.toType.dimension
  });
  const id = getOrCreateNode(dag, nodeData);
  recordInBasicBlock(cfg, cfg.currentBlock, id);
  return { id, dimension: nodeData.dimension };
}
function structInstanceNode(strandsContext, structTypeInfo, identifier, dependsOn) {
  const { cfg, dag } = strandsContext;
  if (dependsOn.length === 0) {
    for (const prop of structTypeInfo.properties) {
      const typeInfo = prop.dataType;
      const nodeData2 = createNodeData({
        nodeType: NodeType.VARIABLE,
        baseType: typeInfo.baseType,
        dimension: typeInfo.dimension,
        identifier: `${identifier}.${prop.name}`
      });
      const componentID = getOrCreateNode(dag, nodeData2);
      recordInBasicBlock(cfg, cfg.currentBlock, componentID);
      dependsOn.push(componentID);
    }
  }
  const nodeData = createNodeData({
    nodeType: NodeType.VARIABLE,
    dimension: structTypeInfo.properties.length,
    baseType: structTypeInfo.typeName,
    identifier,
    dependsOn
  });
  const structID = getOrCreateNode(dag, nodeData);
  recordInBasicBlock(cfg, cfg.currentBlock, structID);
  return { id: structID, dimension: 0, components: dependsOn };
}
function mapPrimitiveDepsToIDs(strandsContext, typeInfo, dependsOn) {
  const inputs = Array.isArray(dependsOn) ? dependsOn : [dependsOn];
  const mappedDependencies = [];
  let { dimension, baseType } = typeInfo;
  const dag = strandsContext.dag;
  let calculatedDimensions = 0;
  let originalNodeID = null;
  for (const dep of inputs.flat(Infinity)) {
    if (dep instanceof StrandsNode) {
      const node = getNodeDataFromID(dag, dep.id);
      originalNodeID = dep.id;
      baseType = node.baseType;
      if (node.opCode === OpCode.Nary.CONSTRUCTOR) {
        for (const inner of node.dependsOn) {
          mappedDependencies.push(inner);
        }
      } else {
        mappedDependencies.push(dep.id);
      }
      calculatedDimensions += node.dimension;
      continue;
    } else if (typeof dep === "number") {
      const { id, dimension: dimension2 } = scalarLiteralNode(strandsContext, { dimension: 1, baseType }, dep);
      mappedDependencies.push(id);
      calculatedDimensions += dimension2;
      continue;
    } else {
      userError("type error", `You've tried to construct a scalar or vector type with a non-numeric value: ${dep}`);
    }
  }
  if (dimension === null) {
    dimension = calculatedDimensions;
  } else if (dimension > calculatedDimensions && calculatedDimensions === 1) {
    calculatedDimensions = dimension;
  } else if (calculatedDimensions !== 1 && calculatedDimensions !== dimension) {
    userError("type error", `You've tried to construct a ${baseType + dimension} with ${calculatedDimensions} components`);
  }
  const inferredTypeInfo = {
    dimension,
    baseType,
    priority: BasePriority[baseType]
  };
  return { originalNodeID, mappedDependencies, inferredTypeInfo };
}
function constructTypeFromIDs(strandsContext, typeInfo, strandsNodesArray) {
  const nodeData = createNodeData({
    nodeType: NodeType.OPERATION,
    opCode: OpCode.Nary.CONSTRUCTOR,
    dimension: typeInfo.dimension,
    baseType: typeInfo.baseType,
    dependsOn: strandsNodesArray
  });
  const id = getOrCreateNode(strandsContext.dag, nodeData);
  return id;
}
function primitiveConstructorNode(strandsContext, typeInfo, dependsOn) {
  const cfg = strandsContext.cfg;
  const { mappedDependencies, inferredTypeInfo } = mapPrimitiveDepsToIDs(strandsContext, typeInfo, dependsOn);
  const finalType = {
    baseType: typeInfo.baseType,
    dimension: inferredTypeInfo.dimension
  };
  const id = constructTypeFromIDs(strandsContext, finalType, mappedDependencies);
  if (typeInfo.baseType !== BaseType.DEFER) {
    recordInBasicBlock(cfg, cfg.currentBlock, id);
  }
  return { id, dimension: finalType.dimension, components: mappedDependencies };
}
function structConstructorNode(strandsContext, structTypeInfo, rawUserArgs) {
  const { cfg, dag } = strandsContext;
  const { identifer, properties } = structTypeInfo;
  if (!(rawUserArgs.length === properties.length)) {
    userError("type error", `You've tried to construct a ${structTypeInfo.typeName} struct with ${rawUserArgs.length} properties, but it expects ${properties.length} properties.
` + `The properties it expects are:
` + `${properties.map((prop) => prop.name + " " + prop.DataType.baseType + prop.DataType.dimension)}`);
  }
  const dependsOn = [];
  for (let i2 = 0;i2 < properties.length; i2++) {
    const expectedProperty = properties[i2];
    const { originalNodeID, mappedDependencies } = mapPrimitiveDepsToIDs(strandsContext, expectedProperty.dataType, rawUserArgs[i2]);
    if (originalNodeID) {
      dependsOn.push(originalNodeID);
    } else {
      dependsOn.push(constructTypeFromIDs(strandsContext, expectedProperty.dataType, mappedDependencies));
    }
  }
  const nodeData = createNodeData({
    nodeType: NodeType.OPERATION,
    opCode: OpCode.Nary.CONSTRUCTOR,
    dimension: properties.length,
    baseType: structTypeInfo.typeName,
    dependsOn
  });
  const id = getOrCreateNode(dag, nodeData);
  recordInBasicBlock(cfg, cfg.currentBlock, id);
  return { id, dimension: properties.length, components: structTypeInfo.components };
}
function functionCallNode(strandsContext, functionName, rawUserArgs, { overloads: rawOverloads } = {}) {
  const { cfg, dag } = strandsContext;
  const overloads = rawOverloads || strandsBuiltinFunctions[functionName];
  const preprocessedArgs = rawUserArgs.map((rawUserArg) => mapPrimitiveDepsToIDs(strandsContext, DataType.defer, rawUserArg));
  const matchingArgsCounts = overloads.filter((overload) => overload.params.length === preprocessedArgs.length);
  if (matchingArgsCounts.length === 0) {
    const argsLengthSet = new Set;
    const argsLengthArr = [];
    overloads.forEach((overload) => argsLengthSet.add(overload.params.length));
    argsLengthSet.forEach((len) => argsLengthArr.push(`${len}`));
    const argsLengthStr = argsLengthArr.join(", or ");
    userError("parameter validation error", `Function '${functionName}' has ${overloads.length} variants which expect ${argsLengthStr} arguments, but ${preprocessedArgs.length} arguments were provided.`);
  }
  const isGeneric = (T) => T.dimension === null;
  let bestOverload = null;
  let bestScore = 0;
  let inferredReturnType = null;
  let inferredDimension = null;
  for (const overload of matchingArgsCounts) {
    let isValid = true;
    let similarity = 0;
    for (let i2 = 0;i2 < preprocessedArgs.length; i2++) {
      const preArg = preprocessedArgs[i2];
      const argType = preArg.inferredTypeInfo;
      const expectedType = overload.params[i2];
      let dimension = expectedType.dimension;
      if (isGeneric(expectedType)) {
        if (inferredDimension === null || inferredDimension === 1) {
          inferredDimension = argType.dimension;
        }
        if (inferredDimension !== argType.dimension && !(argType.dimension === 1 && inferredDimension >= 1)) {
          isValid = false;
        }
        dimension = inferredDimension;
      } else {
        if (argType.dimension > dimension) {
          isValid = false;
        }
      }
      if (argType.baseType === expectedType.baseType) {
        similarity += 2;
      } else if (expectedType.priority > argType.priority) {
        similarity += 1;
      }
    }
    if (isValid && (!bestOverload || similarity > bestScore)) {
      bestOverload = overload;
      bestScore = similarity;
      inferredReturnType = { ...overload.returnType };
      if (isGeneric(inferredReturnType)) {
        inferredReturnType.dimension = inferredDimension;
      }
    }
  }
  if (bestOverload === null) {
    userError("parameter validation", `No matching overload for ${functionName} was found!`);
  }
  let dependsOn = [];
  for (let i2 = 0;i2 < bestOverload.params.length; i2++) {
    const arg = preprocessedArgs[i2];
    const paramType = { ...bestOverload.params[i2] };
    if (isGeneric(paramType)) {
      paramType.dimension = inferredDimension;
    }
    if (arg.originalNodeID && typeEquals(arg.inferredTypeInfo, paramType)) {
      dependsOn.push(arg.originalNodeID);
    } else {
      const castedArgID = constructTypeFromIDs(strandsContext, paramType, arg.mappedDependencies);
      recordInBasicBlock(cfg, cfg.currentBlock, castedArgID);
      dependsOn.push(castedArgID);
    }
  }
  const nodeData = createNodeData({
    nodeType: NodeType.OPERATION,
    opCode: OpCode.Nary.FUNCTION_CALL,
    identifier: functionName,
    dependsOn,
    baseType: inferredReturnType.baseType,
    dimension: inferredReturnType.dimension
  });
  const id = getOrCreateNode(dag, nodeData);
  recordInBasicBlock(cfg, cfg.currentBlock, id);
  return { id, dimension: inferredReturnType.dimension };
}
function statementNode(strandsContext, statementType) {
  const { dag, cfg } = strandsContext;
  const nodeData = createNodeData({
    nodeType: NodeType.STATEMENT,
    statementType
  });
  const id = getOrCreateNode(dag, nodeData);
  recordInBasicBlock(cfg, cfg.currentBlock, id);
  return id;
}
function swizzleNode(strandsContext, parentNode, swizzle) {
  const { dag, cfg } = strandsContext;
  const baseType = dag.baseTypes[parentNode.id];
  const nodeData = createNodeData({
    nodeType: NodeType.OPERATION,
    baseType,
    dimension: swizzle.length,
    opCode: OpCode.Unary.SWIZZLE,
    dependsOn: [parentNode.id],
    swizzle
  });
  const id = getOrCreateNode(dag, nodeData);
  recordInBasicBlock(cfg, cfg.currentBlock, id);
  return { id, dimension: swizzle.length };
}
function swizzleTrap(id, dimension, strandsContext, onRebind) {
  const swizzleSets = [
    ["x", "y", "z", "w"],
    ["r", "g", "b", "a"],
    ["s", "t", "p", "q"]
  ].map((s) => s.slice(0, dimension));
  const trap = {
    get(target, property, receiver) {
      if (property in target) {
        return Reflect.get(...arguments);
      } else {
        for (const set3 of swizzleSets) {
          if ([...property.toString()].every((char) => set3.includes(char))) {
            const swizzle = [...property].map((char) => {
              const index = set3.indexOf(char);
              return swizzleSets[0][index];
            }).join("");
            const node = swizzleNode(strandsContext, target, swizzle);
            return createStrandsNode(node.id, node.dimension, strandsContext);
          }
        }
      }
    },
    set(target, property, value, receiver) {
      for (const swizzleSet of swizzleSets) {
        const chars = [...property];
        const valid = chars.every((c) => swizzleSet.includes(c)) && new Set(chars).size === chars.length && target.dimension >= chars.length;
        if (!valid)
          continue;
        const dim = target.dimension;
        const lanes = new Array(dim);
        for (let i2 = 0;i2 < dim; i2++) {
          const { id: id2, dimension: dimension2 } = swizzleNode(strandsContext, target, "xyzw"[i2]);
          lanes[i2] = createStrandsNode(id2, dimension2, strandsContext);
        }
        let scalars = [];
        if (value instanceof StrandsNode) {
          if (value.dimension === 1) {
            scalars = Array(chars.length).fill(value);
          } else if (value.dimension === chars.length) {
            for (let k = 0;k < chars.length; k++) {
              const { id: id2, dimension: dimension2 } = swizzleNode(strandsContext, value, "xyzw"[k]);
              scalars.push(createStrandsNode(id2, dimension2, strandsContext));
            }
          } else {
            userError("type error", `Swizzle assignment: RHS vector does not match LHS vector (need ${chars.length}, got ${value.dimension}).`);
          }
        } else if (Array.isArray(value)) {
          const flat = value.flat(Infinity);
          if (flat.length === 1) {
            scalars = Array(chars.length).fill(flat[0]);
          } else if (flat.length === chars.length) {
            scalars = flat;
          } else {
            userError("type error", `Swizzle assignment: RHS length ${flat.length} does not match ${chars.length}.`);
          }
        } else if (typeof value === "number") {
          scalars = Array(chars.length).fill(value);
        } else {
          userError("type error", `Unsupported RHS for swizzle assignment: ${value}`);
        }
        for (let j = 0;j < chars.length; j++) {
          const canonicalIndex = swizzleSet.indexOf(chars[j]);
          lanes[canonicalIndex] = scalars[j];
        }
        const orig = getNodeDataFromID(strandsContext.dag, target.id);
        const baseType = orig?.baseType ?? BaseType.FLOAT;
        const { id: newID } = primitiveConstructorNode(strandsContext, { baseType, dimension: dim }, lanes);
        target.id = newID;
        if (typeof onRebind === "function") {
          onRebind(newID);
        }
        return true;
      }
      return Reflect.set(...arguments);
    }
  };
  return trap;
}

// node_modules/p5/dist/strands/strands_phi_utils.js
function createPhiNode(strandsContext, phiInputs, varName) {
  const validInputs = phiInputs.filter((input) => input.value.id !== null);
  if (validInputs.length === 0) {
    throw new Error(`No valid inputs for phi node for variable ${varName}`);
  }
  const firstInput = getNodeDataFromID(strandsContext.dag, validInputs[0].value.id);
  const dimension = firstInput.dimension;
  const baseType = firstInput.baseType;
  const nodeData = {
    nodeType: NodeType.PHI,
    dimension,
    baseType,
    dependsOn: phiInputs.map((input) => input.value.id).filter((id2) => id2 !== null),
    phiBlocks: phiInputs.map((input) => input.blockId)
  };
  const id = getOrCreateNode(strandsContext.dag, nodeData);
  recordInBasicBlock(strandsContext.cfg, strandsContext.cfg.currentBlock, id);
  return {
    id,
    dimension,
    baseType
  };
}

// node_modules/p5/dist/strands/strands_conditionals.js
class StrandsConditional {
  constructor(strandsContext, condition, branchCallback) {
    this.branches = [{
      condition,
      branchCallback,
      blockType: BlockType.IF_BODY
    }];
    this.ctx = strandsContext;
  }
  ElseIf(condition, branchCallback) {
    this.branches.push({
      condition,
      branchCallback,
      blockType: BlockType.IF_BODY
    });
    return this;
  }
  Else(branchCallback = () => ({})) {
    this.branches.push({
      condition: null,
      branchCallback,
      blockType: BlockType.IF_BODY
    });
    const phiNodes = buildConditional(this.ctx, this);
    const assignments = {};
    for (const [varName, phiNode] of Object.entries(phiNodes)) {
      assignments[varName] = createStrandsNode(phiNode.id, phiNode.dimension, this.ctx);
    }
    return assignments;
  }
}
function buildConditional(strandsContext, conditional) {
  const cfg = strandsContext.cfg;
  const branches = conditional.branches;
  const mergeBlock = createBasicBlock(cfg, BlockType.MERGE);
  const results = [];
  const branchEndBlocks = [];
  const mergedAssignments = {};
  const phiBlockDependencies = {};
  const branchBlock = createBasicBlock(cfg, BlockType.BRANCH);
  addEdge(cfg, cfg.currentBlock, branchBlock);
  addEdge(cfg, branchBlock, mergeBlock);
  let previousBlock = branchBlock;
  for (let i2 = 0;i2 < branches.length; i2++) {
    const { condition, branchCallback, blockType } = branches[i2];
    if (condition !== null) {
      const conditionBlock = createBasicBlock(cfg, BlockType.IF_COND);
      addEdge(cfg, previousBlock, conditionBlock);
      pushBlock(cfg, conditionBlock);
      cfg.blockConditions[conditionBlock] = condition.id;
      previousBlock = conditionBlock;
      popBlock(cfg);
    } else {
      const elseCondBlock = createBasicBlock(cfg, BlockType.ELSE_COND);
      addEdge(cfg, previousBlock, elseCondBlock);
      previousBlock = elseCondBlock;
    }
    const scopeStartBlock = createBasicBlock(cfg, BlockType.SCOPE_START);
    addEdge(cfg, previousBlock, scopeStartBlock);
    const branchContentBlock = createBasicBlock(cfg, blockType);
    addEdge(cfg, scopeStartBlock, branchContentBlock);
    pushBlock(cfg, branchContentBlock);
    const branchResults = branchCallback();
    for (const key in branchResults) {
      if (!phiBlockDependencies[key]) {
        phiBlockDependencies[key] = [{ value: branchResults[key], blockId: branchContentBlock }];
      } else {
        phiBlockDependencies[key].push({ value: branchResults[key], blockId: branchContentBlock });
      }
    }
    results.push(branchResults);
    const branchEndBlock = createBasicBlock(cfg, BlockType.DEFAULT);
    addEdge(cfg, cfg.currentBlock, branchEndBlock);
    branchEndBlocks.push(branchEndBlock);
    popBlock(cfg);
    const scopeEndBlock = createBasicBlock(cfg, BlockType.SCOPE_END);
    addEdge(cfg, branchEndBlock, scopeEndBlock);
    addEdge(cfg, scopeEndBlock, mergeBlock);
    previousBlock = scopeStartBlock;
  }
  pushBlockForModification(cfg, branchBlock);
  for (const key in phiBlockDependencies) {
    mergedAssignments[key] = createPhiNode(strandsContext, phiBlockDependencies[key], key);
  }
  popBlock(cfg);
  for (let i2 = 0;i2 < results.length; i2++) {
    const branchResult = results[i2];
    const branchEndBlockID = branchEndBlocks[i2];
    pushBlockForModification(cfg, branchEndBlockID);
    for (const key in branchResult) {
      if (mergedAssignments[key]) {
        const phiNodeID = mergedAssignments[key].id;
        const sourceNodeID = branchResult[key].id;
        const assignmentNode = {
          nodeType: NodeType.ASSIGNMENT,
          dependsOn: [phiNodeID, sourceNodeID],
          phiBlocks: []
        };
        const assignmentID = getOrCreateNode(strandsContext.dag, assignmentNode);
        recordInBasicBlock(cfg, branchEndBlockID, assignmentID);
      }
    }
    popBlock(cfg);
  }
  pushBlock(cfg, mergeBlock);
  return mergedAssignments;
}

// node_modules/p5/dist/strands/strands_for.js
class StrandsFor {
  constructor(strandsContext, initialCb, conditionCb, updateCb, bodyCb, initialVars) {
    this.strandsContext = strandsContext;
    this.initialCb = initialCb;
    this.conditionCb = conditionCb;
    this.updateCb = updateCb;
    this.bodyCb = bodyCb;
    this.initialVars = initialVars;
  }
  build() {
    const cfg = this.strandsContext.cfg;
    const mergeBlock = createBasicBlock(cfg, BlockType.MERGE);
    const branchBlock = createBasicBlock(cfg, BlockType.BRANCH);
    addEdge(cfg, cfg.currentBlock, branchBlock);
    addEdge(cfg, branchBlock, mergeBlock);
    const { initialVar, phiNode } = this.initializeLoopVariable(cfg, branchBlock);
    pushBlock(cfg, cfg.currentBlock);
    const loopVarNode = createStrandsNode(phiNode.id, phiNode.dimension, this.strandsContext);
    const conditionNode = this.conditionCb(loopVarNode);
    const updateResult = this.updateCb(loopVarNode);
    popBlock(cfg);
    const isBounded = this.loopIsBounded(initialVar, conditionNode, updateResult);
    if (isBounded) {
      this.buildBoundedLoop(cfg, branchBlock, mergeBlock, initialVar, phiNode, conditionNode, updateResult);
    } else {
      this.buildUnboundedLoop(cfg, branchBlock, mergeBlock, initialVar, phiNode, conditionNode, updateResult);
    }
    const finalPhiNodes = this.phiNodesForBody;
    pushBlockForModification(cfg, branchBlock);
    for (const [varName, resultNode] of Object.entries(this.bodyResults)) {
      if (varName !== "loopVar" && finalPhiNodes[varName]) {
        const phiNodeID = finalPhiNodes[varName].id;
        const phiNodeData = getNodeDataFromID(this.strandsContext.dag, phiNodeID);
        if (phiNodeData.dependsOn.length > 1) {
          phiNodeData.dependsOn[1] = resultNode.id;
        }
        if (phiNodeData.phiInputs && phiNodeData.phiInputs.length > 1) {
          phiNodeData.phiInputs[1].value = resultNode;
        }
      }
    }
    popBlock(cfg);
    pushBlockForModification(cfg, branchBlock);
    for (const [varName, initialValueNode] of Object.entries(this.initialVars)) {
      if (varName !== "loopVar" && finalPhiNodes[varName]) {
        const phiNodeID = finalPhiNodes[varName].id;
        const sourceNodeID = initialValueNode.id;
        const assignmentNode = createNodeData({
          nodeType: NodeType.ASSIGNMENT,
          dependsOn: [phiNodeID, sourceNodeID],
          phiBlocks: []
        });
        const assignmentID = getOrCreateNode(this.strandsContext.dag, assignmentNode);
        recordInBasicBlock(cfg, branchBlock, assignmentID);
      }
    }
    popBlock(cfg);
    pushBlockForModification(cfg, this.finalBodyBlock);
    for (const [varName, resultNode] of Object.entries(this.bodyResults)) {
      if (varName !== "loopVar" && finalPhiNodes[varName]) {
        const phiNodeID = finalPhiNodes[varName].id;
        const sourceNodeID = resultNode.id;
        const assignmentNode = createNodeData({
          nodeType: NodeType.ASSIGNMENT,
          dependsOn: [phiNodeID, sourceNodeID],
          phiBlocks: []
        });
        const assignmentID = getOrCreateNode(this.strandsContext.dag, assignmentNode);
        recordInBasicBlock(cfg, this.finalBodyBlock, assignmentID);
      }
    }
    popBlock(cfg);
    const finalBodyResults = {};
    for (const [varName, phiNode2] of Object.entries(finalPhiNodes)) {
      finalBodyResults[varName] = createStrandsNode(phiNode2.id, phiNode2.dimension, this.strandsContext);
    }
    pushBlock(cfg, mergeBlock);
    return finalBodyResults;
  }
  buildBoundedLoop(cfg, branchBlock, mergeBlock, initialVar, phiNode, conditionNode, updateResult) {
    const forBlock = createBasicBlock(cfg, BlockType.FOR);
    addEdge(cfg, branchBlock, forBlock);
    pushBlock(cfg, forBlock);
    if (initialVar) {
      const initAssignmentNode = createNodeData({
        nodeType: NodeType.ASSIGNMENT,
        dependsOn: [phiNode.id, initialVar.id],
        phiBlocks: []
      });
      const initAssignmentID = getOrCreateNode(this.strandsContext.dag, initAssignmentNode);
      recordInBasicBlock(cfg, forBlock, initAssignmentID);
    }
    const conditionStatementNode = createNodeData({
      nodeType: NodeType.STATEMENT,
      statementType: StatementType.EXPRESSION,
      dependsOn: [conditionNode.id],
      phiBlocks: []
    });
    const conditionStatementID = getOrCreateNode(this.strandsContext.dag, conditionStatementNode);
    recordInBasicBlock(cfg, forBlock, conditionStatementID);
    const updateAssignmentNode = createNodeData({
      nodeType: NodeType.ASSIGNMENT,
      dependsOn: [phiNode.id, updateResult.id],
      phiBlocks: []
    });
    const updateAssignmentID = getOrCreateNode(this.strandsContext.dag, updateAssignmentNode);
    recordInBasicBlock(cfg, forBlock, updateAssignmentID);
    popBlock(cfg);
    const instructions = cfg.blockInstructions[forBlock] || [];
    const expectedLength = initialVar ? 3 : 2;
    if (instructions.length !== expectedLength) {
      throw new Error(`FOR block must have exactly ${expectedLength} statements, got ${instructions.length}`);
    }
    const scopeStartBlock = createBasicBlock(cfg, BlockType.SCOPE_START);
    addEdge(cfg, forBlock, scopeStartBlock);
    const bodyBlock = createBasicBlock(cfg, BlockType.DEFAULT);
    this.bodyBlock = bodyBlock;
    addEdge(cfg, scopeStartBlock, bodyBlock);
    this.executeBodyCallback(cfg, branchBlock, bodyBlock, phiNode);
    const scopeEndBlock = createBasicBlock(cfg, BlockType.SCOPE_END);
    addEdge(cfg, bodyBlock, scopeEndBlock);
    addEdge(cfg, scopeEndBlock, mergeBlock);
  }
  buildUnboundedLoop(cfg, branchBlock, mergeBlock, initialVar, phiNode, conditionNode, updateResult) {
    const forBlock = createBasicBlock(cfg, BlockType.FOR);
    addEdge(cfg, branchBlock, forBlock);
    pushBlock(cfg, forBlock);
    if (initialVar) {
      const initAssignmentNode = createNodeData({
        nodeType: NodeType.ASSIGNMENT,
        dependsOn: [phiNode.id, initialVar.id],
        phiBlocks: []
      });
      const initAssignmentID = getOrCreateNode(this.strandsContext.dag, initAssignmentNode);
      recordInBasicBlock(cfg, forBlock, initAssignmentID);
    } else {
      const emptyInitNode = createNodeData({
        nodeType: NodeType.STATEMENT,
        statementType: StatementType.EMPTY,
        dependsOn: [],
        phiBlocks: []
      });
      const emptyInitID = getOrCreateNode(this.strandsContext.dag, emptyInitNode);
      recordInBasicBlock(cfg, forBlock, emptyInitID);
    }
    const emptyConditionNode = createNodeData({
      nodeType: NodeType.STATEMENT,
      statementType: StatementType.EMPTY,
      dependsOn: [],
      phiBlocks: []
    });
    const emptyConditionID = getOrCreateNode(this.strandsContext.dag, emptyConditionNode);
    recordInBasicBlock(cfg, forBlock, emptyConditionID);
    const emptyUpdateNode = createNodeData({
      nodeType: NodeType.STATEMENT,
      statementType: StatementType.EMPTY,
      dependsOn: [],
      phiBlocks: []
    });
    const emptyUpdateID = getOrCreateNode(this.strandsContext.dag, emptyUpdateNode);
    recordInBasicBlock(cfg, forBlock, emptyUpdateID);
    popBlock(cfg);
    const scopeStartBlock = createBasicBlock(cfg, BlockType.SCOPE_START);
    addEdge(cfg, forBlock, scopeStartBlock);
    const breakCheckBlock = createBasicBlock(cfg, BlockType.DEFAULT);
    addEdge(cfg, scopeStartBlock, breakCheckBlock);
    pushBlock(cfg, breakCheckBlock);
    const condition = conditionNode;
    const negatedCondition = this.createLogicalNotNode(condition);
    const breakConditionBlock = createBasicBlock(cfg, BlockType.IF_COND);
    addEdge(cfg, breakCheckBlock, breakConditionBlock);
    cfg.blockConditions[breakConditionBlock] = negatedCondition.id;
    const breakStatementBlock = createBasicBlock(cfg, BlockType.DEFAULT);
    addEdge(cfg, breakConditionBlock, breakStatementBlock);
    pushBlock(cfg, breakStatementBlock);
    const breakStatementNode = createNodeData({
      nodeType: NodeType.STATEMENT,
      statementType: StatementType.BREAK,
      dependsOn: [],
      phiBlocks: []
    });
    const breakStatementID = getOrCreateNode(this.strandsContext.dag, breakStatementNode);
    recordInBasicBlock(cfg, breakStatementBlock, breakStatementID);
    popBlock(cfg);
    addEdge(cfg, breakStatementBlock, mergeBlock);
    popBlock(cfg);
    const bodyBlock = createBasicBlock(cfg, BlockType.DEFAULT);
    this.bodyBlock = bodyBlock;
    addEdge(cfg, breakCheckBlock, bodyBlock);
    this.executeBodyCallback(cfg, branchBlock, bodyBlock, phiNode);
    const updateBlock = createBasicBlock(cfg, BlockType.DEFAULT);
    addEdge(cfg, bodyBlock, updateBlock);
    pushBlock(cfg, updateBlock);
    const updateAssignmentNode = createNodeData({
      nodeType: NodeType.ASSIGNMENT,
      dependsOn: [phiNode.id, updateResult.id],
      phiBlocks: []
    });
    const updateAssignmentID = getOrCreateNode(this.strandsContext.dag, updateAssignmentNode);
    recordInBasicBlock(cfg, updateBlock, updateAssignmentID);
    popBlock(cfg);
    const scopeEndBlock = createBasicBlock(cfg, BlockType.SCOPE_END);
    addEdge(cfg, updateBlock, scopeEndBlock);
    addEdge(cfg, scopeEndBlock, breakCheckBlock);
    addEdge(cfg, breakCheckBlock, mergeBlock);
  }
  initializeLoopVariable(cfg, branchBlock) {
    pushBlock(cfg, branchBlock);
    let initialVar = this.initialCb();
    if (!(initialVar instanceof StrandsNode)) {
      const { id, dimension } = primitiveConstructorNode(this.strandsContext, { baseType: BaseType.FLOAT, dimension: 1 }, initialVar);
      initialVar = createStrandsNode(id, dimension, this.strandsContext);
    }
    const phiNode = createPhiNode(this.strandsContext, [
      { value: initialVar, blockId: branchBlock },
      { value: initialVar, blockId: branchBlock }
    ], "loopVar");
    popBlock(cfg);
    return { initialVar, phiNode };
  }
  createLogicalNotNode(conditionNode) {
    const notOperationNode = createNodeData({
      nodeType: NodeType.OPERATION,
      opCode: OpCode.Unary.LOGICAL_NOT,
      baseType: BaseType.BOOL,
      dimension: 1,
      dependsOn: [conditionNode.id],
      phiBlocks: [],
      usedBy: []
    });
    const notOperationID = getOrCreateNode(this.strandsContext.dag, notOperationNode);
    return createStrandsNode(notOperationID, 1, this.strandsContext);
  }
  executeBodyCallback(cfg, branchBlock, bodyBlock, phiNode) {
    pushBlock(cfg, bodyBlock);
    const phiVars = {};
    const phiNodesForBody = {};
    pushBlockForModification(cfg, branchBlock);
    for (const [varName, initialValueNode] of Object.entries(this.initialVars)) {
      if (varName !== "loopVar") {
        const varPhiNode = createPhiNode(this.strandsContext, [
          { value: initialValueNode, blockId: branchBlock },
          { value: initialValueNode, blockId: bodyBlock }
        ], varName);
        phiNodesForBody[varName] = varPhiNode;
        phiVars[varName] = createStrandsNode(varPhiNode.id, varPhiNode.dimension, this.strandsContext);
      }
    }
    popBlock(cfg);
    const loopVarNode = createStrandsNode(phiNode.id, phiNode.dimension, this.strandsContext);
    this.bodyResults = this.bodyCb(loopVarNode, phiVars);
    this.phiNodesForBody = phiNodesForBody;
    this.finalBodyBlock = cfg.currentBlock;
    popBlock(cfg);
  }
  loopIsBounded(initialVar, conditionNode, updateVar) {
    if (!conditionNode)
      return false;
    const conditionData = getNodeDataFromID(this.strandsContext.dag, conditionNode.id);
    if (conditionData.nodeType !== NodeType.OPERATION) {
      return false;
    }
    if (!conditionData.dependsOn || conditionData.dependsOn.length !== 2) {
      return false;
    }
    const leftOperand = createStrandsNode(conditionData.dependsOn[0], 1, this.strandsContext);
    const rightOperand = createStrandsNode(conditionData.dependsOn[1], 1, this.strandsContext);
    const leftUsesOnlyLiterals = this.nodeUsesOnlyLiterals(leftOperand);
    const rightUsesOnlyLiterals = this.nodeUsesOnlyLiterals(rightOperand);
    return leftUsesOnlyLiterals || rightUsesOnlyLiterals;
  }
  nodeUsesOnlyLiterals(node) {
    const nodeData = getNodeDataFromID(this.strandsContext.dag, node.id);
    switch (nodeData.nodeType) {
      case NodeType.LITERAL:
        return true;
      case NodeType.VARIABLE:
        return false;
      case NodeType.PHI:
        return false;
      case NodeType.OPERATION:
        if (nodeData.dependsOn) {
          for (const depId of nodeData.dependsOn) {
            const depNode = createStrandsNode(depId, 1, this.strandsContext);
            if (!this.nodeUsesOnlyLiterals(depNode)) {
              return false;
            }
          }
        }
        return true;
      default:
        return false;
    }
  }
}

// node_modules/p5/dist/strands/strands_api.js
var noiseGLSL = `// Based on https://github.com/stegu/webgl-noise/blob/22434e04d7753f7e949e8d724ab3da2864c17a0f/src/noise3D.glsl
// MIT licensed, adapted for p5.strands

vec3 mod289(vec3 x) {
  return x - floor(x * (1.0 / 289.0)) * 289.0;
}

vec4 mod289(vec4 x) {
  return x - floor(x * (1.0 / 289.0)) * 289.0;
}

vec4 permute(vec4 x) {
  return mod289(((x*34.0)+10.0)*x);
}

vec4 taylorInvSqrt(vec4 r)
{
  return 1.79284291400159 - 0.85373472095314 * r;
}

float baseNoise(vec3 v)
{
  const vec2  C = vec2(1.0/6.0, 1.0/3.0) ;
  const vec4  D = vec4(0.0, 0.5, 1.0, 2.0);

  // First corner
  vec3 i  = floor(v + dot(v, C.yyy) );
  vec3 x0 =   v - i + dot(i, C.xxx) ;

  // Other corners
  vec3 g = step(x0.yzx, x0.xyz);
  vec3 l = 1.0 - g;
  vec3 i1 = min( g.xyz, l.zxy );
  vec3 i2 = max( g.xyz, l.zxy );

  //   x0 = x0 - 0.0 + 0.0 * C.xxx;
  //   x1 = x0 - i1  + 1.0 * C.xxx;
  //   x2 = x0 - i2  + 2.0 * C.xxx;
  //   x3 = x0 - 1.0 + 3.0 * C.xxx;
  vec3 x1 = x0 - i1 + C.xxx;
  vec3 x2 = x0 - i2 + C.yyy; // 2.0*C.x = 1/3 = C.y
  vec3 x3 = x0 - D.yyy;      // -1.0+3.0*C.x = -0.5 = -D.y

  // Permutations
  i = mod289(i);
  vec4 p = permute( permute( permute(
          i.z + vec4(0.0, i1.z, i2.z, 1.0 ))
        + i.y + vec4(0.0, i1.y, i2.y, 1.0 ))
      + i.x + vec4(0.0, i1.x, i2.x, 1.0 ));

  // Gradients: 7x7 points over a square, mapped onto an octahedron.
  // The ring size 17*17 = 289 is close to a multiple of 49 (49*6 = 294)
  float n_ = 0.142857142857; // 1.0/7.0
  vec3  ns = n_ * D.wyz - D.xzx;

  vec4 j = p - 49.0 * floor(p * ns.z * ns.z);  //  mod(p,7*7)

  vec4 x_ = floor(j * ns.z);
  vec4 y_ = floor(j - 7.0 * x_ );    // mod(j,N)

  vec4 x = x_ *ns.x + ns.yyyy;
  vec4 y = y_ *ns.x + ns.yyyy;
  vec4 h = 1.0 - abs(x) - abs(y);

  vec4 b0 = vec4( x.xy, y.xy );
  vec4 b1 = vec4( x.zw, y.zw );

  //vec4 s0 = vec4(lessThan(b0,0.0))*2.0 - 1.0;
  //vec4 s1 = vec4(lessThan(b1,0.0))*2.0 - 1.0;
  vec4 s0 = floor(b0)*2.0 + 1.0;
  vec4 s1 = floor(b1)*2.0 + 1.0;
  vec4 sh = -step(h, vec4(0.0));

  vec4 a0 = b0.xzyw + s0.xzyw*sh.xxyy ;
  vec4 a1 = b1.xzyw + s1.xzyw*sh.zzww ;

  vec3 p0 = vec3(a0.xy,h.x);
  vec3 p1 = vec3(a0.zw,h.y);
  vec3 p2 = vec3(a1.xy,h.z);
  vec3 p3 = vec3(a1.zw,h.w);

  //Normalise gradients
  vec4 norm = taylorInvSqrt(vec4(dot(p0,p0), dot(p1,p1), dot(p2, p2), dot(p3,p3)));
  p0 *= norm.x;
  p1 *= norm.y;
  p2 *= norm.z;
  p3 *= norm.w;

  // Mix final noise value
  vec4 m = max(0.5 - vec4(dot(x0,x0), dot(x1,x1), dot(x2,x2), dot(x3,x3)), 0.0);
  m = m * m;
  return 105.0 * dot( m*m, vec4( dot(p0,x0), dot(p1,x1),
        dot(p2,x2), dot(p3,x3) ) );
}

float noise(vec3 st) {
  float result = 0.0;
  float amplitude = 1.0;
  float frequency = 1.0;

  for (int i = 0; i < 4; i++) {
    result += amplitude * baseNoise(st * frequency);
    frequency *= 2.0;
    amplitude *= 0.5;
  }

  return result;
}
`;
function initGlobalStrandsAPI(p53, fn2, strandsContext) {
  for (const { name, arity, opCode } of OperatorTable) {
    if (arity === "binary") {
      StrandsNode.prototype[name] = function(...right) {
        const { id, dimension } = binaryOpNode(strandsContext, this, right, opCode);
        return createStrandsNode(id, dimension, strandsContext);
      };
    }
    if (arity === "unary") {
      p53[name] = function(nodeOrValue) {
        const { id, dimension } = unaryOpNode(strandsContext, nodeOrValue, opCode);
        return createStrandsNode(id, dimension, strandsContext);
      };
    }
  }
  fn2.discard = function() {
    statementNode(strandsContext, StatementType.DISCARD);
  };
  fn2.break = function() {
    statementNode(strandsContext, StatementType.BREAK);
  };
  p53.break = fn2.break;
  fn2.instanceID = function() {
    const node = variableNode(strandsContext, { baseType: BaseType.INT, dimension: 1 }, "gl_InstanceID");
    return createStrandsNode(node.id, node.dimension, strandsContext);
  };
  p53.strandsIf = function(conditionNode, ifBody) {
    return new StrandsConditional(strandsContext, conditionNode, ifBody);
  };
  fn2.strandsIf = p53.strandsIf;
  p53.strandsFor = function(initialCb, conditionCb, updateCb, bodyCb, initialVars) {
    return new StrandsFor(strandsContext, initialCb, conditionCb, updateCb, bodyCb, initialVars).build();
  };
  fn2.strandsFor = p53.strandsFor;
  p53.strandsNode = function(...args) {
    if (args.length === 1 && args[0] instanceof StrandsNode) {
      return args[0];
    }
    if (args.length > 4) {
      userError("type error", "It looks like you've tried to construct a p5.strands node implicitly, with more than 4 components. This is currently not supported.");
    }
    const { id, dimension } = primitiveConstructorNode(strandsContext, { baseType: BaseType.FLOAT, dimension: null }, args.flat());
    return createStrandsNode(id, dimension, strandsContext);
  };
  for (const [functionName, overrides] of Object.entries(strandsBuiltinFunctions)) {
    const isp5Function = overrides[0].isp5Function;
    if (isp5Function) {
      const originalFn = fn2[functionName];
      fn2[functionName] = function(...args) {
        if (strandsContext.active) {
          const { id, dimension } = functionCallNode(strandsContext, functionName, args);
          return createStrandsNode(id, dimension, strandsContext);
        } else {
          return originalFn.apply(this, args);
        }
      };
    } else {
      fn2[functionName] = function(...args) {
        if (strandsContext.active) {
          const { id, dimension } = functionCallNode(strandsContext, functionName, args);
          return createStrandsNode(id, dimension, strandsContext);
        } else {
          p53._friendlyError(`It looks like you've called ${functionName} outside of a shader's modify() function.`);
        }
      };
    }
  }
  const originalNoise = fn2.noise;
  fn2.noise = function(...args) {
    if (!strandsContext.active) {
      return originalNoise.apply(this, args);
    }
    strandsContext.vertexDeclarations.add(noiseGLSL);
    strandsContext.fragmentDeclarations.add(noiseGLSL);
    const strandsArgs = args.map((arg) => p53.strandsNode(arg));
    let nodeArgs;
    if (strandsArgs.length === 3) {
      nodeArgs = [fn2.vec3(strandsArgs[0], strandsArgs[1], strandsArgs[2])];
    } else if (strandsArgs.length === 2) {
      nodeArgs = [fn2.vec3(strandsArgs[0], strandsArgs[1], 0)];
    } else if (strandsArgs.length === 1 && strandsArgs[0].dimension <= 3) {
      if (strandsArgs[0].dimension === 3) {
        nodeArgs = strandsArgs;
      } else if (strandsArgs[0].dimension === 2) {
        nodeArgs = [fn2.vec3(strandsArgs[0], 0)];
      } else {
        nodeArgs = [fn2.vec3(strandsArgs[0], 0, 0)];
      }
    } else {
      p53._friendlyError(`It looks like you've called noise() with ${args.length} arguments. It only supports 1D to 3D input.`);
    }
    const { id, dimension } = functionCallNode(strandsContext, "noise", nodeArgs, {
      overloads: [{
        params: [DataType.float3],
        returnType: DataType.float1
      }]
    });
    return createStrandsNode(id, dimension, strandsContext);
  };
  for (const type2 in DataType) {
    if (type2 === BaseType.DEFER) {
      continue;
    }
    const typeInfo = DataType[type2];
    const typeAliases = [];
    let pascalTypeName;
    if (/^[ib]vec/.test(typeInfo.fnName)) {
      pascalTypeName = typeInfo.fnName.slice(0, 2).toUpperCase() + typeInfo.fnName.slice(2).toLowerCase();
      typeAliases.push(pascalTypeName.replace("Vec", "Vector"));
    } else {
      pascalTypeName = typeInfo.fnName.charAt(0).toUpperCase() + typeInfo.fnName.slice(1);
      if (pascalTypeName === "Sampler2D") {
        typeAliases.push("Texture");
      } else if (/^vec/.test(typeInfo.fnName)) {
        typeAliases.push(pascalTypeName.replace("Vec", "Vector"));
      }
    }
    fn2[`uniform${pascalTypeName}`] = function(name, defaultValue) {
      const { id, dimension } = variableNode(strandsContext, typeInfo, name);
      strandsContext.uniforms.push({ name, typeInfo, defaultValue });
      return createStrandsNode(id, dimension, strandsContext);
    };
    fn2[`shared${pascalTypeName}`] = function(name) {
      const { id, dimension } = variableNode(strandsContext, typeInfo, name);
      if (!strandsContext.sharedVariables) {
        strandsContext.sharedVariables = new Map;
      }
      strandsContext.sharedVariables.set(name, {
        typeInfo,
        usedInVertex: false,
        usedInFragment: false,
        declared: false
      });
      return createStrandsNode(id, dimension, strandsContext);
    };
    fn2[`varying${pascalTypeName}`] = fn2[`shared${pascalTypeName}`];
    for (const typeAlias of typeAliases) {
      fn2[`uniform${typeAlias}`] = fn2[`uniform${pascalTypeName}`];
      fn2[`varying${typeAlias}`] = fn2[`varying${pascalTypeName}`];
      fn2[`shared${typeAlias}`] = fn2[`shared${pascalTypeName}`];
    }
    const originalp5Fn = fn2[typeInfo.fnName];
    fn2[typeInfo.fnName] = function(...args) {
      if (strandsContext.active) {
        const { id, dimension } = primitiveConstructorNode(strandsContext, typeInfo, args);
        return createStrandsNode(id, dimension, strandsContext);
      } else if (originalp5Fn) {
        return originalp5Fn.apply(this, args);
      } else {
        p53._friendlyError(`It looks like you've called ${typeInfo.fnName} outside of a shader's modify() function.`);
      }
    };
  }
}
function createHookArguments(strandsContext, parameters) {
  const args = [];
  const dag = strandsContext.dag;
  for (const param of parameters) {
    if (isStructType(param.type.typeName)) {
      const structTypeInfo = structType(param);
      const { id, dimension } = structInstanceNode(strandsContext, structTypeInfo, param.name, []);
      const structNode = createStrandsNode(id, dimension, strandsContext);
      for (let i2 = 0;i2 < structTypeInfo.properties.length; i2++) {
        const propertyType = structTypeInfo.properties[i2];
        Object.defineProperty(structNode, propertyType.name, {
          get() {
            const propNode = getNodeDataFromID(dag, dag.dependsOn[structNode.id][i2]);
            const onRebind = (newFieldID) => {
              const oldDeps = dag.dependsOn[structNode.id];
              const newDeps = oldDeps.slice();
              newDeps[i2] = newFieldID;
              const rebuilt = structInstanceNode(strandsContext, structTypeInfo, param.name, newDeps);
              structNode.id = rebuilt.id;
            };
            return createStrandsNode(propNode.id, propNode.dimension, strandsContext, onRebind);
          },
          set(val) {
            const oldDependsOn = dag.dependsOn[structNode.id];
            const newDependsOn = [...oldDependsOn];
            let newValueID;
            if (val instanceof StrandsNode) {
              newValueID = val.id;
            } else {
              let newVal = primitiveConstructorNode(strandsContext, propertyType.dataType, val);
              newValueID = newVal.id;
            }
            newDependsOn[i2] = newValueID;
            const newStructInfo = structInstanceNode(strandsContext, structTypeInfo, param.name, newDependsOn);
            structNode.id = newStructInfo.id;
          }
        });
      }
      args.push(structNode);
    } else {
      const typeInfo = TypeInfoFromGLSLName[param.type.typeName];
      const { id, dimension } = variableNode(strandsContext, typeInfo, param.name);
      const arg = createStrandsNode(id, dimension, strandsContext);
      args.push(arg);
    }
  }
  return args;
}
function enforceReturnTypeMatch(strandsContext, expectedType, returned, hookName) {
  if (!(returned instanceof StrandsNode)) {
    const result = primitiveConstructorNode(strandsContext, expectedType, returned);
    return result.id;
  }
  const dag = strandsContext.dag;
  let returnedNodeID = returned.id;
  const receivedType = {
    baseType: dag.baseTypes[returnedNodeID],
    dimension: dag.dimensions[returnedNodeID]
  };
  if (receivedType.dimension !== expectedType.dimension) {
    if (receivedType.dimension !== 1) {
      userError("type error", `You have returned a vector with ${receivedType.dimension} components in ${hookName} when a ${expectedType.baseType + expectedType.dimension} was expected!`);
    } else {
      const result = primitiveConstructorNode(strandsContext, expectedType, returned);
      returnedNodeID = result.id;
    }
  } else if (receivedType.baseType !== expectedType.baseType) {
    const result = primitiveConstructorNode(strandsContext, expectedType, returned);
    returnedNodeID = result.id;
  }
  return returnedNodeID;
}
function createShaderHooksFunctions(strandsContext, fn2, shader2) {
  const vertexHooksWithContext = Object.fromEntries(Object.entries(shader2.hooks.vertex).map(([name, hook]) => [name, { ...hook, shaderContext: "vertex" }]));
  const fragmentHooksWithContext = Object.fromEntries(Object.entries(shader2.hooks.fragment).map(([name, hook]) => [name, { ...hook, shaderContext: "fragment" }]));
  const availableHooks = {
    ...vertexHooksWithContext,
    ...fragmentHooksWithContext
  };
  const hookTypes = Object.keys(availableHooks).map((name) => shader2.hookTypes(name));
  const { cfg, dag } = strandsContext;
  for (const hookType of hookTypes) {
    const hookImplementation = function(hookUserCallback) {
      const entryBlockID = createBasicBlock(cfg, BlockType.FUNCTION);
      addEdge(cfg, cfg.currentBlock, entryBlockID);
      pushBlock(cfg, entryBlockID);
      const args = createHookArguments(strandsContext, hookType.parameters);
      const userReturned = hookUserCallback(...args);
      const expectedReturnType = hookType.returnType;
      let rootNodeID = null;
      if (isStructType(expectedReturnType.typeName)) {
        const expectedStructType = structType(expectedReturnType);
        if (userReturned instanceof StrandsNode) {
          const returnedNode = getNodeDataFromID(strandsContext.dag, userReturned.id);
          if (returnedNode.baseType !== expectedStructType.typeName) {
            userError("type error", `You have returned a ${userReturned.baseType} from ${hookType.name} when a ${expectedStructType.typeName} was expected.`);
          }
          const newDeps = returnedNode.dependsOn.slice();
          for (let i2 = 0;i2 < expectedStructType.properties.length; i2++) {
            const expectedType = expectedStructType.properties[i2].dataType;
            const receivedNode = createStrandsNode(returnedNode.dependsOn[i2], dag.dependsOn[userReturned.id], strandsContext);
            newDeps[i2] = enforceReturnTypeMatch(strandsContext, expectedType, receivedNode, hookType.name);
          }
          dag.dependsOn[userReturned.id] = newDeps;
          rootNodeID = userReturned.id;
        } else {
          const expectedProperties = expectedStructType.properties;
          const newStructDependencies = [];
          for (let i2 = 0;i2 < expectedProperties.length; i2++) {
            const expectedProp = expectedProperties[i2];
            const propName = expectedProp.name;
            const receivedValue = userReturned[propName];
            if (receivedValue === undefined) {
              userError("type error", `You've returned an incomplete struct from ${hookType.name}.
` + `Expected: { ${expectedReturnType.properties.map((p2) => p2.name).join(", ")} }
` + `Received: { ${Object.keys(userReturned).join(", ")} }
` + `All of the properties are required!`);
            }
            const expectedTypeInfo = expectedProp.dataType;
            const returnedPropID = enforceReturnTypeMatch(strandsContext, expectedTypeInfo, receivedValue, hookType.name);
            newStructDependencies.push(returnedPropID);
          }
          const newStruct = structConstructorNode(strandsContext, expectedStructType, newStructDependencies);
          rootNodeID = newStruct.id;
        }
      } else {
        const expectedTypeInfo = TypeInfoFromGLSLName[expectedReturnType.typeName];
        rootNodeID = enforceReturnTypeMatch(strandsContext, expectedTypeInfo, userReturned, hookType.name);
      }
      const fullHookName = `${hookType.returnType.typeName} ${hookType.name}`;
      const hookInfo = availableHooks[fullHookName];
      strandsContext.hooks.push({
        hookType,
        entryBlockID,
        rootNodeID,
        shaderContext: hookInfo?.shaderContext
      });
      popBlock(cfg);
    };
    strandsContext.windowOverrides[hookType.name] = window[hookType.name];
    strandsContext.fnOverrides[hookType.name] = fn2[hookType.name];
    window[hookType.name] = hookImplementation;
    fn2[hookType.name] = hookImplementation;
  }
}

// node_modules/p5/dist/strands/p5.strands.js
var import_escodegen2 = __toESM(require_escodegen(), 1);
function strands(p53, fn2) {
  function initStrandsContext(ctx, backend, { active = false } = {}) {
    ctx.dag = createDirectedAcyclicGraph();
    ctx.cfg = createControlFlowGraph();
    ctx.uniforms = [];
    ctx.vertexDeclarations = new Set;
    ctx.fragmentDeclarations = new Set;
    ctx.hooks = [];
    ctx.globalAssignments = [];
    ctx.backend = backend;
    ctx.active = active;
    ctx.previousFES = p53.disableFriendlyErrors;
    ctx.windowOverrides = {};
    ctx.fnOverrides = {};
    if (active) {
      p53.disableFriendlyErrors = true;
    }
  }
  function deinitStrandsContext(ctx) {
    ctx.dag = createDirectedAcyclicGraph();
    ctx.cfg = createControlFlowGraph();
    ctx.uniforms = [];
    ctx.vertexDeclarations = new Set;
    ctx.fragmentDeclarations = new Set;
    ctx.hooks = [];
    ctx.globalAssignments = [];
    ctx.active = false;
    p53.disableFriendlyErrors = ctx.previousFES;
    for (const key in ctx.windowOverrides) {
      window[key] = ctx.windowOverrides[key];
    }
    for (const key in ctx.fnOverrides) {
      fn2[key] = ctx.fnOverrides[key];
    }
  }
  const strandsContext = {};
  initStrandsContext(strandsContext);
  initGlobalStrandsAPI(p53, fn2, strandsContext);
  const oldModify = p53.Shader.prototype.modify;
  p53.Shader.prototype.modify = function(shaderModifier, scope = {}) {
    if (shaderModifier instanceof Function) {
      initStrandsContext(strandsContext, glslBackend, { active: true });
      createShaderHooksFunctions(strandsContext, fn2, this);
      const options2 = { srcLocations: false };
      let strandsCallback;
      {
        const sourceString = `(${shaderModifier.toString()})`;
        strandsCallback = transpileStrandsToJS(p53, sourceString, options2.srcLocations, scope);
      }
      const globalScope = createBasicBlock(strandsContext.cfg, BlockType.GLOBAL);
      pushBlock(strandsContext.cfg, globalScope);
      strandsCallback();
      popBlock(strandsContext.cfg);
      const hooksObject = generateShaderCode(strandsContext);
      deinitStrandsContext(strandsContext);
      return oldModify.call(this, hooksObject);
    } else {
      return oldModify.call(this, shaderModifier);
    }
  };
}
if (typeof p5 !== "undefined") {
  p5.registerAddon(strands);
}

// node_modules/p5/dist/webgl/index.js
var import_file_saver14 = __toESM(require_FileSaver(), 1);
var import_omggif9 = __toESM(require_omggif(), 1);
var import_gifenc10 = __toESM(require_gifenc(), 1);
var import_libtess10 = __toESM(require_libtess_min(), 1);
var import_unicode_range3 = __toESM(require_lib(), 1);
var import_bezier_path3 = __toESM(require_bezier_path(), 1);
var import_escodegen3 = __toESM(require_escodegen(), 1);
function webgl(p53) {
  rendererGL(p53, p53.prototype);
  primitives3D(p53, p53.prototype);
  interaction(p53, p53.prototype);
  light(p53, p53.prototype);
  loading2(p53, p53.prototype);
  material(p53, p53.prototype);
  text(p53, p53.prototype);
  renderBuffer(p53, p53.prototype);
  quat(p53, p53.prototype);
  matrix(p53, p53.prototype);
  geometry(p53, p53.prototype);
  camera(p53, p53.prototype);
  framebuffer(p53, p53.prototype);
  dataArray(p53, p53.prototype);
  shader(p53, p53.prototype);
  texture(p53, p53.prototype);
  strands(p53, p53.prototype);
}

// node_modules/p5/dist/type/index.js
var import_file_saver15 = __toESM(require_FileSaver(), 1);
var import_unicode_range4 = __toESM(require_lib(), 1);
var import_bezier_path4 = __toESM(require_bezier_path(), 1);
function type2(p53) {
  p53.registerAddon(textCore);
  p53.registerAddon(font);
}

// node_modules/p5/dist/core/init.js
var import_file_saver16 = __toESM(require_FileSaver(), 1);
var import_omggif10 = __toESM(require_omggif(), 1);
var import_gifenc11 = __toESM(require_gifenc(), 1);
var import_libtess11 = __toESM(require_libtess_min(), 1);
var _globalInit = () => {
  if (typeof window._setupDone !== "undefined") {
    console.warn("p5.js seems to have been imported multiple times. Please remove the duplicate import");
    return;
  }
  if (!window.mocha) {
    const p5ReadyEvent = new Event("p5Ready");
    window.dispatchEvent(p5ReadyEvent);
    if ((window.setup && typeof window.setup === "function" || window.draw && typeof window.draw === "function") && !p52.instance) {
      new p52;
    }
  }
};
var waitForDocumentReady = () => new Promise((resolve, reject) => {
  if (document.readyState === "complete") {
    resolve();
  } else {
    window.addEventListener("load", resolve, false);
  }
});
var waitingForTranslator = typeof IS_MINIFIED === "undefined" ? initialize() : Promise.resolve();

// node_modules/p5/dist/app.js
var import_file_saver17 = __toESM(require_FileSaver(), 1);
var import_omggif11 = __toESM(require_omggif(), 1);
var import_gifenc12 = __toESM(require_gifenc(), 1);
var import_libtess12 = __toESM(require_libtess_min(), 1);
var import_unicode_range5 = __toESM(require_lib(), 1);
var import_bezier_path5 = __toESM(require_bezier_path(), 1);
var import_escodegen4 = __toESM(require_escodegen(), 1);
shape(p52);
accessibility(p52);
color2(p52);
friendlyErrors(p52);
data2(p52);
dom2(p52);
events(p52);
image3(p52);
io(p52);
math2(p52);
utilities(p52);
webgl(p52);
type2(p52);
Promise.all([waitForDocumentReady(), waitingForTranslator]).then(_globalInit);

// index.ts
var sketch = (p2) => {
  let oscillator;
  p2.setup = () => {
    p2.createCanvas(400, 400);
    p2.background(220);
    oscillator = new p2.Oscillator("sine");
    oscillator.amp(0);
    oscillator.start();
    p2.text("Click to start sound", 10, 20);
  };
  p2.draw = () => {
    p2.fill(p2.random(255), p2.random(255), p2.random(255));
    p2.ellipse(p2.mouseX, p2.mouseY, 50, 50);
  };
  p2.mousePressed = () => {
    if (oscillator) {
      oscillator.amp(0.5, 0.05);
    }
  };
};
new p52(sketch);
